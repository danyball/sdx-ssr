'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

/*!
 Stencil Mock Doc v3.2.0 | MIT Licensed | https://stenciljs.com
 */
const CONTENT_REF_ID = 'r';
const ORG_LOCATION_ID = 'o';
const SLOT_NODE_ID = 's';
const TEXT_NODE_ID = 't';
const XLINK_NS = 'http://www.w3.org/1999/xlink';

const attrHandler = {
  get(obj, prop) {
    if (prop in obj) {
      return obj[prop];
    }
    if (typeof prop !== 'symbol' && !isNaN(prop)) {
      return obj.__items[prop];
    }
    return undefined;
  },
};
const createAttributeProxy = (caseInsensitive) => new Proxy(new MockAttributeMap(caseInsensitive), attrHandler);
class MockAttributeMap {
  constructor(caseInsensitive = false) {
    this.caseInsensitive = caseInsensitive;
    this.__items = [];
  }
  get length() {
    return this.__items.length;
  }
  item(index) {
    return this.__items[index] || null;
  }
  setNamedItem(attr) {
    attr.namespaceURI = null;
    this.setNamedItemNS(attr);
  }
  setNamedItemNS(attr) {
    if (attr != null && attr.value != null) {
      attr.value = String(attr.value);
    }
    const existingAttr = this.__items.find((a) => a.name === attr.name && a.namespaceURI === attr.namespaceURI);
    if (existingAttr != null) {
      existingAttr.value = attr.value;
    }
    else {
      this.__items.push(attr);
    }
  }
  getNamedItem(attrName) {
    if (this.caseInsensitive) {
      attrName = attrName.toLowerCase();
    }
    return this.getNamedItemNS(null, attrName);
  }
  getNamedItemNS(namespaceURI, attrName) {
    namespaceURI = getNamespaceURI(namespaceURI);
    return (this.__items.find((attr) => attr.name === attrName && getNamespaceURI(attr.namespaceURI) === namespaceURI) || null);
  }
  removeNamedItem(attr) {
    this.removeNamedItemNS(attr);
  }
  removeNamedItemNS(attr) {
    for (let i = 0, ii = this.__items.length; i < ii; i++) {
      if (this.__items[i].name === attr.name && this.__items[i].namespaceURI === attr.namespaceURI) {
        this.__items.splice(i, 1);
        break;
      }
    }
  }
  [Symbol.iterator]() {
    let i = 0;
    return {
      next: () => ({
        done: i === this.length,
        value: this.item(i++),
      }),
    };
  }
  get [Symbol.toStringTag]() {
    return 'MockAttributeMap';
  }
}
function getNamespaceURI(namespaceURI) {
  return namespaceURI === XLINK_NS ? null : namespaceURI;
}
function cloneAttributes(srcAttrs, sortByName = false) {
  const dstAttrs = new MockAttributeMap(srcAttrs.caseInsensitive);
  if (srcAttrs != null) {
    const attrLen = srcAttrs.length;
    if (sortByName && attrLen > 1) {
      const sortedAttrs = [];
      for (let i = 0; i < attrLen; i++) {
        const srcAttr = srcAttrs.item(i);
        const dstAttr = new MockAttr(srcAttr.name, srcAttr.value, srcAttr.namespaceURI);
        sortedAttrs.push(dstAttr);
      }
      sortedAttrs.sort(sortAttributes).forEach((attr) => {
        dstAttrs.setNamedItemNS(attr);
      });
    }
    else {
      for (let i = 0; i < attrLen; i++) {
        const srcAttr = srcAttrs.item(i);
        const dstAttr = new MockAttr(srcAttr.name, srcAttr.value, srcAttr.namespaceURI);
        dstAttrs.setNamedItemNS(dstAttr);
      }
    }
  }
  return dstAttrs;
}
function sortAttributes(a, b) {
  if (a.name < b.name)
    return -1;
  if (a.name > b.name)
    return 1;
  return 0;
}
class MockAttr {
  constructor(attrName, attrValue, namespaceURI = null) {
    this._name = attrName;
    this._value = String(attrValue);
    this._namespaceURI = namespaceURI;
  }
  get name() {
    return this._name;
  }
  set name(value) {
    this._name = value;
  }
  get value() {
    return this._value;
  }
  set value(value) {
    this._value = String(value);
  }
  get nodeName() {
    return this._name;
  }
  set nodeName(value) {
    this._name = value;
  }
  get nodeValue() {
    return this._value;
  }
  set nodeValue(value) {
    this._value = String(value);
  }
  get namespaceURI() {
    return this._namespaceURI;
  }
  set namespaceURI(namespaceURI) {
    this._namespaceURI = namespaceURI;
  }
}

class MockClassList {
  constructor(elm) {
    this.elm = elm;
  }
  add(...classNames) {
    const clsNames = getItems(this.elm);
    let updated = false;
    classNames.forEach((className) => {
      className = String(className);
      validateClass(className);
      if (clsNames.includes(className) === false) {
        clsNames.push(className);
        updated = true;
      }
    });
    if (updated) {
      this.elm.setAttributeNS(null, 'class', clsNames.join(' '));
    }
  }
  remove(...classNames) {
    const clsNames = getItems(this.elm);
    let updated = false;
    classNames.forEach((className) => {
      className = String(className);
      validateClass(className);
      const index = clsNames.indexOf(className);
      if (index > -1) {
        clsNames.splice(index, 1);
        updated = true;
      }
    });
    if (updated) {
      this.elm.setAttributeNS(null, 'class', clsNames.filter((c) => c.length > 0).join(' '));
    }
  }
  contains(className) {
    className = String(className);
    return getItems(this.elm).includes(className);
  }
  toggle(className) {
    className = String(className);
    if (this.contains(className) === true) {
      this.remove(className);
    }
    else {
      this.add(className);
    }
  }
  get length() {
    return getItems(this.elm).length;
  }
  item(index) {
    return getItems(this.elm)[index];
  }
  toString() {
    return getItems(this.elm).join(' ');
  }
}
function validateClass(className) {
  if (className === '') {
    throw new Error('The token provided must not be empty.');
  }
  if (/\s/.test(className)) {
    throw new Error(`The token provided ('${className}') contains HTML space characters, which are not valid in tokens.`);
  }
}
function getItems(elm) {
  const className = elm.getAttribute('class');
  if (typeof className === 'string' && className.length > 0) {
    return className
      .trim()
      .split(' ')
      .filter((c) => c.length > 0);
  }
  return [];
}

class MockCSSStyleDeclaration {
  constructor() {
    this._styles = new Map();
  }
  setProperty(prop, value) {
    prop = jsCaseToCssCase(prop);
    if (value == null || value === '') {
      this._styles.delete(prop);
    }
    else {
      this._styles.set(prop, String(value));
    }
  }
  getPropertyValue(prop) {
    prop = jsCaseToCssCase(prop);
    return String(this._styles.get(prop) || '');
  }
  removeProperty(prop) {
    prop = jsCaseToCssCase(prop);
    this._styles.delete(prop);
  }
  get length() {
    return this._styles.size;
  }
  get cssText() {
    const cssText = [];
    this._styles.forEach((value, prop) => {
      cssText.push(`${prop}: ${value};`);
    });
    return cssText.join(' ').trim();
  }
  set cssText(cssText) {
    if (cssText == null || cssText === '') {
      this._styles.clear();
      return;
    }
    cssText.split(';').forEach((rule) => {
      rule = rule.trim();
      if (rule.length > 0) {
        const splt = rule.split(':');
        if (splt.length > 1) {
          const prop = splt[0].trim();
          const value = splt.slice(1).join(':').trim();
          if (prop !== '' && value !== '') {
            this._styles.set(jsCaseToCssCase(prop), value);
          }
        }
      }
    });
  }
}
function createCSSStyleDeclaration() {
  return new Proxy(new MockCSSStyleDeclaration(), cssProxyHandler);
}
const cssProxyHandler = {
  get(cssStyle, prop) {
    if (prop in cssStyle) {
      return cssStyle[prop];
    }
    prop = cssCaseToJsCase(prop);
    return cssStyle.getPropertyValue(prop);
  },
  set(cssStyle, prop, value) {
    if (prop in cssStyle) {
      cssStyle[prop] = value;
    }
    else {
      cssStyle.setProperty(prop, value);
    }
    return true;
  },
};
function cssCaseToJsCase(str) {
  // font-size to fontSize
  if (str.length > 1 && str.includes('-') === true) {
    str = str
      .toLowerCase()
      .split('-')
      .map((segment) => segment.charAt(0).toUpperCase() + segment.slice(1))
      .join('');
    str = str.slice(0, 1).toLowerCase() + str.slice(1);
  }
  return str;
}
function jsCaseToCssCase(str) {
  // fontSize to font-size
  if (str.length > 1 && str.includes('-') === false && /[A-Z]/.test(str) === true) {
    str = str
      .replace(/([A-Z])/g, (g) => ' ' + g[0])
      .trim()
      .replace(/ /g, '-')
      .toLowerCase();
  }
  return str;
}

class MockCustomElementRegistry {
  constructor(win) {
    this.win = win;
  }
  define(tagName, cstr, options) {
    if (tagName.toLowerCase() !== tagName) {
      throw new Error(`Failed to execute 'define' on 'CustomElementRegistry': "${tagName}" is not a valid custom element name`);
    }
    if (this.__registry == null) {
      this.__registry = new Map();
    }
    this.__registry.set(tagName, { cstr, options });
    if (this.__whenDefined != null) {
      const whenDefinedResolveFns = this.__whenDefined.get(tagName);
      if (whenDefinedResolveFns != null) {
        whenDefinedResolveFns.forEach((whenDefinedResolveFn) => {
          whenDefinedResolveFn();
        });
        whenDefinedResolveFns.length = 0;
        this.__whenDefined.delete(tagName);
      }
    }
    const doc = this.win.document;
    if (doc != null) {
      const hosts = doc.querySelectorAll(tagName);
      hosts.forEach((host) => {
        if (upgradedElements.has(host) === false) {
          tempDisableCallbacks.add(doc);
          const upgradedCmp = createCustomElement(this, doc, tagName);
          for (let i = 0; i < host.childNodes.length; i++) {
            const childNode = host.childNodes[i];
            childNode.remove();
            upgradedCmp.appendChild(childNode);
          }
          tempDisableCallbacks.delete(doc);
          if (proxyElements.has(host)) {
            proxyElements.set(host, upgradedCmp);
          }
        }
        fireConnectedCallback(host);
      });
    }
  }
  get(tagName) {
    if (this.__registry != null) {
      const def = this.__registry.get(tagName.toLowerCase());
      if (def != null) {
        return def.cstr;
      }
    }
    return undefined;
  }
  upgrade(_rootNode) {
    //
  }
  clear() {
    if (this.__registry != null) {
      this.__registry.clear();
    }
    if (this.__whenDefined != null) {
      this.__whenDefined.clear();
    }
  }
  whenDefined(tagName) {
    tagName = tagName.toLowerCase();
    if (this.__registry != null && this.__registry.has(tagName) === true) {
      return Promise.resolve(this.__registry.get(tagName).cstr);
    }
    return new Promise((resolve) => {
      if (this.__whenDefined == null) {
        this.__whenDefined = new Map();
      }
      let whenDefinedResolveFns = this.__whenDefined.get(tagName);
      if (whenDefinedResolveFns == null) {
        whenDefinedResolveFns = [];
        this.__whenDefined.set(tagName, whenDefinedResolveFns);
      }
      whenDefinedResolveFns.push(resolve);
    });
  }
}
function createCustomElement(customElements, ownerDocument, tagName) {
  const Cstr = customElements.get(tagName);
  if (Cstr != null) {
    const cmp = new Cstr(ownerDocument);
    cmp.nodeName = tagName.toUpperCase();
    upgradedElements.add(cmp);
    return cmp;
  }
  const host = new Proxy({}, {
    get(obj, prop) {
      const elm = proxyElements.get(host);
      if (elm != null) {
        return elm[prop];
      }
      return obj[prop];
    },
    set(obj, prop, val) {
      const elm = proxyElements.get(host);
      if (elm != null) {
        elm[prop] = val;
      }
      else {
        obj[prop] = val;
      }
      return true;
    },
    has(obj, prop) {
      const elm = proxyElements.get(host);
      if (prop in elm) {
        return true;
      }
      if (prop in obj) {
        return true;
      }
      return false;
    },
  });
  const elm = new MockHTMLElement(ownerDocument, tagName);
  proxyElements.set(host, elm);
  return host;
}
const proxyElements = new WeakMap();
const upgradedElements = new WeakSet();
function connectNode(ownerDocument, node) {
  node.ownerDocument = ownerDocument;
  if (node.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */) {
    if (ownerDocument != null && node.nodeName.includes('-')) {
      const win = ownerDocument.defaultView;
      if (win != null && typeof node.connectedCallback === 'function' && node.isConnected) {
        fireConnectedCallback(node);
      }
      const shadowRoot = node.shadowRoot;
      if (shadowRoot != null) {
        shadowRoot.childNodes.forEach((childNode) => {
          connectNode(ownerDocument, childNode);
        });
      }
    }
    node.childNodes.forEach((childNode) => {
      connectNode(ownerDocument, childNode);
    });
  }
  else {
    node.childNodes.forEach((childNode) => {
      childNode.ownerDocument = ownerDocument;
    });
  }
}
function fireConnectedCallback(node) {
  if (typeof node.connectedCallback === 'function') {
    if (tempDisableCallbacks.has(node.ownerDocument) === false) {
      try {
        node.connectedCallback();
      }
      catch (e) {
        console.error(e);
      }
    }
  }
}
function disconnectNode(node) {
  if (node.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */) {
    if (node.nodeName.includes('-') === true && typeof node.disconnectedCallback === 'function') {
      if (tempDisableCallbacks.has(node.ownerDocument) === false) {
        try {
          node.disconnectedCallback();
        }
        catch (e) {
          console.error(e);
        }
      }
    }
    node.childNodes.forEach(disconnectNode);
  }
}
function attributeChanged(node, attrName, oldValue, newValue) {
  attrName = attrName.toLowerCase();
  const observedAttributes = node.constructor.observedAttributes;
  if (Array.isArray(observedAttributes) === true &&
    observedAttributes.some((obs) => obs.toLowerCase() === attrName) === true) {
    try {
      node.attributeChangedCallback(attrName, oldValue, newValue);
    }
    catch (e) {
      console.error(e);
    }
  }
}
function checkAttributeChanged(node) {
  return node.nodeName.includes('-') === true && typeof node.attributeChangedCallback === 'function';
}
const tempDisableCallbacks = new Set();

function dataset(elm) {
  const ds = {};
  const attributes = elm.attributes;
  const attrLen = attributes.length;
  for (let i = 0; i < attrLen; i++) {
    const attr = attributes.item(i);
    const nodeName = attr.nodeName;
    if (nodeName.startsWith('data-')) {
      ds[dashToPascalCase(nodeName)] = attr.nodeValue;
    }
  }
  return new Proxy(ds, {
    get(_obj, camelCaseProp) {
      return ds[camelCaseProp];
    },
    set(_obj, camelCaseProp, value) {
      const dataAttr = toDataAttribute(camelCaseProp);
      elm.setAttribute(dataAttr, value);
      return true;
    },
  });
}
function toDataAttribute(str) {
  return ('data-' +
    String(str)
      .replace(/([A-Z0-9])/g, (g) => ' ' + g[0])
      .trim()
      .replace(/ /g, '-')
      .toLowerCase());
}
function dashToPascalCase(str) {
  str = String(str).slice(5);
  return str
    .split('-')
    .map((segment, index) => {
    if (index === 0) {
      return segment.charAt(0).toLowerCase() + segment.slice(1);
    }
    return segment.charAt(0).toUpperCase() + segment.slice(1);
  })
    .join('');
}

class MockEvent {
  constructor(type, eventInitDict) {
    this.bubbles = false;
    this.cancelBubble = false;
    this.cancelable = false;
    this.composed = false;
    this.currentTarget = null;
    this.defaultPrevented = false;
    this.srcElement = null;
    this.target = null;
    if (typeof type !== 'string') {
      throw new Error(`Event type required`);
    }
    this.type = type;
    this.timeStamp = Date.now();
    if (eventInitDict != null) {
      Object.assign(this, eventInitDict);
    }
  }
  preventDefault() {
    this.defaultPrevented = true;
  }
  stopPropagation() {
    this.cancelBubble = true;
  }
  stopImmediatePropagation() {
    this.cancelBubble = true;
  }
  composedPath() {
    const composedPath = [];
    let currentElement = this.target;
    while (currentElement) {
      composedPath.push(currentElement);
      if (!currentElement.parentElement && currentElement.nodeName === "#document" /* NODE_NAMES.DOCUMENT_NODE */) {
        // the current element doesn't have a parent, but we've detected it's our root document node. push the window
        // object associated with the document onto the path
        composedPath.push(currentElement.defaultView);
        break;
      }
      currentElement = currentElement.parentElement;
    }
    return composedPath;
  }
}
class MockCustomEvent extends MockEvent {
  constructor(type, customEventInitDic) {
    super(type);
    this.detail = null;
    if (customEventInitDic != null) {
      Object.assign(this, customEventInitDic);
    }
  }
}
class MockKeyboardEvent extends MockEvent {
  constructor(type, keyboardEventInitDic) {
    super(type);
    this.code = '';
    this.key = '';
    this.altKey = false;
    this.ctrlKey = false;
    this.metaKey = false;
    this.shiftKey = false;
    this.location = 0;
    this.repeat = false;
    if (keyboardEventInitDic != null) {
      Object.assign(this, keyboardEventInitDic);
    }
  }
}
class MockMouseEvent extends MockEvent {
  constructor(type, mouseEventInitDic) {
    super(type);
    this.screenX = 0;
    this.screenY = 0;
    this.clientX = 0;
    this.clientY = 0;
    this.ctrlKey = false;
    this.shiftKey = false;
    this.altKey = false;
    this.metaKey = false;
    this.button = 0;
    this.buttons = 0;
    this.relatedTarget = null;
    if (mouseEventInitDic != null) {
      Object.assign(this, mouseEventInitDic);
    }
  }
}
class MockUIEvent extends MockEvent {
  constructor(type, uiEventInitDic) {
    super(type);
    this.detail = null;
    this.view = null;
    if (uiEventInitDic != null) {
      Object.assign(this, uiEventInitDic);
    }
  }
}
class MockFocusEvent extends MockUIEvent {
  constructor(type, focusEventInitDic) {
    super(type);
    this.relatedTarget = null;
    if (focusEventInitDic != null) {
      Object.assign(this, focusEventInitDic);
    }
  }
}
class MockEventListener {
  constructor(type, handler) {
    this.type = type;
    this.handler = handler;
  }
}
function addEventListener(elm, type, handler) {
  const target = elm;
  if (target.__listeners == null) {
    target.__listeners = [];
  }
  target.__listeners.push(new MockEventListener(type, handler));
}
function removeEventListener(elm, type, handler) {
  const target = elm;
  if (target != null && Array.isArray(target.__listeners) === true) {
    const elmListener = target.__listeners.find((e) => e.type === type && e.handler === handler);
    if (elmListener != null) {
      const index = target.__listeners.indexOf(elmListener);
      target.__listeners.splice(index, 1);
    }
  }
}
function resetEventListeners(target) {
  if (target != null && target.__listeners != null) {
    target.__listeners = null;
  }
}
function triggerEventListener(elm, ev) {
  if (elm == null || ev.cancelBubble === true) {
    return;
  }
  const target = elm;
  ev.currentTarget = elm;
  if (Array.isArray(target.__listeners) === true) {
    const listeners = target.__listeners.filter((e) => e.type === ev.type);
    listeners.forEach((listener) => {
      try {
        listener.handler.call(target, ev);
      }
      catch (err) {
        console.error(err);
      }
    });
  }
  if (ev.bubbles === false) {
    return;
  }
  if (elm.nodeName === "#document" /* NODE_NAMES.DOCUMENT_NODE */) {
    triggerEventListener(elm.defaultView, ev);
  }
  else {
    triggerEventListener(elm.parentElement, ev);
  }
}
function dispatchEvent(currentTarget, ev) {
  ev.target = currentTarget;
  triggerEventListener(currentTarget, ev);
  return true;
}

// Parse5 7.1.2
const e=function(e){const t=new Set([65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111]),s="�";var a;!function(e){e[e.EOF=-1]="EOF",e[e.NULL=0]="NULL",e[e.TABULATION=9]="TABULATION",e[e.CARRIAGE_RETURN=13]="CARRIAGE_RETURN",e[e.LINE_FEED=10]="LINE_FEED",e[e.FORM_FEED=12]="FORM_FEED",e[e.SPACE=32]="SPACE",e[e.EXCLAMATION_MARK=33]="EXCLAMATION_MARK",e[e.QUOTATION_MARK=34]="QUOTATION_MARK",e[e.NUMBER_SIGN=35]="NUMBER_SIGN",e[e.AMPERSAND=38]="AMPERSAND",e[e.APOSTROPHE=39]="APOSTROPHE",e[e.HYPHEN_MINUS=45]="HYPHEN_MINUS",e[e.SOLIDUS=47]="SOLIDUS",e[e.DIGIT_0=48]="DIGIT_0",e[e.DIGIT_9=57]="DIGIT_9",e[e.SEMICOLON=59]="SEMICOLON",e[e.LESS_THAN_SIGN=60]="LESS_THAN_SIGN",e[e.EQUALS_SIGN=61]="EQUALS_SIGN",e[e.GREATER_THAN_SIGN=62]="GREATER_THAN_SIGN",e[e.QUESTION_MARK=63]="QUESTION_MARK",e[e.LATIN_CAPITAL_A=65]="LATIN_CAPITAL_A",e[e.LATIN_CAPITAL_F=70]="LATIN_CAPITAL_F",e[e.LATIN_CAPITAL_X=88]="LATIN_CAPITAL_X",e[e.LATIN_CAPITAL_Z=90]="LATIN_CAPITAL_Z",e[e.RIGHT_SQUARE_BRACKET=93]="RIGHT_SQUARE_BRACKET",e[e.GRAVE_ACCENT=96]="GRAVE_ACCENT",e[e.LATIN_SMALL_A=97]="LATIN_SMALL_A",e[e.LATIN_SMALL_F=102]="LATIN_SMALL_F",e[e.LATIN_SMALL_X=120]="LATIN_SMALL_X",e[e.LATIN_SMALL_Z=122]="LATIN_SMALL_Z",e[e.REPLACEMENT_CHARACTER=65533]="REPLACEMENT_CHARACTER";}(a=a||(a={}));const r="[CDATA[",n="doctype",i="script";function o(e){return e>=55296&&e<=57343}function c(e){return 32!==e&&10!==e&&13!==e&&9!==e&&12!==e&&e>=1&&e<=31||e>=127&&e<=159}function E(e){return e>=64976&&e<=65007||t.has(e)}var T,h;!function(e){e.controlCharacterInInputStream="control-character-in-input-stream",e.noncharacterInInputStream="noncharacter-in-input-stream",e.surrogateInInputStream="surrogate-in-input-stream",e.nonVoidHtmlElementStartTagWithTrailingSolidus="non-void-html-element-start-tag-with-trailing-solidus",e.endTagWithAttributes="end-tag-with-attributes",e.endTagWithTrailingSolidus="end-tag-with-trailing-solidus",e.unexpectedSolidusInTag="unexpected-solidus-in-tag",e.unexpectedNullCharacter="unexpected-null-character",e.unexpectedQuestionMarkInsteadOfTagName="unexpected-question-mark-instead-of-tag-name",e.invalidFirstCharacterOfTagName="invalid-first-character-of-tag-name",e.unexpectedEqualsSignBeforeAttributeName="unexpected-equals-sign-before-attribute-name",e.missingEndTagName="missing-end-tag-name",e.unexpectedCharacterInAttributeName="unexpected-character-in-attribute-name",e.unknownNamedCharacterReference="unknown-named-character-reference",e.missingSemicolonAfterCharacterReference="missing-semicolon-after-character-reference",e.unexpectedCharacterAfterDoctypeSystemIdentifier="unexpected-character-after-doctype-system-identifier",e.unexpectedCharacterInUnquotedAttributeValue="unexpected-character-in-unquoted-attribute-value",e.eofBeforeTagName="eof-before-tag-name",e.eofInTag="eof-in-tag",e.missingAttributeValue="missing-attribute-value",e.missingWhitespaceBetweenAttributes="missing-whitespace-between-attributes",e.missingWhitespaceAfterDoctypePublicKeyword="missing-whitespace-after-doctype-public-keyword",e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers="missing-whitespace-between-doctype-public-and-system-identifiers",e.missingWhitespaceAfterDoctypeSystemKeyword="missing-whitespace-after-doctype-system-keyword",e.missingQuoteBeforeDoctypePublicIdentifier="missing-quote-before-doctype-public-identifier",e.missingQuoteBeforeDoctypeSystemIdentifier="missing-quote-before-doctype-system-identifier",e.missingDoctypePublicIdentifier="missing-doctype-public-identifier",e.missingDoctypeSystemIdentifier="missing-doctype-system-identifier",e.abruptDoctypePublicIdentifier="abrupt-doctype-public-identifier",e.abruptDoctypeSystemIdentifier="abrupt-doctype-system-identifier",e.cdataInHtmlContent="cdata-in-html-content",e.incorrectlyOpenedComment="incorrectly-opened-comment",e.eofInScriptHtmlCommentLikeText="eof-in-script-html-comment-like-text",e.eofInDoctype="eof-in-doctype",e.nestedComment="nested-comment",e.abruptClosingOfEmptyComment="abrupt-closing-of-empty-comment",e.eofInComment="eof-in-comment",e.incorrectlyClosedComment="incorrectly-closed-comment",e.eofInCdata="eof-in-cdata",e.absenceOfDigitsInNumericCharacterReference="absence-of-digits-in-numeric-character-reference",e.nullCharacterReference="null-character-reference",e.surrogateCharacterReference="surrogate-character-reference",e.characterReferenceOutsideUnicodeRange="character-reference-outside-unicode-range",e.controlCharacterReference="control-character-reference",e.noncharacterCharacterReference="noncharacter-character-reference",e.missingWhitespaceBeforeDoctypeName="missing-whitespace-before-doctype-name",e.missingDoctypeName="missing-doctype-name",e.invalidCharacterSequenceAfterDoctypeName="invalid-character-sequence-after-doctype-name",e.duplicateAttribute="duplicate-attribute",e.nonConformingDoctype="non-conforming-doctype",e.missingDoctype="missing-doctype",e.misplacedDoctype="misplaced-doctype",e.endTagWithoutMatchingOpenElement="end-tag-without-matching-open-element",e.closingOfElementWithOpenChildElements="closing-of-element-with-open-child-elements",e.disallowedContentInNoscriptInHead="disallowed-content-in-noscript-in-head",e.openElementsLeftAfterEof="open-elements-left-after-eof",e.abandonedHeadElementChild="abandoned-head-element-child",e.misplacedStartTagForHeadElement="misplaced-start-tag-for-head-element",e.nestedNoscriptInHead="nested-noscript-in-head",e.eofInElementThatCanContainOnlyText="eof-in-element-that-can-contain-only-text";}(T=T||(T={}));class _{constructor(e){this.handler=e,this.html="",this.pos=-1,this.lastGapPos=-2,this.gapStack=[],this.skipNextNewLine=!1,this.lastChunkWritten=!1,this.endOfChunkHit=!1,this.bufferWaterline=65536,this.isEol=!1,this.lineStartPos=0,this.droppedBufferSize=0,this.line=1,this.lastErrOffset=-1;}get col(){return this.pos-this.lineStartPos+Number(this.lastGapPos!==this.pos)}get offset(){return this.droppedBufferSize+this.pos}getError(e){const{line:t,col:s,offset:a}=this;return {code:e,startLine:t,endLine:t,startCol:s,endCol:s,startOffset:a,endOffset:a}}_err(e){this.handler.onParseError&&this.lastErrOffset!==this.offset&&(this.lastErrOffset=this.offset,this.handler.onParseError(this.getError(e)));}_addGap(){this.gapStack.push(this.lastGapPos),this.lastGapPos=this.pos;}_processSurrogate(e){if(this.pos!==this.html.length-1){const t=this.html.charCodeAt(this.pos+1);if(function(e){return e>=56320&&e<=57343}(t))return this.pos++,this._addGap(),1024*(e-55296)+9216+t}else if(!this.lastChunkWritten)return this.endOfChunkHit=!0,a.EOF;return this._err(T.surrogateInInputStream),e}willDropParsedChunk(){return this.pos>this.bufferWaterline}dropParsedChunk(){this.willDropParsedChunk()&&(this.html=this.html.substring(this.pos),this.lineStartPos-=this.pos,this.droppedBufferSize+=this.pos,this.pos=0,this.lastGapPos=-2,this.gapStack.length=0);}write(e,t){this.html.length>0?this.html+=e:this.html=e,this.endOfChunkHit=!1,this.lastChunkWritten=t;}insertHtmlAtCurrentPos(e){this.html=this.html.substring(0,this.pos+1)+e+this.html.substring(this.pos+1),this.endOfChunkHit=!1;}startsWith(e,t){if(this.pos+e.length>this.html.length)return this.endOfChunkHit=!this.lastChunkWritten,!1;if(t)return this.html.startsWith(e,this.pos);for(let t=0;t<e.length;t++)if((32|this.html.charCodeAt(this.pos+t))!==e.charCodeAt(t))return !1;return !0}peek(e){const t=this.pos+e;if(t>=this.html.length)return this.endOfChunkHit=!this.lastChunkWritten,a.EOF;const s=this.html.charCodeAt(t);return s===a.CARRIAGE_RETURN?a.LINE_FEED:s}advance(){if(this.pos++,this.isEol&&(this.isEol=!1,this.line++,this.lineStartPos=this.pos),this.pos>=this.html.length)return this.endOfChunkHit=!this.lastChunkWritten,a.EOF;let e=this.html.charCodeAt(this.pos);return e===a.CARRIAGE_RETURN?(this.isEol=!0,this.skipNextNewLine=!0,a.LINE_FEED):e===a.LINE_FEED&&(this.isEol=!0,this.skipNextNewLine)?(this.line--,this.skipNextNewLine=!1,this._addGap(),this.advance()):(this.skipNextNewLine=!1,o(e)&&(e=this._processSurrogate(e)),null===this.handler.onParseError||e>31&&e<127||e===a.LINE_FEED||e===a.CARRIAGE_RETURN||e>159&&e<64976||this._checkForProblematicCharacters(e),e)}_checkForProblematicCharacters(e){c(e)?this._err(T.controlCharacterInInputStream):E(e)&&this._err(T.noncharacterInInputStream);}retreat(e){for(this.pos-=e;this.pos<this.lastGapPos;)this.lastGapPos=this.gapStack.pop(),this.pos--;this.isEol=!1;}}function A(e,t){for(let s=e.attrs.length-1;s>=0;s--)if(e.attrs[s].name===t)return e.attrs[s].value;return null}!function(e){e[e.CHARACTER=0]="CHARACTER",e[e.NULL_CHARACTER=1]="NULL_CHARACTER",e[e.WHITESPACE_CHARACTER=2]="WHITESPACE_CHARACTER",e[e.START_TAG=3]="START_TAG",e[e.END_TAG=4]="END_TAG",e[e.COMMENT=5]="COMMENT",e[e.DOCTYPE=6]="DOCTYPE",e[e.EOF=7]="EOF",e[e.HIBERNATION=8]="HIBERNATION";}(h=h||(h={}));var l="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function m(e,t,s){return e(s={path:t,exports:{},require:function(e,t){return function(){throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs")}(null==t&&s.path)}},s.exports),s.exports}var p,d,I,N,u,C=m((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=new Uint16Array('ᵁ<Õıʊҝջאٵ۞ޢߖࠏ੊ઑඡ๭༉༦჊ረዡᐕᒝᓃᓟᔥ\0\0\0\0\0\0ᕫᛍᦍᰒᷝ὾⁠↰⊍⏀⏻⑂⠤⤒ⴈ⹈⿎〖㊺㘹㞬㣾㨨㩱㫠㬮ࠀEMabcfglmnoprstu\\bfms¦³¹ÈÏlig耻Æ䃆P耻&䀦cute耻Á䃁reve;䄂Āiyx}rc耻Â䃂;䐐r;쀀𝔄rave耻À䃀pha;䎑acr;䄀d;橓Āgp¡on;䄄f;쀀𝔸plyFunction;恡ing耻Å䃅Ācs¾Ãr;쀀𝒜ign;扔ilde耻Ã䃃ml耻Ä䃄ЀaceforsuåûþėĜĢħĪĀcrêòkslash;或Ŷöø;櫧ed;挆y;䐑ƀcrtąċĔause;戵noullis;愬a;䎒r;쀀𝔅pf;쀀𝔹eve;䋘còēmpeq;扎܀HOacdefhilorsuōőŖƀƞƢƵƷƺǜȕɳɸɾcy;䐧PY耻©䂩ƀcpyŝŢźute;䄆Ā;iŧŨ拒talDifferentialD;慅leys;愭ȀaeioƉƎƔƘron;䄌dil耻Ç䃇rc;䄈nint;戰ot;䄊ĀdnƧƭilla;䂸terDot;䂷òſi;䎧rcleȀDMPTǇǋǑǖot;抙inus;抖lus;投imes;抗oĀcsǢǸkwiseContourIntegral;戲eCurlyĀDQȃȏoubleQuote;思uote;怙ȀlnpuȞȨɇɕonĀ;eȥȦ户;橴ƀgitȯȶȺruent;扡nt;戯ourIntegral;戮ĀfrɌɎ;愂oduct;成nterClockwiseContourIntegral;戳oss;樯cr;쀀𝒞pĀ;Cʄʅ拓ap;才րDJSZacefiosʠʬʰʴʸˋ˗ˡ˦̳ҍĀ;oŹʥtrahd;椑cy;䐂cy;䐅cy;䐏ƀgrsʿ˄ˇger;怡r;憡hv;櫤Āayː˕ron;䄎;䐔lĀ;t˝˞戇a;䎔r;쀀𝔇Āaf˫̧Ācm˰̢riticalȀADGT̖̜̀̆cute;䂴oŴ̋̍;䋙bleAcute;䋝rave;䁠ilde;䋜ond;拄ferentialD;慆Ѱ̽\0\0\0͔͂\0Ѕf;쀀𝔻ƀ;DE͈͉͍䂨ot;惜qual;扐blèCDLRUVͣͲ΂ϏϢϸontourIntegraìȹoɴ͹\0\0ͻ»͉nArrow;懓Āeo·ΤftƀARTΐΖΡrrow;懐ightArrow;懔eåˊngĀLRΫτeftĀARγιrrow;柸ightArrow;柺ightArrow;柹ightĀATϘϞrrow;懒ee;抨pɁϩ\0\0ϯrrow;懑ownArrow;懕erticalBar;戥ǹABLRTaВЪаўѿͼrrowƀ;BUНОТ憓ar;椓pArrow;懵reve;䌑eft˒к\0ц\0ѐightVector;楐eeVector;楞ectorĀ;Bљњ憽ar;楖ightǔѧ\0ѱeeVector;楟ectorĀ;BѺѻ懁ar;楗eeĀ;A҆҇护rrow;憧ĀctҒҗr;쀀𝒟rok;䄐ࠀNTacdfglmopqstuxҽӀӄӋӞӢӧӮӵԡԯԶՒ՝ՠեG;䅊H耻Ð䃐cute耻É䃉ƀaiyӒӗӜron;䄚rc耻Ê䃊;䐭ot;䄖r;쀀𝔈rave耻È䃈ement;戈ĀapӺӾcr;䄒tyɓԆ\0\0ԒmallSquare;旻erySmallSquare;斫ĀgpԦԪon;䄘f;쀀𝔼silon;䎕uĀaiԼՉlĀ;TՂՃ橵ilde;扂librium;懌Āci՗՚r;愰m;橳a;䎗ml耻Ë䃋Āipժկsts;戃onentialE;慇ʀcfiosօֈ֍ֲ׌y;䐤r;쀀𝔉lledɓ֗\0\0֣mallSquare;旼erySmallSquare;斪Ͱֺ\0ֿ\0\0ׄf;쀀𝔽All;戀riertrf;愱cò׋؀JTabcdfgorstר׬ׯ׺؀ؒؖ؛؝أ٬ٲcy;䐃耻>䀾mmaĀ;d׷׸䎓;䏜reve;䄞ƀeiy؇،ؐdil;䄢rc;䄜;䐓ot;䄠r;쀀𝔊;拙pf;쀀𝔾eater̀EFGLSTصلَٖٛ٦qualĀ;Lؾؿ扥ess;招ullEqual;执reater;檢ess;扷lantEqual;橾ilde;扳cr;쀀𝒢;扫ЀAacfiosuڅڋږڛڞڪھۊRDcy;䐪Āctڐڔek;䋇;䁞irc;䄤r;愌lbertSpace;愋ǰگ\0ڲf;愍izontalLine;攀Āctۃۅòکrok;䄦mpńېۘownHumðįqual;扏܀EJOacdfgmnostuۺ۾܃܇܎ܚܞܡܨ݄ݸދޏޕcy;䐕lig;䄲cy;䐁cute耻Í䃍Āiyܓܘrc耻Î䃎;䐘ot;䄰r;愑rave耻Ì䃌ƀ;apܠܯܿĀcgܴܷr;䄪inaryI;慈lieóϝǴ݉\0ݢĀ;eݍݎ戬Āgrݓݘral;戫section;拂isibleĀCTݬݲomma;恣imes;恢ƀgptݿރވon;䄮f;쀀𝕀a;䎙cr;愐ilde;䄨ǫޚ\0ޞcy;䐆l耻Ï䃏ʀcfosuެ޷޼߂ߐĀiyޱ޵rc;䄴;䐙r;쀀𝔍pf;쀀𝕁ǣ߇\0ߌr;쀀𝒥rcy;䐈kcy;䐄΀HJacfosߤߨ߽߬߱ࠂࠈcy;䐥cy;䐌ppa;䎚Āey߶߻dil;䄶;䐚r;쀀𝔎pf;쀀𝕂cr;쀀𝒦րJTaceflmostࠥࠩࠬࡐࡣ঳সে্਷ੇcy;䐉耻<䀼ʀcmnpr࠷࠼ࡁࡄࡍute;䄹bda;䎛g;柪lacetrf;愒r;憞ƀaeyࡗ࡜ࡡron;䄽dil;䄻;䐛Āfsࡨ॰tԀACDFRTUVarࡾࢩࢱࣦ࣠ࣼयज़ΐ४Ānrࢃ࢏gleBracket;柨rowƀ;BR࢙࢚࢞憐ar;懤ightArrow;懆eiling;挈oǵࢷ\0ࣃbleBracket;柦nǔࣈ\0࣒eeVector;楡ectorĀ;Bࣛࣜ懃ar;楙loor;挊ightĀAV࣯ࣵrrow;憔ector;楎Āerँगeƀ;AVउऊऐ抣rrow;憤ector;楚iangleƀ;BEतथऩ抲ar;槏qual;抴pƀDTVषूौownVector;楑eeVector;楠ectorĀ;Bॖॗ憿ar;楘ectorĀ;B॥०憼ar;楒ightáΜs̀EFGLSTॾঋকঝঢভqualGreater;拚ullEqual;扦reater;扶ess;檡lantEqual;橽ilde;扲r;쀀𝔏Ā;eঽা拘ftarrow;懚idot;䄿ƀnpw৔ਖਛgȀLRlr৞৷ਂਐeftĀAR০৬rrow;柵ightArrow;柷ightArrow;柶eftĀarγਊightáοightáϊf;쀀𝕃erĀLRਢਬeftArrow;憙ightArrow;憘ƀchtਾੀੂòࡌ;憰rok;䅁;扪Ѐacefiosuਗ਼੝੠੷੼અઋ઎p;椅y;䐜Ādl੥੯iumSpace;恟lintrf;愳r;쀀𝔐nusPlus;戓pf;쀀𝕄cò੶;䎜ҀJacefostuણધભીଔଙඑ඗ඞcy;䐊cute;䅃ƀaey઴હાron;䅇dil;䅅;䐝ƀgswે૰଎ativeƀMTV૓૟૨ediumSpace;怋hiĀcn૦૘ë૙eryThiî૙tedĀGL૸ଆreaterGreateòٳessLesóੈLine;䀊r;쀀𝔑ȀBnptଢନଷ଺reak;恠BreakingSpace;䂠f;愕ڀ;CDEGHLNPRSTV୕ୖ୪୼஡௫ఄ౞಄ದ೘ൡඅ櫬Āou୛୤ngruent;扢pCap;扭oubleVerticalBar;戦ƀlqxஃஊ஛ement;戉ualĀ;Tஒஓ扠ilde;쀀≂̸ists;戄reater΀;EFGLSTஶஷ஽௉௓௘௥扯qual;扱ullEqual;쀀≧̸reater;쀀≫̸ess;批lantEqual;쀀⩾̸ilde;扵umpń௲௽ownHump;쀀≎̸qual;쀀≏̸eĀfsఊధtTriangleƀ;BEచఛడ拪ar;쀀⧏̸qual;括s̀;EGLSTవశ఼ౄోౘ扮qual;扰reater;扸ess;쀀≪̸lantEqual;쀀⩽̸ilde;扴estedĀGL౨౹reaterGreater;쀀⪢̸essLess;쀀⪡̸recedesƀ;ESಒಓಛ技qual;쀀⪯̸lantEqual;拠ĀeiಫಹverseElement;戌ghtTriangleƀ;BEೋೌ೒拫ar;쀀⧐̸qual;拭ĀquೝഌuareSuĀbp೨೹setĀ;E೰ೳ쀀⊏̸qual;拢ersetĀ;Eഃആ쀀⊐̸qual;拣ƀbcpഓതൎsetĀ;Eഛഞ쀀⊂⃒qual;抈ceedsȀ;ESTലള഻െ抁qual;쀀⪰̸lantEqual;拡ilde;쀀≿̸ersetĀ;E൘൛쀀⊃⃒qual;抉ildeȀ;EFT൮൯൵ൿ扁qual;扄ullEqual;扇ilde;扉erticalBar;戤cr;쀀𝒩ilde耻Ñ䃑;䎝܀Eacdfgmoprstuvලෂ෉෕ෛ෠෧෼ขภยา฿ไlig;䅒cute耻Ó䃓Āiy෎ීrc耻Ô䃔;䐞blac;䅐r;쀀𝔒rave耻Ò䃒ƀaei෮ෲ෶cr;䅌ga;䎩cron;䎟pf;쀀𝕆enCurlyĀDQฎบoubleQuote;怜uote;怘;橔Āclวฬr;쀀𝒪ash耻Ø䃘iŬื฼de耻Õ䃕es;樷ml耻Ö䃖erĀBP๋๠Āar๐๓r;怾acĀek๚๜;揞et;掴arenthesis;揜Ҁacfhilors๿ງຊຏຒດຝະ໼rtialD;戂y;䐟r;쀀𝔓i;䎦;䎠usMinus;䂱Āipຢອncareplanåڝf;愙Ȁ;eio຺ູ໠໤檻cedesȀ;EST່້໏໚扺qual;檯lantEqual;扼ilde;找me;怳Ādp໩໮uct;戏ortionĀ;aȥ໹l;戝Āci༁༆r;쀀𝒫;䎨ȀUfos༑༖༛༟OT耻"䀢r;쀀𝔔pf;愚cr;쀀𝒬؀BEacefhiorsu༾གྷཇའཱིྦྷྪྭ႖ႩႴႾarr;椐G耻®䂮ƀcnrཎནབute;䅔g;柫rĀ;tཛྷཝ憠l;椖ƀaeyཧཬཱron;䅘dil;䅖;䐠Ā;vླྀཹ愜erseĀEUྂྙĀlq྇ྎement;戋uilibrium;懋pEquilibrium;楯r»ཹo;䎡ghtЀACDFTUVa࿁࿫࿳ဢဨၛႇϘĀnr࿆࿒gleBracket;柩rowƀ;BL࿜࿝࿡憒ar;懥eftArrow;懄eiling;按oǵ࿹\0စbleBracket;柧nǔည\0နeeVector;楝ectorĀ;Bဝသ懂ar;楕loor;挋Āerိ၃eƀ;AVဵံြ抢rrow;憦ector;楛iangleƀ;BEၐၑၕ抳ar;槐qual;抵pƀDTVၣၮၸownVector;楏eeVector;楜ectorĀ;Bႂႃ憾ar;楔ectorĀ;B႑႒懀ar;楓Āpuႛ႞f;愝ndImplies;楰ightarrow;懛ĀchႹႼr;愛;憱leDelayed;槴ڀHOacfhimoqstuფჱჷჽᄙᄞᅑᅖᅡᅧᆵᆻᆿĀCcჩხHcy;䐩y;䐨FTcy;䐬cute;䅚ʀ;aeiyᄈᄉᄎᄓᄗ檼ron;䅠dil;䅞rc;䅜;䐡r;쀀𝔖ortȀDLRUᄪᄴᄾᅉownArrow»ОeftArrow»࢚ightArrow»࿝pArrow;憑gma;䎣allCircle;战pf;쀀𝕊ɲᅭ\0\0ᅰt;戚areȀ;ISUᅻᅼᆉᆯ斡ntersection;抓uĀbpᆏᆞsetĀ;Eᆗᆘ抏qual;抑ersetĀ;Eᆨᆩ抐qual;抒nion;抔cr;쀀𝒮ar;拆ȀbcmpᇈᇛሉላĀ;sᇍᇎ拐etĀ;Eᇍᇕqual;抆ĀchᇠህeedsȀ;ESTᇭᇮᇴᇿ扻qual;檰lantEqual;扽ilde;承Tháྌ;我ƀ;esሒሓሣ拑rsetĀ;Eሜም抃qual;抇et»ሓրHRSacfhiorsሾቄ቉ቕ቞ቱቶኟዂወዑORN耻Þ䃞ADE;愢ĀHc቎ቒcy;䐋y;䐦Ābuቚቜ;䀉;䎤ƀaeyብቪቯron;䅤dil;䅢;䐢r;쀀𝔗Āeiቻ኉ǲኀ\0ኇefore;戴a;䎘Ācn኎ኘkSpace;쀀  Space;怉ldeȀ;EFTካኬኲኼ戼qual;扃ullEqual;扅ilde;扈pf;쀀𝕋ipleDot;惛Āctዖዛr;쀀𝒯rok;䅦ૡዷጎጚጦ\0ጬጱ\0\0\0\0\0ጸጽ፷ᎅ\0᏿ᐄᐊᐐĀcrዻጁute耻Ú䃚rĀ;oጇገ憟cir;楉rǣጓ\0጖y;䐎ve;䅬Āiyጞጣrc耻Û䃛;䐣blac;䅰r;쀀𝔘rave耻Ù䃙acr;䅪Ādiፁ፩erĀBPፈ፝Āarፍፐr;䁟acĀekፗፙ;揟et;掵arenthesis;揝onĀ;P፰፱拃lus;抎Āgp፻፿on;䅲f;쀀𝕌ЀADETadps᎕ᎮᎸᏄϨᏒᏗᏳrrowƀ;BDᅐᎠᎤar;椒ownArrow;懅ownArrow;憕quilibrium;楮eeĀ;AᏋᏌ报rrow;憥ownáϳerĀLRᏞᏨeftArrow;憖ightArrow;憗iĀ;lᏹᏺ䏒on;䎥ing;䅮cr;쀀𝒰ilde;䅨ml耻Ü䃜ҀDbcdefosvᐧᐬᐰᐳᐾᒅᒊᒐᒖash;披ar;櫫y;䐒ashĀ;lᐻᐼ抩;櫦Āerᑃᑅ;拁ƀbtyᑌᑐᑺar;怖Ā;iᑏᑕcalȀBLSTᑡᑥᑪᑴar;戣ine;䁼eparator;杘ilde;所ThinSpace;怊r;쀀𝔙pf;쀀𝕍cr;쀀𝒱dash;抪ʀcefosᒧᒬᒱᒶᒼirc;䅴dge;拀r;쀀𝔚pf;쀀𝕎cr;쀀𝒲Ȁfiosᓋᓐᓒᓘr;쀀𝔛;䎞pf;쀀𝕏cr;쀀𝒳ҀAIUacfosuᓱᓵᓹᓽᔄᔏᔔᔚᔠcy;䐯cy;䐇cy;䐮cute耻Ý䃝Āiyᔉᔍrc;䅶;䐫r;쀀𝔜pf;쀀𝕐cr;쀀𝒴ml;䅸ЀHacdefosᔵᔹᔿᕋᕏᕝᕠᕤcy;䐖cute;䅹Āayᕄᕉron;䅽;䐗ot;䅻ǲᕔ\0ᕛoWidtè૙a;䎖r;愨pf;愤cr;쀀𝒵௡ᖃᖊᖐ\0ᖰᖶᖿ\0\0\0\0ᗆᗛᗫᙟ᙭\0ᚕ᚛ᚲᚹ\0ᚾcute耻á䃡reve;䄃̀;Ediuyᖜᖝᖡᖣᖨᖭ戾;쀀∾̳;房rc耻â䃢te肻´̆;䐰lig耻æ䃦Ā;r²ᖺ;쀀𝔞rave耻à䃠ĀepᗊᗖĀfpᗏᗔsym;愵èᗓha;䎱ĀapᗟcĀclᗤᗧr;䄁g;樿ɤᗰ\0\0ᘊʀ;adsvᗺᗻᗿᘁᘇ戧nd;橕;橜lope;橘;橚΀;elmrszᘘᘙᘛᘞᘿᙏᙙ戠;榤e»ᘙsdĀ;aᘥᘦ戡ѡᘰᘲᘴᘶᘸᘺᘼᘾ;榨;榩;榪;榫;榬;榭;榮;榯tĀ;vᙅᙆ戟bĀ;dᙌᙍ抾;榝Āptᙔᙗh;戢»¹arr;捼Āgpᙣᙧon;䄅f;쀀𝕒΀;Eaeiop዁ᙻᙽᚂᚄᚇᚊ;橰cir;橯;扊d;手s;䀧roxĀ;e዁ᚒñᚃing耻å䃥ƀctyᚡᚦᚨr;쀀𝒶;䀪mpĀ;e዁ᚯñʈilde耻ã䃣ml耻ä䃤Āciᛂᛈoninôɲnt;樑ࠀNabcdefiklnoprsu᛭ᛱᜰ᜼ᝃᝈ᝸᝽០៦ᠹᡐᜍ᤽᥈ᥰot;櫭Ācrᛶ᜞kȀcepsᜀᜅᜍᜓong;扌psilon;䏶rime;怵imĀ;e᜚᜛戽q;拍Ŷᜢᜦee;抽edĀ;gᜬᜭ挅e»ᜭrkĀ;t፜᜷brk;掶Āoyᜁᝁ;䐱quo;怞ʀcmprtᝓ᝛ᝡᝤᝨausĀ;eĊĉptyv;榰séᜌnoõēƀahwᝯ᝱ᝳ;䎲;愶een;扬r;쀀𝔟g΀costuvwឍឝឳេ៕៛៞ƀaiuបពរðݠrc;旯p»፱ƀdptឤឨឭot;樀lus;樁imes;樂ɱឹ\0\0ើcup;樆ar;昅riangleĀdu៍្own;施p;斳plus;樄eåᑄåᒭarow;植ƀako៭ᠦᠵĀcn៲ᠣkƀlst៺֫᠂ozenge;槫riangleȀ;dlr᠒᠓᠘᠝斴own;斾eft;旂ight;斸k;搣Ʊᠫ\0ᠳƲᠯ\0ᠱ;斒;斑4;斓ck;斈ĀeoᠾᡍĀ;qᡃᡆ쀀=⃥uiv;쀀≡⃥t;挐Ȁptwxᡙᡞᡧᡬf;쀀𝕓Ā;tᏋᡣom»Ꮜtie;拈؀DHUVbdhmptuvᢅᢖᢪᢻᣗᣛᣬ᣿ᤅᤊᤐᤡȀLRlrᢎᢐᢒᢔ;敗;敔;敖;敓ʀ;DUduᢡᢢᢤᢦᢨ敐;敦;敩;敤;敧ȀLRlrᢳᢵᢷᢹ;敝;敚;敜;教΀;HLRhlrᣊᣋᣍᣏᣑᣓᣕ救;敬;散;敠;敫;敢;敟ox;槉ȀLRlrᣤᣦᣨᣪ;敕;敒;攐;攌ʀ;DUduڽ᣷᣹᣻᣽;敥;敨;攬;攴inus;抟lus;択imes;抠ȀLRlrᤙᤛᤝ᤟;敛;敘;攘;攔΀;HLRhlrᤰᤱᤳᤵᤷ᤻᤹攂;敪;敡;敞;攼;攤;攜Āevģ᥂bar耻¦䂦Ȁceioᥑᥖᥚᥠr;쀀𝒷mi;恏mĀ;e᜚᜜lƀ;bhᥨᥩᥫ䁜;槅sub;柈Ŭᥴ᥾lĀ;e᥹᥺怢t»᥺pƀ;Eeįᦅᦇ;檮Ā;qۜۛೡᦧ\0᧨ᨑᨕᨲ\0ᨷᩐ\0\0᪴\0\0᫁\0\0ᬡᬮ᭍᭒\0᯽\0ᰌƀcpr᦭ᦲ᧝ute;䄇̀;abcdsᦿᧀᧄ᧊᧕᧙戩nd;橄rcup;橉Āau᧏᧒p;橋p;橇ot;橀;쀀∩︀Āeo᧢᧥t;恁îړȀaeiu᧰᧻ᨁᨅǰ᧵\0᧸s;橍on;䄍dil耻ç䃧rc;䄉psĀ;sᨌᨍ橌m;橐ot;䄋ƀdmnᨛᨠᨦil肻¸ƭptyv;榲t脀¢;eᨭᨮ䂢räƲr;쀀𝔠ƀceiᨽᩀᩍy;䑇ckĀ;mᩇᩈ朓ark»ᩈ;䏇r΀;Ecefms᩟᩠ᩢᩫ᪤᪪᪮旋;槃ƀ;elᩩᩪᩭ䋆q;扗eɡᩴ\0\0᪈rrowĀlr᩼᪁eft;憺ight;憻ʀRSacd᪒᪔᪖᪚᪟»ཇ;擈st;抛irc;抚ash;抝nint;樐id;櫯cir;槂ubsĀ;u᪻᪼晣it»᪼ˬ᫇᫔᫺\0ᬊonĀ;eᫍᫎ䀺Ā;qÇÆɭ᫙\0\0᫢aĀ;t᫞᫟䀬;䁀ƀ;fl᫨᫩᫫戁îᅠeĀmx᫱᫶ent»᫩eóɍǧ᫾\0ᬇĀ;dኻᬂot;橭nôɆƀfryᬐᬔᬗ;쀀𝕔oäɔ脀©;sŕᬝr;愗Āaoᬥᬩrr;憵ss;朗Ācuᬲᬷr;쀀𝒸Ābpᬼ᭄Ā;eᭁᭂ櫏;櫑Ā;eᭉᭊ櫐;櫒dot;拯΀delprvw᭠᭬᭷ᮂᮬᯔ᯹arrĀlr᭨᭪;椸;椵ɰ᭲\0\0᭵r;拞c;拟arrĀ;p᭿ᮀ憶;椽̀;bcdosᮏᮐᮖᮡᮥᮨ截rcap;橈Āauᮛᮞp;橆p;橊ot;抍r;橅;쀀∪︀Ȁalrv᮵ᮿᯞᯣrrĀ;mᮼᮽ憷;椼yƀevwᯇᯔᯘqɰᯎ\0\0ᯒreã᭳uã᭵ee;拎edge;拏en耻¤䂤earrowĀlrᯮ᯳eft»ᮀight»ᮽeäᯝĀciᰁᰇoninôǷnt;戱lcty;挭ঀAHabcdefhijlorstuwz᰸᰻᰿ᱝᱩᱵᲊᲞᲬᲷ᳻᳿ᴍᵻᶑᶫᶻ᷆᷍rò΁ar;楥Ȁglrs᱈ᱍ᱒᱔ger;怠eth;愸òᄳhĀ;vᱚᱛ怐»ऊūᱡᱧarow;椏aã̕Āayᱮᱳron;䄏;䐴ƀ;ao̲ᱼᲄĀgrʿᲁr;懊tseq;橷ƀglmᲑᲔᲘ耻°䂰ta;䎴ptyv;榱ĀirᲣᲨsht;楿;쀀𝔡arĀlrᲳᲵ»ࣜ»သʀaegsv᳂͸᳖᳜᳠mƀ;oș᳊᳔ndĀ;ș᳑uit;晦amma;䏝in;拲ƀ;io᳧᳨᳸䃷de脀÷;o᳧ᳰntimes;拇nø᳷cy;䑒cɯᴆ\0\0ᴊrn;挞op;挍ʀlptuwᴘᴝᴢᵉᵕlar;䀤f;쀀𝕕ʀ;emps̋ᴭᴷᴽᵂqĀ;d͒ᴳot;扑inus;戸lus;戔quare;抡blebarwedgåúnƀadhᄮᵝᵧownarrowóᲃarpoonĀlrᵲᵶefôᲴighôᲶŢᵿᶅkaro÷གɯᶊ\0\0ᶎrn;挟op;挌ƀcotᶘᶣᶦĀryᶝᶡ;쀀𝒹;䑕l;槶rok;䄑Ādrᶰᶴot;拱iĀ;fᶺ᠖斿Āah᷀᷃ròЩaòྦangle;榦Āci᷒ᷕy;䑟grarr;柿ऀDacdefglmnopqrstuxḁḉḙḸոḼṉṡṾấắẽỡἪἷὄ὎὚ĀDoḆᴴoôᲉĀcsḎḔute耻é䃩ter;橮ȀaioyḢḧḱḶron;䄛rĀ;cḭḮ扖耻ê䃪lon;払;䑍ot;䄗ĀDrṁṅot;扒;쀀𝔢ƀ;rsṐṑṗ檚ave耻è䃨Ā;dṜṝ檖ot;檘Ȁ;ilsṪṫṲṴ檙nters;揧;愓Ā;dṹṺ檕ot;檗ƀapsẅẉẗcr;䄓tyƀ;svẒẓẕ戅et»ẓpĀ1;ẝẤĳạả;怄;怅怃ĀgsẪẬ;䅋p;怂ĀgpẴẸon;䄙f;쀀𝕖ƀalsỄỎỒrĀ;sỊị拕l;槣us;橱iƀ;lvỚớở䎵on»ớ;䏵ȀcsuvỪỳἋἣĀioữḱrc»Ḯɩỹ\0\0ỻíՈantĀglἂἆtr»ṝess»Ṻƀaeiἒ἖Ἒls;䀽st;扟vĀ;DȵἠD;橸parsl;槥ĀDaἯἳot;打rr;楱ƀcdiἾὁỸr;愯oô͒ĀahὉὋ;䎷耻ð䃰Āmrὓὗl耻ë䃫o;悬ƀcipὡὤὧl;䀡sôծĀeoὬὴctatioîՙnentialåչৡᾒ\0ᾞ\0ᾡᾧ\0\0ῆῌ\0ΐ\0ῦῪ \0 ⁚llingdotseñṄy;䑄male;晀ƀilrᾭᾳ῁lig;耀ﬃɩᾹ\0\0᾽g;耀ﬀig;耀ﬄ;쀀𝔣lig;耀ﬁlig;쀀fjƀaltῙ῜ῡt;晭ig;耀ﬂns;斱of;䆒ǰ΅\0ῳf;쀀𝕗ĀakֿῷĀ;vῼ´拔;櫙artint;樍Āao‌⁕Ācs‑⁒α‚‰‸⁅⁈\0⁐β•‥‧‪‬\0‮耻½䂽;慓耻¼䂼;慕;慙;慛Ƴ‴\0‶;慔;慖ʴ‾⁁\0\0⁃耻¾䂾;慗;慜5;慘ƶ⁌\0⁎;慚;慝8;慞l;恄wn;挢cr;쀀𝒻ࢀEabcdefgijlnorstv₂₉₟₥₰₴⃰⃵⃺⃿℃ℒℸ̗ℾ⅒↞Ā;lٍ₇;檌ƀcmpₐₕ₝ute;䇵maĀ;dₜ᳚䎳;檆reve;䄟Āiy₪₮rc;䄝;䐳ot;䄡Ȁ;lqsؾق₽⃉ƀ;qsؾٌ⃄lanô٥Ȁ;cdl٥⃒⃥⃕c;檩otĀ;o⃜⃝檀Ā;l⃢⃣檂;檄Ā;e⃪⃭쀀⋛︀s;檔r;쀀𝔤Ā;gٳ؛mel;愷cy;䑓Ȁ;Eajٚℌℎℐ;檒;檥;檤ȀEaesℛℝ℩ℴ;扩pĀ;p℣ℤ檊rox»ℤĀ;q℮ℯ檈Ā;q℮ℛim;拧pf;쀀𝕘Āci⅃ⅆr;愊mƀ;el٫ⅎ⅐;檎;檐茀>;cdlqr׮ⅠⅪⅮⅳⅹĀciⅥⅧ;檧r;橺ot;拗Par;榕uest;橼ʀadelsↄⅪ←ٖ↛ǰ↉\0↎proø₞r;楸qĀlqؿ↖lesó₈ií٫Āen↣↭rtneqq;쀀≩︀Å↪ԀAabcefkosy⇄⇇⇱⇵⇺∘∝∯≨≽ròΠȀilmr⇐⇔⇗⇛rsðᒄf»․ilôکĀdr⇠⇤cy;䑊ƀ;cwࣴ⇫⇯ir;楈;憭ar;意irc;䄥ƀalr∁∎∓rtsĀ;u∉∊晥it»∊lip;怦con;抹r;쀀𝔥sĀew∣∩arow;椥arow;椦ʀamopr∺∾≃≞≣rr;懿tht;戻kĀlr≉≓eftarrow;憩ightarrow;憪f;쀀𝕙bar;怕ƀclt≯≴≸r;쀀𝒽asè⇴rok;䄧Ābp⊂⊇ull;恃hen»ᱛૡ⊣\0⊪\0⊸⋅⋎\0⋕⋳\0\0⋸⌢⍧⍢⍿\0⎆⎪⎴cute耻í䃭ƀ;iyݱ⊰⊵rc耻î䃮;䐸Ācx⊼⊿y;䐵cl耻¡䂡ĀfrΟ⋉;쀀𝔦rave耻ì䃬Ȁ;inoܾ⋝⋩⋮Āin⋢⋦nt;樌t;戭fin;槜ta;愩lig;䄳ƀaop⋾⌚⌝ƀcgt⌅⌈⌗r;䄫ƀelpܟ⌏⌓inåގarôܠh;䄱f;抷ed;䆵ʀ;cfotӴ⌬⌱⌽⍁are;愅inĀ;t⌸⌹戞ie;槝doô⌙ʀ;celpݗ⍌⍐⍛⍡al;抺Āgr⍕⍙eróᕣã⍍arhk;樗rod;樼Ȁcgpt⍯⍲⍶⍻y;䑑on;䄯f;쀀𝕚a;䎹uest耻¿䂿Āci⎊⎏r;쀀𝒾nʀ;EdsvӴ⎛⎝⎡ӳ;拹ot;拵Ā;v⎦⎧拴;拳Ā;iݷ⎮lde;䄩ǫ⎸\0⎼cy;䑖l耻ï䃯̀cfmosu⏌⏗⏜⏡⏧⏵Āiy⏑⏕rc;䄵;䐹r;쀀𝔧ath;䈷pf;쀀𝕛ǣ⏬\0⏱r;쀀𝒿rcy;䑘kcy;䑔Ѐacfghjos␋␖␢␧␭␱␵␻ppaĀ;v␓␔䎺;䏰Āey␛␠dil;䄷;䐺r;쀀𝔨reen;䄸cy;䑅cy;䑜pf;쀀𝕜cr;쀀𝓀஀ABEHabcdefghjlmnoprstuv⑰⒁⒆⒍⒑┎┽╚▀♎♞♥♹♽⚚⚲⛘❝❨➋⟀⠁⠒ƀart⑷⑺⑼rò৆òΕail;椛arr;椎Ā;gঔ⒋;檋ar;楢ॣ⒥\0⒪\0⒱\0\0\0\0\0⒵Ⓔ\0ⓆⓈⓍ\0⓹ute;䄺mptyv;榴raîࡌbda;䎻gƀ;dlࢎⓁⓃ;榑åࢎ;檅uo耻«䂫rЀ;bfhlpst࢙ⓞⓦⓩ⓫⓮⓱⓵Ā;f࢝ⓣs;椟s;椝ë≒p;憫l;椹im;楳l;憢ƀ;ae⓿─┄檫il;椙Ā;s┉┊檭;쀀⪭︀ƀabr┕┙┝rr;椌rk;杲Āak┢┬cĀek┨┪;䁻;䁛Āes┱┳;榋lĀdu┹┻;榏;榍Ȁaeuy╆╋╖╘ron;䄾Ādi═╔il;䄼ìࢰâ┩;䐻Ȁcqrs╣╦╭╽a;椶uoĀ;rนᝆĀdu╲╷har;楧shar;楋h;憲ʀ;fgqs▋▌উ◳◿扤tʀahlrt▘▤▷◂◨rrowĀ;t࢙□aé⓶arpoonĀdu▯▴own»њp»०eftarrows;懇ightƀahs◍◖◞rrowĀ;sࣴࢧarpoonó྘quigarro÷⇰hreetimes;拋ƀ;qs▋ও◺lanôবʀ;cdgsব☊☍☝☨c;檨otĀ;o☔☕橿Ā;r☚☛檁;檃Ā;e☢☥쀀⋚︀s;檓ʀadegs☳☹☽♉♋pproøⓆot;拖qĀgq♃♅ôউgtò⒌ôছiíলƀilr♕࣡♚sht;楼;쀀𝔩Ā;Eজ♣;檑š♩♶rĀdu▲♮Ā;l॥♳;楪lk;斄cy;䑙ʀ;achtੈ⚈⚋⚑⚖rò◁orneòᴈard;楫ri;旺Āio⚟⚤dot;䅀ustĀ;a⚬⚭掰che»⚭ȀEaes⚻⚽⛉⛔;扨pĀ;p⛃⛄檉rox»⛄Ā;q⛎⛏檇Ā;q⛎⚻im;拦Ѐabnoptwz⛩⛴⛷✚✯❁❇❐Ānr⛮⛱g;柬r;懽rëࣁgƀlmr⛿✍✔eftĀar০✇ightá৲apsto;柼ightá৽parrowĀlr✥✩efô⓭ight;憬ƀafl✶✹✽r;榅;쀀𝕝us;樭imes;樴š❋❏st;戗áፎƀ;ef❗❘᠀旊nge»❘arĀ;l❤❥䀨t;榓ʀachmt❳❶❼➅➇ròࢨorneòᶌarĀ;d྘➃;業;怎ri;抿̀achiqt➘➝ੀ➢➮➻quo;怹r;쀀𝓁mƀ;egল➪➬;檍;檏Ābu┪➳oĀ;rฟ➹;怚rok;䅂萀<;cdhilqrࠫ⟒☹⟜⟠⟥⟪⟰Āci⟗⟙;檦r;橹reå◲mes;拉arr;楶uest;橻ĀPi⟵⟹ar;榖ƀ;ef⠀भ᠛旃rĀdu⠇⠍shar;楊har;楦Āen⠗⠡rtneqq;쀀≨︀Å⠞܀Dacdefhilnopsu⡀⡅⢂⢎⢓⢠⢥⢨⣚⣢⣤ઃ⣳⤂Dot;戺Ȁclpr⡎⡒⡣⡽r耻¯䂯Āet⡗⡙;時Ā;e⡞⡟朠se»⡟Ā;sျ⡨toȀ;dluျ⡳⡷⡻owîҌefôएðᏑker;斮Āoy⢇⢌mma;権;䐼ash;怔asuredangle»ᘦr;쀀𝔪o;愧ƀcdn⢯⢴⣉ro耻µ䂵Ȁ;acdᑤ⢽⣀⣄sôᚧir;櫰ot肻·Ƶusƀ;bd⣒ᤃ⣓戒Ā;uᴼ⣘;横ţ⣞⣡p;櫛ò−ðઁĀdp⣩⣮els;抧f;쀀𝕞Āct⣸⣽r;쀀𝓂pos»ᖝƀ;lm⤉⤊⤍䎼timap;抸ఀGLRVabcdefghijlmoprstuvw⥂⥓⥾⦉⦘⧚⧩⨕⨚⩘⩝⪃⪕⪤⪨⬄⬇⭄⭿⮮ⰴⱧⱼ⳩Āgt⥇⥋;쀀⋙̸Ā;v⥐௏쀀≫⃒ƀelt⥚⥲⥶ftĀar⥡⥧rrow;懍ightarrow;懎;쀀⋘̸Ā;v⥻ే쀀≪⃒ightarrow;懏ĀDd⦎⦓ash;抯ash;抮ʀbcnpt⦣⦧⦬⦱⧌la»˞ute;䅄g;쀀∠⃒ʀ;Eiop඄⦼⧀⧅⧈;쀀⩰̸d;쀀≋̸s;䅉roø඄urĀ;a⧓⧔普lĀ;s⧓ସǳ⧟\0⧣p肻 ଷmpĀ;e௹ఀʀaeouy⧴⧾⨃⨐⨓ǰ⧹\0⧻;橃on;䅈dil;䅆ngĀ;dൾ⨊ot;쀀⩭̸p;橂;䐽ash;怓΀;Aadqsxஒ⨩⨭⨻⩁⩅⩐rr;懗rĀhr⨳⨶k;椤Ā;oᏲᏰot;쀀≐̸uiöୣĀei⩊⩎ar;椨í஘istĀ;s஠டr;쀀𝔫ȀEest௅⩦⩹⩼ƀ;qs஼⩭௡ƀ;qs஼௅⩴lanô௢ií௪Ā;rஶ⪁»ஷƀAap⪊⪍⪑rò⥱rr;憮ar;櫲ƀ;svྍ⪜ྌĀ;d⪡⪢拼;拺cy;䑚΀AEadest⪷⪺⪾⫂⫅⫶⫹rò⥦;쀀≦̸rr;憚r;急Ȁ;fqs఻⫎⫣⫯tĀar⫔⫙rro÷⫁ightarro÷⪐ƀ;qs఻⪺⫪lanôౕĀ;sౕ⫴»శiíౝĀ;rవ⫾iĀ;eచథiäඐĀpt⬌⬑f;쀀𝕟膀¬;in⬙⬚⬶䂬nȀ;Edvஉ⬤⬨⬮;쀀⋹̸ot;쀀⋵̸ǡஉ⬳⬵;拷;拶iĀ;vಸ⬼ǡಸ⭁⭃;拾;拽ƀaor⭋⭣⭩rȀ;ast୻⭕⭚⭟lleì୻l;쀀⫽⃥;쀀∂̸lint;樔ƀ;ceಒ⭰⭳uåಥĀ;cಘ⭸Ā;eಒ⭽ñಘȀAait⮈⮋⮝⮧rò⦈rrƀ;cw⮔⮕⮙憛;쀀⤳̸;쀀↝̸ghtarrow»⮕riĀ;eೋೖ΀chimpqu⮽⯍⯙⬄୸⯤⯯Ȁ;cerല⯆ഷ⯉uå൅;쀀𝓃ortɭ⬅\0\0⯖ará⭖mĀ;e൮⯟Ā;q൴൳suĀbp⯫⯭å೸åഋƀbcp⯶ⰑⰙȀ;Ees⯿ⰀഢⰄ抄;쀀⫅̸etĀ;eഛⰋqĀ;qണⰀcĀ;eലⰗñസȀ;EesⰢⰣൟⰧ抅;쀀⫆̸etĀ;e൘ⰮqĀ;qൠⰣȀgilrⰽⰿⱅⱇìௗlde耻ñ䃱çృiangleĀlrⱒⱜeftĀ;eచⱚñదightĀ;eೋⱥñ೗Ā;mⱬⱭ䎽ƀ;esⱴⱵⱹ䀣ro;愖p;怇ҀDHadgilrsⲏⲔⲙⲞⲣⲰⲶⳓⳣash;抭arr;椄p;쀀≍⃒ash;抬ĀetⲨⲬ;쀀≥⃒;쀀>⃒nfin;槞ƀAetⲽⳁⳅrr;椂;쀀≤⃒Ā;rⳊⳍ쀀<⃒ie;쀀⊴⃒ĀAtⳘⳜrr;椃rie;쀀⊵⃒im;쀀∼⃒ƀAan⳰⳴ⴂrr;懖rĀhr⳺⳽k;椣Ā;oᏧᏥear;椧ቓ᪕\0\0\0\0\0\0\0\0\0\0\0\0\0ⴭ\0ⴸⵈⵠⵥ⵲ⶄᬇ\0\0ⶍⶫ\0ⷈⷎ\0ⷜ⸙⸫⸾⹃Ācsⴱ᪗ute耻ó䃳ĀiyⴼⵅrĀ;c᪞ⵂ耻ô䃴;䐾ʀabios᪠ⵒⵗǈⵚlac;䅑v;樸old;榼lig;䅓Ācr⵩⵭ir;榿;쀀𝔬ͯ⵹\0\0⵼\0ⶂn;䋛ave耻ò䃲;槁Ābmⶈ෴ar;榵Ȁacitⶕ⶘ⶥⶨrò᪀Āir⶝ⶠr;榾oss;榻nå๒;槀ƀaeiⶱⶵⶹcr;䅍ga;䏉ƀcdnⷀⷅǍron;䎿;榶pf;쀀𝕠ƀaelⷔ⷗ǒr;榷rp;榹΀;adiosvⷪⷫⷮ⸈⸍⸐⸖戨rò᪆Ȁ;efmⷷⷸ⸂⸅橝rĀ;oⷾⷿ愴f»ⷿ耻ª䂪耻º䂺gof;抶r;橖lope;橗;橛ƀclo⸟⸡⸧ò⸁ash耻ø䃸l;折iŬⸯ⸴de耻õ䃵esĀ;aǛ⸺s;樶ml耻ö䃶bar;挽ૡ⹞\0⹽\0⺀⺝\0⺢⺹\0\0⻋ຜ\0⼓\0\0⼫⾼\0⿈rȀ;astЃ⹧⹲຅脀¶;l⹭⹮䂶leìЃɩ⹸\0\0⹻m;櫳;櫽y;䐿rʀcimpt⺋⺏⺓ᡥ⺗nt;䀥od;䀮il;怰enk;怱r;쀀𝔭ƀimo⺨⺰⺴Ā;v⺭⺮䏆;䏕maô੶ne;明ƀ;tv⺿⻀⻈䏀chfork»´;䏖Āau⻏⻟nĀck⻕⻝kĀ;h⇴⻛;愎ö⇴sҀ;abcdemst⻳⻴ᤈ⻹⻽⼄⼆⼊⼎䀫cir;樣ir;樢Āouᵀ⼂;樥;橲n肻±ຝim;樦wo;樧ƀipu⼙⼠⼥ntint;樕f;쀀𝕡nd耻£䂣Ԁ;Eaceinosu່⼿⽁⽄⽇⾁⾉⾒⽾⾶;檳p;檷uå໙Ā;c໎⽌̀;acens່⽙⽟⽦⽨⽾pproø⽃urlyeñ໙ñ໎ƀaes⽯⽶⽺pprox;檹qq;檵im;拨iíໟmeĀ;s⾈ຮ怲ƀEas⽸⾐⽺ð⽵ƀdfp໬⾙⾯ƀals⾠⾥⾪lar;挮ine;挒urf;挓Ā;t໻⾴ï໻rel;抰Āci⿀⿅r;쀀𝓅;䏈ncsp;怈̀fiopsu⿚⋢⿟⿥⿫⿱r;쀀𝔮pf;쀀𝕢rime;恗cr;쀀𝓆ƀaeo⿸〉〓tĀei⿾々rnionóڰnt;樖stĀ;e【】䀿ñἙô༔઀ABHabcdefhilmnoprstux぀けさすムㄎㄫㅇㅢㅲㆎ㈆㈕㈤㈩㉘㉮㉲㊐㊰㊷ƀartぇおがròႳòϝail;検aròᱥar;楤΀cdenqrtとふへみわゔヌĀeuねぱ;쀀∽̱te;䅕iãᅮmptyv;榳gȀ;del࿑らるろ;榒;榥å࿑uo耻»䂻rր;abcfhlpstw࿜ガクシスゼゾダッデナp;極Ā;f࿠ゴs;椠;椳s;椞ë≝ð✮l;楅im;楴l;憣;憝Āaiパフil;椚oĀ;nホボ戶aló༞ƀabrョリヮrò៥rk;杳ĀakンヽcĀekヹ・;䁽;䁝Āes㄂㄄;榌lĀduㄊㄌ;榎;榐Ȁaeuyㄗㄜㄧㄩron;䅙Ādiㄡㄥil;䅗ì࿲âヺ;䑀Ȁclqsㄴㄷㄽㅄa;椷dhar;楩uoĀ;rȎȍh;憳ƀacgㅎㅟངlȀ;ipsླྀㅘㅛႜnåႻarôྩt;断ƀilrㅩဣㅮsht;楽;쀀𝔯ĀaoㅷㆆrĀduㅽㅿ»ѻĀ;l႑ㆄ;楬Ā;vㆋㆌ䏁;䏱ƀgns㆕ㇹㇼht̀ahlrstㆤㆰ㇂㇘㇤㇮rrowĀ;t࿜ㆭaéトarpoonĀduㆻㆿowîㅾp»႒eftĀah㇊㇐rrowó࿪arpoonóՑightarrows;應quigarro÷ニhreetimes;拌g;䋚ingdotseñἲƀahm㈍㈐㈓rò࿪aòՑ;怏oustĀ;a㈞㈟掱che»㈟mid;櫮Ȁabpt㈲㈽㉀㉒Ānr㈷㈺g;柭r;懾rëဃƀafl㉇㉊㉎r;榆;쀀𝕣us;樮imes;樵Āap㉝㉧rĀ;g㉣㉤䀩t;榔olint;樒arò㇣Ȁachq㉻㊀Ⴜ㊅quo;怺r;쀀𝓇Ābu・㊊oĀ;rȔȓƀhir㊗㊛㊠reåㇸmes;拊iȀ;efl㊪ၙᠡ㊫方tri;槎luhar;楨;愞ൡ㋕㋛㋟㌬㌸㍱\0㍺㎤\0\0㏬㏰\0㐨㑈㑚㒭㒱㓊㓱\0㘖\0\0㘳cute;䅛quï➺Ԁ;Eaceinpsyᇭ㋳㋵㋿㌂㌋㌏㌟㌦㌩;檴ǰ㋺\0㋼;檸on;䅡uåᇾĀ;dᇳ㌇il;䅟rc;䅝ƀEas㌖㌘㌛;檶p;檺im;择olint;樓iíሄ;䑁otƀ;be㌴ᵇ㌵担;橦΀Aacmstx㍆㍊㍗㍛㍞㍣㍭rr;懘rĀhr㍐㍒ë∨Ā;oਸ਼਴t耻§䂧i;䀻war;椩mĀin㍩ðnuóñt;朶rĀ;o㍶⁕쀀𝔰Ȁacoy㎂㎆㎑㎠rp;景Āhy㎋㎏cy;䑉;䑈rtɭ㎙\0\0㎜iäᑤaraì⹯耻­䂭Āgm㎨㎴maƀ;fv㎱㎲㎲䏃;䏂Ѐ;deglnprካ㏅㏉㏎㏖㏞㏡㏦ot;橪Ā;q኱ኰĀ;E㏓㏔檞;檠Ā;E㏛㏜檝;檟e;扆lus;樤arr;楲aròᄽȀaeit㏸㐈㐏㐗Āls㏽㐄lsetmé㍪hp;樳parsl;槤Ādlᑣ㐔e;挣Ā;e㐜㐝檪Ā;s㐢㐣檬;쀀⪬︀ƀflp㐮㐳㑂tcy;䑌Ā;b㐸㐹䀯Ā;a㐾㐿槄r;挿f;쀀𝕤aĀdr㑍ЂesĀ;u㑔㑕晠it»㑕ƀcsu㑠㑹㒟Āau㑥㑯pĀ;sᆈ㑫;쀀⊓︀pĀ;sᆴ㑵;쀀⊔︀uĀbp㑿㒏ƀ;esᆗᆜ㒆etĀ;eᆗ㒍ñᆝƀ;esᆨᆭ㒖etĀ;eᆨ㒝ñᆮƀ;afᅻ㒦ְrť㒫ֱ»ᅼaròᅈȀcemt㒹㒾㓂㓅r;쀀𝓈tmîñiì㐕aræᆾĀar㓎㓕rĀ;f㓔ឿ昆Āan㓚㓭ightĀep㓣㓪psiloîỠhé⺯s»⡒ʀbcmnp㓻㕞ሉ㖋㖎Ҁ;Edemnprs㔎㔏㔑㔕㔞㔣㔬㔱㔶抂;櫅ot;檽Ā;dᇚ㔚ot;櫃ult;櫁ĀEe㔨㔪;櫋;把lus;檿arr;楹ƀeiu㔽㕒㕕tƀ;en㔎㕅㕋qĀ;qᇚ㔏eqĀ;q㔫㔨m;櫇Ābp㕚㕜;櫕;櫓c̀;acensᇭ㕬㕲㕹㕻㌦pproø㋺urlyeñᇾñᇳƀaes㖂㖈㌛pproø㌚qñ㌗g;晪ڀ123;Edehlmnps㖩㖬㖯ሜ㖲㖴㗀㗉㗕㗚㗟㗨㗭耻¹䂹耻²䂲耻³䂳;櫆Āos㖹㖼t;檾ub;櫘Ā;dሢ㗅ot;櫄sĀou㗏㗒l;柉b;櫗arr;楻ult;櫂ĀEe㗤㗦;櫌;抋lus;櫀ƀeiu㗴㘉㘌tƀ;enሜ㗼㘂qĀ;qሢ㖲eqĀ;q㗧㗤m;櫈Ābp㘑㘓;櫔;櫖ƀAan㘜㘠㘭rr;懙rĀhr㘦㘨ë∮Ā;oਫ਩war;椪lig耻ß䃟௡㙑㙝㙠ዎ㙳㙹\0㙾㛂\0\0\0\0\0㛛㜃\0㜉㝬\0\0\0㞇ɲ㙖\0\0㙛get;挖;䏄rë๟ƀaey㙦㙫㙰ron;䅥dil;䅣;䑂lrec;挕r;쀀𝔱Ȁeiko㚆㚝㚵㚼ǲ㚋\0㚑eĀ4fኄኁaƀ;sv㚘㚙㚛䎸ym;䏑Ācn㚢㚲kĀas㚨㚮pproø዁im»ኬsðኞĀas㚺㚮ð዁rn耻þ䃾Ǭ̟㛆⋧es膀×;bd㛏㛐㛘䃗Ā;aᤏ㛕r;樱;樰ƀeps㛡㛣㜀á⩍Ȁ;bcf҆㛬㛰㛴ot;挶ir;櫱Ā;o㛹㛼쀀𝕥rk;櫚á㍢rime;怴ƀaip㜏㜒㝤dåቈ΀adempst㜡㝍㝀㝑㝗㝜㝟ngleʀ;dlqr㜰㜱㜶㝀㝂斵own»ᶻeftĀ;e⠀㜾ñम;扜ightĀ;e㊪㝋ñၚot;旬inus;樺lus;樹b;槍ime;樻ezium;揢ƀcht㝲㝽㞁Āry㝷㝻;쀀𝓉;䑆cy;䑛rok;䅧Āio㞋㞎xô᝷headĀlr㞗㞠eftarro÷ࡏightarrow»ཝऀAHabcdfghlmoprstuw㟐㟓㟗㟤㟰㟼㠎㠜㠣㠴㡑㡝㡫㢩㣌㣒㣪㣶ròϭar;楣Ācr㟜㟢ute耻ú䃺òᅐrǣ㟪\0㟭y;䑞ve;䅭Āiy㟵㟺rc耻û䃻;䑃ƀabh㠃㠆㠋ròᎭlac;䅱aòᏃĀir㠓㠘sht;楾;쀀𝔲rave耻ù䃹š㠧㠱rĀlr㠬㠮»ॗ»ႃlk;斀Āct㠹㡍ɯ㠿\0\0㡊rnĀ;e㡅㡆挜r»㡆op;挏ri;旸Āal㡖㡚cr;䅫肻¨͉Āgp㡢㡦on;䅳f;쀀𝕦̀adhlsuᅋ㡸㡽፲㢑㢠ownáᎳarpoonĀlr㢈㢌efô㠭ighô㠯iƀ;hl㢙㢚㢜䏅»ᏺon»㢚parrows;懈ƀcit㢰㣄㣈ɯ㢶\0\0㣁rnĀ;e㢼㢽挝r»㢽op;挎ng;䅯ri;旹cr;쀀𝓊ƀdir㣙㣝㣢ot;拰lde;䅩iĀ;f㜰㣨»᠓Āam㣯㣲rò㢨l耻ü䃼angle;榧ހABDacdeflnoprsz㤜㤟㤩㤭㦵㦸㦽㧟㧤㧨㧳㧹㧽㨁㨠ròϷarĀ;v㤦㤧櫨;櫩asèϡĀnr㤲㤷grt;榜΀eknprst㓣㥆㥋㥒㥝㥤㦖appá␕othinçẖƀhir㓫⻈㥙opô⾵Ā;hᎷ㥢ïㆍĀiu㥩㥭gmá㎳Ābp㥲㦄setneqĀ;q㥽㦀쀀⊊︀;쀀⫋︀setneqĀ;q㦏㦒쀀⊋︀;쀀⫌︀Āhr㦛㦟etá㚜iangleĀlr㦪㦯eft»थight»ၑy;䐲ash»ံƀelr㧄㧒㧗ƀ;beⷪ㧋㧏ar;抻q;扚lip;拮Ābt㧜ᑨaòᑩr;쀀𝔳tré㦮suĀbp㧯㧱»ജ»൙pf;쀀𝕧roð໻tré㦴Ācu㨆㨋r;쀀𝓋Ābp㨐㨘nĀEe㦀㨖»㥾nĀEe㦒㨞»㦐igzag;榚΀cefoprs㨶㨻㩖㩛㩔㩡㩪irc;䅵Ādi㩀㩑Ābg㩅㩉ar;機eĀ;qᗺ㩏;扙erp;愘r;쀀𝔴pf;쀀𝕨Ā;eᑹ㩦atèᑹcr;쀀𝓌ૣណ㪇\0㪋\0㪐㪛\0\0㪝㪨㪫㪯\0\0㫃㫎\0㫘ៜ៟tré៑r;쀀𝔵ĀAa㪔㪗ròσrò৶;䎾ĀAa㪡㪤ròθrò৫að✓is;拻ƀdptឤ㪵㪾Āfl㪺ឩ;쀀𝕩imåឲĀAa㫇㫊ròώròਁĀcq㫒ីr;쀀𝓍Āpt៖㫜ré។Ѐacefiosu㫰㫽㬈㬌㬑㬕㬛㬡cĀuy㫶㫻te耻ý䃽;䑏Āiy㬂㬆rc;䅷;䑋n耻¥䂥r;쀀𝔶cy;䑗pf;쀀𝕪cr;쀀𝓎Ācm㬦㬩y;䑎l耻ÿ䃿Ԁacdefhiosw㭂㭈㭔㭘㭤㭩㭭㭴㭺㮀cute;䅺Āay㭍㭒ron;䅾;䐷ot;䅼Āet㭝㭡træᕟa;䎶r;쀀𝔷cy;䐶grarr;懝pf;쀀𝕫cr;쀀𝓏Ājn㮅㮇;怍j;怌'.split("").map((function(e){return e.charCodeAt(0)})));})),D=m((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=new Uint16Array("Ȁaglq\tɭ\0\0p;䀦os;䀧t;䀾t;䀼uot;䀢".split("").map((function(e){return e.charCodeAt(0)})));})),S=m((function(e,t){var s;Object.defineProperty(t,"__esModule",{value:!0}),t.replaceCodePoint=t.fromCodePoint=void 0;var a=new Map([[0,65533],[128,8364],[130,8218],[131,402],[132,8222],[133,8230],[134,8224],[135,8225],[136,710],[137,8240],[138,352],[139,8249],[140,338],[142,381],[145,8216],[146,8217],[147,8220],[148,8221],[149,8226],[150,8211],[151,8212],[152,732],[153,8482],[154,353],[155,8250],[156,339],[158,382],[159,376]]);function r(e){var t;return e>=55296&&e<=57343||e>1114111?65533:null!==(t=a.get(e))&&void 0!==t?t:e}t.fromCodePoint=null!==(s=String.fromCodePoint)&&void 0!==s?s:function(e){var t="";return e>65535&&(e-=65536,t+=String.fromCharCode(e>>>10&1023|55296),e=56320|1023&e),t+String.fromCharCode(e)},t.replaceCodePoint=r,t.default=function(e){return (0, t.fromCodePoint)(r(e))};})),R=m((function(e,t){var s=l&&l.__importDefault||function(e){return e&&e.__esModule?e:{default:e}};Object.defineProperty(t,"__esModule",{value:!0}),t.decodeXML=t.decodeHTMLStrict=t.decodeHTML=t.determineBranch=t.BinTrieFlags=t.fromCodePoint=t.replaceCodePoint=t.decodeCodePoint=t.xmlDecodeTree=t.htmlDecodeTree=void 0;var a=s(C);t.htmlDecodeTree=a.default;var r=s(D);t.xmlDecodeTree=r.default;var n=s(S);t.decodeCodePoint=n.default;var i,o,c=S;function E(e){return function(t,s){for(var a="",r=0,c=0;(c=t.indexOf("&",c))>=0;)if(a+=t.slice(r,c),r=c,c+=1,t.charCodeAt(c)!==i.NUM){for(var E=0,h=1,_=0,A=e[_];c<t.length&&!((_=T(e,A,_+1,t.charCodeAt(c)))<0);c++,h++){var l=(A=e[_])&o.VALUE_LENGTH;if(l){var m;if(s&&t.charCodeAt(c)!==i.SEMI||(E=_,h=0),0==(m=(l>>14)-1))break;_+=m;}}0!==E&&(a+=1==(m=(e[E]&o.VALUE_LENGTH)>>14)?String.fromCharCode(e[E]&~o.VALUE_LENGTH):2===m?String.fromCharCode(e[E+1]):String.fromCharCode(e[E+1],e[E+2]),r=c-h+1);}else {var p=c+1,d=10,I=t.charCodeAt(p);(I|i.To_LOWER_BIT)===i.LOWER_X&&(d=16,c+=1,p+=1);do{I=t.charCodeAt(++c);}while(I>=i.ZERO&&I<=i.NINE||16===d&&(I|i.To_LOWER_BIT)>=i.LOWER_A&&(I|i.To_LOWER_BIT)<=i.LOWER_F);if(p!==c){var N=t.substring(p,c),u=parseInt(N,d);if(t.charCodeAt(c)===i.SEMI)c+=1;else if(s)continue;a+=(0, n.default)(u),r=c;}}return a+t.slice(r)}}function T(e,t,s,a){var r=(t&o.BRANCH_LENGTH)>>7,n=t&o.JUMP_TABLE;if(0===r)return 0!==n&&a===n?s:-1;if(n){var i=a-n;return i<0||i>=r?-1:e[s+i]-1}for(var c=s,E=c+r-1;c<=E;){var T=c+E>>>1,h=e[T];if(h<a)c=T+1;else {if(!(h>a))return e[T+r];E=T-1;}}return -1}Object.defineProperty(t,"replaceCodePoint",{enumerable:!0,get:function(){return c.replaceCodePoint}}),Object.defineProperty(t,"fromCodePoint",{enumerable:!0,get:function(){return c.fromCodePoint}}),function(e){e[e.NUM=35]="NUM",e[e.SEMI=59]="SEMI",e[e.ZERO=48]="ZERO",e[e.NINE=57]="NINE",e[e.LOWER_A=97]="LOWER_A",e[e.LOWER_F=102]="LOWER_F",e[e.LOWER_X=120]="LOWER_X",e[e.To_LOWER_BIT=32]="To_LOWER_BIT";}(i||(i={})),function(e){e[e.VALUE_LENGTH=49152]="VALUE_LENGTH",e[e.BRANCH_LENGTH=16256]="BRANCH_LENGTH",e[e.JUMP_TABLE=127]="JUMP_TABLE";}(o=t.BinTrieFlags||(t.BinTrieFlags={})),t.determineBranch=T;var h=E(a.default),_=E(r.default);t.decodeHTML=function(e){return h(e,!1)},t.decodeHTMLStrict=function(e){return h(e,!0)},t.decodeXML=function(e){return _(e,!0)};}));!function(e){e.HTML="http://www.w3.org/1999/xhtml",e.MATHML="http://www.w3.org/1998/Math/MathML",e.SVG="http://www.w3.org/2000/svg",e.XLINK="http://www.w3.org/1999/xlink",e.XML="http://www.w3.org/XML/1998/namespace",e.XMLNS="http://www.w3.org/2000/xmlns/";}(p=p||(p={})),function(e){e.TYPE="type",e.ACTION="action",e.ENCODING="encoding",e.PROMPT="prompt",e.NAME="name",e.COLOR="color",e.FACE="face",e.SIZE="size";}(d=d||(d={})),function(e){e.NO_QUIRKS="no-quirks",e.QUIRKS="quirks",e.LIMITED_QUIRKS="limited-quirks";}(I=I||(I={})),function(e){e.A="a",e.ADDRESS="address",e.ANNOTATION_XML="annotation-xml",e.APPLET="applet",e.AREA="area",e.ARTICLE="article",e.ASIDE="aside",e.B="b",e.BASE="base",e.BASEFONT="basefont",e.BGSOUND="bgsound",e.BIG="big",e.BLOCKQUOTE="blockquote",e.BODY="body",e.BR="br",e.BUTTON="button",e.CAPTION="caption",e.CENTER="center",e.CODE="code",e.COL="col",e.COLGROUP="colgroup",e.DD="dd",e.DESC="desc",e.DETAILS="details",e.DIALOG="dialog",e.DIR="dir",e.DIV="div",e.DL="dl",e.DT="dt",e.EM="em",e.EMBED="embed",e.FIELDSET="fieldset",e.FIGCAPTION="figcaption",e.FIGURE="figure",e.FONT="font",e.FOOTER="footer",e.FOREIGN_OBJECT="foreignObject",e.FORM="form",e.FRAME="frame",e.FRAMESET="frameset",e.H1="h1",e.H2="h2",e.H3="h3",e.H4="h4",e.H5="h5",e.H6="h6",e.HEAD="head",e.HEADER="header",e.HGROUP="hgroup",e.HR="hr",e.HTML="html",e.I="i",e.IMG="img",e.IMAGE="image",e.INPUT="input",e.IFRAME="iframe",e.KEYGEN="keygen",e.LABEL="label",e.LI="li",e.LINK="link",e.LISTING="listing",e.MAIN="main",e.MALIGNMARK="malignmark",e.MARQUEE="marquee",e.MATH="math",e.MENU="menu",e.META="meta",e.MGLYPH="mglyph",e.MI="mi",e.MO="mo",e.MN="mn",e.MS="ms",e.MTEXT="mtext",e.NAV="nav",e.NOBR="nobr",e.NOFRAMES="noframes",e.NOEMBED="noembed",e.NOSCRIPT="noscript",e.OBJECT="object",e.OL="ol",e.OPTGROUP="optgroup",e.OPTION="option",e.P="p",e.PARAM="param",e.PLAINTEXT="plaintext",e.PRE="pre",e.RB="rb",e.RP="rp",e.RT="rt",e.RTC="rtc",e.RUBY="ruby",e.S="s",e.SCRIPT="script",e.SECTION="section",e.SELECT="select",e.SOURCE="source",e.SMALL="small",e.SPAN="span",e.STRIKE="strike",e.STRONG="strong",e.STYLE="style",e.SUB="sub",e.SUMMARY="summary",e.SUP="sup",e.TABLE="table",e.TBODY="tbody",e.TEMPLATE="template",e.TEXTAREA="textarea",e.TFOOT="tfoot",e.TD="td",e.TH="th",e.THEAD="thead",e.TITLE="title",e.TR="tr",e.TRACK="track",e.TT="tt",e.U="u",e.UL="ul",e.SVG="svg",e.VAR="var",e.WBR="wbr",e.XMP="xmp";}(N=N||(N={})),function(e){e[e.UNKNOWN=0]="UNKNOWN",e[e.A=1]="A",e[e.ADDRESS=2]="ADDRESS",e[e.ANNOTATION_XML=3]="ANNOTATION_XML",e[e.APPLET=4]="APPLET",e[e.AREA=5]="AREA",e[e.ARTICLE=6]="ARTICLE",e[e.ASIDE=7]="ASIDE",e[e.B=8]="B",e[e.BASE=9]="BASE",e[e.BASEFONT=10]="BASEFONT",e[e.BGSOUND=11]="BGSOUND",e[e.BIG=12]="BIG",e[e.BLOCKQUOTE=13]="BLOCKQUOTE",e[e.BODY=14]="BODY",e[e.BR=15]="BR",e[e.BUTTON=16]="BUTTON",e[e.CAPTION=17]="CAPTION",e[e.CENTER=18]="CENTER",e[e.CODE=19]="CODE",e[e.COL=20]="COL",e[e.COLGROUP=21]="COLGROUP",e[e.DD=22]="DD",e[e.DESC=23]="DESC",e[e.DETAILS=24]="DETAILS",e[e.DIALOG=25]="DIALOG",e[e.DIR=26]="DIR",e[e.DIV=27]="DIV",e[e.DL=28]="DL",e[e.DT=29]="DT",e[e.EM=30]="EM",e[e.EMBED=31]="EMBED",e[e.FIELDSET=32]="FIELDSET",e[e.FIGCAPTION=33]="FIGCAPTION",e[e.FIGURE=34]="FIGURE",e[e.FONT=35]="FONT",e[e.FOOTER=36]="FOOTER",e[e.FOREIGN_OBJECT=37]="FOREIGN_OBJECT",e[e.FORM=38]="FORM",e[e.FRAME=39]="FRAME",e[e.FRAMESET=40]="FRAMESET",e[e.H1=41]="H1",e[e.H2=42]="H2",e[e.H3=43]="H3",e[e.H4=44]="H4",e[e.H5=45]="H5",e[e.H6=46]="H6",e[e.HEAD=47]="HEAD",e[e.HEADER=48]="HEADER",e[e.HGROUP=49]="HGROUP",e[e.HR=50]="HR",e[e.HTML=51]="HTML",e[e.I=52]="I",e[e.IMG=53]="IMG",e[e.IMAGE=54]="IMAGE",e[e.INPUT=55]="INPUT",e[e.IFRAME=56]="IFRAME",e[e.KEYGEN=57]="KEYGEN",e[e.LABEL=58]="LABEL",e[e.LI=59]="LI",e[e.LINK=60]="LINK",e[e.LISTING=61]="LISTING",e[e.MAIN=62]="MAIN",e[e.MALIGNMARK=63]="MALIGNMARK",e[e.MARQUEE=64]="MARQUEE",e[e.MATH=65]="MATH",e[e.MENU=66]="MENU",e[e.META=67]="META",e[e.MGLYPH=68]="MGLYPH",e[e.MI=69]="MI",e[e.MO=70]="MO",e[e.MN=71]="MN",e[e.MS=72]="MS",e[e.MTEXT=73]="MTEXT",e[e.NAV=74]="NAV",e[e.NOBR=75]="NOBR",e[e.NOFRAMES=76]="NOFRAMES",e[e.NOEMBED=77]="NOEMBED",e[e.NOSCRIPT=78]="NOSCRIPT",e[e.OBJECT=79]="OBJECT",e[e.OL=80]="OL",e[e.OPTGROUP=81]="OPTGROUP",e[e.OPTION=82]="OPTION",e[e.P=83]="P",e[e.PARAM=84]="PARAM",e[e.PLAINTEXT=85]="PLAINTEXT",e[e.PRE=86]="PRE",e[e.RB=87]="RB",e[e.RP=88]="RP",e[e.RT=89]="RT",e[e.RTC=90]="RTC",e[e.RUBY=91]="RUBY",e[e.S=92]="S",e[e.SCRIPT=93]="SCRIPT",e[e.SECTION=94]="SECTION",e[e.SELECT=95]="SELECT",e[e.SOURCE=96]="SOURCE",e[e.SMALL=97]="SMALL",e[e.SPAN=98]="SPAN",e[e.STRIKE=99]="STRIKE",e[e.STRONG=100]="STRONG",e[e.STYLE=101]="STYLE",e[e.SUB=102]="SUB",e[e.SUMMARY=103]="SUMMARY",e[e.SUP=104]="SUP",e[e.TABLE=105]="TABLE",e[e.TBODY=106]="TBODY",e[e.TEMPLATE=107]="TEMPLATE",e[e.TEXTAREA=108]="TEXTAREA",e[e.TFOOT=109]="TFOOT",e[e.TD=110]="TD",e[e.TH=111]="TH",e[e.THEAD=112]="THEAD",e[e.TITLE=113]="TITLE",e[e.TR=114]="TR",e[e.TRACK=115]="TRACK",e[e.TT=116]="TT",e[e.U=117]="U",e[e.UL=118]="UL",e[e.SVG=119]="SVG",e[e.VAR=120]="VAR",e[e.WBR=121]="WBR",e[e.XMP=122]="XMP";}(u=u||(u={}));const O=new Map([[N.A,u.A],[N.ADDRESS,u.ADDRESS],[N.ANNOTATION_XML,u.ANNOTATION_XML],[N.APPLET,u.APPLET],[N.AREA,u.AREA],[N.ARTICLE,u.ARTICLE],[N.ASIDE,u.ASIDE],[N.B,u.B],[N.BASE,u.BASE],[N.BASEFONT,u.BASEFONT],[N.BGSOUND,u.BGSOUND],[N.BIG,u.BIG],[N.BLOCKQUOTE,u.BLOCKQUOTE],[N.BODY,u.BODY],[N.BR,u.BR],[N.BUTTON,u.BUTTON],[N.CAPTION,u.CAPTION],[N.CENTER,u.CENTER],[N.CODE,u.CODE],[N.COL,u.COL],[N.COLGROUP,u.COLGROUP],[N.DD,u.DD],[N.DESC,u.DESC],[N.DETAILS,u.DETAILS],[N.DIALOG,u.DIALOG],[N.DIR,u.DIR],[N.DIV,u.DIV],[N.DL,u.DL],[N.DT,u.DT],[N.EM,u.EM],[N.EMBED,u.EMBED],[N.FIELDSET,u.FIELDSET],[N.FIGCAPTION,u.FIGCAPTION],[N.FIGURE,u.FIGURE],[N.FONT,u.FONT],[N.FOOTER,u.FOOTER],[N.FOREIGN_OBJECT,u.FOREIGN_OBJECT],[N.FORM,u.FORM],[N.FRAME,u.FRAME],[N.FRAMESET,u.FRAMESET],[N.H1,u.H1],[N.H2,u.H2],[N.H3,u.H3],[N.H4,u.H4],[N.H5,u.H5],[N.H6,u.H6],[N.HEAD,u.HEAD],[N.HEADER,u.HEADER],[N.HGROUP,u.HGROUP],[N.HR,u.HR],[N.HTML,u.HTML],[N.I,u.I],[N.IMG,u.IMG],[N.IMAGE,u.IMAGE],[N.INPUT,u.INPUT],[N.IFRAME,u.IFRAME],[N.KEYGEN,u.KEYGEN],[N.LABEL,u.LABEL],[N.LI,u.LI],[N.LINK,u.LINK],[N.LISTING,u.LISTING],[N.MAIN,u.MAIN],[N.MALIGNMARK,u.MALIGNMARK],[N.MARQUEE,u.MARQUEE],[N.MATH,u.MATH],[N.MENU,u.MENU],[N.META,u.META],[N.MGLYPH,u.MGLYPH],[N.MI,u.MI],[N.MO,u.MO],[N.MN,u.MN],[N.MS,u.MS],[N.MTEXT,u.MTEXT],[N.NAV,u.NAV],[N.NOBR,u.NOBR],[N.NOFRAMES,u.NOFRAMES],[N.NOEMBED,u.NOEMBED],[N.NOSCRIPT,u.NOSCRIPT],[N.OBJECT,u.OBJECT],[N.OL,u.OL],[N.OPTGROUP,u.OPTGROUP],[N.OPTION,u.OPTION],[N.P,u.P],[N.PARAM,u.PARAM],[N.PLAINTEXT,u.PLAINTEXT],[N.PRE,u.PRE],[N.RB,u.RB],[N.RP,u.RP],[N.RT,u.RT],[N.RTC,u.RTC],[N.RUBY,u.RUBY],[N.S,u.S],[N.SCRIPT,u.SCRIPT],[N.SECTION,u.SECTION],[N.SELECT,u.SELECT],[N.SOURCE,u.SOURCE],[N.SMALL,u.SMALL],[N.SPAN,u.SPAN],[N.STRIKE,u.STRIKE],[N.STRONG,u.STRONG],[N.STYLE,u.STYLE],[N.SUB,u.SUB],[N.SUMMARY,u.SUMMARY],[N.SUP,u.SUP],[N.TABLE,u.TABLE],[N.TBODY,u.TBODY],[N.TEMPLATE,u.TEMPLATE],[N.TEXTAREA,u.TEXTAREA],[N.TFOOT,u.TFOOT],[N.TD,u.TD],[N.TH,u.TH],[N.THEAD,u.THEAD],[N.TITLE,u.TITLE],[N.TR,u.TR],[N.TRACK,u.TRACK],[N.TT,u.TT],[N.U,u.U],[N.UL,u.UL],[N.SVG,u.SVG],[N.VAR,u.VAR],[N.WBR,u.WBR],[N.XMP,u.XMP]]);function f(e){var t;return null!==(t=O.get(e))&&void 0!==t?t:u.UNKNOWN}const L=u,g={[p.HTML]:new Set([L.ADDRESS,L.APPLET,L.AREA,L.ARTICLE,L.ASIDE,L.BASE,L.BASEFONT,L.BGSOUND,L.BLOCKQUOTE,L.BODY,L.BR,L.BUTTON,L.CAPTION,L.CENTER,L.COL,L.COLGROUP,L.DD,L.DETAILS,L.DIR,L.DIV,L.DL,L.DT,L.EMBED,L.FIELDSET,L.FIGCAPTION,L.FIGURE,L.FOOTER,L.FORM,L.FRAME,L.FRAMESET,L.H1,L.H2,L.H3,L.H4,L.H5,L.H6,L.HEAD,L.HEADER,L.HGROUP,L.HR,L.HTML,L.IFRAME,L.IMG,L.INPUT,L.LI,L.LINK,L.LISTING,L.MAIN,L.MARQUEE,L.MENU,L.META,L.NAV,L.NOEMBED,L.NOFRAMES,L.NOSCRIPT,L.OBJECT,L.OL,L.P,L.PARAM,L.PLAINTEXT,L.PRE,L.SCRIPT,L.SECTION,L.SELECT,L.SOURCE,L.STYLE,L.SUMMARY,L.TABLE,L.TBODY,L.TD,L.TEMPLATE,L.TEXTAREA,L.TFOOT,L.TH,L.THEAD,L.TITLE,L.TR,L.TRACK,L.UL,L.WBR,L.XMP]),[p.MATHML]:new Set([L.MI,L.MO,L.MN,L.MS,L.MTEXT,L.ANNOTATION_XML]),[p.SVG]:new Set([L.TITLE,L.FOREIGN_OBJECT,L.DESC]),[p.XLINK]:new Set,[p.XML]:new Set,[p.XMLNS]:new Set};function M(e){return e===L.H1||e===L.H2||e===L.H3||e===L.H4||e===L.H5||e===L.H6}new Set([N.STYLE,N.SCRIPT,N.XMP,N.IFRAME,N.NOEMBED,N.NOFRAMES,N.PLAINTEXT]);const k=new Map([[128,8364],[130,8218],[131,402],[132,8222],[133,8230],[134,8224],[135,8225],[136,710],[137,8240],[138,352],[139,8249],[140,338],[142,381],[145,8216],[146,8217],[147,8220],[148,8221],[149,8226],[150,8211],[151,8212],[152,732],[153,8482],[154,353],[155,8250],[156,339],[158,382],[159,376]]);var P;!function(e){e[e.DATA=0]="DATA",e[e.RCDATA=1]="RCDATA",e[e.RAWTEXT=2]="RAWTEXT",e[e.SCRIPT_DATA=3]="SCRIPT_DATA",e[e.PLAINTEXT=4]="PLAINTEXT",e[e.TAG_OPEN=5]="TAG_OPEN",e[e.END_TAG_OPEN=6]="END_TAG_OPEN",e[e.TAG_NAME=7]="TAG_NAME",e[e.RCDATA_LESS_THAN_SIGN=8]="RCDATA_LESS_THAN_SIGN",e[e.RCDATA_END_TAG_OPEN=9]="RCDATA_END_TAG_OPEN",e[e.RCDATA_END_TAG_NAME=10]="RCDATA_END_TAG_NAME",e[e.RAWTEXT_LESS_THAN_SIGN=11]="RAWTEXT_LESS_THAN_SIGN",e[e.RAWTEXT_END_TAG_OPEN=12]="RAWTEXT_END_TAG_OPEN",e[e.RAWTEXT_END_TAG_NAME=13]="RAWTEXT_END_TAG_NAME",e[e.SCRIPT_DATA_LESS_THAN_SIGN=14]="SCRIPT_DATA_LESS_THAN_SIGN",e[e.SCRIPT_DATA_END_TAG_OPEN=15]="SCRIPT_DATA_END_TAG_OPEN",e[e.SCRIPT_DATA_END_TAG_NAME=16]="SCRIPT_DATA_END_TAG_NAME",e[e.SCRIPT_DATA_ESCAPE_START=17]="SCRIPT_DATA_ESCAPE_START",e[e.SCRIPT_DATA_ESCAPE_START_DASH=18]="SCRIPT_DATA_ESCAPE_START_DASH",e[e.SCRIPT_DATA_ESCAPED=19]="SCRIPT_DATA_ESCAPED",e[e.SCRIPT_DATA_ESCAPED_DASH=20]="SCRIPT_DATA_ESCAPED_DASH",e[e.SCRIPT_DATA_ESCAPED_DASH_DASH=21]="SCRIPT_DATA_ESCAPED_DASH_DASH",e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN=22]="SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN",e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN=23]="SCRIPT_DATA_ESCAPED_END_TAG_OPEN",e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME=24]="SCRIPT_DATA_ESCAPED_END_TAG_NAME",e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START=25]="SCRIPT_DATA_DOUBLE_ESCAPE_START",e[e.SCRIPT_DATA_DOUBLE_ESCAPED=26]="SCRIPT_DATA_DOUBLE_ESCAPED",e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH=27]="SCRIPT_DATA_DOUBLE_ESCAPED_DASH",e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH=28]="SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH",e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN=29]="SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN",e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END=30]="SCRIPT_DATA_DOUBLE_ESCAPE_END",e[e.BEFORE_ATTRIBUTE_NAME=31]="BEFORE_ATTRIBUTE_NAME",e[e.ATTRIBUTE_NAME=32]="ATTRIBUTE_NAME",e[e.AFTER_ATTRIBUTE_NAME=33]="AFTER_ATTRIBUTE_NAME",e[e.BEFORE_ATTRIBUTE_VALUE=34]="BEFORE_ATTRIBUTE_VALUE",e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED=35]="ATTRIBUTE_VALUE_DOUBLE_QUOTED",e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED=36]="ATTRIBUTE_VALUE_SINGLE_QUOTED",e[e.ATTRIBUTE_VALUE_UNQUOTED=37]="ATTRIBUTE_VALUE_UNQUOTED",e[e.AFTER_ATTRIBUTE_VALUE_QUOTED=38]="AFTER_ATTRIBUTE_VALUE_QUOTED",e[e.SELF_CLOSING_START_TAG=39]="SELF_CLOSING_START_TAG",e[e.BOGUS_COMMENT=40]="BOGUS_COMMENT",e[e.MARKUP_DECLARATION_OPEN=41]="MARKUP_DECLARATION_OPEN",e[e.COMMENT_START=42]="COMMENT_START",e[e.COMMENT_START_DASH=43]="COMMENT_START_DASH",e[e.COMMENT=44]="COMMENT",e[e.COMMENT_LESS_THAN_SIGN=45]="COMMENT_LESS_THAN_SIGN",e[e.COMMENT_LESS_THAN_SIGN_BANG=46]="COMMENT_LESS_THAN_SIGN_BANG",e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH=47]="COMMENT_LESS_THAN_SIGN_BANG_DASH",e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH=48]="COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH",e[e.COMMENT_END_DASH=49]="COMMENT_END_DASH",e[e.COMMENT_END=50]="COMMENT_END",e[e.COMMENT_END_BANG=51]="COMMENT_END_BANG",e[e.DOCTYPE=52]="DOCTYPE",e[e.BEFORE_DOCTYPE_NAME=53]="BEFORE_DOCTYPE_NAME",e[e.DOCTYPE_NAME=54]="DOCTYPE_NAME",e[e.AFTER_DOCTYPE_NAME=55]="AFTER_DOCTYPE_NAME",e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD=56]="AFTER_DOCTYPE_PUBLIC_KEYWORD",e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER=57]="BEFORE_DOCTYPE_PUBLIC_IDENTIFIER",e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED=58]="DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED",e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED=59]="DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED",e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER=60]="AFTER_DOCTYPE_PUBLIC_IDENTIFIER",e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS=61]="BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS",e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD=62]="AFTER_DOCTYPE_SYSTEM_KEYWORD",e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER=63]="BEFORE_DOCTYPE_SYSTEM_IDENTIFIER",e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED=64]="DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED",e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED=65]="DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED",e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER=66]="AFTER_DOCTYPE_SYSTEM_IDENTIFIER",e[e.BOGUS_DOCTYPE=67]="BOGUS_DOCTYPE",e[e.CDATA_SECTION=68]="CDATA_SECTION",e[e.CDATA_SECTION_BRACKET=69]="CDATA_SECTION_BRACKET",e[e.CDATA_SECTION_END=70]="CDATA_SECTION_END",e[e.CHARACTER_REFERENCE=71]="CHARACTER_REFERENCE",e[e.NAMED_CHARACTER_REFERENCE=72]="NAMED_CHARACTER_REFERENCE",e[e.AMBIGUOUS_AMPERSAND=73]="AMBIGUOUS_AMPERSAND",e[e.NUMERIC_CHARACTER_REFERENCE=74]="NUMERIC_CHARACTER_REFERENCE",e[e.HEXADEMICAL_CHARACTER_REFERENCE_START=75]="HEXADEMICAL_CHARACTER_REFERENCE_START",e[e.HEXADEMICAL_CHARACTER_REFERENCE=76]="HEXADEMICAL_CHARACTER_REFERENCE",e[e.DECIMAL_CHARACTER_REFERENCE=77]="DECIMAL_CHARACTER_REFERENCE",e[e.NUMERIC_CHARACTER_REFERENCE_END=78]="NUMERIC_CHARACTER_REFERENCE_END";}(P||(P={}));const b={DATA:P.DATA,RCDATA:P.RCDATA,RAWTEXT:P.RAWTEXT,SCRIPT_DATA:P.SCRIPT_DATA,PLAINTEXT:P.PLAINTEXT,CDATA_SECTION:P.CDATA_SECTION};function B(e){return e>=a.DIGIT_0&&e<=a.DIGIT_9}function H(e){return e>=a.LATIN_CAPITAL_A&&e<=a.LATIN_CAPITAL_Z}function F(e){return function(e){return e>=a.LATIN_SMALL_A&&e<=a.LATIN_SMALL_Z}(e)||H(e)}function U(e){return F(e)||B(e)}function G(e){return e>=a.LATIN_CAPITAL_A&&e<=a.LATIN_CAPITAL_F}function y(e){return e>=a.LATIN_SMALL_A&&e<=a.LATIN_SMALL_F}function w(e){return e+32}function Y(e){return e===a.SPACE||e===a.LINE_FEED||e===a.TABULATION||e===a.FORM_FEED}function x(e){return Y(e)||e===a.SOLIDUS||e===a.GREATER_THAN_SIGN}class v{constructor(e,t){this.options=e,this.handler=t,this.paused=!1,this.inLoop=!1,this.inForeignNode=!1,this.lastStartTagName="",this.active=!1,this.state=P.DATA,this.returnState=P.DATA,this.charRefCode=-1,this.consumedAfterSnapshot=-1,this.currentCharacterToken=null,this.currentToken=null,this.currentAttr={name:"",value:""},this.preprocessor=new _(t),this.currentLocation=this.getCurrentLocation(-1);}_err(e){var t,s;null===(s=(t=this.handler).onParseError)||void 0===s||s.call(t,this.preprocessor.getError(e));}getCurrentLocation(e){return this.options.sourceCodeLocationInfo?{startLine:this.preprocessor.line,startCol:this.preprocessor.col-e,startOffset:this.preprocessor.offset-e,endLine:-1,endCol:-1,endOffset:-1}:null}_runParsingLoop(){if(!this.inLoop){for(this.inLoop=!0;this.active&&!this.paused;){this.consumedAfterSnapshot=0;const e=this._consume();this._ensureHibernation()||this._callState(e);}this.inLoop=!1;}}pause(){this.paused=!0;}resume(e){if(!this.paused)throw new Error("Parser was already resumed");this.paused=!1,this.inLoop||(this._runParsingLoop(),this.paused||null==e||e());}write(e,t,s){this.active=!0,this.preprocessor.write(e,t),this._runParsingLoop(),this.paused||null==s||s();}insertHtmlAtCurrentPos(e){this.active=!0,this.preprocessor.insertHtmlAtCurrentPos(e),this._runParsingLoop();}_ensureHibernation(){return !!this.preprocessor.endOfChunkHit&&(this._unconsume(this.consumedAfterSnapshot),this.active=!1,!0)}_consume(){return this.consumedAfterSnapshot++,this.preprocessor.advance()}_unconsume(e){this.consumedAfterSnapshot-=e,this.preprocessor.retreat(e);}_reconsumeInState(e,t){this.state=e,this._callState(t);}_advanceBy(e){this.consumedAfterSnapshot+=e;for(let t=0;t<e;t++)this.preprocessor.advance();}_consumeSequenceIfMatch(e,t){return !!this.preprocessor.startsWith(e,t)&&(this._advanceBy(e.length-1),!0)}_createStartTagToken(){this.currentToken={type:h.START_TAG,tagName:"",tagID:u.UNKNOWN,selfClosing:!1,ackSelfClosing:!1,attrs:[],location:this.getCurrentLocation(1)};}_createEndTagToken(){this.currentToken={type:h.END_TAG,tagName:"",tagID:u.UNKNOWN,selfClosing:!1,ackSelfClosing:!1,attrs:[],location:this.getCurrentLocation(2)};}_createCommentToken(e){this.currentToken={type:h.COMMENT,data:"",location:this.getCurrentLocation(e)};}_createDoctypeToken(e){this.currentToken={type:h.DOCTYPE,name:e,forceQuirks:!1,publicId:null,systemId:null,location:this.currentLocation};}_createCharacterToken(e,t){this.currentCharacterToken={type:e,chars:t,location:this.currentLocation};}_createAttr(e){this.currentAttr={name:e,value:""},this.currentLocation=this.getCurrentLocation(0);}_leaveAttrName(){var e,t;const s=this.currentToken;null===A(s,this.currentAttr.name)?(s.attrs.push(this.currentAttr),s.location&&this.currentLocation&&((null!==(e=(t=s.location).attrs)&&void 0!==e?e:t.attrs=Object.create(null))[this.currentAttr.name]=this.currentLocation,this._leaveAttrValue())):this._err(T.duplicateAttribute);}_leaveAttrValue(){this.currentLocation&&(this.currentLocation.endLine=this.preprocessor.line,this.currentLocation.endCol=this.preprocessor.col,this.currentLocation.endOffset=this.preprocessor.offset);}prepareToken(e){this._emitCurrentCharacterToken(e.location),this.currentToken=null,e.location&&(e.location.endLine=this.preprocessor.line,e.location.endCol=this.preprocessor.col+1,e.location.endOffset=this.preprocessor.offset+1),this.currentLocation=this.getCurrentLocation(-1);}emitCurrentTagToken(){const e=this.currentToken;this.prepareToken(e),e.tagID=f(e.tagName),e.type===h.START_TAG?(this.lastStartTagName=e.tagName,this.handler.onStartTag(e)):(e.attrs.length>0&&this._err(T.endTagWithAttributes),e.selfClosing&&this._err(T.endTagWithTrailingSolidus),this.handler.onEndTag(e)),this.preprocessor.dropParsedChunk();}emitCurrentComment(e){this.prepareToken(e),this.handler.onComment(e),this.preprocessor.dropParsedChunk();}emitCurrentDoctype(e){this.prepareToken(e),this.handler.onDoctype(e),this.preprocessor.dropParsedChunk();}_emitCurrentCharacterToken(e){if(this.currentCharacterToken){switch(e&&this.currentCharacterToken.location&&(this.currentCharacterToken.location.endLine=e.startLine,this.currentCharacterToken.location.endCol=e.startCol,this.currentCharacterToken.location.endOffset=e.startOffset),this.currentCharacterToken.type){case h.CHARACTER:this.handler.onCharacter(this.currentCharacterToken);break;case h.NULL_CHARACTER:this.handler.onNullCharacter(this.currentCharacterToken);break;case h.WHITESPACE_CHARACTER:this.handler.onWhitespaceCharacter(this.currentCharacterToken);}this.currentCharacterToken=null;}}_emitEOFToken(){const e=this.getCurrentLocation(0);e&&(e.endLine=e.startLine,e.endCol=e.startCol,e.endOffset=e.startOffset),this._emitCurrentCharacterToken(e),this.handler.onEof({type:h.EOF,location:e}),this.active=!1;}_appendCharToCurrentCharacterToken(e,t){if(this.currentCharacterToken){if(this.currentCharacterToken.type===e)return void(this.currentCharacterToken.chars+=t);this.currentLocation=this.getCurrentLocation(0),this._emitCurrentCharacterToken(this.currentLocation),this.preprocessor.dropParsedChunk();}this._createCharacterToken(e,t);}_emitCodePoint(e){const t=Y(e)?h.WHITESPACE_CHARACTER:e===a.NULL?h.NULL_CHARACTER:h.CHARACTER;this._appendCharToCurrentCharacterToken(t,String.fromCodePoint(e));}_emitChars(e){this._appendCharToCurrentCharacterToken(h.CHARACTER,e);}_matchNamedCharacterReference(e){let t=null,s=0,r=!1;for(let i=0,o=R.htmlDecodeTree[0];i>=0&&(i=R.determineBranch(R.htmlDecodeTree,o,i+1,e),!(i<0));e=this._consume()){s+=1,o=R.htmlDecodeTree[i];const c=o&R.BinTrieFlags.VALUE_LENGTH;if(c){const o=(c>>14)-1;if(e!==a.SEMICOLON&&this._isCharacterReferenceInAttribute()&&((n=this.preprocessor.peek(1))===a.EQUALS_SIGN||U(n))?(t=[a.AMPERSAND],i+=o):(t=0===o?[R.htmlDecodeTree[i]&~R.BinTrieFlags.VALUE_LENGTH]:1===o?[R.htmlDecodeTree[++i]]:[R.htmlDecodeTree[++i],R.htmlDecodeTree[++i]],s=0,r=e!==a.SEMICOLON),0===o){this._consume();break}}}var n;return this._unconsume(s),r&&!this.preprocessor.endOfChunkHit&&this._err(T.missingSemicolonAfterCharacterReference),this._unconsume(1),t}_isCharacterReferenceInAttribute(){return this.returnState===P.ATTRIBUTE_VALUE_DOUBLE_QUOTED||this.returnState===P.ATTRIBUTE_VALUE_SINGLE_QUOTED||this.returnState===P.ATTRIBUTE_VALUE_UNQUOTED}_flushCodePointConsumedAsCharacterReference(e){this._isCharacterReferenceInAttribute()?this.currentAttr.value+=String.fromCodePoint(e):this._emitCodePoint(e);}_callState(e){switch(this.state){case P.DATA:this._stateData(e);break;case P.RCDATA:this._stateRcdata(e);break;case P.RAWTEXT:this._stateRawtext(e);break;case P.SCRIPT_DATA:this._stateScriptData(e);break;case P.PLAINTEXT:this._statePlaintext(e);break;case P.TAG_OPEN:this._stateTagOpen(e);break;case P.END_TAG_OPEN:this._stateEndTagOpen(e);break;case P.TAG_NAME:this._stateTagName(e);break;case P.RCDATA_LESS_THAN_SIGN:this._stateRcdataLessThanSign(e);break;case P.RCDATA_END_TAG_OPEN:this._stateRcdataEndTagOpen(e);break;case P.RCDATA_END_TAG_NAME:this._stateRcdataEndTagName(e);break;case P.RAWTEXT_LESS_THAN_SIGN:this._stateRawtextLessThanSign(e);break;case P.RAWTEXT_END_TAG_OPEN:this._stateRawtextEndTagOpen(e);break;case P.RAWTEXT_END_TAG_NAME:this._stateRawtextEndTagName(e);break;case P.SCRIPT_DATA_LESS_THAN_SIGN:this._stateScriptDataLessThanSign(e);break;case P.SCRIPT_DATA_END_TAG_OPEN:this._stateScriptDataEndTagOpen(e);break;case P.SCRIPT_DATA_END_TAG_NAME:this._stateScriptDataEndTagName(e);break;case P.SCRIPT_DATA_ESCAPE_START:this._stateScriptDataEscapeStart(e);break;case P.SCRIPT_DATA_ESCAPE_START_DASH:this._stateScriptDataEscapeStartDash(e);break;case P.SCRIPT_DATA_ESCAPED:this._stateScriptDataEscaped(e);break;case P.SCRIPT_DATA_ESCAPED_DASH:this._stateScriptDataEscapedDash(e);break;case P.SCRIPT_DATA_ESCAPED_DASH_DASH:this._stateScriptDataEscapedDashDash(e);break;case P.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN:this._stateScriptDataEscapedLessThanSign(e);break;case P.SCRIPT_DATA_ESCAPED_END_TAG_OPEN:this._stateScriptDataEscapedEndTagOpen(e);break;case P.SCRIPT_DATA_ESCAPED_END_TAG_NAME:this._stateScriptDataEscapedEndTagName(e);break;case P.SCRIPT_DATA_DOUBLE_ESCAPE_START:this._stateScriptDataDoubleEscapeStart(e);break;case P.SCRIPT_DATA_DOUBLE_ESCAPED:this._stateScriptDataDoubleEscaped(e);break;case P.SCRIPT_DATA_DOUBLE_ESCAPED_DASH:this._stateScriptDataDoubleEscapedDash(e);break;case P.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH:this._stateScriptDataDoubleEscapedDashDash(e);break;case P.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN:this._stateScriptDataDoubleEscapedLessThanSign(e);break;case P.SCRIPT_DATA_DOUBLE_ESCAPE_END:this._stateScriptDataDoubleEscapeEnd(e);break;case P.BEFORE_ATTRIBUTE_NAME:this._stateBeforeAttributeName(e);break;case P.ATTRIBUTE_NAME:this._stateAttributeName(e);break;case P.AFTER_ATTRIBUTE_NAME:this._stateAfterAttributeName(e);break;case P.BEFORE_ATTRIBUTE_VALUE:this._stateBeforeAttributeValue(e);break;case P.ATTRIBUTE_VALUE_DOUBLE_QUOTED:this._stateAttributeValueDoubleQuoted(e);break;case P.ATTRIBUTE_VALUE_SINGLE_QUOTED:this._stateAttributeValueSingleQuoted(e);break;case P.ATTRIBUTE_VALUE_UNQUOTED:this._stateAttributeValueUnquoted(e);break;case P.AFTER_ATTRIBUTE_VALUE_QUOTED:this._stateAfterAttributeValueQuoted(e);break;case P.SELF_CLOSING_START_TAG:this._stateSelfClosingStartTag(e);break;case P.BOGUS_COMMENT:this._stateBogusComment(e);break;case P.MARKUP_DECLARATION_OPEN:this._stateMarkupDeclarationOpen(e);break;case P.COMMENT_START:this._stateCommentStart(e);break;case P.COMMENT_START_DASH:this._stateCommentStartDash(e);break;case P.COMMENT:this._stateComment(e);break;case P.COMMENT_LESS_THAN_SIGN:this._stateCommentLessThanSign(e);break;case P.COMMENT_LESS_THAN_SIGN_BANG:this._stateCommentLessThanSignBang(e);break;case P.COMMENT_LESS_THAN_SIGN_BANG_DASH:this._stateCommentLessThanSignBangDash(e);break;case P.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH:this._stateCommentLessThanSignBangDashDash(e);break;case P.COMMENT_END_DASH:this._stateCommentEndDash(e);break;case P.COMMENT_END:this._stateCommentEnd(e);break;case P.COMMENT_END_BANG:this._stateCommentEndBang(e);break;case P.DOCTYPE:this._stateDoctype(e);break;case P.BEFORE_DOCTYPE_NAME:this._stateBeforeDoctypeName(e);break;case P.DOCTYPE_NAME:this._stateDoctypeName(e);break;case P.AFTER_DOCTYPE_NAME:this._stateAfterDoctypeName(e);break;case P.AFTER_DOCTYPE_PUBLIC_KEYWORD:this._stateAfterDoctypePublicKeyword(e);break;case P.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER:this._stateBeforeDoctypePublicIdentifier(e);break;case P.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED:this._stateDoctypePublicIdentifierDoubleQuoted(e);break;case P.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED:this._stateDoctypePublicIdentifierSingleQuoted(e);break;case P.AFTER_DOCTYPE_PUBLIC_IDENTIFIER:this._stateAfterDoctypePublicIdentifier(e);break;case P.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS:this._stateBetweenDoctypePublicAndSystemIdentifiers(e);break;case P.AFTER_DOCTYPE_SYSTEM_KEYWORD:this._stateAfterDoctypeSystemKeyword(e);break;case P.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER:this._stateBeforeDoctypeSystemIdentifier(e);break;case P.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED:this._stateDoctypeSystemIdentifierDoubleQuoted(e);break;case P.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED:this._stateDoctypeSystemIdentifierSingleQuoted(e);break;case P.AFTER_DOCTYPE_SYSTEM_IDENTIFIER:this._stateAfterDoctypeSystemIdentifier(e);break;case P.BOGUS_DOCTYPE:this._stateBogusDoctype(e);break;case P.CDATA_SECTION:this._stateCdataSection(e);break;case P.CDATA_SECTION_BRACKET:this._stateCdataSectionBracket(e);break;case P.CDATA_SECTION_END:this._stateCdataSectionEnd(e);break;case P.CHARACTER_REFERENCE:this._stateCharacterReference(e);break;case P.NAMED_CHARACTER_REFERENCE:this._stateNamedCharacterReference(e);break;case P.AMBIGUOUS_AMPERSAND:this._stateAmbiguousAmpersand(e);break;case P.NUMERIC_CHARACTER_REFERENCE:this._stateNumericCharacterReference(e);break;case P.HEXADEMICAL_CHARACTER_REFERENCE_START:this._stateHexademicalCharacterReferenceStart(e);break;case P.HEXADEMICAL_CHARACTER_REFERENCE:this._stateHexademicalCharacterReference(e);break;case P.DECIMAL_CHARACTER_REFERENCE:this._stateDecimalCharacterReference(e);break;case P.NUMERIC_CHARACTER_REFERENCE_END:this._stateNumericCharacterReferenceEnd(e);break;default:throw new Error("Unknown state")}}_stateData(e){switch(e){case a.LESS_THAN_SIGN:this.state=P.TAG_OPEN;break;case a.AMPERSAND:this.returnState=P.DATA,this.state=P.CHARACTER_REFERENCE;break;case a.NULL:this._err(T.unexpectedNullCharacter),this._emitCodePoint(e);break;case a.EOF:this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateRcdata(e){switch(e){case a.AMPERSAND:this.returnState=P.RCDATA,this.state=P.CHARACTER_REFERENCE;break;case a.LESS_THAN_SIGN:this.state=P.RCDATA_LESS_THAN_SIGN;break;case a.NULL:this._err(T.unexpectedNullCharacter),this._emitChars(s);break;case a.EOF:this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateRawtext(e){switch(e){case a.LESS_THAN_SIGN:this.state=P.RAWTEXT_LESS_THAN_SIGN;break;case a.NULL:this._err(T.unexpectedNullCharacter),this._emitChars(s);break;case a.EOF:this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateScriptData(e){switch(e){case a.LESS_THAN_SIGN:this.state=P.SCRIPT_DATA_LESS_THAN_SIGN;break;case a.NULL:this._err(T.unexpectedNullCharacter),this._emitChars(s);break;case a.EOF:this._emitEOFToken();break;default:this._emitCodePoint(e);}}_statePlaintext(e){switch(e){case a.NULL:this._err(T.unexpectedNullCharacter),this._emitChars(s);break;case a.EOF:this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateTagOpen(e){if(F(e))this._createStartTagToken(),this.state=P.TAG_NAME,this._stateTagName(e);else switch(e){case a.EXCLAMATION_MARK:this.state=P.MARKUP_DECLARATION_OPEN;break;case a.SOLIDUS:this.state=P.END_TAG_OPEN;break;case a.QUESTION_MARK:this._err(T.unexpectedQuestionMarkInsteadOfTagName),this._createCommentToken(1),this.state=P.BOGUS_COMMENT,this._stateBogusComment(e);break;case a.EOF:this._err(T.eofBeforeTagName),this._emitChars("<"),this._emitEOFToken();break;default:this._err(T.invalidFirstCharacterOfTagName),this._emitChars("<"),this.state=P.DATA,this._stateData(e);}}_stateEndTagOpen(e){if(F(e))this._createEndTagToken(),this.state=P.TAG_NAME,this._stateTagName(e);else switch(e){case a.GREATER_THAN_SIGN:this._err(T.missingEndTagName),this.state=P.DATA;break;case a.EOF:this._err(T.eofBeforeTagName),this._emitChars("</"),this._emitEOFToken();break;default:this._err(T.invalidFirstCharacterOfTagName),this._createCommentToken(2),this.state=P.BOGUS_COMMENT,this._stateBogusComment(e);}}_stateTagName(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this.state=P.BEFORE_ATTRIBUTE_NAME;break;case a.SOLIDUS:this.state=P.SELF_CLOSING_START_TAG;break;case a.GREATER_THAN_SIGN:this.state=P.DATA,this.emitCurrentTagToken();break;case a.NULL:this._err(T.unexpectedNullCharacter),t.tagName+=s;break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:t.tagName+=String.fromCodePoint(H(e)?w(e):e);}}_stateRcdataLessThanSign(e){e===a.SOLIDUS?this.state=P.RCDATA_END_TAG_OPEN:(this._emitChars("<"),this.state=P.RCDATA,this._stateRcdata(e));}_stateRcdataEndTagOpen(e){F(e)?(this.state=P.RCDATA_END_TAG_NAME,this._stateRcdataEndTagName(e)):(this._emitChars("</"),this.state=P.RCDATA,this._stateRcdata(e));}handleSpecialEndTag(e){if(!this.preprocessor.startsWith(this.lastStartTagName,!1))return !this._ensureHibernation();switch(this._createEndTagToken(),this.currentToken.tagName=this.lastStartTagName,this.preprocessor.peek(this.lastStartTagName.length)){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:return this._advanceBy(this.lastStartTagName.length),this.state=P.BEFORE_ATTRIBUTE_NAME,!1;case a.SOLIDUS:return this._advanceBy(this.lastStartTagName.length),this.state=P.SELF_CLOSING_START_TAG,!1;case a.GREATER_THAN_SIGN:return this._advanceBy(this.lastStartTagName.length),this.emitCurrentTagToken(),this.state=P.DATA,!1;default:return !this._ensureHibernation()}}_stateRcdataEndTagName(e){this.handleSpecialEndTag(e)&&(this._emitChars("</"),this.state=P.RCDATA,this._stateRcdata(e));}_stateRawtextLessThanSign(e){e===a.SOLIDUS?this.state=P.RAWTEXT_END_TAG_OPEN:(this._emitChars("<"),this.state=P.RAWTEXT,this._stateRawtext(e));}_stateRawtextEndTagOpen(e){F(e)?(this.state=P.RAWTEXT_END_TAG_NAME,this._stateRawtextEndTagName(e)):(this._emitChars("</"),this.state=P.RAWTEXT,this._stateRawtext(e));}_stateRawtextEndTagName(e){this.handleSpecialEndTag(e)&&(this._emitChars("</"),this.state=P.RAWTEXT,this._stateRawtext(e));}_stateScriptDataLessThanSign(e){switch(e){case a.SOLIDUS:this.state=P.SCRIPT_DATA_END_TAG_OPEN;break;case a.EXCLAMATION_MARK:this.state=P.SCRIPT_DATA_ESCAPE_START,this._emitChars("<!");break;default:this._emitChars("<"),this.state=P.SCRIPT_DATA,this._stateScriptData(e);}}_stateScriptDataEndTagOpen(e){F(e)?(this.state=P.SCRIPT_DATA_END_TAG_NAME,this._stateScriptDataEndTagName(e)):(this._emitChars("</"),this.state=P.SCRIPT_DATA,this._stateScriptData(e));}_stateScriptDataEndTagName(e){this.handleSpecialEndTag(e)&&(this._emitChars("</"),this.state=P.SCRIPT_DATA,this._stateScriptData(e));}_stateScriptDataEscapeStart(e){e===a.HYPHEN_MINUS?(this.state=P.SCRIPT_DATA_ESCAPE_START_DASH,this._emitChars("-")):(this.state=P.SCRIPT_DATA,this._stateScriptData(e));}_stateScriptDataEscapeStartDash(e){e===a.HYPHEN_MINUS?(this.state=P.SCRIPT_DATA_ESCAPED_DASH_DASH,this._emitChars("-")):(this.state=P.SCRIPT_DATA,this._stateScriptData(e));}_stateScriptDataEscaped(e){switch(e){case a.HYPHEN_MINUS:this.state=P.SCRIPT_DATA_ESCAPED_DASH,this._emitChars("-");break;case a.LESS_THAN_SIGN:this.state=P.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;break;case a.NULL:this._err(T.unexpectedNullCharacter),this._emitChars(s);break;case a.EOF:this._err(T.eofInScriptHtmlCommentLikeText),this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateScriptDataEscapedDash(e){switch(e){case a.HYPHEN_MINUS:this.state=P.SCRIPT_DATA_ESCAPED_DASH_DASH,this._emitChars("-");break;case a.LESS_THAN_SIGN:this.state=P.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;break;case a.NULL:this._err(T.unexpectedNullCharacter),this.state=P.SCRIPT_DATA_ESCAPED,this._emitChars(s);break;case a.EOF:this._err(T.eofInScriptHtmlCommentLikeText),this._emitEOFToken();break;default:this.state=P.SCRIPT_DATA_ESCAPED,this._emitCodePoint(e);}}_stateScriptDataEscapedDashDash(e){switch(e){case a.HYPHEN_MINUS:this._emitChars("-");break;case a.LESS_THAN_SIGN:this.state=P.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN;break;case a.GREATER_THAN_SIGN:this.state=P.SCRIPT_DATA,this._emitChars(">");break;case a.NULL:this._err(T.unexpectedNullCharacter),this.state=P.SCRIPT_DATA_ESCAPED,this._emitChars(s);break;case a.EOF:this._err(T.eofInScriptHtmlCommentLikeText),this._emitEOFToken();break;default:this.state=P.SCRIPT_DATA_ESCAPED,this._emitCodePoint(e);}}_stateScriptDataEscapedLessThanSign(e){e===a.SOLIDUS?this.state=P.SCRIPT_DATA_ESCAPED_END_TAG_OPEN:F(e)?(this._emitChars("<"),this.state=P.SCRIPT_DATA_DOUBLE_ESCAPE_START,this._stateScriptDataDoubleEscapeStart(e)):(this._emitChars("<"),this.state=P.SCRIPT_DATA_ESCAPED,this._stateScriptDataEscaped(e));}_stateScriptDataEscapedEndTagOpen(e){F(e)?(this.state=P.SCRIPT_DATA_ESCAPED_END_TAG_NAME,this._stateScriptDataEscapedEndTagName(e)):(this._emitChars("</"),this.state=P.SCRIPT_DATA_ESCAPED,this._stateScriptDataEscaped(e));}_stateScriptDataEscapedEndTagName(e){this.handleSpecialEndTag(e)&&(this._emitChars("</"),this.state=P.SCRIPT_DATA_ESCAPED,this._stateScriptDataEscaped(e));}_stateScriptDataDoubleEscapeStart(e){if(this.preprocessor.startsWith(i,!1)&&x(this.preprocessor.peek(i.length))){this._emitCodePoint(e);for(let e=0;e<i.length;e++)this._emitCodePoint(this._consume());this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED;}else this._ensureHibernation()||(this.state=P.SCRIPT_DATA_ESCAPED,this._stateScriptDataEscaped(e));}_stateScriptDataDoubleEscaped(e){switch(e){case a.HYPHEN_MINUS:this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED_DASH,this._emitChars("-");break;case a.LESS_THAN_SIGN:this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN,this._emitChars("<");break;case a.NULL:this._err(T.unexpectedNullCharacter),this._emitChars(s);break;case a.EOF:this._err(T.eofInScriptHtmlCommentLikeText),this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateScriptDataDoubleEscapedDash(e){switch(e){case a.HYPHEN_MINUS:this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH,this._emitChars("-");break;case a.LESS_THAN_SIGN:this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN,this._emitChars("<");break;case a.NULL:this._err(T.unexpectedNullCharacter),this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED,this._emitChars(s);break;case a.EOF:this._err(T.eofInScriptHtmlCommentLikeText),this._emitEOFToken();break;default:this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED,this._emitCodePoint(e);}}_stateScriptDataDoubleEscapedDashDash(e){switch(e){case a.HYPHEN_MINUS:this._emitChars("-");break;case a.LESS_THAN_SIGN:this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN,this._emitChars("<");break;case a.GREATER_THAN_SIGN:this.state=P.SCRIPT_DATA,this._emitChars(">");break;case a.NULL:this._err(T.unexpectedNullCharacter),this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED,this._emitChars(s);break;case a.EOF:this._err(T.eofInScriptHtmlCommentLikeText),this._emitEOFToken();break;default:this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED,this._emitCodePoint(e);}}_stateScriptDataDoubleEscapedLessThanSign(e){e===a.SOLIDUS?(this.state=P.SCRIPT_DATA_DOUBLE_ESCAPE_END,this._emitChars("/")):(this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED,this._stateScriptDataDoubleEscaped(e));}_stateScriptDataDoubleEscapeEnd(e){if(this.preprocessor.startsWith(i,!1)&&x(this.preprocessor.peek(i.length))){this._emitCodePoint(e);for(let e=0;e<i.length;e++)this._emitCodePoint(this._consume());this.state=P.SCRIPT_DATA_ESCAPED;}else this._ensureHibernation()||(this.state=P.SCRIPT_DATA_DOUBLE_ESCAPED,this._stateScriptDataDoubleEscaped(e));}_stateBeforeAttributeName(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.SOLIDUS:case a.GREATER_THAN_SIGN:case a.EOF:this.state=P.AFTER_ATTRIBUTE_NAME,this._stateAfterAttributeName(e);break;case a.EQUALS_SIGN:this._err(T.unexpectedEqualsSignBeforeAttributeName),this._createAttr("="),this.state=P.ATTRIBUTE_NAME;break;default:this._createAttr(""),this.state=P.ATTRIBUTE_NAME,this._stateAttributeName(e);}}_stateAttributeName(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:case a.SOLIDUS:case a.GREATER_THAN_SIGN:case a.EOF:this._leaveAttrName(),this.state=P.AFTER_ATTRIBUTE_NAME,this._stateAfterAttributeName(e);break;case a.EQUALS_SIGN:this._leaveAttrName(),this.state=P.BEFORE_ATTRIBUTE_VALUE;break;case a.QUOTATION_MARK:case a.APOSTROPHE:case a.LESS_THAN_SIGN:this._err(T.unexpectedCharacterInAttributeName),this.currentAttr.name+=String.fromCodePoint(e);break;case a.NULL:this._err(T.unexpectedNullCharacter),this.currentAttr.name+=s;break;default:this.currentAttr.name+=String.fromCodePoint(H(e)?w(e):e);}}_stateAfterAttributeName(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.SOLIDUS:this.state=P.SELF_CLOSING_START_TAG;break;case a.EQUALS_SIGN:this.state=P.BEFORE_ATTRIBUTE_VALUE;break;case a.GREATER_THAN_SIGN:this.state=P.DATA,this.emitCurrentTagToken();break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:this._createAttr(""),this.state=P.ATTRIBUTE_NAME,this._stateAttributeName(e);}}_stateBeforeAttributeValue(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.QUOTATION_MARK:this.state=P.ATTRIBUTE_VALUE_DOUBLE_QUOTED;break;case a.APOSTROPHE:this.state=P.ATTRIBUTE_VALUE_SINGLE_QUOTED;break;case a.GREATER_THAN_SIGN:this._err(T.missingAttributeValue),this.state=P.DATA,this.emitCurrentTagToken();break;default:this.state=P.ATTRIBUTE_VALUE_UNQUOTED,this._stateAttributeValueUnquoted(e);}}_stateAttributeValueDoubleQuoted(e){switch(e){case a.QUOTATION_MARK:this.state=P.AFTER_ATTRIBUTE_VALUE_QUOTED;break;case a.AMPERSAND:this.returnState=P.ATTRIBUTE_VALUE_DOUBLE_QUOTED,this.state=P.CHARACTER_REFERENCE;break;case a.NULL:this._err(T.unexpectedNullCharacter),this.currentAttr.value+=s;break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:this.currentAttr.value+=String.fromCodePoint(e);}}_stateAttributeValueSingleQuoted(e){switch(e){case a.APOSTROPHE:this.state=P.AFTER_ATTRIBUTE_VALUE_QUOTED;break;case a.AMPERSAND:this.returnState=P.ATTRIBUTE_VALUE_SINGLE_QUOTED,this.state=P.CHARACTER_REFERENCE;break;case a.NULL:this._err(T.unexpectedNullCharacter),this.currentAttr.value+=s;break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:this.currentAttr.value+=String.fromCodePoint(e);}}_stateAttributeValueUnquoted(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this._leaveAttrValue(),this.state=P.BEFORE_ATTRIBUTE_NAME;break;case a.AMPERSAND:this.returnState=P.ATTRIBUTE_VALUE_UNQUOTED,this.state=P.CHARACTER_REFERENCE;break;case a.GREATER_THAN_SIGN:this._leaveAttrValue(),this.state=P.DATA,this.emitCurrentTagToken();break;case a.NULL:this._err(T.unexpectedNullCharacter),this.currentAttr.value+=s;break;case a.QUOTATION_MARK:case a.APOSTROPHE:case a.LESS_THAN_SIGN:case a.EQUALS_SIGN:case a.GRAVE_ACCENT:this._err(T.unexpectedCharacterInUnquotedAttributeValue),this.currentAttr.value+=String.fromCodePoint(e);break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:this.currentAttr.value+=String.fromCodePoint(e);}}_stateAfterAttributeValueQuoted(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this._leaveAttrValue(),this.state=P.BEFORE_ATTRIBUTE_NAME;break;case a.SOLIDUS:this._leaveAttrValue(),this.state=P.SELF_CLOSING_START_TAG;break;case a.GREATER_THAN_SIGN:this._leaveAttrValue(),this.state=P.DATA,this.emitCurrentTagToken();break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:this._err(T.missingWhitespaceBetweenAttributes),this.state=P.BEFORE_ATTRIBUTE_NAME,this._stateBeforeAttributeName(e);}}_stateSelfClosingStartTag(e){switch(e){case a.GREATER_THAN_SIGN:this.currentToken.selfClosing=!0,this.state=P.DATA,this.emitCurrentTagToken();break;case a.EOF:this._err(T.eofInTag),this._emitEOFToken();break;default:this._err(T.unexpectedSolidusInTag),this.state=P.BEFORE_ATTRIBUTE_NAME,this._stateBeforeAttributeName(e);}}_stateBogusComment(e){const t=this.currentToken;switch(e){case a.GREATER_THAN_SIGN:this.state=P.DATA,this.emitCurrentComment(t);break;case a.EOF:this.emitCurrentComment(t),this._emitEOFToken();break;case a.NULL:this._err(T.unexpectedNullCharacter),t.data+=s;break;default:t.data+=String.fromCodePoint(e);}}_stateMarkupDeclarationOpen(e){this._consumeSequenceIfMatch("--",!0)?(this._createCommentToken("--".length+1),this.state=P.COMMENT_START):this._consumeSequenceIfMatch(n,!1)?(this.currentLocation=this.getCurrentLocation(n.length+1),this.state=P.DOCTYPE):this._consumeSequenceIfMatch(r,!0)?this.inForeignNode?this.state=P.CDATA_SECTION:(this._err(T.cdataInHtmlContent),this._createCommentToken(r.length+1),this.currentToken.data="[CDATA[",this.state=P.BOGUS_COMMENT):this._ensureHibernation()||(this._err(T.incorrectlyOpenedComment),this._createCommentToken(2),this.state=P.BOGUS_COMMENT,this._stateBogusComment(e));}_stateCommentStart(e){switch(e){case a.HYPHEN_MINUS:this.state=P.COMMENT_START_DASH;break;case a.GREATER_THAN_SIGN:{this._err(T.abruptClosingOfEmptyComment),this.state=P.DATA;const e=this.currentToken;this.emitCurrentComment(e);break}default:this.state=P.COMMENT,this._stateComment(e);}}_stateCommentStartDash(e){const t=this.currentToken;switch(e){case a.HYPHEN_MINUS:this.state=P.COMMENT_END;break;case a.GREATER_THAN_SIGN:this._err(T.abruptClosingOfEmptyComment),this.state=P.DATA,this.emitCurrentComment(t);break;case a.EOF:this._err(T.eofInComment),this.emitCurrentComment(t),this._emitEOFToken();break;default:t.data+="-",this.state=P.COMMENT,this._stateComment(e);}}_stateComment(e){const t=this.currentToken;switch(e){case a.HYPHEN_MINUS:this.state=P.COMMENT_END_DASH;break;case a.LESS_THAN_SIGN:t.data+="<",this.state=P.COMMENT_LESS_THAN_SIGN;break;case a.NULL:this._err(T.unexpectedNullCharacter),t.data+=s;break;case a.EOF:this._err(T.eofInComment),this.emitCurrentComment(t),this._emitEOFToken();break;default:t.data+=String.fromCodePoint(e);}}_stateCommentLessThanSign(e){const t=this.currentToken;switch(e){case a.EXCLAMATION_MARK:t.data+="!",this.state=P.COMMENT_LESS_THAN_SIGN_BANG;break;case a.LESS_THAN_SIGN:t.data+="<";break;default:this.state=P.COMMENT,this._stateComment(e);}}_stateCommentLessThanSignBang(e){e===a.HYPHEN_MINUS?this.state=P.COMMENT_LESS_THAN_SIGN_BANG_DASH:(this.state=P.COMMENT,this._stateComment(e));}_stateCommentLessThanSignBangDash(e){e===a.HYPHEN_MINUS?this.state=P.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH:(this.state=P.COMMENT_END_DASH,this._stateCommentEndDash(e));}_stateCommentLessThanSignBangDashDash(e){e!==a.GREATER_THAN_SIGN&&e!==a.EOF&&this._err(T.nestedComment),this.state=P.COMMENT_END,this._stateCommentEnd(e);}_stateCommentEndDash(e){const t=this.currentToken;switch(e){case a.HYPHEN_MINUS:this.state=P.COMMENT_END;break;case a.EOF:this._err(T.eofInComment),this.emitCurrentComment(t),this._emitEOFToken();break;default:t.data+="-",this.state=P.COMMENT,this._stateComment(e);}}_stateCommentEnd(e){const t=this.currentToken;switch(e){case a.GREATER_THAN_SIGN:this.state=P.DATA,this.emitCurrentComment(t);break;case a.EXCLAMATION_MARK:this.state=P.COMMENT_END_BANG;break;case a.HYPHEN_MINUS:t.data+="-";break;case a.EOF:this._err(T.eofInComment),this.emitCurrentComment(t),this._emitEOFToken();break;default:t.data+="--",this.state=P.COMMENT,this._stateComment(e);}}_stateCommentEndBang(e){const t=this.currentToken;switch(e){case a.HYPHEN_MINUS:t.data+="--!",this.state=P.COMMENT_END_DASH;break;case a.GREATER_THAN_SIGN:this._err(T.incorrectlyClosedComment),this.state=P.DATA,this.emitCurrentComment(t);break;case a.EOF:this._err(T.eofInComment),this.emitCurrentComment(t),this._emitEOFToken();break;default:t.data+="--!",this.state=P.COMMENT,this._stateComment(e);}}_stateDoctype(e){switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this.state=P.BEFORE_DOCTYPE_NAME;break;case a.GREATER_THAN_SIGN:this.state=P.BEFORE_DOCTYPE_NAME,this._stateBeforeDoctypeName(e);break;case a.EOF:{this._err(T.eofInDoctype),this._createDoctypeToken(null);const e=this.currentToken;e.forceQuirks=!0,this.emitCurrentDoctype(e),this._emitEOFToken();break}default:this._err(T.missingWhitespaceBeforeDoctypeName),this.state=P.BEFORE_DOCTYPE_NAME,this._stateBeforeDoctypeName(e);}}_stateBeforeDoctypeName(e){if(H(e))this._createDoctypeToken(String.fromCharCode(w(e))),this.state=P.DOCTYPE_NAME;else switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.NULL:this._err(T.unexpectedNullCharacter),this._createDoctypeToken(s),this.state=P.DOCTYPE_NAME;break;case a.GREATER_THAN_SIGN:{this._err(T.missingDoctypeName),this._createDoctypeToken(null);const e=this.currentToken;e.forceQuirks=!0,this.emitCurrentDoctype(e),this.state=P.DATA;break}case a.EOF:{this._err(T.eofInDoctype),this._createDoctypeToken(null);const e=this.currentToken;e.forceQuirks=!0,this.emitCurrentDoctype(e),this._emitEOFToken();break}default:this._createDoctypeToken(String.fromCodePoint(e)),this.state=P.DOCTYPE_NAME;}}_stateDoctypeName(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this.state=P.AFTER_DOCTYPE_NAME;break;case a.GREATER_THAN_SIGN:this.state=P.DATA,this.emitCurrentDoctype(t);break;case a.NULL:this._err(T.unexpectedNullCharacter),t.name+=s;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:t.name+=String.fromCodePoint(H(e)?w(e):e);}}_stateAfterDoctypeName(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.GREATER_THAN_SIGN:this.state=P.DATA,this.emitCurrentDoctype(t);break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._consumeSequenceIfMatch("public",!1)?this.state=P.AFTER_DOCTYPE_PUBLIC_KEYWORD:this._consumeSequenceIfMatch("system",!1)?this.state=P.AFTER_DOCTYPE_SYSTEM_KEYWORD:this._ensureHibernation()||(this._err(T.invalidCharacterSequenceAfterDoctypeName),t.forceQuirks=!0,this.state=P.BOGUS_DOCTYPE,this._stateBogusDoctype(e));}}_stateAfterDoctypePublicKeyword(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this.state=P.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER;break;case a.QUOTATION_MARK:this._err(T.missingWhitespaceAfterDoctypePublicKeyword),t.publicId="",this.state=P.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;break;case a.APOSTROPHE:this._err(T.missingWhitespaceAfterDoctypePublicKeyword),t.publicId="",this.state=P.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;break;case a.GREATER_THAN_SIGN:this._err(T.missingDoctypePublicIdentifier),t.forceQuirks=!0,this.state=P.DATA,this.emitCurrentDoctype(t);break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.missingQuoteBeforeDoctypePublicIdentifier),t.forceQuirks=!0,this.state=P.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateBeforeDoctypePublicIdentifier(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.QUOTATION_MARK:t.publicId="",this.state=P.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED;break;case a.APOSTROPHE:t.publicId="",this.state=P.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED;break;case a.GREATER_THAN_SIGN:this._err(T.missingDoctypePublicIdentifier),t.forceQuirks=!0,this.state=P.DATA,this.emitCurrentDoctype(t);break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.missingQuoteBeforeDoctypePublicIdentifier),t.forceQuirks=!0,this.state=P.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateDoctypePublicIdentifierDoubleQuoted(e){const t=this.currentToken;switch(e){case a.QUOTATION_MARK:this.state=P.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;break;case a.NULL:this._err(T.unexpectedNullCharacter),t.publicId+=s;break;case a.GREATER_THAN_SIGN:this._err(T.abruptDoctypePublicIdentifier),t.forceQuirks=!0,this.emitCurrentDoctype(t),this.state=P.DATA;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:t.publicId+=String.fromCodePoint(e);}}_stateDoctypePublicIdentifierSingleQuoted(e){const t=this.currentToken;switch(e){case a.APOSTROPHE:this.state=P.AFTER_DOCTYPE_PUBLIC_IDENTIFIER;break;case a.NULL:this._err(T.unexpectedNullCharacter),t.publicId+=s;break;case a.GREATER_THAN_SIGN:this._err(T.abruptDoctypePublicIdentifier),t.forceQuirks=!0,this.emitCurrentDoctype(t),this.state=P.DATA;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:t.publicId+=String.fromCodePoint(e);}}_stateAfterDoctypePublicIdentifier(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this.state=P.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS;break;case a.GREATER_THAN_SIGN:this.state=P.DATA,this.emitCurrentDoctype(t);break;case a.QUOTATION_MARK:this._err(T.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers),t.systemId="",this.state=P.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;break;case a.APOSTROPHE:this._err(T.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers),t.systemId="",this.state=P.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.missingQuoteBeforeDoctypeSystemIdentifier),t.forceQuirks=!0,this.state=P.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateBetweenDoctypePublicAndSystemIdentifiers(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.GREATER_THAN_SIGN:this.emitCurrentDoctype(t),this.state=P.DATA;break;case a.QUOTATION_MARK:t.systemId="",this.state=P.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;break;case a.APOSTROPHE:t.systemId="",this.state=P.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.missingQuoteBeforeDoctypeSystemIdentifier),t.forceQuirks=!0,this.state=P.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateAfterDoctypeSystemKeyword(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:this.state=P.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER;break;case a.QUOTATION_MARK:this._err(T.missingWhitespaceAfterDoctypeSystemKeyword),t.systemId="",this.state=P.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;break;case a.APOSTROPHE:this._err(T.missingWhitespaceAfterDoctypeSystemKeyword),t.systemId="",this.state=P.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;break;case a.GREATER_THAN_SIGN:this._err(T.missingDoctypeSystemIdentifier),t.forceQuirks=!0,this.state=P.DATA,this.emitCurrentDoctype(t);break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.missingQuoteBeforeDoctypeSystemIdentifier),t.forceQuirks=!0,this.state=P.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateBeforeDoctypeSystemIdentifier(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.QUOTATION_MARK:t.systemId="",this.state=P.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED;break;case a.APOSTROPHE:t.systemId="",this.state=P.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED;break;case a.GREATER_THAN_SIGN:this._err(T.missingDoctypeSystemIdentifier),t.forceQuirks=!0,this.state=P.DATA,this.emitCurrentDoctype(t);break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.missingQuoteBeforeDoctypeSystemIdentifier),t.forceQuirks=!0,this.state=P.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateDoctypeSystemIdentifierDoubleQuoted(e){const t=this.currentToken;switch(e){case a.QUOTATION_MARK:this.state=P.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;break;case a.NULL:this._err(T.unexpectedNullCharacter),t.systemId+=s;break;case a.GREATER_THAN_SIGN:this._err(T.abruptDoctypeSystemIdentifier),t.forceQuirks=!0,this.emitCurrentDoctype(t),this.state=P.DATA;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:t.systemId+=String.fromCodePoint(e);}}_stateDoctypeSystemIdentifierSingleQuoted(e){const t=this.currentToken;switch(e){case a.APOSTROPHE:this.state=P.AFTER_DOCTYPE_SYSTEM_IDENTIFIER;break;case a.NULL:this._err(T.unexpectedNullCharacter),t.systemId+=s;break;case a.GREATER_THAN_SIGN:this._err(T.abruptDoctypeSystemIdentifier),t.forceQuirks=!0,this.emitCurrentDoctype(t),this.state=P.DATA;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:t.systemId+=String.fromCodePoint(e);}}_stateAfterDoctypeSystemIdentifier(e){const t=this.currentToken;switch(e){case a.SPACE:case a.LINE_FEED:case a.TABULATION:case a.FORM_FEED:break;case a.GREATER_THAN_SIGN:this.emitCurrentDoctype(t),this.state=P.DATA;break;case a.EOF:this._err(T.eofInDoctype),t.forceQuirks=!0,this.emitCurrentDoctype(t),this._emitEOFToken();break;default:this._err(T.unexpectedCharacterAfterDoctypeSystemIdentifier),this.state=P.BOGUS_DOCTYPE,this._stateBogusDoctype(e);}}_stateBogusDoctype(e){const t=this.currentToken;switch(e){case a.GREATER_THAN_SIGN:this.emitCurrentDoctype(t),this.state=P.DATA;break;case a.NULL:this._err(T.unexpectedNullCharacter);break;case a.EOF:this.emitCurrentDoctype(t),this._emitEOFToken();}}_stateCdataSection(e){switch(e){case a.RIGHT_SQUARE_BRACKET:this.state=P.CDATA_SECTION_BRACKET;break;case a.EOF:this._err(T.eofInCdata),this._emitEOFToken();break;default:this._emitCodePoint(e);}}_stateCdataSectionBracket(e){e===a.RIGHT_SQUARE_BRACKET?this.state=P.CDATA_SECTION_END:(this._emitChars("]"),this.state=P.CDATA_SECTION,this._stateCdataSection(e));}_stateCdataSectionEnd(e){switch(e){case a.GREATER_THAN_SIGN:this.state=P.DATA;break;case a.RIGHT_SQUARE_BRACKET:this._emitChars("]");break;default:this._emitChars("]]"),this.state=P.CDATA_SECTION,this._stateCdataSection(e);}}_stateCharacterReference(e){e===a.NUMBER_SIGN?this.state=P.NUMERIC_CHARACTER_REFERENCE:U(e)?(this.state=P.NAMED_CHARACTER_REFERENCE,this._stateNamedCharacterReference(e)):(this._flushCodePointConsumedAsCharacterReference(a.AMPERSAND),this._reconsumeInState(this.returnState,e));}_stateNamedCharacterReference(e){const t=this._matchNamedCharacterReference(e);if(this._ensureHibernation());else if(t){for(let e=0;e<t.length;e++)this._flushCodePointConsumedAsCharacterReference(t[e]);this.state=this.returnState;}else this._flushCodePointConsumedAsCharacterReference(a.AMPERSAND),this.state=P.AMBIGUOUS_AMPERSAND;}_stateAmbiguousAmpersand(e){U(e)?this._flushCodePointConsumedAsCharacterReference(e):(e===a.SEMICOLON&&this._err(T.unknownNamedCharacterReference),this._reconsumeInState(this.returnState,e));}_stateNumericCharacterReference(e){this.charRefCode=0,e===a.LATIN_SMALL_X||e===a.LATIN_CAPITAL_X?this.state=P.HEXADEMICAL_CHARACTER_REFERENCE_START:B(e)?(this.state=P.DECIMAL_CHARACTER_REFERENCE,this._stateDecimalCharacterReference(e)):(this._err(T.absenceOfDigitsInNumericCharacterReference),this._flushCodePointConsumedAsCharacterReference(a.AMPERSAND),this._flushCodePointConsumedAsCharacterReference(a.NUMBER_SIGN),this._reconsumeInState(this.returnState,e));}_stateHexademicalCharacterReferenceStart(e){!function(e){return B(e)||G(e)||y(e)}(e)?(this._err(T.absenceOfDigitsInNumericCharacterReference),this._flushCodePointConsumedAsCharacterReference(a.AMPERSAND),this._flushCodePointConsumedAsCharacterReference(a.NUMBER_SIGN),this._unconsume(2),this.state=this.returnState):(this.state=P.HEXADEMICAL_CHARACTER_REFERENCE,this._stateHexademicalCharacterReference(e));}_stateHexademicalCharacterReference(e){G(e)?this.charRefCode=16*this.charRefCode+e-55:y(e)?this.charRefCode=16*this.charRefCode+e-87:B(e)?this.charRefCode=16*this.charRefCode+e-48:e===a.SEMICOLON?this.state=P.NUMERIC_CHARACTER_REFERENCE_END:(this._err(T.missingSemicolonAfterCharacterReference),this.state=P.NUMERIC_CHARACTER_REFERENCE_END,this._stateNumericCharacterReferenceEnd(e));}_stateDecimalCharacterReference(e){B(e)?this.charRefCode=10*this.charRefCode+e-48:e===a.SEMICOLON?this.state=P.NUMERIC_CHARACTER_REFERENCE_END:(this._err(T.missingSemicolonAfterCharacterReference),this.state=P.NUMERIC_CHARACTER_REFERENCE_END,this._stateNumericCharacterReferenceEnd(e));}_stateNumericCharacterReferenceEnd(e){if(this.charRefCode===a.NULL)this._err(T.nullCharacterReference),this.charRefCode=a.REPLACEMENT_CHARACTER;else if(this.charRefCode>1114111)this._err(T.characterReferenceOutsideUnicodeRange),this.charRefCode=a.REPLACEMENT_CHARACTER;else if(o(this.charRefCode))this._err(T.surrogateCharacterReference),this.charRefCode=a.REPLACEMENT_CHARACTER;else if(E(this.charRefCode))this._err(T.noncharacterCharacterReference);else if(c(this.charRefCode)||this.charRefCode===a.CARRIAGE_RETURN){this._err(T.controlCharacterReference);const e=k.get(this.charRefCode);void 0!==e&&(this.charRefCode=e);}this._flushCodePointConsumedAsCharacterReference(this.charRefCode),this._reconsumeInState(this.returnState,e);}}const Q=new Set([u.DD,u.DT,u.LI,u.OPTGROUP,u.OPTION,u.P,u.RB,u.RP,u.RT,u.RTC]),q=new Set([...Q,u.CAPTION,u.COLGROUP,u.TBODY,u.TD,u.TFOOT,u.TH,u.THEAD,u.TR]),W=new Map([[u.APPLET,p.HTML],[u.CAPTION,p.HTML],[u.HTML,p.HTML],[u.MARQUEE,p.HTML],[u.OBJECT,p.HTML],[u.TABLE,p.HTML],[u.TD,p.HTML],[u.TEMPLATE,p.HTML],[u.TH,p.HTML],[u.ANNOTATION_XML,p.MATHML],[u.MI,p.MATHML],[u.MN,p.MATHML],[u.MO,p.MATHML],[u.MS,p.MATHML],[u.MTEXT,p.MATHML],[u.DESC,p.SVG],[u.FOREIGN_OBJECT,p.SVG],[u.TITLE,p.SVG]]),X=[u.H1,u.H2,u.H3,u.H4,u.H5,u.H6],K=[u.TR,u.TEMPLATE,u.HTML],V=[u.TBODY,u.TFOOT,u.THEAD,u.TEMPLATE,u.HTML],z=[u.TABLE,u.TEMPLATE,u.HTML],j=[u.TD,u.TH];class J{get currentTmplContentOrNode(){return this._isInTemplate()?this.treeAdapter.getTemplateContent(this.current):this.current}constructor(e,t,s){this.treeAdapter=t,this.handler=s,this.items=[],this.tagIDs=[],this.stackTop=-1,this.tmplCount=0,this.currentTagId=u.UNKNOWN,this.current=e;}_indexOf(e){return this.items.lastIndexOf(e,this.stackTop)}_isInTemplate(){return this.currentTagId===u.TEMPLATE&&this.treeAdapter.getNamespaceURI(this.current)===p.HTML}_updateCurrentElement(){this.current=this.items[this.stackTop],this.currentTagId=this.tagIDs[this.stackTop];}push(e,t){this.stackTop++,this.items[this.stackTop]=e,this.current=e,this.tagIDs[this.stackTop]=t,this.currentTagId=t,this._isInTemplate()&&this.tmplCount++,this.handler.onItemPush(e,t,!0);}pop(){const e=this.current;this.tmplCount>0&&this._isInTemplate()&&this.tmplCount--,this.stackTop--,this._updateCurrentElement(),this.handler.onItemPop(e,!0);}replace(e,t){const s=this._indexOf(e);this.items[s]=t,s===this.stackTop&&(this.current=t);}insertAfter(e,t,s){const a=this._indexOf(e)+1;this.items.splice(a,0,t),this.tagIDs.splice(a,0,s),this.stackTop++,a===this.stackTop&&this._updateCurrentElement(),this.handler.onItemPush(this.current,this.currentTagId,a===this.stackTop);}popUntilTagNamePopped(e){let t=this.stackTop+1;do{t=this.tagIDs.lastIndexOf(e,t-1);}while(t>0&&this.treeAdapter.getNamespaceURI(this.items[t])!==p.HTML);this.shortenToLength(t<0?0:t);}shortenToLength(e){for(;this.stackTop>=e;){const t=this.current;this.tmplCount>0&&this._isInTemplate()&&(this.tmplCount-=1),this.stackTop--,this._updateCurrentElement(),this.handler.onItemPop(t,this.stackTop<e);}}popUntilElementPopped(e){const t=this._indexOf(e);this.shortenToLength(t<0?0:t);}popUntilPopped(e,t){const s=this._indexOfTagNames(e,t);this.shortenToLength(s<0?0:s);}popUntilNumberedHeaderPopped(){this.popUntilPopped(X,p.HTML);}popUntilTableCellPopped(){this.popUntilPopped(j,p.HTML);}popAllUpToHtmlElement(){this.tmplCount=0,this.shortenToLength(1);}_indexOfTagNames(e,t){for(let s=this.stackTop;s>=0;s--)if(e.includes(this.tagIDs[s])&&this.treeAdapter.getNamespaceURI(this.items[s])===t)return s;return -1}clearBackTo(e,t){const s=this._indexOfTagNames(e,t);this.shortenToLength(s+1);}clearBackToTableContext(){this.clearBackTo(z,p.HTML);}clearBackToTableBodyContext(){this.clearBackTo(V,p.HTML);}clearBackToTableRowContext(){this.clearBackTo(K,p.HTML);}remove(e){const t=this._indexOf(e);t>=0&&(t===this.stackTop?this.pop():(this.items.splice(t,1),this.tagIDs.splice(t,1),this.stackTop--,this._updateCurrentElement(),this.handler.onItemPop(e,!1)));}tryPeekProperlyNestedBodyElement(){return this.stackTop>=1&&this.tagIDs[1]===u.BODY?this.items[1]:null}contains(e){return this._indexOf(e)>-1}getCommonAncestor(e){const t=this._indexOf(e)-1;return t>=0?this.items[t]:null}isRootHtmlElementCurrent(){return 0===this.stackTop&&this.tagIDs[0]===u.HTML}hasInScope(e){for(let t=this.stackTop;t>=0;t--){const s=this.tagIDs[t],a=this.treeAdapter.getNamespaceURI(this.items[t]);if(s===e&&a===p.HTML)return !0;if(W.get(s)===a)return !1}return !0}hasNumberedHeaderInScope(){for(let e=this.stackTop;e>=0;e--){const t=this.tagIDs[e],s=this.treeAdapter.getNamespaceURI(this.items[e]);if(M(t)&&s===p.HTML)return !0;if(W.get(t)===s)return !1}return !0}hasInListItemScope(e){for(let t=this.stackTop;t>=0;t--){const s=this.tagIDs[t],a=this.treeAdapter.getNamespaceURI(this.items[t]);if(s===e&&a===p.HTML)return !0;if((s===u.UL||s===u.OL)&&a===p.HTML||W.get(s)===a)return !1}return !0}hasInButtonScope(e){for(let t=this.stackTop;t>=0;t--){const s=this.tagIDs[t],a=this.treeAdapter.getNamespaceURI(this.items[t]);if(s===e&&a===p.HTML)return !0;if(s===u.BUTTON&&a===p.HTML||W.get(s)===a)return !1}return !0}hasInTableScope(e){for(let t=this.stackTop;t>=0;t--){const s=this.tagIDs[t];if(this.treeAdapter.getNamespaceURI(this.items[t])===p.HTML){if(s===e)return !0;if(s===u.TABLE||s===u.TEMPLATE||s===u.HTML)return !1}}return !0}hasTableBodyContextInTableScope(){for(let e=this.stackTop;e>=0;e--){const t=this.tagIDs[e];if(this.treeAdapter.getNamespaceURI(this.items[e])===p.HTML){if(t===u.TBODY||t===u.THEAD||t===u.TFOOT)return !0;if(t===u.TABLE||t===u.HTML)return !1}}return !0}hasInSelectScope(e){for(let t=this.stackTop;t>=0;t--){const s=this.tagIDs[t];if(this.treeAdapter.getNamespaceURI(this.items[t])===p.HTML){if(s===e)return !0;if(s!==u.OPTION&&s!==u.OPTGROUP)return !1}}return !0}generateImpliedEndTags(){for(;Q.has(this.currentTagId);)this.pop();}generateImpliedEndTagsThoroughly(){for(;q.has(this.currentTagId);)this.pop();}generateImpliedEndTagsWithExclusion(e){for(;this.currentTagId!==e&&q.has(this.currentTagId);)this.pop();}}var Z;!function(e){e[e.Marker=0]="Marker",e[e.Element=1]="Element";}(Z=Z||(Z={}));const $={type:Z.Marker};class ee{constructor(e){this.treeAdapter=e,this.entries=[],this.bookmark=null;}_getNoahArkConditionCandidates(e,t){const s=[],a=t.length,r=this.treeAdapter.getTagName(e),n=this.treeAdapter.getNamespaceURI(e);for(let e=0;e<this.entries.length;e++){const t=this.entries[e];if(t.type===Z.Marker)break;const{element:i}=t;if(this.treeAdapter.getTagName(i)===r&&this.treeAdapter.getNamespaceURI(i)===n){const t=this.treeAdapter.getAttrList(i);t.length===a&&s.push({idx:e,attrs:t});}}return s}_ensureNoahArkCondition(e){if(this.entries.length<3)return;const t=this.treeAdapter.getAttrList(e),s=this._getNoahArkConditionCandidates(e,t);if(s.length<3)return;const a=new Map(t.map((e=>[e.name,e.value])));let r=0;for(let e=0;e<s.length;e++){const t=s[e];t.attrs.every((e=>a.get(e.name)===e.value))&&(r+=1,r>=3&&this.entries.splice(t.idx,1));}}insertMarker(){this.entries.unshift($);}pushElement(e,t){this._ensureNoahArkCondition(e),this.entries.unshift({type:Z.Element,element:e,token:t});}insertElementAfterBookmark(e,t){const s=this.entries.indexOf(this.bookmark);this.entries.splice(s,0,{type:Z.Element,element:e,token:t});}removeEntry(e){const t=this.entries.indexOf(e);t>=0&&this.entries.splice(t,1);}clearToLastMarker(){const e=this.entries.indexOf($);e>=0?this.entries.splice(0,e+1):this.entries.length=0;}getElementEntryInScopeWithTagName(e){const t=this.entries.find((t=>t.type===Z.Marker||this.treeAdapter.getTagName(t.element)===e));return t&&t.type===Z.Element?t:null}getElementEntry(e){return this.entries.find((t=>t.type===Z.Element&&t.element===e))}}function te(e){return {nodeName:"#text",value:e,parentNode:null}}const se={createDocument:()=>({nodeName:"#document",mode:I.NO_QUIRKS,childNodes:[]}),createDocumentFragment:()=>({nodeName:"#document-fragment",childNodes:[]}),createElement:(e,t,s)=>({nodeName:e,tagName:e,attrs:s,namespaceURI:t,childNodes:[],parentNode:null}),createCommentNode:e=>({nodeName:"#comment",data:e,parentNode:null}),appendChild(e,t){e.childNodes.push(t),t.parentNode=e;},insertBefore(e,t,s){const a=e.childNodes.indexOf(s);e.childNodes.splice(a,0,t),t.parentNode=e;},setTemplateContent(e,t){e.content=t;},getTemplateContent:e=>e.content,setDocumentType(e,t,s,a){const r=e.childNodes.find((e=>"#documentType"===e.nodeName));if(r)r.name=t,r.publicId=s,r.systemId=a;else {const r={nodeName:"#documentType",name:t,publicId:s,systemId:a,parentNode:null};se.appendChild(e,r);}},setDocumentMode(e,t){e.mode=t;},getDocumentMode:e=>e.mode,detachNode(e){if(e.parentNode){const t=e.parentNode.childNodes.indexOf(e);e.parentNode.childNodes.splice(t,1),e.parentNode=null;}},insertText(e,t){if(e.childNodes.length>0){const s=e.childNodes[e.childNodes.length-1];if(se.isTextNode(s))return void(s.value+=t)}se.appendChild(e,te(t));},insertTextBefore(e,t,s){const a=e.childNodes[e.childNodes.indexOf(s)-1];a&&se.isTextNode(a)?a.value+=t:se.insertBefore(e,te(t),s);},adoptAttributes(e,t){const s=new Set(e.attrs.map((e=>e.name)));for(let a=0;a<t.length;a++)s.has(t[a].name)||e.attrs.push(t[a]);},getFirstChild:e=>e.childNodes[0],getChildNodes:e=>e.childNodes,getParentNode:e=>e.parentNode,getAttrList:e=>e.attrs,getTagName:e=>e.tagName,getNamespaceURI:e=>e.namespaceURI,getTextNodeContent:e=>e.value,getCommentNodeContent:e=>e.data,getDocumentTypeNodeName:e=>e.name,getDocumentTypeNodePublicId:e=>e.publicId,getDocumentTypeNodeSystemId:e=>e.systemId,isTextNode:e=>"#text"===e.nodeName,isCommentNode:e=>"#comment"===e.nodeName,isDocumentTypeNode:e=>"#documentType"===e.nodeName,isElementNode:e=>Object.prototype.hasOwnProperty.call(e,"tagName"),setNodeSourceCodeLocation(e,t){e.sourceCodeLocation=t;},getNodeSourceCodeLocation:e=>e.sourceCodeLocation,updateNodeSourceCodeLocation(e,t){e.sourceCodeLocation={...e.sourceCodeLocation,...t};}},ae="html",re=["+//silmaril//dtd html pro v0r11 19970101//","-//as//dtd html 3.0 aswedit + extensions//","-//advasoft ltd//dtd html 3.0 aswedit + extensions//","-//ietf//dtd html 2.0 level 1//","-//ietf//dtd html 2.0 level 2//","-//ietf//dtd html 2.0 strict level 1//","-//ietf//dtd html 2.0 strict level 2//","-//ietf//dtd html 2.0 strict//","-//ietf//dtd html 2.0//","-//ietf//dtd html 2.1e//","-//ietf//dtd html 3.0//","-//ietf//dtd html 3.2 final//","-//ietf//dtd html 3.2//","-//ietf//dtd html 3//","-//ietf//dtd html level 0//","-//ietf//dtd html level 1//","-//ietf//dtd html level 2//","-//ietf//dtd html level 3//","-//ietf//dtd html strict level 0//","-//ietf//dtd html strict level 1//","-//ietf//dtd html strict level 2//","-//ietf//dtd html strict level 3//","-//ietf//dtd html strict//","-//ietf//dtd html//","-//metrius//dtd metrius presentational//","-//microsoft//dtd internet explorer 2.0 html strict//","-//microsoft//dtd internet explorer 2.0 html//","-//microsoft//dtd internet explorer 2.0 tables//","-//microsoft//dtd internet explorer 3.0 html strict//","-//microsoft//dtd internet explorer 3.0 html//","-//microsoft//dtd internet explorer 3.0 tables//","-//netscape comm. corp.//dtd html//","-//netscape comm. corp.//dtd strict html//","-//o'reilly and associates//dtd html 2.0//","-//o'reilly and associates//dtd html extended 1.0//","-//o'reilly and associates//dtd html extended relaxed 1.0//","-//sq//dtd html 2.0 hotmetal + extensions//","-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//","-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//","-//spyglass//dtd html 2.0 extended//","-//sun microsystems corp.//dtd hotjava html//","-//sun microsystems corp.//dtd hotjava strict html//","-//w3c//dtd html 3 1995-03-24//","-//w3c//dtd html 3.2 draft//","-//w3c//dtd html 3.2 final//","-//w3c//dtd html 3.2//","-//w3c//dtd html 3.2s draft//","-//w3c//dtd html 4.0 frameset//","-//w3c//dtd html 4.0 transitional//","-//w3c//dtd html experimental 19960712//","-//w3c//dtd html experimental 970421//","-//w3c//dtd w3 html//","-//w3o//dtd w3 html 3.0//","-//webtechs//dtd mozilla html 2.0//","-//webtechs//dtd mozilla html//"],ne=[...re,"-//w3c//dtd html 4.01 frameset//","-//w3c//dtd html 4.01 transitional//"],ie=new Set(["-//w3o//dtd w3 html strict 3.0//en//","-/w3c/dtd html 4.0 transitional/en","html"]),oe=["-//w3c//dtd xhtml 1.0 frameset//","-//w3c//dtd xhtml 1.0 transitional//"],ce=[...oe,"-//w3c//dtd html 4.01 frameset//","-//w3c//dtd html 4.01 transitional//"];function Ee(e,t){return t.some((t=>e.startsWith(t)))}const Te={TEXT_HTML:"text/html",APPLICATION_XML:"application/xhtml+xml"},he="definitionurl",_e="definitionURL",Ae=new Map(["attributeName","attributeType","baseFrequency","baseProfile","calcMode","clipPathUnits","diffuseConstant","edgeMode","filterUnits","glyphRef","gradientTransform","gradientUnits","kernelMatrix","kernelUnitLength","keyPoints","keySplines","keyTimes","lengthAdjust","limitingConeAngle","markerHeight","markerUnits","markerWidth","maskContentUnits","maskUnits","numOctaves","pathLength","patternContentUnits","patternTransform","patternUnits","pointsAtX","pointsAtY","pointsAtZ","preserveAlpha","preserveAspectRatio","primitiveUnits","refX","refY","repeatCount","repeatDur","requiredExtensions","requiredFeatures","specularConstant","specularExponent","spreadMethod","startOffset","stdDeviation","stitchTiles","surfaceScale","systemLanguage","tableValues","targetX","targetY","textLength","viewBox","viewTarget","xChannelSelector","yChannelSelector","zoomAndPan"].map((e=>[e.toLowerCase(),e]))),le=new Map([["xlink:actuate",{prefix:"xlink",name:"actuate",namespace:p.XLINK}],["xlink:arcrole",{prefix:"xlink",name:"arcrole",namespace:p.XLINK}],["xlink:href",{prefix:"xlink",name:"href",namespace:p.XLINK}],["xlink:role",{prefix:"xlink",name:"role",namespace:p.XLINK}],["xlink:show",{prefix:"xlink",name:"show",namespace:p.XLINK}],["xlink:title",{prefix:"xlink",name:"title",namespace:p.XLINK}],["xlink:type",{prefix:"xlink",name:"type",namespace:p.XLINK}],["xml:base",{prefix:"xml",name:"base",namespace:p.XML}],["xml:lang",{prefix:"xml",name:"lang",namespace:p.XML}],["xml:space",{prefix:"xml",name:"space",namespace:p.XML}],["xmlns",{prefix:"",name:"xmlns",namespace:p.XMLNS}],["xmlns:xlink",{prefix:"xmlns",name:"xlink",namespace:p.XMLNS}]]),me=new Map(["altGlyph","altGlyphDef","altGlyphItem","animateColor","animateMotion","animateTransform","clipPath","feBlend","feColorMatrix","feComponentTransfer","feComposite","feConvolveMatrix","feDiffuseLighting","feDisplacementMap","feDistantLight","feFlood","feFuncA","feFuncB","feFuncG","feFuncR","feGaussianBlur","feImage","feMerge","feMergeNode","feMorphology","feOffset","fePointLight","feSpecularLighting","feSpotLight","feTile","feTurbulence","foreignObject","glyphRef","linearGradient","radialGradient","textPath"].map((e=>[e.toLowerCase(),e]))),pe=new Set([u.B,u.BIG,u.BLOCKQUOTE,u.BODY,u.BR,u.CENTER,u.CODE,u.DD,u.DIV,u.DL,u.DT,u.EM,u.EMBED,u.H1,u.H2,u.H3,u.H4,u.H5,u.H6,u.HEAD,u.HR,u.I,u.IMG,u.LI,u.LISTING,u.MENU,u.META,u.NOBR,u.OL,u.P,u.PRE,u.RUBY,u.S,u.SMALL,u.SPAN,u.STRONG,u.STRIKE,u.SUB,u.SUP,u.TABLE,u.TT,u.U,u.UL,u.VAR]);function de(e){for(let t=0;t<e.attrs.length;t++)if(e.attrs[t].name===he){e.attrs[t].name=_e;break}}function Ie(e){for(let t=0;t<e.attrs.length;t++){const s=Ae.get(e.attrs[t].name);null!=s&&(e.attrs[t].name=s);}}function Ne(e){for(let t=0;t<e.attrs.length;t++){const s=le.get(e.attrs[t].name);s&&(e.attrs[t].prefix=s.prefix,e.attrs[t].name=s.name,e.attrs[t].namespace=s.namespace);}}const ue="hidden",Ce=8,De=3;var Se;!function(e){e[e.INITIAL=0]="INITIAL",e[e.BEFORE_HTML=1]="BEFORE_HTML",e[e.BEFORE_HEAD=2]="BEFORE_HEAD",e[e.IN_HEAD=3]="IN_HEAD",e[e.IN_HEAD_NO_SCRIPT=4]="IN_HEAD_NO_SCRIPT",e[e.AFTER_HEAD=5]="AFTER_HEAD",e[e.IN_BODY=6]="IN_BODY",e[e.TEXT=7]="TEXT",e[e.IN_TABLE=8]="IN_TABLE",e[e.IN_TABLE_TEXT=9]="IN_TABLE_TEXT",e[e.IN_CAPTION=10]="IN_CAPTION",e[e.IN_COLUMN_GROUP=11]="IN_COLUMN_GROUP",e[e.IN_TABLE_BODY=12]="IN_TABLE_BODY",e[e.IN_ROW=13]="IN_ROW",e[e.IN_CELL=14]="IN_CELL",e[e.IN_SELECT=15]="IN_SELECT",e[e.IN_SELECT_IN_TABLE=16]="IN_SELECT_IN_TABLE",e[e.IN_TEMPLATE=17]="IN_TEMPLATE",e[e.AFTER_BODY=18]="AFTER_BODY",e[e.IN_FRAMESET=19]="IN_FRAMESET",e[e.AFTER_FRAMESET=20]="AFTER_FRAMESET",e[e.AFTER_AFTER_BODY=21]="AFTER_AFTER_BODY",e[e.AFTER_AFTER_FRAMESET=22]="AFTER_AFTER_FRAMESET";}(Se||(Se={}));const Re={startLine:-1,startCol:-1,startOffset:-1,endLine:-1,endCol:-1,endOffset:-1},Oe=new Set([u.TABLE,u.TBODY,u.TFOOT,u.THEAD,u.TR]),fe={scriptingEnabled:!0,sourceCodeLocationInfo:!1,treeAdapter:se,onParseError:null};class Le{constructor(e,t,s=null,a=null){this.fragmentContext=s,this.scriptHandler=a,this.currentToken=null,this.stopped=!1,this.insertionMode=Se.INITIAL,this.originalInsertionMode=Se.INITIAL,this.headElement=null,this.formElement=null,this.currentNotInHTML=!1,this.tmplInsertionModeStack=[],this.pendingCharacterTokens=[],this.hasNonWhitespacePendingCharacterToken=!1,this.framesetOk=!0,this.skipNextNewLine=!1,this.fosterParentingEnabled=!1,this.options={...fe,...e},this.treeAdapter=this.options.treeAdapter,this.onParseError=this.options.onParseError,this.onParseError&&(this.options.sourceCodeLocationInfo=!0),this.document=null!=t?t:this.treeAdapter.createDocument(),this.tokenizer=new v(this.options,this),this.activeFormattingElements=new ee(this.treeAdapter),this.fragmentContextID=s?f(this.treeAdapter.getTagName(s)):u.UNKNOWN,this._setContextModes(null!=s?s:this.document,this.fragmentContextID),this.openElements=new J(this.document,this.treeAdapter,this);}static parse(e,t){const s=new this(t);return s.tokenizer.write(e,!0),s.document}static getFragmentParser(e,t){const s={...fe,...t};null!=e||(e=s.treeAdapter.createElement(N.TEMPLATE,p.HTML,[]));const a=s.treeAdapter.createElement("documentmock",p.HTML,[]),r=new this(s,a,e);return r.fragmentContextID===u.TEMPLATE&&r.tmplInsertionModeStack.unshift(Se.IN_TEMPLATE),r._initTokenizerForFragmentParsing(),r._insertFakeRootElement(),r._resetInsertionMode(),r._findFormInFragmentContext(),r}getFragment(){const e=this.treeAdapter.getFirstChild(this.document),t=this.treeAdapter.createDocumentFragment();return this._adoptNodes(e,t),t}_err(e,t,s){var a;if(!this.onParseError)return;const r=null!==(a=e.location)&&void 0!==a?a:Re,n={code:t,startLine:r.startLine,startCol:r.startCol,startOffset:r.startOffset,endLine:s?r.startLine:r.endLine,endCol:s?r.startCol:r.endCol,endOffset:s?r.startOffset:r.endOffset};this.onParseError(n);}onItemPush(e,t,s){var a,r;null===(r=(a=this.treeAdapter).onItemPush)||void 0===r||r.call(a,e),s&&this.openElements.stackTop>0&&this._setContextModes(e,t);}onItemPop(e,t){var s,a;if(this.options.sourceCodeLocationInfo&&this._setEndLocation(e,this.currentToken),null===(a=(s=this.treeAdapter).onItemPop)||void 0===a||a.call(s,e,this.openElements.current),t){let e,t;0===this.openElements.stackTop&&this.fragmentContext?(e=this.fragmentContext,t=this.fragmentContextID):({current:e,currentTagId:t}=this.openElements),this._setContextModes(e,t);}}_setContextModes(e,t){const s=e===this.document||this.treeAdapter.getNamespaceURI(e)===p.HTML;this.currentNotInHTML=!s,this.tokenizer.inForeignNode=!s&&!this._isIntegrationPoint(t,e);}_switchToTextParsing(e,t){this._insertElement(e,p.HTML),this.tokenizer.state=t,this.originalInsertionMode=this.insertionMode,this.insertionMode=Se.TEXT;}switchToPlaintextParsing(){this.insertionMode=Se.TEXT,this.originalInsertionMode=Se.IN_BODY,this.tokenizer.state=b.PLAINTEXT;}_getAdjustedCurrentElement(){return 0===this.openElements.stackTop&&this.fragmentContext?this.fragmentContext:this.openElements.current}_findFormInFragmentContext(){let e=this.fragmentContext;for(;e;){if(this.treeAdapter.getTagName(e)===N.FORM){this.formElement=e;break}e=this.treeAdapter.getParentNode(e);}}_initTokenizerForFragmentParsing(){if(this.fragmentContext&&this.treeAdapter.getNamespaceURI(this.fragmentContext)===p.HTML)switch(this.fragmentContextID){case u.TITLE:case u.TEXTAREA:this.tokenizer.state=b.RCDATA;break;case u.STYLE:case u.XMP:case u.IFRAME:case u.NOEMBED:case u.NOFRAMES:case u.NOSCRIPT:this.tokenizer.state=b.RAWTEXT;break;case u.SCRIPT:this.tokenizer.state=b.SCRIPT_DATA;break;case u.PLAINTEXT:this.tokenizer.state=b.PLAINTEXT;}}_setDocumentType(e){const t=e.name||"",s=e.publicId||"",a=e.systemId||"";if(this.treeAdapter.setDocumentType(this.document,t,s,a),e.location){const t=this.treeAdapter.getChildNodes(this.document).find((e=>this.treeAdapter.isDocumentTypeNode(e)));t&&this.treeAdapter.setNodeSourceCodeLocation(t,e.location);}}_attachElementToTree(e,t){if(this.options.sourceCodeLocationInfo){const s=t&&{...t,startTag:t};this.treeAdapter.setNodeSourceCodeLocation(e,s);}if(this._shouldFosterParentOnInsertion())this._fosterParentElement(e);else {const t=this.openElements.currentTmplContentOrNode;this.treeAdapter.appendChild(t,e);}}_appendElement(e,t){const s=this.treeAdapter.createElement(e.tagName,t,e.attrs);this._attachElementToTree(s,e.location);}_insertElement(e,t){const s=this.treeAdapter.createElement(e.tagName,t,e.attrs);this._attachElementToTree(s,e.location),this.openElements.push(s,e.tagID);}_insertFakeElement(e,t){const s=this.treeAdapter.createElement(e,p.HTML,[]);this._attachElementToTree(s,null),this.openElements.push(s,t);}_insertTemplate(e){const t=this.treeAdapter.createElement(e.tagName,p.HTML,e.attrs),s=this.treeAdapter.createDocumentFragment();this.treeAdapter.setTemplateContent(t,s),this._attachElementToTree(t,e.location),this.openElements.push(t,e.tagID),this.options.sourceCodeLocationInfo&&this.treeAdapter.setNodeSourceCodeLocation(s,null);}_insertFakeRootElement(){const e=this.treeAdapter.createElement(N.HTML,p.HTML,[]);this.options.sourceCodeLocationInfo&&this.treeAdapter.setNodeSourceCodeLocation(e,null),this.treeAdapter.appendChild(this.openElements.current,e),this.openElements.push(e,u.HTML);}_appendCommentNode(e,t){const s=this.treeAdapter.createCommentNode(e.data);this.treeAdapter.appendChild(t,s),this.options.sourceCodeLocationInfo&&this.treeAdapter.setNodeSourceCodeLocation(s,e.location);}_insertCharacters(e){let t,s;if(this._shouldFosterParentOnInsertion()?(({parent:t,beforeElement:s}=this._findFosterParentingLocation()),s?this.treeAdapter.insertTextBefore(t,e.chars,s):this.treeAdapter.insertText(t,e.chars)):(t=this.openElements.currentTmplContentOrNode,this.treeAdapter.insertText(t,e.chars)),!e.location)return;const a=this.treeAdapter.getChildNodes(t),r=s?a.lastIndexOf(s):a.length,n=a[r-1];if(this.treeAdapter.getNodeSourceCodeLocation(n)){const{endLine:t,endCol:s,endOffset:a}=e.location;this.treeAdapter.updateNodeSourceCodeLocation(n,{endLine:t,endCol:s,endOffset:a});}else this.options.sourceCodeLocationInfo&&this.treeAdapter.setNodeSourceCodeLocation(n,e.location);}_adoptNodes(e,t){for(let s=this.treeAdapter.getFirstChild(e);s;s=this.treeAdapter.getFirstChild(e))this.treeAdapter.detachNode(s),this.treeAdapter.appendChild(t,s);}_setEndLocation(e,t){if(this.treeAdapter.getNodeSourceCodeLocation(e)&&t.location){const s=t.location,a=this.treeAdapter.getTagName(e),r=t.type===h.END_TAG&&a===t.tagName?{endTag:{...s},endLine:s.endLine,endCol:s.endCol,endOffset:s.endOffset}:{endLine:s.startLine,endCol:s.startCol,endOffset:s.startOffset};this.treeAdapter.updateNodeSourceCodeLocation(e,r);}}shouldProcessStartTagTokenInForeignContent(e){if(!this.currentNotInHTML)return !1;let t,s;return 0===this.openElements.stackTop&&this.fragmentContext?(t=this.fragmentContext,s=this.fragmentContextID):({current:t,currentTagId:s}=this.openElements),(e.tagID!==u.SVG||this.treeAdapter.getTagName(t)!==N.ANNOTATION_XML||this.treeAdapter.getNamespaceURI(t)!==p.MATHML)&&(this.tokenizer.inForeignNode||(e.tagID===u.MGLYPH||e.tagID===u.MALIGNMARK)&&!this._isIntegrationPoint(s,t,p.HTML))}_processToken(e){switch(e.type){case h.CHARACTER:this.onCharacter(e);break;case h.NULL_CHARACTER:this.onNullCharacter(e);break;case h.COMMENT:this.onComment(e);break;case h.DOCTYPE:this.onDoctype(e);break;case h.START_TAG:this._processStartTag(e);break;case h.END_TAG:this.onEndTag(e);break;case h.EOF:this.onEof(e);break;case h.WHITESPACE_CHARACTER:this.onWhitespaceCharacter(e);}}_isIntegrationPoint(e,t,s){return function(e,t,s,a){return (!a||a===p.HTML)&&function(e,t,s){if(t===p.MATHML&&e===u.ANNOTATION_XML)for(let e=0;e<s.length;e++)if(s[e].name===d.ENCODING){const t=s[e].value.toLowerCase();return t===Te.TEXT_HTML||t===Te.APPLICATION_XML}return t===p.SVG&&(e===u.FOREIGN_OBJECT||e===u.DESC||e===u.TITLE)}(e,t,s)||(!a||a===p.MATHML)&&function(e,t){return t===p.MATHML&&(e===u.MI||e===u.MO||e===u.MN||e===u.MS||e===u.MTEXT)}(e,t)}(e,this.treeAdapter.getNamespaceURI(t),this.treeAdapter.getAttrList(t),s)}_reconstructActiveFormattingElements(){const e=this.activeFormattingElements.entries.length;if(e){const t=this.activeFormattingElements.entries.findIndex((e=>e.type===Z.Marker||this.openElements.contains(e.element)));for(let s=t<0?e-1:t-1;s>=0;s--){const e=this.activeFormattingElements.entries[s];this._insertElement(e.token,this.treeAdapter.getNamespaceURI(e.element)),e.element=this.openElements.current;}}}_closeTableCell(){this.openElements.generateImpliedEndTags(),this.openElements.popUntilTableCellPopped(),this.activeFormattingElements.clearToLastMarker(),this.insertionMode=Se.IN_ROW;}_closePElement(){this.openElements.generateImpliedEndTagsWithExclusion(u.P),this.openElements.popUntilTagNamePopped(u.P);}_resetInsertionMode(){for(let e=this.openElements.stackTop;e>=0;e--)switch(0===e&&this.fragmentContext?this.fragmentContextID:this.openElements.tagIDs[e]){case u.TR:return void(this.insertionMode=Se.IN_ROW);case u.TBODY:case u.THEAD:case u.TFOOT:return void(this.insertionMode=Se.IN_TABLE_BODY);case u.CAPTION:return void(this.insertionMode=Se.IN_CAPTION);case u.COLGROUP:return void(this.insertionMode=Se.IN_COLUMN_GROUP);case u.TABLE:return void(this.insertionMode=Se.IN_TABLE);case u.BODY:return void(this.insertionMode=Se.IN_BODY);case u.FRAMESET:return void(this.insertionMode=Se.IN_FRAMESET);case u.SELECT:return void this._resetInsertionModeForSelect(e);case u.TEMPLATE:return void(this.insertionMode=this.tmplInsertionModeStack[0]);case u.HTML:return void(this.insertionMode=this.headElement?Se.AFTER_HEAD:Se.BEFORE_HEAD);case u.TD:case u.TH:if(e>0)return void(this.insertionMode=Se.IN_CELL);break;case u.HEAD:if(e>0)return void(this.insertionMode=Se.IN_HEAD)}this.insertionMode=Se.IN_BODY;}_resetInsertionModeForSelect(e){if(e>0)for(let t=e-1;t>0;t--){const e=this.openElements.tagIDs[t];if(e===u.TEMPLATE)break;if(e===u.TABLE)return void(this.insertionMode=Se.IN_SELECT_IN_TABLE)}this.insertionMode=Se.IN_SELECT;}_isElementCausesFosterParenting(e){return Oe.has(e)}_shouldFosterParentOnInsertion(){return this.fosterParentingEnabled&&this._isElementCausesFosterParenting(this.openElements.currentTagId)}_findFosterParentingLocation(){for(let e=this.openElements.stackTop;e>=0;e--){const t=this.openElements.items[e];switch(this.openElements.tagIDs[e]){case u.TEMPLATE:if(this.treeAdapter.getNamespaceURI(t)===p.HTML)return {parent:this.treeAdapter.getTemplateContent(t),beforeElement:null};break;case u.TABLE:{const s=this.treeAdapter.getParentNode(t);return s?{parent:s,beforeElement:t}:{parent:this.openElements.items[e-1],beforeElement:null}}}}return {parent:this.openElements.items[0],beforeElement:null}}_fosterParentElement(e){const t=this._findFosterParentingLocation();t.beforeElement?this.treeAdapter.insertBefore(t.parent,e,t.beforeElement):this.treeAdapter.appendChild(t.parent,e);}_isSpecialElement(e,t){const s=this.treeAdapter.getNamespaceURI(e);return g[s].has(t)}onCharacter(e){if(this.skipNextNewLine=!1,this.tokenizer.inForeignNode)!function(e,t){e._insertCharacters(t),e.framesetOk=!1;}(this,e);else switch(this.insertionMode){case Se.INITIAL:Ge(this,e);break;case Se.BEFORE_HTML:ye(this,e);break;case Se.BEFORE_HEAD:we(this,e);break;case Se.IN_HEAD:ve(this,e);break;case Se.IN_HEAD_NO_SCRIPT:Qe(this,e);break;case Se.AFTER_HEAD:qe(this,e);break;case Se.IN_BODY:case Se.IN_CAPTION:case Se.IN_CELL:case Se.IN_TEMPLATE:Ke(this,e);break;case Se.TEXT:case Se.IN_SELECT:case Se.IN_SELECT_IN_TABLE:this._insertCharacters(e);break;case Se.IN_TABLE:case Se.IN_TABLE_BODY:case Se.IN_ROW:st(this,e);break;case Se.IN_TABLE_TEXT:ot(this,e);break;case Se.IN_COLUMN_GROUP:ht(this,e);break;case Se.AFTER_BODY:ut(this,e);break;case Se.AFTER_AFTER_BODY:Ct(this,e);}}onNullCharacter(e){if(this.skipNextNewLine=!1,this.tokenizer.inForeignNode)!function(e,t){t.chars=s,e._insertCharacters(t);}(this,e);else switch(this.insertionMode){case Se.INITIAL:Ge(this,e);break;case Se.BEFORE_HTML:ye(this,e);break;case Se.BEFORE_HEAD:we(this,e);break;case Se.IN_HEAD:ve(this,e);break;case Se.IN_HEAD_NO_SCRIPT:Qe(this,e);break;case Se.AFTER_HEAD:qe(this,e);break;case Se.TEXT:this._insertCharacters(e);break;case Se.IN_TABLE:case Se.IN_TABLE_BODY:case Se.IN_ROW:st(this,e);break;case Se.IN_COLUMN_GROUP:ht(this,e);break;case Se.AFTER_BODY:ut(this,e);break;case Se.AFTER_AFTER_BODY:Ct(this,e);}}onComment(e){if(this.skipNextNewLine=!1,this.currentNotInHTML)Fe(this,e);else switch(this.insertionMode){case Se.INITIAL:case Se.BEFORE_HTML:case Se.BEFORE_HEAD:case Se.IN_HEAD:case Se.IN_HEAD_NO_SCRIPT:case Se.AFTER_HEAD:case Se.IN_BODY:case Se.IN_TABLE:case Se.IN_CAPTION:case Se.IN_COLUMN_GROUP:case Se.IN_TABLE_BODY:case Se.IN_ROW:case Se.IN_CELL:case Se.IN_SELECT:case Se.IN_SELECT_IN_TABLE:case Se.IN_TEMPLATE:case Se.IN_FRAMESET:case Se.AFTER_FRAMESET:Fe(this,e);break;case Se.IN_TABLE_TEXT:ct(this,e);break;case Se.AFTER_BODY:!function(e,t){e._appendCommentNode(t,e.openElements.items[0]);}(this,e);break;case Se.AFTER_AFTER_BODY:case Se.AFTER_AFTER_FRAMESET:!function(e,t){e._appendCommentNode(t,e.document);}(this,e);}}onDoctype(e){switch(this.skipNextNewLine=!1,this.insertionMode){case Se.INITIAL:!function(e,t){e._setDocumentType(t);const s=t.forceQuirks?I.QUIRKS:function(e){if(e.name!==ae)return I.QUIRKS;const{systemId:t}=e;if(t&&"http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd"===t.toLowerCase())return I.QUIRKS;let{publicId:s}=e;if(null!==s){if(s=s.toLowerCase(),ie.has(s))return I.QUIRKS;let e=null===t?ne:re;if(Ee(s,e))return I.QUIRKS;if(e=null===t?oe:ce,Ee(s,e))return I.LIMITED_QUIRKS}return I.NO_QUIRKS}(t);(function(e){return e.name===ae&&null===e.publicId&&(null===e.systemId||"about:legacy-compat"===e.systemId)})(t)||e._err(t,T.nonConformingDoctype),e.treeAdapter.setDocumentMode(e.document,s),e.insertionMode=Se.BEFORE_HTML;}(this,e);break;case Se.BEFORE_HEAD:case Se.IN_HEAD:case Se.IN_HEAD_NO_SCRIPT:case Se.AFTER_HEAD:this._err(e,T.misplacedDoctype);break;case Se.IN_TABLE_TEXT:ct(this,e);}}onStartTag(e){this.skipNextNewLine=!1,this.currentToken=e,this._processStartTag(e),e.selfClosing&&!e.ackSelfClosing&&this._err(e,T.nonVoidHtmlElementStartTagWithTrailingSolidus);}_processStartTag(e){this.shouldProcessStartTagTokenInForeignContent(e)?function(e,t){if(function(e){const t=e.tagID;return t===u.FONT&&e.attrs.some((({name:e})=>e===d.COLOR||e===d.SIZE||e===d.FACE))||pe.has(t)}(t))Dt(e),e._startTagOutsideForeignContent(t);else {const s=e._getAdjustedCurrentElement(),a=e.treeAdapter.getNamespaceURI(s);a===p.MATHML?de(t):a===p.SVG&&(function(e){const t=me.get(e.tagName);null!=t&&(e.tagName=t,e.tagID=f(e.tagName));}(t),Ie(t)),Ne(t),t.selfClosing?e._appendElement(t,a):e._insertElement(t,a),t.ackSelfClosing=!0;}}(this,e):this._startTagOutsideForeignContent(e);}_startTagOutsideForeignContent(e){switch(this.insertionMode){case Se.INITIAL:Ge(this,e);break;case Se.BEFORE_HTML:!function(e,t){t.tagID===u.HTML?(e._insertElement(t,p.HTML),e.insertionMode=Se.BEFORE_HEAD):ye(e,t);}(this,e);break;case Se.BEFORE_HEAD:!function(e,t){switch(t.tagID){case u.HTML:Ze(e,t);break;case u.HEAD:e._insertElement(t,p.HTML),e.headElement=e.openElements.current,e.insertionMode=Se.IN_HEAD;break;default:we(e,t);}}(this,e);break;case Se.IN_HEAD:Ye(this,e);break;case Se.IN_HEAD_NO_SCRIPT:!function(e,t){switch(t.tagID){case u.HTML:Ze(e,t);break;case u.BASEFONT:case u.BGSOUND:case u.HEAD:case u.LINK:case u.META:case u.NOFRAMES:case u.STYLE:Ye(e,t);break;case u.NOSCRIPT:e._err(t,T.nestedNoscriptInHead);break;default:Qe(e,t);}}(this,e);break;case Se.AFTER_HEAD:!function(e,t){switch(t.tagID){case u.HTML:Ze(e,t);break;case u.BODY:e._insertElement(t,p.HTML),e.framesetOk=!1,e.insertionMode=Se.IN_BODY;break;case u.FRAMESET:e._insertElement(t,p.HTML),e.insertionMode=Se.IN_FRAMESET;break;case u.BASE:case u.BASEFONT:case u.BGSOUND:case u.LINK:case u.META:case u.NOFRAMES:case u.SCRIPT:case u.STYLE:case u.TEMPLATE:case u.TITLE:e._err(t,T.abandonedHeadElementChild),e.openElements.push(e.headElement,u.HEAD),Ye(e,t),e.openElements.remove(e.headElement);break;case u.HEAD:e._err(t,T.misplacedStartTagForHeadElement);break;default:qe(e,t);}}(this,e);break;case Se.IN_BODY:Ze(this,e);break;case Se.IN_TABLE:at(this,e);break;case Se.IN_TABLE_TEXT:ct(this,e);break;case Se.IN_CAPTION:!function(e,t){const s=t.tagID;Et.has(s)?e.openElements.hasInTableScope(u.CAPTION)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(u.CAPTION),e.activeFormattingElements.clearToLastMarker(),e.insertionMode=Se.IN_TABLE,at(e,t)):Ze(e,t);}(this,e);break;case Se.IN_COLUMN_GROUP:Tt(this,e);break;case Se.IN_TABLE_BODY:_t(this,e);break;case Se.IN_ROW:lt(this,e);break;case Se.IN_CELL:!function(e,t){const s=t.tagID;Et.has(s)?(e.openElements.hasInTableScope(u.TD)||e.openElements.hasInTableScope(u.TH))&&(e._closeTableCell(),lt(e,t)):Ze(e,t);}(this,e);break;case Se.IN_SELECT:pt(this,e);break;case Se.IN_SELECT_IN_TABLE:!function(e,t){const s=t.tagID;s===u.CAPTION||s===u.TABLE||s===u.TBODY||s===u.TFOOT||s===u.THEAD||s===u.TR||s===u.TD||s===u.TH?(e.openElements.popUntilTagNamePopped(u.SELECT),e._resetInsertionMode(),e._processStartTag(t)):pt(e,t);}(this,e);break;case Se.IN_TEMPLATE:!function(e,t){switch(t.tagID){case u.BASE:case u.BASEFONT:case u.BGSOUND:case u.LINK:case u.META:case u.NOFRAMES:case u.SCRIPT:case u.STYLE:case u.TEMPLATE:case u.TITLE:Ye(e,t);break;case u.CAPTION:case u.COLGROUP:case u.TBODY:case u.TFOOT:case u.THEAD:e.tmplInsertionModeStack[0]=Se.IN_TABLE,e.insertionMode=Se.IN_TABLE,at(e,t);break;case u.COL:e.tmplInsertionModeStack[0]=Se.IN_COLUMN_GROUP,e.insertionMode=Se.IN_COLUMN_GROUP,Tt(e,t);break;case u.TR:e.tmplInsertionModeStack[0]=Se.IN_TABLE_BODY,e.insertionMode=Se.IN_TABLE_BODY,_t(e,t);break;case u.TD:case u.TH:e.tmplInsertionModeStack[0]=Se.IN_ROW,e.insertionMode=Se.IN_ROW,lt(e,t);break;default:e.tmplInsertionModeStack[0]=Se.IN_BODY,e.insertionMode=Se.IN_BODY,Ze(e,t);}}(this,e);break;case Se.AFTER_BODY:!function(e,t){t.tagID===u.HTML?Ze(e,t):ut(e,t);}(this,e);break;case Se.IN_FRAMESET:!function(e,t){switch(t.tagID){case u.HTML:Ze(e,t);break;case u.FRAMESET:e._insertElement(t,p.HTML);break;case u.FRAME:e._appendElement(t,p.HTML),t.ackSelfClosing=!0;break;case u.NOFRAMES:Ye(e,t);}}(this,e);break;case Se.AFTER_FRAMESET:!function(e,t){switch(t.tagID){case u.HTML:Ze(e,t);break;case u.NOFRAMES:Ye(e,t);}}(this,e);break;case Se.AFTER_AFTER_BODY:!function(e,t){t.tagID===u.HTML?Ze(e,t):Ct(e,t);}(this,e);break;case Se.AFTER_AFTER_FRAMESET:!function(e,t){switch(t.tagID){case u.HTML:Ze(e,t);break;case u.NOFRAMES:Ye(e,t);}}(this,e);}}onEndTag(e){this.skipNextNewLine=!1,this.currentToken=e,this.currentNotInHTML?function(e,t){if(t.tagID===u.P||t.tagID===u.BR)return Dt(e),void e._endTagOutsideForeignContent(t);for(let s=e.openElements.stackTop;s>0;s--){const a=e.openElements.items[s];if(e.treeAdapter.getNamespaceURI(a)===p.HTML){e._endTagOutsideForeignContent(t);break}const r=e.treeAdapter.getTagName(a);if(r.toLowerCase()===t.tagName){t.tagName=r,e.openElements.shortenToLength(s);break}}}(this,e):this._endTagOutsideForeignContent(e);}_endTagOutsideForeignContent(e){switch(this.insertionMode){case Se.INITIAL:Ge(this,e);break;case Se.BEFORE_HTML:!function(e,t){const s=t.tagID;s!==u.HTML&&s!==u.HEAD&&s!==u.BODY&&s!==u.BR||ye(e,t);}(this,e);break;case Se.BEFORE_HEAD:!function(e,t){const s=t.tagID;s===u.HEAD||s===u.BODY||s===u.HTML||s===u.BR?we(e,t):e._err(t,T.endTagWithoutMatchingOpenElement);}(this,e);break;case Se.IN_HEAD:!function(e,t){switch(t.tagID){case u.HEAD:e.openElements.pop(),e.insertionMode=Se.AFTER_HEAD;break;case u.BODY:case u.BR:case u.HTML:ve(e,t);break;case u.TEMPLATE:xe(e,t);break;default:e._err(t,T.endTagWithoutMatchingOpenElement);}}(this,e);break;case Se.IN_HEAD_NO_SCRIPT:!function(e,t){switch(t.tagID){case u.NOSCRIPT:e.openElements.pop(),e.insertionMode=Se.IN_HEAD;break;case u.BR:Qe(e,t);break;default:e._err(t,T.endTagWithoutMatchingOpenElement);}}(this,e);break;case Se.AFTER_HEAD:!function(e,t){switch(t.tagID){case u.BODY:case u.HTML:case u.BR:qe(e,t);break;case u.TEMPLATE:xe(e,t);break;default:e._err(t,T.endTagWithoutMatchingOpenElement);}}(this,e);break;case Se.IN_BODY:et(this,e);break;case Se.TEXT:!function(e,t){var s;t.tagID===u.SCRIPT&&(null===(s=e.scriptHandler)||void 0===s||s.call(e,e.openElements.current)),e.openElements.pop(),e.insertionMode=e.originalInsertionMode;}(this,e);break;case Se.IN_TABLE:rt(this,e);break;case Se.IN_TABLE_TEXT:ct(this,e);break;case Se.IN_CAPTION:!function(e,t){const s=t.tagID;switch(s){case u.CAPTION:case u.TABLE:e.openElements.hasInTableScope(u.CAPTION)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(u.CAPTION),e.activeFormattingElements.clearToLastMarker(),e.insertionMode=Se.IN_TABLE,s===u.TABLE&&rt(e,t));break;case u.BODY:case u.COL:case u.COLGROUP:case u.HTML:case u.TBODY:case u.TD:case u.TFOOT:case u.TH:case u.THEAD:case u.TR:break;default:et(e,t);}}(this,e);break;case Se.IN_COLUMN_GROUP:!function(e,t){switch(t.tagID){case u.COLGROUP:e.openElements.currentTagId===u.COLGROUP&&(e.openElements.pop(),e.insertionMode=Se.IN_TABLE);break;case u.TEMPLATE:xe(e,t);break;case u.COL:break;default:ht(e,t);}}(this,e);break;case Se.IN_TABLE_BODY:At(this,e);break;case Se.IN_ROW:mt(this,e);break;case Se.IN_CELL:!function(e,t){const s=t.tagID;switch(s){case u.TD:case u.TH:e.openElements.hasInTableScope(s)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(s),e.activeFormattingElements.clearToLastMarker(),e.insertionMode=Se.IN_ROW);break;case u.TABLE:case u.TBODY:case u.TFOOT:case u.THEAD:case u.TR:e.openElements.hasInTableScope(s)&&(e._closeTableCell(),mt(e,t));break;case u.BODY:case u.CAPTION:case u.COL:case u.COLGROUP:case u.HTML:break;default:et(e,t);}}(this,e);break;case Se.IN_SELECT:dt(this,e);break;case Se.IN_SELECT_IN_TABLE:!function(e,t){const s=t.tagID;s===u.CAPTION||s===u.TABLE||s===u.TBODY||s===u.TFOOT||s===u.THEAD||s===u.TR||s===u.TD||s===u.TH?e.openElements.hasInTableScope(s)&&(e.openElements.popUntilTagNamePopped(u.SELECT),e._resetInsertionMode(),e.onEndTag(t)):dt(e,t);}(this,e);break;case Se.IN_TEMPLATE:!function(e,t){t.tagID===u.TEMPLATE&&xe(e,t);}(this,e);break;case Se.AFTER_BODY:Nt(this,e);break;case Se.IN_FRAMESET:!function(e,t){t.tagID!==u.FRAMESET||e.openElements.isRootHtmlElementCurrent()||(e.openElements.pop(),e.fragmentContext||e.openElements.currentTagId===u.FRAMESET||(e.insertionMode=Se.AFTER_FRAMESET));}(this,e);break;case Se.AFTER_FRAMESET:!function(e,t){t.tagID===u.HTML&&(e.insertionMode=Se.AFTER_AFTER_FRAMESET);}(this,e);break;case Se.AFTER_AFTER_BODY:Ct(this,e);}}onEof(e){switch(this.insertionMode){case Se.INITIAL:Ge(this,e);break;case Se.BEFORE_HTML:ye(this,e);break;case Se.BEFORE_HEAD:we(this,e);break;case Se.IN_HEAD:ve(this,e);break;case Se.IN_HEAD_NO_SCRIPT:Qe(this,e);break;case Se.AFTER_HEAD:qe(this,e);break;case Se.IN_BODY:case Se.IN_TABLE:case Se.IN_CAPTION:case Se.IN_COLUMN_GROUP:case Se.IN_TABLE_BODY:case Se.IN_ROW:case Se.IN_CELL:case Se.IN_SELECT:case Se.IN_SELECT_IN_TABLE:tt(this,e);break;case Se.TEXT:!function(e,t){e._err(t,T.eofInElementThatCanContainOnlyText),e.openElements.pop(),e.insertionMode=e.originalInsertionMode,e.onEof(t);}(this,e);break;case Se.IN_TABLE_TEXT:ct(this,e);break;case Se.IN_TEMPLATE:It(this,e);break;case Se.AFTER_BODY:case Se.IN_FRAMESET:case Se.AFTER_FRAMESET:case Se.AFTER_AFTER_BODY:case Se.AFTER_AFTER_FRAMESET:Ue(this,e);}}onWhitespaceCharacter(e){if(this.skipNextNewLine&&(this.skipNextNewLine=!1,e.chars.charCodeAt(0)===a.LINE_FEED)){if(1===e.chars.length)return;e.chars=e.chars.substr(1);}if(this.tokenizer.inForeignNode)this._insertCharacters(e);else switch(this.insertionMode){case Se.IN_HEAD:case Se.IN_HEAD_NO_SCRIPT:case Se.AFTER_HEAD:case Se.TEXT:case Se.IN_COLUMN_GROUP:case Se.IN_SELECT:case Se.IN_SELECT_IN_TABLE:case Se.IN_FRAMESET:case Se.AFTER_FRAMESET:this._insertCharacters(e);break;case Se.IN_BODY:case Se.IN_CAPTION:case Se.IN_CELL:case Se.IN_TEMPLATE:case Se.AFTER_BODY:case Se.AFTER_AFTER_BODY:case Se.AFTER_AFTER_FRAMESET:Xe(this,e);break;case Se.IN_TABLE:case Se.IN_TABLE_BODY:case Se.IN_ROW:st(this,e);break;case Se.IN_TABLE_TEXT:it(this,e);}}}function ge(e,t){let s=e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName);return s?e.openElements.contains(s.element)?e.openElements.hasInScope(t.tagID)||(s=null):(e.activeFormattingElements.removeEntry(s),s=null):$e(e,t),s}function Me(e,t){let s=null,a=e.openElements.stackTop;for(;a>=0;a--){const r=e.openElements.items[a];if(r===t.element)break;e._isSpecialElement(r,e.openElements.tagIDs[a])&&(s=r);}return s||(e.openElements.shortenToLength(a<0?0:a),e.activeFormattingElements.removeEntry(t)),s}function ke(e,t,s){let a=t,r=e.openElements.getCommonAncestor(t);for(let n=0,i=r;i!==s;n++,i=r){r=e.openElements.getCommonAncestor(i);const s=e.activeFormattingElements.getElementEntry(i),o=s&&n>=De;!s||o?(o&&e.activeFormattingElements.removeEntry(s),e.openElements.remove(i)):(i=Pe(e,s),a===t&&(e.activeFormattingElements.bookmark=s),e.treeAdapter.detachNode(a),e.treeAdapter.appendChild(i,a),a=i);}return a}function Pe(e,t){const s=e.treeAdapter.getNamespaceURI(t.element),a=e.treeAdapter.createElement(t.token.tagName,s,t.token.attrs);return e.openElements.replace(t.element,a),t.element=a,a}function be(e,t,s){const a=f(e.treeAdapter.getTagName(t));if(e._isElementCausesFosterParenting(a))e._fosterParentElement(s);else {const r=e.treeAdapter.getNamespaceURI(t);a===u.TEMPLATE&&r===p.HTML&&(t=e.treeAdapter.getTemplateContent(t)),e.treeAdapter.appendChild(t,s);}}function Be(e,t,s){const a=e.treeAdapter.getNamespaceURI(s.element),{token:r}=s,n=e.treeAdapter.createElement(r.tagName,a,r.attrs);e._adoptNodes(t,n),e.treeAdapter.appendChild(t,n),e.activeFormattingElements.insertElementAfterBookmark(n,r),e.activeFormattingElements.removeEntry(s),e.openElements.remove(s.element),e.openElements.insertAfter(t,n,r.tagID);}function He(e,t){for(let s=0;s<Ce;s++){const s=ge(e,t);if(!s)break;const a=Me(e,s);if(!a)break;e.activeFormattingElements.bookmark=s;const r=ke(e,a,s.element),n=e.openElements.getCommonAncestor(s.element);e.treeAdapter.detachNode(r),n&&be(e,n,r),Be(e,a,s);}}function Fe(e,t){e._appendCommentNode(t,e.openElements.currentTmplContentOrNode);}function Ue(e,t){if(e.stopped=!0,t.location){const s=e.fragmentContext?0:2;for(let a=e.openElements.stackTop;a>=s;a--)e._setEndLocation(e.openElements.items[a],t);if(!e.fragmentContext&&e.openElements.stackTop>=0){const s=e.openElements.items[0],a=e.treeAdapter.getNodeSourceCodeLocation(s);if(a&&!a.endTag&&(e._setEndLocation(s,t),e.openElements.stackTop>=1)){const s=e.openElements.items[1],a=e.treeAdapter.getNodeSourceCodeLocation(s);a&&!a.endTag&&e._setEndLocation(s,t);}}}}function Ge(e,t){e._err(t,T.missingDoctype,!0),e.treeAdapter.setDocumentMode(e.document,I.QUIRKS),e.insertionMode=Se.BEFORE_HTML,e._processToken(t);}function ye(e,t){e._insertFakeRootElement(),e.insertionMode=Se.BEFORE_HEAD,e._processToken(t);}function we(e,t){e._insertFakeElement(N.HEAD,u.HEAD),e.headElement=e.openElements.current,e.insertionMode=Se.IN_HEAD,e._processToken(t);}function Ye(e,t){switch(t.tagID){case u.HTML:Ze(e,t);break;case u.BASE:case u.BASEFONT:case u.BGSOUND:case u.LINK:case u.META:e._appendElement(t,p.HTML),t.ackSelfClosing=!0;break;case u.TITLE:e._switchToTextParsing(t,b.RCDATA);break;case u.NOSCRIPT:e.options.scriptingEnabled?e._switchToTextParsing(t,b.RAWTEXT):(e._insertElement(t,p.HTML),e.insertionMode=Se.IN_HEAD_NO_SCRIPT);break;case u.NOFRAMES:case u.STYLE:e._switchToTextParsing(t,b.RAWTEXT);break;case u.SCRIPT:e._switchToTextParsing(t,b.SCRIPT_DATA);break;case u.TEMPLATE:e._insertTemplate(t),e.activeFormattingElements.insertMarker(),e.framesetOk=!1,e.insertionMode=Se.IN_TEMPLATE,e.tmplInsertionModeStack.unshift(Se.IN_TEMPLATE);break;case u.HEAD:e._err(t,T.misplacedStartTagForHeadElement);break;default:ve(e,t);}}function xe(e,t){e.openElements.tmplCount>0?(e.openElements.generateImpliedEndTagsThoroughly(),e.openElements.currentTagId!==u.TEMPLATE&&e._err(t,T.closingOfElementWithOpenChildElements),e.openElements.popUntilTagNamePopped(u.TEMPLATE),e.activeFormattingElements.clearToLastMarker(),e.tmplInsertionModeStack.shift(),e._resetInsertionMode()):e._err(t,T.endTagWithoutMatchingOpenElement);}function ve(e,t){e.openElements.pop(),e.insertionMode=Se.AFTER_HEAD,e._processToken(t);}function Qe(e,t){const s=t.type===h.EOF?T.openElementsLeftAfterEof:T.disallowedContentInNoscriptInHead;e._err(t,s),e.openElements.pop(),e.insertionMode=Se.IN_HEAD,e._processToken(t);}function qe(e,t){e._insertFakeElement(N.BODY,u.BODY),e.insertionMode=Se.IN_BODY,We(e,t);}function We(e,t){switch(t.type){case h.CHARACTER:Ke(e,t);break;case h.WHITESPACE_CHARACTER:Xe(e,t);break;case h.COMMENT:Fe(e,t);break;case h.START_TAG:Ze(e,t);break;case h.END_TAG:et(e,t);break;case h.EOF:tt(e,t);}}function Xe(e,t){e._reconstructActiveFormattingElements(),e._insertCharacters(t);}function Ke(e,t){e._reconstructActiveFormattingElements(),e._insertCharacters(t),e.framesetOk=!1;}function Ve(e,t){e._reconstructActiveFormattingElements(),e._appendElement(t,p.HTML),e.framesetOk=!1,t.ackSelfClosing=!0;}function ze(e){const t=A(e,d.TYPE);return null!=t&&t.toLowerCase()===ue}function je(e,t){e._switchToTextParsing(t,b.RAWTEXT);}function Je(e,t){e._reconstructActiveFormattingElements(),e._insertElement(t,p.HTML);}function Ze(e,t){switch(t.tagID){case u.I:case u.S:case u.B:case u.U:case u.EM:case u.TT:case u.BIG:case u.CODE:case u.FONT:case u.SMALL:case u.STRIKE:case u.STRONG:!function(e,t){e._reconstructActiveFormattingElements(),e._insertElement(t,p.HTML),e.activeFormattingElements.pushElement(e.openElements.current,t);}(e,t);break;case u.A:!function(e,t){const s=e.activeFormattingElements.getElementEntryInScopeWithTagName(N.A);s&&(He(e,t),e.openElements.remove(s.element),e.activeFormattingElements.removeEntry(s)),e._reconstructActiveFormattingElements(),e._insertElement(t,p.HTML),e.activeFormattingElements.pushElement(e.openElements.current,t);}(e,t);break;case u.H1:case u.H2:case u.H3:case u.H4:case u.H5:case u.H6:!function(e,t){e.openElements.hasInButtonScope(u.P)&&e._closePElement(),M(e.openElements.currentTagId)&&e.openElements.pop(),e._insertElement(t,p.HTML);}(e,t);break;case u.P:case u.DL:case u.OL:case u.UL:case u.DIV:case u.DIR:case u.NAV:case u.MAIN:case u.MENU:case u.ASIDE:case u.CENTER:case u.FIGURE:case u.FOOTER:case u.HEADER:case u.HGROUP:case u.DIALOG:case u.DETAILS:case u.ADDRESS:case u.ARTICLE:case u.SECTION:case u.SUMMARY:case u.FIELDSET:case u.BLOCKQUOTE:case u.FIGCAPTION:!function(e,t){e.openElements.hasInButtonScope(u.P)&&e._closePElement(),e._insertElement(t,p.HTML);}(e,t);break;case u.LI:case u.DD:case u.DT:!function(e,t){e.framesetOk=!1;const s=t.tagID;for(let t=e.openElements.stackTop;t>=0;t--){const a=e.openElements.tagIDs[t];if(s===u.LI&&a===u.LI||(s===u.DD||s===u.DT)&&(a===u.DD||a===u.DT)){e.openElements.generateImpliedEndTagsWithExclusion(a),e.openElements.popUntilTagNamePopped(a);break}if(a!==u.ADDRESS&&a!==u.DIV&&a!==u.P&&e._isSpecialElement(e.openElements.items[t],a))break}e.openElements.hasInButtonScope(u.P)&&e._closePElement(),e._insertElement(t,p.HTML);}(e,t);break;case u.BR:case u.IMG:case u.WBR:case u.AREA:case u.EMBED:case u.KEYGEN:Ve(e,t);break;case u.HR:!function(e,t){e.openElements.hasInButtonScope(u.P)&&e._closePElement(),e._appendElement(t,p.HTML),e.framesetOk=!1,t.ackSelfClosing=!0;}(e,t);break;case u.RB:case u.RTC:!function(e,t){e.openElements.hasInScope(u.RUBY)&&e.openElements.generateImpliedEndTags(),e._insertElement(t,p.HTML);}(e,t);break;case u.RT:case u.RP:!function(e,t){e.openElements.hasInScope(u.RUBY)&&e.openElements.generateImpliedEndTagsWithExclusion(u.RTC),e._insertElement(t,p.HTML);}(e,t);break;case u.PRE:case u.LISTING:!function(e,t){e.openElements.hasInButtonScope(u.P)&&e._closePElement(),e._insertElement(t,p.HTML),e.skipNextNewLine=!0,e.framesetOk=!1;}(e,t);break;case u.XMP:!function(e,t){e.openElements.hasInButtonScope(u.P)&&e._closePElement(),e._reconstructActiveFormattingElements(),e.framesetOk=!1,e._switchToTextParsing(t,b.RAWTEXT);}(e,t);break;case u.SVG:!function(e,t){e._reconstructActiveFormattingElements(),Ie(t),Ne(t),t.selfClosing?e._appendElement(t,p.SVG):e._insertElement(t,p.SVG),t.ackSelfClosing=!0;}(e,t);break;case u.HTML:!function(e,t){0===e.openElements.tmplCount&&e.treeAdapter.adoptAttributes(e.openElements.items[0],t.attrs);}(e,t);break;case u.BASE:case u.LINK:case u.META:case u.STYLE:case u.TITLE:case u.SCRIPT:case u.BGSOUND:case u.BASEFONT:case u.TEMPLATE:Ye(e,t);break;case u.BODY:!function(e,t){const s=e.openElements.tryPeekProperlyNestedBodyElement();s&&0===e.openElements.tmplCount&&(e.framesetOk=!1,e.treeAdapter.adoptAttributes(s,t.attrs));}(e,t);break;case u.FORM:!function(e,t){const s=e.openElements.tmplCount>0;e.formElement&&!s||(e.openElements.hasInButtonScope(u.P)&&e._closePElement(),e._insertElement(t,p.HTML),s||(e.formElement=e.openElements.current));}(e,t);break;case u.NOBR:!function(e,t){e._reconstructActiveFormattingElements(),e.openElements.hasInScope(u.NOBR)&&(He(e,t),e._reconstructActiveFormattingElements()),e._insertElement(t,p.HTML),e.activeFormattingElements.pushElement(e.openElements.current,t);}(e,t);break;case u.MATH:!function(e,t){e._reconstructActiveFormattingElements(),de(t),Ne(t),t.selfClosing?e._appendElement(t,p.MATHML):e._insertElement(t,p.MATHML),t.ackSelfClosing=!0;}(e,t);break;case u.TABLE:!function(e,t){e.treeAdapter.getDocumentMode(e.document)!==I.QUIRKS&&e.openElements.hasInButtonScope(u.P)&&e._closePElement(),e._insertElement(t,p.HTML),e.framesetOk=!1,e.insertionMode=Se.IN_TABLE;}(e,t);break;case u.INPUT:!function(e,t){e._reconstructActiveFormattingElements(),e._appendElement(t,p.HTML),ze(t)||(e.framesetOk=!1),t.ackSelfClosing=!0;}(e,t);break;case u.PARAM:case u.TRACK:case u.SOURCE:!function(e,t){e._appendElement(t,p.HTML),t.ackSelfClosing=!0;}(e,t);break;case u.IMAGE:!function(e,t){t.tagName=N.IMG,t.tagID=u.IMG,Ve(e,t);}(e,t);break;case u.BUTTON:!function(e,t){e.openElements.hasInScope(u.BUTTON)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(u.BUTTON)),e._reconstructActiveFormattingElements(),e._insertElement(t,p.HTML),e.framesetOk=!1;}(e,t);break;case u.APPLET:case u.OBJECT:case u.MARQUEE:!function(e,t){e._reconstructActiveFormattingElements(),e._insertElement(t,p.HTML),e.activeFormattingElements.insertMarker(),e.framesetOk=!1;}(e,t);break;case u.IFRAME:!function(e,t){e.framesetOk=!1,e._switchToTextParsing(t,b.RAWTEXT);}(e,t);break;case u.SELECT:!function(e,t){e._reconstructActiveFormattingElements(),e._insertElement(t,p.HTML),e.framesetOk=!1,e.insertionMode=e.insertionMode===Se.IN_TABLE||e.insertionMode===Se.IN_CAPTION||e.insertionMode===Se.IN_TABLE_BODY||e.insertionMode===Se.IN_ROW||e.insertionMode===Se.IN_CELL?Se.IN_SELECT_IN_TABLE:Se.IN_SELECT;}(e,t);break;case u.OPTION:case u.OPTGROUP:!function(e,t){e.openElements.currentTagId===u.OPTION&&e.openElements.pop(),e._reconstructActiveFormattingElements(),e._insertElement(t,p.HTML);}(e,t);break;case u.NOEMBED:je(e,t);break;case u.FRAMESET:!function(e,t){const s=e.openElements.tryPeekProperlyNestedBodyElement();e.framesetOk&&s&&(e.treeAdapter.detachNode(s),e.openElements.popAllUpToHtmlElement(),e._insertElement(t,p.HTML),e.insertionMode=Se.IN_FRAMESET);}(e,t);break;case u.TEXTAREA:!function(e,t){e._insertElement(t,p.HTML),e.skipNextNewLine=!0,e.tokenizer.state=b.RCDATA,e.originalInsertionMode=e.insertionMode,e.framesetOk=!1,e.insertionMode=Se.TEXT;}(e,t);break;case u.NOSCRIPT:e.options.scriptingEnabled?je(e,t):Je(e,t);break;case u.PLAINTEXT:!function(e,t){e.openElements.hasInButtonScope(u.P)&&e._closePElement(),e._insertElement(t,p.HTML),e.tokenizer.state=b.PLAINTEXT;}(e,t);break;case u.COL:case u.TH:case u.TD:case u.TR:case u.HEAD:case u.FRAME:case u.TBODY:case u.TFOOT:case u.THEAD:case u.CAPTION:case u.COLGROUP:break;default:Je(e,t);}}function $e(e,t){const s=t.tagName,a=t.tagID;for(let t=e.openElements.stackTop;t>0;t--){const r=e.openElements.items[t],n=e.openElements.tagIDs[t];if(a===n&&(a!==u.UNKNOWN||e.treeAdapter.getTagName(r)===s)){e.openElements.generateImpliedEndTagsWithExclusion(a),e.openElements.stackTop>=t&&e.openElements.shortenToLength(t);break}if(e._isSpecialElement(r,n))break}}function et(e,t){switch(t.tagID){case u.A:case u.B:case u.I:case u.S:case u.U:case u.EM:case u.TT:case u.BIG:case u.CODE:case u.FONT:case u.NOBR:case u.SMALL:case u.STRIKE:case u.STRONG:He(e,t);break;case u.P:!function(e){e.openElements.hasInButtonScope(u.P)||e._insertFakeElement(N.P,u.P),e._closePElement();}(e);break;case u.DL:case u.UL:case u.OL:case u.DIR:case u.DIV:case u.NAV:case u.PRE:case u.MAIN:case u.MENU:case u.ASIDE:case u.BUTTON:case u.CENTER:case u.FIGURE:case u.FOOTER:case u.HEADER:case u.HGROUP:case u.DIALOG:case u.ADDRESS:case u.ARTICLE:case u.DETAILS:case u.SECTION:case u.SUMMARY:case u.LISTING:case u.FIELDSET:case u.BLOCKQUOTE:case u.FIGCAPTION:!function(e,t){const s=t.tagID;e.openElements.hasInScope(s)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(s));}(e,t);break;case u.LI:!function(e){e.openElements.hasInListItemScope(u.LI)&&(e.openElements.generateImpliedEndTagsWithExclusion(u.LI),e.openElements.popUntilTagNamePopped(u.LI));}(e);break;case u.DD:case u.DT:!function(e,t){const s=t.tagID;e.openElements.hasInScope(s)&&(e.openElements.generateImpliedEndTagsWithExclusion(s),e.openElements.popUntilTagNamePopped(s));}(e,t);break;case u.H1:case u.H2:case u.H3:case u.H4:case u.H5:case u.H6:!function(e){e.openElements.hasNumberedHeaderInScope()&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilNumberedHeaderPopped());}(e);break;case u.BR:!function(e){e._reconstructActiveFormattingElements(),e._insertFakeElement(N.BR,u.BR),e.openElements.pop(),e.framesetOk=!1;}(e);break;case u.BODY:!function(e,t){if(e.openElements.hasInScope(u.BODY)&&(e.insertionMode=Se.AFTER_BODY,e.options.sourceCodeLocationInfo)){const s=e.openElements.tryPeekProperlyNestedBodyElement();s&&e._setEndLocation(s,t);}}(e,t);break;case u.HTML:!function(e,t){e.openElements.hasInScope(u.BODY)&&(e.insertionMode=Se.AFTER_BODY,Nt(e,t));}(e,t);break;case u.FORM:!function(e){const t=e.openElements.tmplCount>0,{formElement:s}=e;t||(e.formElement=null),(s||t)&&e.openElements.hasInScope(u.FORM)&&(e.openElements.generateImpliedEndTags(),t?e.openElements.popUntilTagNamePopped(u.FORM):s&&e.openElements.remove(s));}(e);break;case u.APPLET:case u.OBJECT:case u.MARQUEE:!function(e,t){const s=t.tagID;e.openElements.hasInScope(s)&&(e.openElements.generateImpliedEndTags(),e.openElements.popUntilTagNamePopped(s),e.activeFormattingElements.clearToLastMarker());}(e,t);break;case u.TEMPLATE:xe(e,t);break;default:$e(e,t);}}function tt(e,t){e.tmplInsertionModeStack.length>0?It(e,t):Ue(e,t);}function st(e,t){if(Oe.has(e.openElements.currentTagId))switch(e.pendingCharacterTokens.length=0,e.hasNonWhitespacePendingCharacterToken=!1,e.originalInsertionMode=e.insertionMode,e.insertionMode=Se.IN_TABLE_TEXT,t.type){case h.CHARACTER:ot(e,t);break;case h.WHITESPACE_CHARACTER:it(e,t);}else nt(e,t);}function at(e,t){switch(t.tagID){case u.TD:case u.TH:case u.TR:!function(e,t){e.openElements.clearBackToTableContext(),e._insertFakeElement(N.TBODY,u.TBODY),e.insertionMode=Se.IN_TABLE_BODY,_t(e,t);}(e,t);break;case u.STYLE:case u.SCRIPT:case u.TEMPLATE:Ye(e,t);break;case u.COL:!function(e,t){e.openElements.clearBackToTableContext(),e._insertFakeElement(N.COLGROUP,u.COLGROUP),e.insertionMode=Se.IN_COLUMN_GROUP,Tt(e,t);}(e,t);break;case u.FORM:!function(e,t){e.formElement||0!==e.openElements.tmplCount||(e._insertElement(t,p.HTML),e.formElement=e.openElements.current,e.openElements.pop());}(e,t);break;case u.TABLE:!function(e,t){e.openElements.hasInTableScope(u.TABLE)&&(e.openElements.popUntilTagNamePopped(u.TABLE),e._resetInsertionMode(),e._processStartTag(t));}(e,t);break;case u.TBODY:case u.TFOOT:case u.THEAD:!function(e,t){e.openElements.clearBackToTableContext(),e._insertElement(t,p.HTML),e.insertionMode=Se.IN_TABLE_BODY;}(e,t);break;case u.INPUT:!function(e,t){ze(t)?e._appendElement(t,p.HTML):nt(e,t),t.ackSelfClosing=!0;}(e,t);break;case u.CAPTION:!function(e,t){e.openElements.clearBackToTableContext(),e.activeFormattingElements.insertMarker(),e._insertElement(t,p.HTML),e.insertionMode=Se.IN_CAPTION;}(e,t);break;case u.COLGROUP:!function(e,t){e.openElements.clearBackToTableContext(),e._insertElement(t,p.HTML),e.insertionMode=Se.IN_COLUMN_GROUP;}(e,t);break;default:nt(e,t);}}function rt(e,t){switch(t.tagID){case u.TABLE:e.openElements.hasInTableScope(u.TABLE)&&(e.openElements.popUntilTagNamePopped(u.TABLE),e._resetInsertionMode());break;case u.TEMPLATE:xe(e,t);break;case u.BODY:case u.CAPTION:case u.COL:case u.COLGROUP:case u.HTML:case u.TBODY:case u.TD:case u.TFOOT:case u.TH:case u.THEAD:case u.TR:break;default:nt(e,t);}}function nt(e,t){const s=e.fosterParentingEnabled;e.fosterParentingEnabled=!0,We(e,t),e.fosterParentingEnabled=s;}function it(e,t){e.pendingCharacterTokens.push(t);}function ot(e,t){e.pendingCharacterTokens.push(t),e.hasNonWhitespacePendingCharacterToken=!0;}function ct(e,t){let s=0;if(e.hasNonWhitespacePendingCharacterToken)for(;s<e.pendingCharacterTokens.length;s++)nt(e,e.pendingCharacterTokens[s]);else for(;s<e.pendingCharacterTokens.length;s++)e._insertCharacters(e.pendingCharacterTokens[s]);e.insertionMode=e.originalInsertionMode,e._processToken(t);}const Et=new Set([u.CAPTION,u.COL,u.COLGROUP,u.TBODY,u.TD,u.TFOOT,u.TH,u.THEAD,u.TR]);function Tt(e,t){switch(t.tagID){case u.HTML:Ze(e,t);break;case u.COL:e._appendElement(t,p.HTML),t.ackSelfClosing=!0;break;case u.TEMPLATE:Ye(e,t);break;default:ht(e,t);}}function ht(e,t){e.openElements.currentTagId===u.COLGROUP&&(e.openElements.pop(),e.insertionMode=Se.IN_TABLE,e._processToken(t));}function _t(e,t){switch(t.tagID){case u.TR:e.openElements.clearBackToTableBodyContext(),e._insertElement(t,p.HTML),e.insertionMode=Se.IN_ROW;break;case u.TH:case u.TD:e.openElements.clearBackToTableBodyContext(),e._insertFakeElement(N.TR,u.TR),e.insertionMode=Se.IN_ROW,lt(e,t);break;case u.CAPTION:case u.COL:case u.COLGROUP:case u.TBODY:case u.TFOOT:case u.THEAD:e.openElements.hasTableBodyContextInTableScope()&&(e.openElements.clearBackToTableBodyContext(),e.openElements.pop(),e.insertionMode=Se.IN_TABLE,at(e,t));break;default:at(e,t);}}function At(e,t){const s=t.tagID;switch(t.tagID){case u.TBODY:case u.TFOOT:case u.THEAD:e.openElements.hasInTableScope(s)&&(e.openElements.clearBackToTableBodyContext(),e.openElements.pop(),e.insertionMode=Se.IN_TABLE);break;case u.TABLE:e.openElements.hasTableBodyContextInTableScope()&&(e.openElements.clearBackToTableBodyContext(),e.openElements.pop(),e.insertionMode=Se.IN_TABLE,rt(e,t));break;case u.BODY:case u.CAPTION:case u.COL:case u.COLGROUP:case u.HTML:case u.TD:case u.TH:case u.TR:break;default:rt(e,t);}}function lt(e,t){switch(t.tagID){case u.TH:case u.TD:e.openElements.clearBackToTableRowContext(),e._insertElement(t,p.HTML),e.insertionMode=Se.IN_CELL,e.activeFormattingElements.insertMarker();break;case u.CAPTION:case u.COL:case u.COLGROUP:case u.TBODY:case u.TFOOT:case u.THEAD:case u.TR:e.openElements.hasInTableScope(u.TR)&&(e.openElements.clearBackToTableRowContext(),e.openElements.pop(),e.insertionMode=Se.IN_TABLE_BODY,_t(e,t));break;default:at(e,t);}}function mt(e,t){switch(t.tagID){case u.TR:e.openElements.hasInTableScope(u.TR)&&(e.openElements.clearBackToTableRowContext(),e.openElements.pop(),e.insertionMode=Se.IN_TABLE_BODY);break;case u.TABLE:e.openElements.hasInTableScope(u.TR)&&(e.openElements.clearBackToTableRowContext(),e.openElements.pop(),e.insertionMode=Se.IN_TABLE_BODY,At(e,t));break;case u.TBODY:case u.TFOOT:case u.THEAD:(e.openElements.hasInTableScope(t.tagID)||e.openElements.hasInTableScope(u.TR))&&(e.openElements.clearBackToTableRowContext(),e.openElements.pop(),e.insertionMode=Se.IN_TABLE_BODY,At(e,t));break;case u.BODY:case u.CAPTION:case u.COL:case u.COLGROUP:case u.HTML:case u.TD:case u.TH:break;default:rt(e,t);}}function pt(e,t){switch(t.tagID){case u.HTML:Ze(e,t);break;case u.OPTION:e.openElements.currentTagId===u.OPTION&&e.openElements.pop(),e._insertElement(t,p.HTML);break;case u.OPTGROUP:e.openElements.currentTagId===u.OPTION&&e.openElements.pop(),e.openElements.currentTagId===u.OPTGROUP&&e.openElements.pop(),e._insertElement(t,p.HTML);break;case u.INPUT:case u.KEYGEN:case u.TEXTAREA:case u.SELECT:e.openElements.hasInSelectScope(u.SELECT)&&(e.openElements.popUntilTagNamePopped(u.SELECT),e._resetInsertionMode(),t.tagID!==u.SELECT&&e._processStartTag(t));break;case u.SCRIPT:case u.TEMPLATE:Ye(e,t);}}function dt(e,t){switch(t.tagID){case u.OPTGROUP:e.openElements.stackTop>0&&e.openElements.currentTagId===u.OPTION&&e.openElements.tagIDs[e.openElements.stackTop-1]===u.OPTGROUP&&e.openElements.pop(),e.openElements.currentTagId===u.OPTGROUP&&e.openElements.pop();break;case u.OPTION:e.openElements.currentTagId===u.OPTION&&e.openElements.pop();break;case u.SELECT:e.openElements.hasInSelectScope(u.SELECT)&&(e.openElements.popUntilTagNamePopped(u.SELECT),e._resetInsertionMode());break;case u.TEMPLATE:xe(e,t);}}function It(e,t){e.openElements.tmplCount>0?(e.openElements.popUntilTagNamePopped(u.TEMPLATE),e.activeFormattingElements.clearToLastMarker(),e.tmplInsertionModeStack.shift(),e._resetInsertionMode(),e.onEof(t)):Ue(e,t);}function Nt(e,t){var s;if(t.tagID===u.HTML){if(e.fragmentContext||(e.insertionMode=Se.AFTER_AFTER_BODY),e.options.sourceCodeLocationInfo&&e.openElements.tagIDs[0]===u.HTML){e._setEndLocation(e.openElements.items[0],t);const a=e.openElements.items[1];a&&!(null===(s=e.treeAdapter.getNodeSourceCodeLocation(a))||void 0===s?void 0:s.endTag)&&e._setEndLocation(a,t);}}else ut(e,t);}function ut(e,t){e.insertionMode=Se.IN_BODY,We(e,t);}function Ct(e,t){e.insertionMode=Se.IN_BODY,We(e,t);}function Dt(e){for(;e.treeAdapter.getNamespaceURI(e.openElements.current)!==p.HTML&&!e._isIntegrationPoint(e.openElements.currentTagId,e.openElements.current);)e.openElements.pop();}return new Set([N.AREA,N.BASE,N.BASEFONT,N.BGSOUND,N.BR,N.COL,N.EMBED,N.FRAME,N.HR,N.IMG,N.INPUT,N.KEYGEN,N.LINK,N.META,N.PARAM,N.SOURCE,N.TRACK,N.WBR]),e.parse=function(e,t){return Le.parse(e,t)},e.parseFragment=function(e,t,s){"string"==typeof e&&(s=t,t=e,e=null);const a=Le.getFragmentParser(e,s);return a.tokenizer.write(t,!0),a.getFragment()},Object.defineProperty(e,"__esModule",{value:!0}),e}({});const parse=e.parse;const parseFragment=e.parseFragment;

const docParser = new WeakMap();
function parseDocumentUtil(ownerDocument, html) {
  const doc = parse(html.trim(), getParser(ownerDocument));
  doc.documentElement = doc.firstElementChild;
  doc.head = doc.documentElement.firstElementChild;
  doc.body = doc.head.nextElementSibling;
  return doc;
}
function parseFragmentUtil(ownerDocument, html) {
  if (typeof html === 'string') {
    html = html.trim();
  }
  else {
    html = '';
  }
  const frag = parseFragment(html, getParser(ownerDocument));
  return frag;
}
function getParser(ownerDocument) {
  let parseOptions = docParser.get(ownerDocument);
  if (parseOptions != null) {
    return parseOptions;
  }
  const treeAdapter = {
    createDocument() {
      const doc = ownerDocument.createElement("#document" /* NODE_NAMES.DOCUMENT_NODE */);
      doc['x-mode'] = 'no-quirks';
      return doc;
    },
    setNodeSourceCodeLocation(node, location) {
      node.sourceCodeLocation = location;
    },
    getNodeSourceCodeLocation(node) {
      return node.sourceCodeLocation;
    },
    createDocumentFragment() {
      return ownerDocument.createDocumentFragment();
    },
    createElement(tagName, namespaceURI, attrs) {
      const elm = ownerDocument.createElementNS(namespaceURI, tagName);
      for (let i = 0; i < attrs.length; i++) {
        const attr = attrs[i];
        if (attr.namespace == null || attr.namespace === 'http://www.w3.org/1999/xhtml') {
          elm.setAttribute(attr.name, attr.value);
        }
        else {
          elm.setAttributeNS(attr.namespace, attr.name, attr.value);
        }
      }
      return elm;
    },
    createCommentNode(data) {
      return ownerDocument.createComment(data);
    },
    appendChild(parentNode, newNode) {
      parentNode.appendChild(newNode);
    },
    insertBefore(parentNode, newNode, referenceNode) {
      parentNode.insertBefore(newNode, referenceNode);
    },
    setTemplateContent(templateElement, contentElement) {
      templateElement.content = contentElement;
    },
    getTemplateContent(templateElement) {
      return templateElement.content;
    },
    setDocumentType(doc, name, publicId, systemId) {
      let doctypeNode = doc.childNodes.find((n) => n.nodeType === 10 /* NODE_TYPES.DOCUMENT_TYPE_NODE */);
      if (doctypeNode == null) {
        doctypeNode = ownerDocument.createDocumentTypeNode();
        doc.insertBefore(doctypeNode, doc.firstChild);
      }
      doctypeNode.nodeValue = '!DOCTYPE';
      doctypeNode['x-name'] = name;
      doctypeNode['x-publicId'] = publicId;
      doctypeNode['x-systemId'] = systemId;
    },
    setDocumentMode(doc, mode) {
      doc['x-mode'] = mode;
    },
    getDocumentMode(doc) {
      return doc['x-mode'];
    },
    detachNode(node) {
      node.remove();
    },
    insertText(parentNode, text) {
      const lastChild = parentNode.lastChild;
      if (lastChild != null && lastChild.nodeType === 3 /* NODE_TYPES.TEXT_NODE */) {
        lastChild.nodeValue += text;
      }
      else {
        parentNode.appendChild(ownerDocument.createTextNode(text));
      }
    },
    insertTextBefore(parentNode, text, referenceNode) {
      const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
      if (prevNode != null && prevNode.nodeType === 3 /* NODE_TYPES.TEXT_NODE */) {
        prevNode.nodeValue += text;
      }
      else {
        parentNode.insertBefore(ownerDocument.createTextNode(text), referenceNode);
      }
    },
    adoptAttributes(recipient, attrs) {
      for (let i = 0; i < attrs.length; i++) {
        const attr = attrs[i];
        if (recipient.hasAttributeNS(attr.namespace, attr.name) === false) {
          recipient.setAttributeNS(attr.namespace, attr.name, attr.value);
        }
      }
    },
    getFirstChild(node) {
      return node.childNodes[0];
    },
    getChildNodes(node) {
      return node.childNodes;
    },
    getParentNode(node) {
      return node.parentNode;
    },
    getAttrList(element) {
      const attrs = element.attributes.__items.map((attr) => {
        return {
          name: attr.name,
          value: attr.value,
          namespace: attr.namespaceURI,
          prefix: null,
        };
      });
      return attrs;
    },
    getTagName(element) {
      if (element.namespaceURI === 'http://www.w3.org/1999/xhtml') {
        return element.nodeName.toLowerCase();
      }
      else {
        return element.nodeName;
      }
    },
    getNamespaceURI(element) {
      // mock-doc widens the type of an element's namespace uri to 'string | null'
      // we use a type assertion here to adhere to parse5's type definitions
      return element.namespaceURI;
    },
    getTextNodeContent(textNode) {
      return textNode.nodeValue;
    },
    getCommentNodeContent(commentNode) {
      return commentNode.nodeValue;
    },
    getDocumentTypeNodeName(doctypeNode) {
      return doctypeNode['x-name'];
    },
    getDocumentTypeNodePublicId(doctypeNode) {
      return doctypeNode['x-publicId'];
    },
    getDocumentTypeNodeSystemId(doctypeNode) {
      return doctypeNode['x-systemId'];
    },
    // @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['text']`. As a result, we cannot
    // complete this function signature
    isTextNode(node) {
      return node.nodeType === 3 /* NODE_TYPES.TEXT_NODE */;
    },
    // @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['comment']`. As a result, we cannot
    // complete this function signature (which requires its return type to be a type predicate)
    isCommentNode(node) {
      return node.nodeType === 8 /* NODE_TYPES.COMMENT_NODE */;
    },
    // @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['document']`. As a result, we cannot
    // complete this function signature (which requires its return type to be a type predicate)
    isDocumentTypeNode(node) {
      return node.nodeType === 10 /* NODE_TYPES.DOCUMENT_TYPE_NODE */;
    },
    // @ts-ignore - a `MockNode` will never be assignable to a `TreeAdapterTypeMap['element']`. As a result, we cannot
    // complete this function signature (which requires its return type to be a type predicate)
    isElementNode(node) {
      return node.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */;
    },
  };
  parseOptions = {
    treeAdapter: treeAdapter,
  };
  docParser.set(ownerDocument, parseOptions);
  return parseOptions;
}

// Sizzle 2.3.10
const Sizzle = (function() {
const window = {
  document: {
  createElement() {
    return {};
  },
  nodeType: 9,
  documentElement: {
    nodeType: 1,
    nodeName: 'HTML'
  }
  }
};
const module = { exports: {} };

/*! Sizzle v2.3.10 | (c) JS Foundation and other contributors | js.foundation */
!function(e){var t,n,r,i,o,u,l,a,c,s,f,d,p,h,g,m,y,v,w,b="sizzle"+1*new Date,N=e.document,C=0,x=0,E=ae(),A=ae(),S=ae(),D=ae(),T=function(e,t){return e===t&&(f=!0),0},L={}.hasOwnProperty,q=[],I=q.pop,B=q.push,R=q.push,$=q.slice,k=function(e,t){for(var n=0,r=e.length;n<r;n++)if(e[n]===t)return n;return -1},H="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",P="(?:\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",z="\\["+M+"*("+P+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+P+"))|)"+M+"*\\]",F=":("+P+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+z+")*)|.*)\\)|)",O=new RegExp(M+"+","g"),j=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),G=new RegExp("^"+M+"*,"+M+"*"),U=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),V=new RegExp(M+"|>"),X=new RegExp(F),J=new RegExp("^"+P+"$"),K={ID:new RegExp("^#("+P+")"),CLASS:new RegExp("^\\.("+P+")"),TAG:new RegExp("^("+P+"|[*])"),ATTR:new RegExp("^"+z),PSEUDO:new RegExp("^"+F),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+H+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Q=/HTML$/i,W=/^(?:input|select|textarea|button)$/i,Y=/^h\d$/i,Z=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ee=/[+~]/,te=new RegExp("\\\\[\\da-fA-F]{1,6}"+M+"?|\\\\([^\\r\\n\\f])","g"),ne=function(e,t){var n="0x"+e.slice(1)-65536;return t||(n<0?String.fromCharCode(n+65536):String.fromCharCode(n>>10|55296,1023&n|56320))},re=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ie=function(e,t){return t?"\0"===e?"\ufffd":e.slice(0,-1)+"\\"+e.charCodeAt(e.length-1).toString(16)+" ":"\\"+e},oe=function(){d();},ue=ve(function(e){return !0===e.disabled&&"fieldset"===e.nodeName.toLowerCase()},{dir:"parentNode",next:"legend"});try{R.apply(q=$.call(N.childNodes),N.childNodes),q[N.childNodes.length].nodeType;}catch(e){R={apply:q.length?function(e,t){B.apply(e,$.call(t));}:function(e,t){var n=e.length,r=0;while(e[n++]=t[r++]);e.length=n-1;}};}function le(e,t,r,i){var o,l,c,s,f,h,y,v=t&&t.ownerDocument,N=t?t.nodeType:9;if(r=r||[],"string"!=typeof e||!e||1!==N&&9!==N&&11!==N)return r;if(!i&&(d(t),t=t||p,g)){if(11!==N&&(f=_.exec(e)))if(o=f[1]){if(9===N){if(!(c=t.getElementById(o)))return r;if(c.id===o)return r.push(c),r}else if(v&&(c=v.getElementById(o))&&w(t,c)&&c.id===o)return r.push(c),r}else {if(f[2])return R.apply(r,t.getElementsByTagName(e)),r;if((o=f[3])&&n.getElementsByClassName&&t.getElementsByClassName)return R.apply(r,t.getElementsByClassName(o)),r}if(n.qsa&&!D[e+" "]&&(!m||!m.test(e))&&(1!==N||"object"!==t.nodeName.toLowerCase())){if(y=e,v=t,1===N&&(V.test(e)||U.test(e))){(v=ee.test(e)&&ge(t.parentNode)||t)===t&&n.scope||((s=t.getAttribute("id"))?s=s.replace(re,ie):t.setAttribute("id",s=b)),l=(h=u(e)).length;while(l--)h[l]=(s?"#"+s:":scope")+" "+ye(h[l]);y=h.join(",");}try{return R.apply(r,v.querySelectorAll(y)),r}catch(t){D(e,!0);}finally{s===b&&t.removeAttribute("id");}}}return a(e.replace(j,"$1"),t,r,i)}function ae(){var e=[];function t(n,i){return e.push(n+" ")>r.cacheLength&&delete t[e.shift()],t[n+" "]=i}return t}function ce(e){return e[b]=!0,e}function se(e){var t=p.createElement("fieldset");try{return !!e(t)}catch(e){return !1}finally{t.parentNode&&t.parentNode.removeChild(t),t=null;}}function fe(e,t){var n=e.split("|"),i=n.length;while(i--)r.attrHandle[n[i]]=t;}function de(e,t){var n=t&&e,r=n&&1===e.nodeType&&1===t.nodeType&&e.sourceIndex-t.sourceIndex;if(r)return r;if(n)while(n=n.nextSibling)if(n===t)return -1;return e?1:-1}function pe(e){return function(t){return "form"in t?t.parentNode&&!1===t.disabled?"label"in t?"label"in t.parentNode?t.parentNode.disabled===e:t.disabled===e:t.isDisabled===e||t.isDisabled!==!e&&ue(t)===e:t.disabled===e:"label"in t&&t.disabled===e}}function he(e){return ce(function(t){return t=+t,ce(function(n,r){var i,o=e([],n.length,t),u=o.length;while(u--)n[i=o[u]]&&(n[i]=!(r[i]=n[i]));})})}function ge(e){return e&&void 0!==e.getElementsByTagName&&e}n=le.support={},o=le.isXML=function(e){var t=e&&e.namespaceURI,n=e&&(e.ownerDocument||e).documentElement;return !Q.test(t||n&&n.nodeName||"HTML")},d=le.setDocument=function(e){var t,i,u=e?e.ownerDocument||e:N;return u!=p&&9===u.nodeType&&u.documentElement?(p=u,h=p.documentElement,g=!o(p),N!=p&&(i=p.defaultView)&&i.top!==i&&(i.addEventListener?i.addEventListener("unload",oe,!1):i.attachEvent&&i.attachEvent("onunload",oe)),n.scope=se(function(e){return h.appendChild(e).appendChild(p.createElement("div")),void 0!==e.querySelectorAll&&!e.querySelectorAll(":scope fieldset div").length}),n.cssHas=se(function(){try{return p.querySelector(":has(*,:jqfake)"),!1}catch(e){return !0}}),n.attributes=se(function(e){return e.className="i",!e.getAttribute("className")}),n.getElementsByTagName=se(function(e){return e.appendChild(p.createComment("")),!e.getElementsByTagName("*").length}),n.getElementsByClassName=Z.test(p.getElementsByClassName),n.getById=se(function(e){return h.appendChild(e).id=b,!p.getElementsByName||!p.getElementsByName(b).length}),n.getById?(r.filter.ID=function(e){var t=e.replace(te,ne);return function(e){return e.getAttribute("id")===t}},r.find.ID=function(e,t){if(void 0!==t.getElementById&&g){var n=t.getElementById(e);return n?[n]:[]}}):(r.filter.ID=function(e){var t=e.replace(te,ne);return function(e){var n=void 0!==e.getAttributeNode&&e.getAttributeNode("id");return n&&n.value===t}},r.find.ID=function(e,t){if(void 0!==t.getElementById&&g){var n,r,i,o=t.getElementById(e);if(o){if((n=o.getAttributeNode("id"))&&n.value===e)return [o];i=t.getElementsByName(e),r=0;while(o=i[r++])if((n=o.getAttributeNode("id"))&&n.value===e)return [o]}return []}}),r.find.TAG=n.getElementsByTagName?function(e,t){return void 0!==t.getElementsByTagName?t.getElementsByTagName(e):n.qsa?t.querySelectorAll(e):void 0}:function(e,t){var n,r=[],i=0,o=t.getElementsByTagName(e);if("*"===e){while(n=o[i++])1===n.nodeType&&r.push(n);return r}return o},r.find.CLASS=n.getElementsByClassName&&function(e,t){if(void 0!==t.getElementsByClassName&&g)return t.getElementsByClassName(e)},y=[],m=[],(n.qsa=Z.test(p.querySelectorAll))&&(se(function(e){var t;h.appendChild(e).innerHTML="<a id='"+b+"'></a><select id='"+b+"-\r\\' msallowcapture=''><option selected=''></option></select>",e.querySelectorAll("[msallowcapture^='']").length&&m.push("[*^$]="+M+"*(?:''|\"\")"),e.querySelectorAll("[selected]").length||m.push("\\["+M+"*(?:value|"+H+")"),e.querySelectorAll("[id~="+b+"-]").length||m.push("~="),(t=p.createElement("input")).setAttribute("name",""),e.appendChild(t),e.querySelectorAll("[name='']").length||m.push("\\["+M+"*name"+M+"*="+M+"*(?:''|\"\")"),e.querySelectorAll(":checked").length||m.push(":checked"),e.querySelectorAll("a#"+b+"+*").length||m.push(".#.+[+~]"),e.querySelectorAll("\\\f"),m.push("[\\r\\n\\f]");}),se(function(e){e.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var t=p.createElement("input");t.setAttribute("type","hidden"),e.appendChild(t).setAttribute("name","D"),e.querySelectorAll("[name=d]").length&&m.push("name"+M+"*[*^$|!~]?="),2!==e.querySelectorAll(":enabled").length&&m.push(":enabled",":disabled"),h.appendChild(e).disabled=!0,2!==e.querySelectorAll(":disabled").length&&m.push(":enabled",":disabled"),e.querySelectorAll("*,:x"),m.push(",.*:");})),(n.matchesSelector=Z.test(v=h.matches||h.webkitMatchesSelector||h.mozMatchesSelector||h.oMatchesSelector||h.msMatchesSelector))&&se(function(e){n.disconnectedMatch=v.call(e,"*"),v.call(e,"[s!='']:x"),y.push("!=",F);}),n.cssHas||m.push(":has"),m=m.length&&new RegExp(m.join("|")),y=y.length&&new RegExp(y.join("|")),t=Z.test(h.compareDocumentPosition),w=t||Z.test(h.contains)?function(e,t){var n=9===e.nodeType&&e.documentElement||e,r=t&&t.parentNode;return e===r||!(!r||1!==r.nodeType||!(n.contains?n.contains(r):e.compareDocumentPosition&&16&e.compareDocumentPosition(r)))}:function(e,t){if(t)while(t=t.parentNode)if(t===e)return !0;return !1},T=t?function(e,t){if(e===t)return f=!0,0;var r=!e.compareDocumentPosition-!t.compareDocumentPosition;return r||(1&(r=(e.ownerDocument||e)==(t.ownerDocument||t)?e.compareDocumentPosition(t):1)||!n.sortDetached&&t.compareDocumentPosition(e)===r?e==p||e.ownerDocument==N&&w(N,e)?-1:t==p||t.ownerDocument==N&&w(N,t)?1:s?k(s,e)-k(s,t):0:4&r?-1:1)}:function(e,t){if(e===t)return f=!0,0;var n,r=0,i=e.parentNode,o=t.parentNode,u=[e],l=[t];if(!i||!o)return e==p?-1:t==p?1:i?-1:o?1:s?k(s,e)-k(s,t):0;if(i===o)return de(e,t);n=e;while(n=n.parentNode)u.unshift(n);n=t;while(n=n.parentNode)l.unshift(n);while(u[r]===l[r])r++;return r?de(u[r],l[r]):u[r]==N?-1:l[r]==N?1:0},p):p},le.matches=function(e,t){return le(e,null,null,t)},le.matchesSelector=function(e,t){if(d(e),n.matchesSelector&&g&&!D[t+" "]&&(!y||!y.test(t))&&(!m||!m.test(t)))try{var r=v.call(e,t);if(r||n.disconnectedMatch||e.document&&11!==e.document.nodeType)return r}catch(e){D(t,!0);}return le(t,p,null,[e]).length>0},le.contains=function(e,t){return (e.ownerDocument||e)!=p&&d(e),w(e,t)},le.attr=function(e,t){(e.ownerDocument||e)!=p&&d(e);var i=r.attrHandle[t.toLowerCase()],o=i&&L.call(r.attrHandle,t.toLowerCase())?i(e,t,!g):void 0;return void 0!==o?o:n.attributes||!g?e.getAttribute(t):(o=e.getAttributeNode(t))&&o.specified?o.value:null},le.escape=function(e){return (e+"").replace(re,ie)},le.error=function(e){throw new Error("Syntax error, unrecognized expression: "+e)},le.uniqueSort=function(e){var t,r=[],i=0,o=0;if(f=!n.detectDuplicates,s=!n.sortStable&&e.slice(0),e.sort(T),f){while(t=e[o++])t===e[o]&&(i=r.push(o));while(i--)e.splice(r[i],1);}return s=null,e},i=le.getText=function(e){var t,n="",r=0,o=e.nodeType;if(o){if(1===o||9===o||11===o){if("string"==typeof e.textContent)return e.textContent;for(e=e.firstChild;e;e=e.nextSibling)n+=i(e);}else if(3===o||4===o)return e.nodeValue}else while(t=e[r++])n+=i(t);return n},(r=le.selectors={cacheLength:50,createPseudo:ce,match:K,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(e){return e[1]=e[1].replace(te,ne),e[3]=(e[3]||e[4]||e[5]||"").replace(te,ne),"~="===e[2]&&(e[3]=" "+e[3]+" "),e.slice(0,4)},CHILD:function(e){return e[1]=e[1].toLowerCase(),"nth"===e[1].slice(0,3)?(e[3]||le.error(e[0]),e[4]=+(e[4]?e[5]+(e[6]||1):2*("even"===e[3]||"odd"===e[3])),e[5]=+(e[7]+e[8]||"odd"===e[3])):e[3]&&le.error(e[0]),e},PSEUDO:function(e){var t,n=!e[6]&&e[2];return K.CHILD.test(e[0])?null:(e[3]?e[2]=e[4]||e[5]||"":n&&X.test(n)&&(t=u(n,!0))&&(t=n.indexOf(")",n.length-t)-n.length)&&(e[0]=e[0].slice(0,t),e[2]=n.slice(0,t)),e.slice(0,3))}},filter:{TAG:function(e){var t=e.replace(te,ne).toLowerCase();return "*"===e?function(){return !0}:function(e){return e.nodeName&&e.nodeName.toLowerCase()===t}},CLASS:function(e){var t=E[e+" "];return t||(t=new RegExp("(^|"+M+")"+e+"("+M+"|$)"))&&E(e,function(e){return t.test("string"==typeof e.className&&e.className||void 0!==e.getAttribute&&e.getAttribute("class")||"")})},ATTR:function(e,t,n){return function(r){var i=le.attr(r,e);return null==i?"!="===t:!t||(i+="","="===t?i===n:"!="===t?i!==n:"^="===t?n&&0===i.indexOf(n):"*="===t?n&&i.indexOf(n)>-1:"$="===t?n&&i.slice(-n.length)===n:"~="===t?(" "+i.replace(O," ")+" ").indexOf(n)>-1:"|="===t&&(i===n||i.slice(0,n.length+1)===n+"-"))}},CHILD:function(e,t,n,r,i){var o="nth"!==e.slice(0,3),u="last"!==e.slice(-4),l="of-type"===t;return 1===r&&0===i?function(e){return !!e.parentNode}:function(t,n,a){var c,s,f,d,p,h,g=o!==u?"nextSibling":"previousSibling",m=t.parentNode,y=l&&t.nodeName.toLowerCase(),v=!a&&!l,w=!1;if(m){if(o){while(g){d=t;while(d=d[g])if(l?d.nodeName.toLowerCase()===y:1===d.nodeType)return !1;h=g="only"===e&&!h&&"nextSibling";}return !0}if(h=[u?m.firstChild:m.lastChild],u&&v){w=(p=(c=(s=(f=(d=m)[b]||(d[b]={}))[d.uniqueID]||(f[d.uniqueID]={}))[e]||[])[0]===C&&c[1])&&c[2],d=p&&m.childNodes[p];while(d=++p&&d&&d[g]||(w=p=0)||h.pop())if(1===d.nodeType&&++w&&d===t){s[e]=[C,p,w];break}}else if(v&&(w=p=(c=(s=(f=(d=t)[b]||(d[b]={}))[d.uniqueID]||(f[d.uniqueID]={}))[e]||[])[0]===C&&c[1]),!1===w)while(d=++p&&d&&d[g]||(w=p=0)||h.pop())if((l?d.nodeName.toLowerCase()===y:1===d.nodeType)&&++w&&(v&&((s=(f=d[b]||(d[b]={}))[d.uniqueID]||(f[d.uniqueID]={}))[e]=[C,w]),d===t))break;return (w-=i)===r||w%r==0&&w/r>=0}}},PSEUDO:function(e,t){var n,i=r.pseudos[e]||r.setFilters[e.toLowerCase()]||le.error("unsupported pseudo: "+e);return i[b]?i(t):i.length>1?(n=[e,e,"",t],r.setFilters.hasOwnProperty(e.toLowerCase())?ce(function(e,n){var r,o=i(e,t),u=o.length;while(u--)e[r=k(e,o[u])]=!(n[r]=o[u]);}):function(e){return i(e,0,n)}):i}},pseudos:{not:ce(function(e){var t=[],n=[],r=l(e.replace(j,"$1"));return r[b]?ce(function(e,t,n,i){var o,u=r(e,null,i,[]),l=e.length;while(l--)(o=u[l])&&(e[l]=!(t[l]=o));}):function(e,i,o){return t[0]=e,r(t,null,o,n),t[0]=null,!n.pop()}}),has:ce(function(e){return function(t){return le(e,t).length>0}}),contains:ce(function(e){return e=e.replace(te,ne),function(t){return (t.textContent||i(t)).indexOf(e)>-1}}),lang:ce(function(e){return J.test(e||"")||le.error("unsupported lang: "+e),e=e.replace(te,ne).toLowerCase(),function(t){var n;do{if(n=g?t.lang:t.getAttribute("xml:lang")||t.getAttribute("lang"))return (n=n.toLowerCase())===e||0===n.indexOf(e+"-")}while((t=t.parentNode)&&1===t.nodeType);return !1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===h},focus:function(e){return e===p.activeElement&&(!p.hasFocus||p.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:pe(!1),disabled:pe(!0),checked:function(e){var t=e.nodeName.toLowerCase();return "input"===t&&!!e.checked||"option"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType<6)return !1;return !0},parent:function(e){return !r.pseudos.empty(e)},header:function(e){return Y.test(e.nodeName)},input:function(e){return W.test(e.nodeName)},button:function(e){var t=e.nodeName.toLowerCase();return "input"===t&&"button"===e.type||"button"===t},text:function(e){var t;return "input"===e.nodeName.toLowerCase()&&"text"===e.type&&(null==(t=e.getAttribute("type"))||"text"===t.toLowerCase())},first:he(function(){return [0]}),last:he(function(e,t){return [t-1]}),eq:he(function(e,t,n){return [n<0?n+t:n]}),even:he(function(e,t){for(var n=0;n<t;n+=2)e.push(n);return e}),odd:he(function(e,t){for(var n=1;n<t;n+=2)e.push(n);return e}),lt:he(function(e,t,n){for(var r=n<0?n+t:n>t?t:n;--r>=0;)e.push(r);return e}),gt:he(function(e,t,n){for(var r=n<0?n+t:n;++r<t;)e.push(r);return e})}}).pseudos.nth=r.pseudos.eq;for(t in {radio:!0,checkbox:!0,file:!0,password:!0,image:!0})r.pseudos[t]=function(e){return function(t){return "input"===t.nodeName.toLowerCase()&&t.type===e}}(t);for(t in {submit:!0,reset:!0})r.pseudos[t]=function(e){return function(t){var n=t.nodeName.toLowerCase();return ("input"===n||"button"===n)&&t.type===e}}(t);function me(){}me.prototype=r.filters=r.pseudos,r.setFilters=new me,u=le.tokenize=function(e,t){var n,i,o,u,l,a,c,s=A[e+" "];if(s)return t?0:s.slice(0);l=e,a=[],c=r.preFilter;while(l){n&&!(i=G.exec(l))||(i&&(l=l.slice(i[0].length)||l),a.push(o=[])),n=!1,(i=U.exec(l))&&(n=i.shift(),o.push({value:n,type:i[0].replace(j," ")}),l=l.slice(n.length));for(u in r.filter)!(i=K[u].exec(l))||c[u]&&!(i=c[u](i))||(n=i.shift(),o.push({value:n,type:u,matches:i}),l=l.slice(n.length));if(!n)break}return t?l.length:l?le.error(e):A(e,a).slice(0)};function ye(e){for(var t=0,n=e.length,r="";t<n;t++)r+=e[t].value;return r}function ve(e,t,n){var r=t.dir,i=t.next,o=i||r,u=n&&"parentNode"===o,l=x++;return t.first?function(t,n,i){while(t=t[r])if(1===t.nodeType||u)return e(t,n,i);return !1}:function(t,n,a){var c,s,f,d=[C,l];if(a){while(t=t[r])if((1===t.nodeType||u)&&e(t,n,a))return !0}else while(t=t[r])if(1===t.nodeType||u)if(f=t[b]||(t[b]={}),s=f[t.uniqueID]||(f[t.uniqueID]={}),i&&i===t.nodeName.toLowerCase())t=t[r]||t;else {if((c=s[o])&&c[0]===C&&c[1]===l)return d[2]=c[2];if(s[o]=d,d[2]=e(t,n,a))return !0}return !1}}function we(e){return e.length>1?function(t,n,r){var i=e.length;while(i--)if(!e[i](t,n,r))return !1;return !0}:e[0]}function be(e,t,n){for(var r=0,i=t.length;r<i;r++)le(e,t[r],n);return n}function Ne(e,t,n,r,i){for(var o,u=[],l=0,a=e.length,c=null!=t;l<a;l++)(o=e[l])&&(n&&!n(o,r,i)||(u.push(o),c&&t.push(l)));return u}function Ce(e,t,n,r,i,o){return r&&!r[b]&&(r=Ce(r)),i&&!i[b]&&(i=Ce(i,o)),ce(function(o,u,l,a){var c,s,f,d=[],p=[],h=u.length,g=o||be(t||"*",l.nodeType?[l]:l,[]),m=!e||!o&&t?g:Ne(g,d,e,l,a),y=n?i||(o?e:h||r)?[]:u:m;if(n&&n(m,y,l,a),r){c=Ne(y,p),r(c,[],l,a),s=c.length;while(s--)(f=c[s])&&(y[p[s]]=!(m[p[s]]=f));}if(o){if(i||e){if(i){c=[],s=y.length;while(s--)(f=y[s])&&c.push(m[s]=f);i(null,y=[],c,a);}s=y.length;while(s--)(f=y[s])&&(c=i?k(o,f):d[s])>-1&&(o[c]=!(u[c]=f));}}else y=Ne(y===u?y.splice(h,y.length):y),i?i(null,u,y,a):R.apply(u,y);})}function xe(e){for(var t,n,i,o=e.length,u=r.relative[e[0].type],l=u||r.relative[" "],a=u?1:0,s=ve(function(e){return e===t},l,!0),f=ve(function(e){return k(t,e)>-1},l,!0),d=[function(e,n,r){var i=!u&&(r||n!==c)||((t=n).nodeType?s(e,n,r):f(e,n,r));return t=null,i}];a<o;a++)if(n=r.relative[e[a].type])d=[ve(we(d),n)];else {if((n=r.filter[e[a].type].apply(null,e[a].matches))[b]){for(i=++a;i<o;i++)if(r.relative[e[i].type])break;return Ce(a>1&&we(d),a>1&&ye(e.slice(0,a-1).concat({value:" "===e[a-2].type?"*":""})).replace(j,"$1"),n,a<i&&xe(e.slice(a,i)),i<o&&xe(e=e.slice(i)),i<o&&ye(e))}d.push(n);}return we(d)}function Ee(e,t){var n=t.length>0,i=e.length>0,o=function(o,u,l,a,s){var f,h,m,y=0,v="0",w=o&&[],b=[],N=c,x=o||i&&r.find.TAG("*",s),E=C+=null==N?1:Math.random()||.1,A=x.length;for(s&&(c=u==p||u||s);v!==A&&null!=(f=x[v]);v++){if(i&&f){h=0,u||f.ownerDocument==p||(d(f),l=!g);while(m=e[h++])if(m(f,u||p,l)){a.push(f);break}s&&(C=E);}n&&((f=!m&&f)&&y--,o&&w.push(f));}if(y+=v,n&&v!==y){h=0;while(m=t[h++])m(w,b,u,l);if(o){if(y>0)while(v--)w[v]||b[v]||(b[v]=I.call(a));b=Ne(b);}R.apply(a,b),s&&!o&&b.length>0&&y+t.length>1&&le.uniqueSort(a);}return s&&(C=E,c=N),w};return n?ce(o):o}l=le.compile=function(e,t){var n,r=[],i=[],o=S[e+" "];if(!o){t||(t=u(e)),n=t.length;while(n--)(o=xe(t[n]))[b]?r.push(o):i.push(o);(o=S(e,Ee(i,r))).selector=e;}return o},a=le.select=function(e,t,n,i){var o,a,c,s,f,d="function"==typeof e&&e,p=!i&&u(e=d.selector||e);if(n=n||[],1===p.length){if((a=p[0]=p[0].slice(0)).length>2&&"ID"===(c=a[0]).type&&9===t.nodeType&&g&&r.relative[a[1].type]){if(!(t=(r.find.ID(c.matches[0].replace(te,ne),t)||[])[0]))return n;d&&(t=t.parentNode),e=e.slice(a.shift().value.length);}o=K.needsContext.test(e)?0:a.length;while(o--){if(c=a[o],r.relative[s=c.type])break;if((f=r.find[s])&&(i=f(c.matches[0].replace(te,ne),ee.test(a[0].type)&&ge(t.parentNode)||t))){if(a.splice(o,1),!(e=i.length&&ye(a)))return R.apply(n,i),n;break}}}return (d||l(e,p))(i,t,!g,n,!t||ee.test(e)&&ge(t.parentNode)||t),n},n.sortStable=b.split("").sort(T).join("")===b,n.detectDuplicates=!!f,d(),n.sortDetached=se(function(e){return 1&e.compareDocumentPosition(p.createElement("fieldset"))}),se(function(e){return e.innerHTML="<a href='#'></a>","#"===e.firstChild.getAttribute("href")})||fe("type|href|height|width",function(e,t,n){if(!n)return e.getAttribute(t,"type"===t.toLowerCase()?1:2)}),n.attributes&&se(function(e){return e.innerHTML="<input/>",e.firstChild.setAttribute("value",""),""===e.firstChild.getAttribute("value")})||fe("value",function(e,t,n){if(!n&&"input"===e.nodeName.toLowerCase())return e.defaultValue}),se(function(e){return null==e.getAttribute("disabled")})||fe(H,function(e,t,n){var r;if(!n)return !0===e[t]?t.toLowerCase():(r=e.getAttributeNode(t))&&r.specified?r.value:null});var Ae=e.Sizzle;le.noConflict=function(){return e.Sizzle===le&&(e.Sizzle=Ae),le},"function"==typeof define&&define.amd?define(function(){return le}):"undefined"!=typeof module&&module.exports?module.exports=le:e.Sizzle=le;}(window);
//# sourceMappingURL=sizzle.min.map

return module.exports;
})();

function matches(selector, elm) {
  const r = Sizzle.matches(selector, [elm]);
  return r.length > 0;
}
function selectOne(selector, elm) {
  const r = Sizzle(selector, elm);
  return r[0] || null;
}
function selectAll(selector, elm) {
  return Sizzle(selector, elm);
}

function serializeNodeToHtml(elm, opts = {}) {
  const output = {
    currentLineWidth: 0,
    indent: 0,
    isWithinBody: false,
    text: [],
  };
  if (opts.prettyHtml) {
    if (typeof opts.indentSpaces !== 'number') {
      opts.indentSpaces = 2;
    }
    if (typeof opts.newLines !== 'boolean') {
      opts.newLines = true;
    }
    opts.approximateLineWidth = -1;
  }
  else {
    opts.prettyHtml = false;
    if (typeof opts.newLines !== 'boolean') {
      opts.newLines = false;
    }
    if (typeof opts.indentSpaces !== 'number') {
      opts.indentSpaces = 0;
    }
  }
  if (typeof opts.approximateLineWidth !== 'number') {
    opts.approximateLineWidth = -1;
  }
  if (typeof opts.removeEmptyAttributes !== 'boolean') {
    opts.removeEmptyAttributes = true;
  }
  if (typeof opts.removeAttributeQuotes !== 'boolean') {
    opts.removeAttributeQuotes = false;
  }
  if (typeof opts.removeBooleanAttributeQuotes !== 'boolean') {
    opts.removeBooleanAttributeQuotes = false;
  }
  if (typeof opts.removeHtmlComments !== 'boolean') {
    opts.removeHtmlComments = false;
  }
  if (typeof opts.serializeShadowRoot !== 'boolean') {
    opts.serializeShadowRoot = false;
  }
  if (opts.outerHtml) {
    serializeToHtml(elm, opts, output, false);
  }
  else {
    for (let i = 0, ii = elm.childNodes.length; i < ii; i++) {
      serializeToHtml(elm.childNodes[i], opts, output, false);
    }
  }
  if (output.text[0] === '\n') {
    output.text.shift();
  }
  if (output.text[output.text.length - 1] === '\n') {
    output.text.pop();
  }
  return output.text.join('');
}
function serializeToHtml(node, opts, output, isShadowRoot) {
  if (node.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */ || isShadowRoot) {
    const tagName = isShadowRoot ? 'mock:shadow-root' : getTagName(node);
    if (tagName === 'body') {
      output.isWithinBody = true;
    }
    const ignoreTag = opts.excludeTags != null && opts.excludeTags.includes(tagName);
    if (ignoreTag === false) {
      const isWithinWhitespaceSensitiveNode = opts.newLines || opts.indentSpaces > 0 ? isWithinWhitespaceSensitive(node) : false;
      if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
        output.text.push('\n');
        output.currentLineWidth = 0;
      }
      if (opts.indentSpaces > 0 && !isWithinWhitespaceSensitiveNode) {
        for (let i = 0; i < output.indent; i++) {
          output.text.push(' ');
        }
        output.currentLineWidth += output.indent;
      }
      output.text.push('<' + tagName);
      output.currentLineWidth += tagName.length + 1;
      const attrsLength = node.attributes.length;
      const attributes = opts.prettyHtml && attrsLength > 1
        ? cloneAttributes(node.attributes, true)
        : node.attributes;
      for (let i = 0; i < attrsLength; i++) {
        const attr = attributes.item(i);
        const attrName = attr.name;
        if (attrName === 'style') {
          continue;
        }
        let attrValue = attr.value;
        if (opts.removeEmptyAttributes && attrValue === '' && REMOVE_EMPTY_ATTR.has(attrName)) {
          continue;
        }
        const attrNamespaceURI = attr.namespaceURI;
        if (attrNamespaceURI == null) {
          output.currentLineWidth += attrName.length + 1;
          if (opts.approximateLineWidth > 0 && output.currentLineWidth > opts.approximateLineWidth) {
            output.text.push('\n' + attrName);
            output.currentLineWidth = 0;
          }
          else {
            output.text.push(' ' + attrName);
          }
        }
        else if (attrNamespaceURI === 'http://www.w3.org/XML/1998/namespace') {
          output.text.push(' xml:' + attrName);
          output.currentLineWidth += attrName.length + 5;
        }
        else if (attrNamespaceURI === 'http://www.w3.org/2000/xmlns/') {
          if (attrName !== 'xmlns') {
            output.text.push(' xmlns:' + attrName);
            output.currentLineWidth += attrName.length + 7;
          }
          else {
            output.text.push(' ' + attrName);
            output.currentLineWidth += attrName.length + 1;
          }
        }
        else if (attrNamespaceURI === XLINK_NS) {
          output.text.push(' xlink:' + attrName);
          output.currentLineWidth += attrName.length + 7;
        }
        else {
          output.text.push(' ' + attrNamespaceURI + ':' + attrName);
          output.currentLineWidth += attrNamespaceURI.length + attrName.length + 2;
        }
        if (opts.prettyHtml && attrName === 'class') {
          attrValue = attr.value = attrValue
            .split(' ')
            .filter((t) => t !== '')
            .sort()
            .join(' ')
            .trim();
        }
        if (attrValue === '') {
          if (opts.removeBooleanAttributeQuotes && BOOLEAN_ATTR.has(attrName)) {
            continue;
          }
          if (opts.removeEmptyAttributes && attrName.startsWith('data-')) {
            continue;
          }
        }
        if (opts.removeAttributeQuotes && CAN_REMOVE_ATTR_QUOTES.test(attrValue)) {
          output.text.push('=' + escapeString(attrValue, true));
          output.currentLineWidth += attrValue.length + 1;
        }
        else {
          output.text.push('="' + escapeString(attrValue, true) + '"');
          output.currentLineWidth += attrValue.length + 3;
        }
      }
      if (node.hasAttribute('style')) {
        const cssText = node.style.cssText;
        if (opts.approximateLineWidth > 0 &&
          output.currentLineWidth + cssText.length + 10 > opts.approximateLineWidth) {
          output.text.push(`\nstyle="${cssText}">`);
          output.currentLineWidth = 0;
        }
        else {
          output.text.push(` style="${cssText}">`);
          output.currentLineWidth += cssText.length + 10;
        }
      }
      else {
        output.text.push('>');
        output.currentLineWidth += 1;
      }
    }
    if (EMPTY_ELEMENTS.has(tagName) === false) {
      if (opts.serializeShadowRoot && node.shadowRoot != null) {
        output.indent = output.indent + opts.indentSpaces;
        serializeToHtml(node.shadowRoot, opts, output, true);
        output.indent = output.indent - opts.indentSpaces;
        if (opts.newLines &&
          (node.childNodes.length === 0 ||
            (node.childNodes.length === 1 &&
              node.childNodes[0].nodeType === 3 /* NODE_TYPES.TEXT_NODE */ &&
              node.childNodes[0].nodeValue.trim() === ''))) {
          output.text.push('\n');
          output.currentLineWidth = 0;
          for (let i = 0; i < output.indent; i++) {
            output.text.push(' ');
          }
          output.currentLineWidth += output.indent;
        }
      }
      if (opts.excludeTagContent == null || opts.excludeTagContent.includes(tagName) === false) {
        const childNodes = tagName === 'template' ? node.content.childNodes : node.childNodes;
        const childNodeLength = childNodes.length;
        if (childNodeLength > 0) {
          if (childNodeLength === 1 &&
            childNodes[0].nodeType === 3 /* NODE_TYPES.TEXT_NODE */ &&
            (typeof childNodes[0].nodeValue !== 'string' || childNodes[0].nodeValue.trim() === '')) ;
          else {
            const isWithinWhitespaceSensitiveNode = opts.newLines || opts.indentSpaces > 0 ? isWithinWhitespaceSensitive(node) : false;
            if (!isWithinWhitespaceSensitiveNode && opts.indentSpaces > 0 && ignoreTag === false) {
              output.indent = output.indent + opts.indentSpaces;
            }
            for (let i = 0; i < childNodeLength; i++) {
              serializeToHtml(childNodes[i], opts, output, false);
            }
            if (ignoreTag === false) {
              if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
                output.text.push('\n');
                output.currentLineWidth = 0;
              }
              if (opts.indentSpaces > 0 && !isWithinWhitespaceSensitiveNode) {
                output.indent = output.indent - opts.indentSpaces;
                for (let i = 0; i < output.indent; i++) {
                  output.text.push(' ');
                }
                output.currentLineWidth += output.indent;
              }
            }
          }
        }
        if (ignoreTag === false) {
          output.text.push('</' + tagName + '>');
          output.currentLineWidth += tagName.length + 3;
        }
      }
    }
    if (opts.approximateLineWidth > 0 && STRUCTURE_ELEMENTS.has(tagName)) {
      output.text.push('\n');
      output.currentLineWidth = 0;
    }
    if (tagName === 'body') {
      output.isWithinBody = false;
    }
  }
  else if (node.nodeType === 3 /* NODE_TYPES.TEXT_NODE */) {
    let textContent = node.nodeValue;
    if (typeof textContent === 'string') {
      const trimmedTextContent = textContent.trim();
      if (trimmedTextContent === '') {
        // this text node is whitespace only
        if (isWithinWhitespaceSensitive(node)) {
          // whitespace matters within this element
          // just add the exact text we were given
          output.text.push(textContent);
          output.currentLineWidth += textContent.length;
        }
        else if (opts.approximateLineWidth > 0 && !output.isWithinBody) ;
        else if (!opts.prettyHtml) {
          // this text node is only whitespace, and it's not
          // within a whitespace sensitive element like <pre> or <code>
          // so replace the entire white space with a single new line
          output.currentLineWidth += 1;
          if (opts.approximateLineWidth > 0 && output.currentLineWidth > opts.approximateLineWidth) {
            // good enough for a new line
            // for perf these are all just estimates
            // we don't care to ensure exact line lengths
            output.text.push('\n');
            output.currentLineWidth = 0;
          }
          else {
            // let's keep it all on the same line yet
            output.text.push(' ');
          }
        }
      }
      else {
        // this text node has text content
        const isWithinWhitespaceSensitiveNode = opts.newLines || opts.indentSpaces > 0 || opts.prettyHtml ? isWithinWhitespaceSensitive(node) : false;
        if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
          output.text.push('\n');
          output.currentLineWidth = 0;
        }
        if (opts.indentSpaces > 0 && !isWithinWhitespaceSensitiveNode) {
          for (let i = 0; i < output.indent; i++) {
            output.text.push(' ');
          }
          output.currentLineWidth += output.indent;
        }
        let textContentLength = textContent.length;
        if (textContentLength > 0) {
          // this text node has text content
          const parentTagName = node.parentNode != null && node.parentNode.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */
            ? node.parentNode.nodeName
            : null;
          if (NON_ESCAPABLE_CONTENT.has(parentTagName)) {
            // this text node cannot have its content escaped since it's going
            // into an element like <style> or <script>
            if (isWithinWhitespaceSensitive(node)) {
              output.text.push(textContent);
            }
            else {
              output.text.push(trimmedTextContent);
              textContentLength = trimmedTextContent.length;
            }
            output.currentLineWidth += textContentLength;
          }
          else {
            // this text node is going into a normal element and html can be escaped
            if (opts.prettyHtml && !isWithinWhitespaceSensitiveNode) {
              // pretty print the text node
              output.text.push(escapeString(textContent.replace(/\s\s+/g, ' ').trim(), false));
              output.currentLineWidth += textContentLength;
            }
            else {
              // not pretty printing the text node
              if (isWithinWhitespaceSensitive(node)) {
                output.currentLineWidth += textContentLength;
              }
              else {
                // this element is not a whitespace sensitive one, like <pre> or <code> so
                // any whitespace at the start and end can be cleaned up to just be one space
                if (/\s/.test(textContent.charAt(0))) {
                  textContent = ' ' + textContent.trimLeft();
                }
                textContentLength = textContent.length;
                if (textContentLength > 1) {
                  if (/\s/.test(textContent.charAt(textContentLength - 1))) {
                    if (opts.approximateLineWidth > 0 &&
                      output.currentLineWidth + textContentLength > opts.approximateLineWidth) {
                      textContent = textContent.trimRight() + '\n';
                      output.currentLineWidth = 0;
                    }
                    else {
                      textContent = textContent.trimRight() + ' ';
                    }
                  }
                }
                output.currentLineWidth += textContentLength;
              }
              output.text.push(escapeString(textContent, false));
            }
          }
        }
      }
    }
  }
  else if (node.nodeType === 8 /* NODE_TYPES.COMMENT_NODE */) {
    const nodeValue = node.nodeValue;
    if (opts.removeHtmlComments) {
      const isHydrateAnnotation = nodeValue.startsWith(CONTENT_REF_ID + '.') ||
        nodeValue.startsWith(ORG_LOCATION_ID + '.') ||
        nodeValue.startsWith(SLOT_NODE_ID + '.') ||
        nodeValue.startsWith(TEXT_NODE_ID + '.');
      if (!isHydrateAnnotation) {
        return;
      }
    }
    const isWithinWhitespaceSensitiveNode = opts.newLines || opts.indentSpaces > 0 ? isWithinWhitespaceSensitive(node) : false;
    if (opts.newLines && !isWithinWhitespaceSensitiveNode) {
      output.text.push('\n');
      output.currentLineWidth = 0;
    }
    if (opts.indentSpaces > 0 && !isWithinWhitespaceSensitiveNode) {
      for (let i = 0; i < output.indent; i++) {
        output.text.push(' ');
      }
      output.currentLineWidth += output.indent;
    }
    output.text.push('<!--' + nodeValue + '-->');
    output.currentLineWidth += nodeValue.length + 7;
  }
  else if (node.nodeType === 10 /* NODE_TYPES.DOCUMENT_TYPE_NODE */) {
    output.text.push('<!doctype html>');
  }
}
const AMP_REGEX = /&/g;
const NBSP_REGEX = /\u00a0/g;
const DOUBLE_QUOTE_REGEX = /"/g;
const LT_REGEX = /</g;
const GT_REGEX = />/g;
const CAN_REMOVE_ATTR_QUOTES = /^[^ \t\n\f\r"'`=<>\/\\-]+$/;
function getTagName(element) {
  if (element.namespaceURI === 'http://www.w3.org/1999/xhtml') {
    return element.nodeName.toLowerCase();
  }
  else {
    return element.nodeName;
  }
}
function escapeString(str, attrMode) {
  str = str.replace(AMP_REGEX, '&amp;').replace(NBSP_REGEX, '&nbsp;');
  if (attrMode) {
    return str.replace(DOUBLE_QUOTE_REGEX, '&quot;');
  }
  return str.replace(LT_REGEX, '&lt;').replace(GT_REGEX, '&gt;');
}
function isWithinWhitespaceSensitive(node) {
  while (node != null) {
    if (WHITESPACE_SENSITIVE.has(node.nodeName)) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
}
/*@__PURE__*/ const NON_ESCAPABLE_CONTENT = new Set([
  'STYLE',
  'SCRIPT',
  'IFRAME',
  'NOSCRIPT',
  'XMP',
  'NOEMBED',
  'NOFRAMES',
  'PLAINTEXT',
]);
/*@__PURE__*/ const WHITESPACE_SENSITIVE = new Set([
  'CODE',
  'OUTPUT',
  'PLAINTEXT',
  'PRE',
  'SCRIPT',
  'TEMPLATE',
  'TEXTAREA',
]);
/*@__PURE__*/ const EMPTY_ELEMENTS = new Set([
  'area',
  'base',
  'basefont',
  'bgsound',
  'br',
  'col',
  'embed',
  'frame',
  'hr',
  'img',
  'input',
  'keygen',
  'link',
  'meta',
  'param',
  'source',
  'trace',
  'wbr',
]);
/*@__PURE__*/ const REMOVE_EMPTY_ATTR = new Set(['class', 'dir', 'id', 'lang', 'name', 'title']);
/*@__PURE__*/ const BOOLEAN_ATTR = new Set([
  'allowfullscreen',
  'async',
  'autofocus',
  'autoplay',
  'checked',
  'compact',
  'controls',
  'declare',
  'default',
  'defaultchecked',
  'defaultmuted',
  'defaultselected',
  'defer',
  'disabled',
  'enabled',
  'formnovalidate',
  'hidden',
  'indeterminate',
  'inert',
  'ismap',
  'itemscope',
  'loop',
  'multiple',
  'muted',
  'nohref',
  'nomodule',
  'noresize',
  'noshade',
  'novalidate',
  'nowrap',
  'open',
  'pauseonexit',
  'readonly',
  'required',
  'reversed',
  'scoped',
  'seamless',
  'selected',
  'sortable',
  'truespeed',
  'typemustmatch',
  'visible',
]);
/*@__PURE__*/ const STRUCTURE_ELEMENTS = new Set([
  'html',
  'body',
  'head',
  'iframe',
  'meta',
  'link',
  'base',
  'title',
  'script',
  'style',
]);

class MockNode {
  constructor(ownerDocument, nodeType, nodeName, nodeValue) {
    this.ownerDocument = ownerDocument;
    this.nodeType = nodeType;
    this.nodeName = nodeName;
    this._nodeValue = nodeValue;
    this.parentNode = null;
    this.childNodes = [];
  }
  appendChild(newNode) {
    if (newNode.nodeType === 11 /* NODE_TYPES.DOCUMENT_FRAGMENT_NODE */) {
      const nodes = newNode.childNodes.slice();
      for (const child of nodes) {
        this.appendChild(child);
      }
    }
    else {
      newNode.remove();
      newNode.parentNode = this;
      this.childNodes.push(newNode);
      connectNode(this.ownerDocument, newNode);
    }
    return newNode;
  }
  append(...items) {
    items.forEach((item) => {
      const isNode = typeof item === 'object' && item !== null && 'nodeType' in item;
      this.appendChild(isNode ? item : this.ownerDocument.createTextNode(String(item)));
    });
  }
  prepend(...items) {
    const firstChild = this.firstChild;
    items.forEach((item) => {
      const isNode = typeof item === 'object' && item !== null && 'nodeType' in item;
      if (firstChild) {
        this.insertBefore(isNode ? item : this.ownerDocument.createTextNode(String(item)), firstChild);
      }
    });
  }
  cloneNode(deep) {
    throw new Error(`invalid node type to clone: ${this.nodeType}, deep: ${deep}`);
  }
  compareDocumentPosition(_other) {
    // unimplemented
    // https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
    return -1;
  }
  get firstChild() {
    return this.childNodes[0] || null;
  }
  insertBefore(newNode, referenceNode) {
    if (newNode.nodeType === 11 /* NODE_TYPES.DOCUMENT_FRAGMENT_NODE */) {
      for (let i = 0, ii = newNode.childNodes.length; i < ii; i++) {
        insertBefore(this, newNode.childNodes[i], referenceNode);
      }
    }
    else {
      insertBefore(this, newNode, referenceNode);
    }
    return newNode;
  }
  get isConnected() {
    let node = this;
    while (node != null) {
      if (node.nodeType === 9 /* NODE_TYPES.DOCUMENT_NODE */) {
        return true;
      }
      node = node.parentNode;
      if (node != null && node.nodeType === 11 /* NODE_TYPES.DOCUMENT_FRAGMENT_NODE */) {
        node = node.host;
      }
    }
    return false;
  }
  isSameNode(node) {
    return this === node;
  }
  get lastChild() {
    return this.childNodes[this.childNodes.length - 1] || null;
  }
  get nextSibling() {
    if (this.parentNode != null) {
      const index = this.parentNode.childNodes.indexOf(this) + 1;
      return this.parentNode.childNodes[index] || null;
    }
    return null;
  }
  get nodeValue() {
    var _a;
    return (_a = this._nodeValue) !== null && _a !== void 0 ? _a : '';
  }
  set nodeValue(value) {
    this._nodeValue = value;
  }
  get parentElement() {
    return this.parentNode || null;
  }
  set parentElement(value) {
    this.parentNode = value;
  }
  get previousSibling() {
    if (this.parentNode != null) {
      const index = this.parentNode.childNodes.indexOf(this) - 1;
      return this.parentNode.childNodes[index] || null;
    }
    return null;
  }
  contains(otherNode) {
    if (otherNode === this) {
      return true;
    }
    const childNodes = Array.from(this.childNodes);
    if (childNodes.includes(otherNode)) {
      return true;
    }
    return childNodes.some((node) => this.contains.bind(node)(otherNode));
  }
  removeChild(childNode) {
    const index = this.childNodes.indexOf(childNode);
    if (index > -1) {
      this.childNodes.splice(index, 1);
      if (this.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */) {
        const wasConnected = this.isConnected;
        childNode.parentNode = null;
        if (wasConnected === true) {
          disconnectNode(childNode);
        }
      }
      else {
        childNode.parentNode = null;
      }
    }
    else {
      throw new Error(`node not found within childNodes during removeChild`);
    }
    return childNode;
  }
  remove() {
    if (this.parentNode != null) {
      this.parentNode.removeChild(this);
    }
  }
  replaceChild(newChild, oldChild) {
    if (oldChild.parentNode === this) {
      this.insertBefore(newChild, oldChild);
      oldChild.remove();
      return newChild;
    }
    return null;
  }
  get textContent() {
    var _a;
    return (_a = this._nodeValue) !== null && _a !== void 0 ? _a : '';
  }
  set textContent(value) {
    this._nodeValue = String(value);
  }
}
MockNode.ELEMENT_NODE = 1;
MockNode.TEXT_NODE = 3;
MockNode.PROCESSING_INSTRUCTION_NODE = 7;
MockNode.COMMENT_NODE = 8;
MockNode.DOCUMENT_NODE = 9;
MockNode.DOCUMENT_TYPE_NODE = 10;
MockNode.DOCUMENT_FRAGMENT_NODE = 11;
class MockNodeList {
  constructor(ownerDocument, childNodes, length) {
    this.ownerDocument = ownerDocument;
    this.childNodes = childNodes;
    this.length = length;
  }
}
class MockElement extends MockNode {
  constructor(ownerDocument, nodeName) {
    super(ownerDocument, 1 /* NODE_TYPES.ELEMENT_NODE */, typeof nodeName === 'string' ? nodeName : null, null);
    this.namespaceURI = null;
    this.__shadowRoot = null;
    this.__attributeMap = null;
  }
  addEventListener(type, handler) {
    addEventListener(this, type, handler);
  }
  attachShadow(_opts) {
    const shadowRoot = this.ownerDocument.createDocumentFragment();
    this.shadowRoot = shadowRoot;
    return shadowRoot;
  }
  blur() {
    dispatchEvent(this, new MockFocusEvent('blur', { relatedTarget: null, bubbles: true, cancelable: true, composed: true }));
  }
  get shadowRoot() {
    return this.__shadowRoot || null;
  }
  set shadowRoot(shadowRoot) {
    if (shadowRoot != null) {
      shadowRoot.host = this;
      this.__shadowRoot = shadowRoot;
    }
    else {
      delete this.__shadowRoot;
    }
  }
  get attributes() {
    if (this.__attributeMap == null) {
      const attrMap = createAttributeProxy(false);
      this.__attributeMap = attrMap;
      return attrMap;
    }
    return this.__attributeMap;
  }
  set attributes(attrs) {
    this.__attributeMap = attrs;
  }
  get children() {
    return this.childNodes.filter((n) => n.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */);
  }
  get childElementCount() {
    return this.childNodes.filter((n) => n.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */).length;
  }
  get className() {
    return this.getAttributeNS(null, 'class') || '';
  }
  set className(value) {
    this.setAttributeNS(null, 'class', value);
  }
  get classList() {
    return new MockClassList(this);
  }
  click() {
    dispatchEvent(this, new MockEvent('click', { bubbles: true, cancelable: true, composed: true }));
  }
  cloneNode(_deep) {
    // implemented on MockElement.prototype from within element.ts
    // @ts-ignore - implemented on MockElement.prototype from within element.ts
    return null;
  }
  closest(selector) {
    let elm = this;
    while (elm != null) {
      if (elm.matches(selector)) {
        return elm;
      }
      elm = elm.parentNode;
    }
    return null;
  }
  get dataset() {
    return dataset(this);
  }
  get dir() {
    return this.getAttributeNS(null, 'dir') || '';
  }
  set dir(value) {
    this.setAttributeNS(null, 'dir', value);
  }
  dispatchEvent(ev) {
    return dispatchEvent(this, ev);
  }
  get firstElementChild() {
    return this.children[0] || null;
  }
  focus(_options) {
    dispatchEvent(this, new MockFocusEvent('focus', { relatedTarget: null, bubbles: true, cancelable: true, composed: true }));
  }
  getAttribute(attrName) {
    if (attrName === 'style') {
      if (this.__style != null && this.__style.length > 0) {
        return this.style.cssText;
      }
      return null;
    }
    const attr = this.attributes.getNamedItem(attrName);
    if (attr != null) {
      return attr.value;
    }
    return null;
  }
  getAttributeNS(namespaceURI, attrName) {
    const attr = this.attributes.getNamedItemNS(namespaceURI, attrName);
    if (attr != null) {
      return attr.value;
    }
    return null;
  }
  getBoundingClientRect() {
    return { bottom: 0, height: 0, left: 0, right: 0, top: 0, width: 0, x: 0, y: 0 };
  }
  getRootNode(opts) {
    const isComposed = opts != null && opts.composed === true;
    let node = this;
    while (node.parentNode != null) {
      node = node.parentNode;
      if (isComposed === true && node.parentNode == null && node.host != null) {
        node = node.host;
      }
    }
    return node;
  }
  get draggable() {
    return this.getAttributeNS(null, 'draggable') === 'true';
  }
  set draggable(value) {
    this.setAttributeNS(null, 'draggable', value);
  }
  hasChildNodes() {
    return this.childNodes.length > 0;
  }
  get id() {
    return this.getAttributeNS(null, 'id') || '';
  }
  set id(value) {
    this.setAttributeNS(null, 'id', value);
  }
  get innerHTML() {
    if (this.childNodes.length === 0) {
      return '';
    }
    return serializeNodeToHtml(this, {
      newLines: false,
      indentSpaces: 0,
    });
  }
  set innerHTML(html) {
    var _a;
    if (NON_ESCAPABLE_CONTENT.has((_a = this.nodeName) !== null && _a !== void 0 ? _a : '') === true) {
      setTextContent(this, html);
    }
    else {
      for (let i = this.childNodes.length - 1; i >= 0; i--) {
        this.removeChild(this.childNodes[i]);
      }
      if (typeof html === 'string') {
        const frag = parseFragmentUtil(this.ownerDocument, html);
        while (frag.childNodes.length > 0) {
          this.appendChild(frag.childNodes[0]);
        }
      }
    }
  }
  get innerText() {
    const text = [];
    getTextContent(this.childNodes, text);
    return text.join('');
  }
  set innerText(value) {
    setTextContent(this, value);
  }
  insertAdjacentElement(position, elm) {
    if (position === 'beforebegin') {
      insertBefore(this.parentNode, elm, this);
    }
    else if (position === 'afterbegin') {
      this.prepend(elm);
    }
    else if (position === 'beforeend') {
      this.appendChild(elm);
    }
    else if (position === 'afterend') {
      insertBefore(this.parentNode, elm, this.nextSibling);
    }
    return elm;
  }
  insertAdjacentHTML(position, html) {
    const frag = parseFragmentUtil(this.ownerDocument, html);
    if (position === 'beforebegin') {
      while (frag.childNodes.length > 0) {
        insertBefore(this.parentNode, frag.childNodes[0], this);
      }
    }
    else if (position === 'afterbegin') {
      while (frag.childNodes.length > 0) {
        this.prepend(frag.childNodes[frag.childNodes.length - 1]);
      }
    }
    else if (position === 'beforeend') {
      while (frag.childNodes.length > 0) {
        this.appendChild(frag.childNodes[0]);
      }
    }
    else if (position === 'afterend') {
      while (frag.childNodes.length > 0) {
        insertBefore(this.parentNode, frag.childNodes[frag.childNodes.length - 1], this.nextSibling);
      }
    }
  }
  insertAdjacentText(position, text) {
    const elm = this.ownerDocument.createTextNode(text);
    if (position === 'beforebegin') {
      insertBefore(this.parentNode, elm, this);
    }
    else if (position === 'afterbegin') {
      this.prepend(elm);
    }
    else if (position === 'beforeend') {
      this.appendChild(elm);
    }
    else if (position === 'afterend') {
      insertBefore(this.parentNode, elm, this.nextSibling);
    }
  }
  hasAttribute(attrName) {
    if (attrName === 'style') {
      return this.__style != null && this.__style.length > 0;
    }
    return this.getAttribute(attrName) !== null;
  }
  hasAttributeNS(namespaceURI, name) {
    return this.getAttributeNS(namespaceURI, name) !== null;
  }
  get hidden() {
    return this.hasAttributeNS(null, 'hidden');
  }
  set hidden(isHidden) {
    if (isHidden === true) {
      this.setAttributeNS(null, 'hidden', '');
    }
    else {
      this.removeAttributeNS(null, 'hidden');
    }
  }
  get lang() {
    return this.getAttributeNS(null, 'lang') || '';
  }
  set lang(value) {
    this.setAttributeNS(null, 'lang', value);
  }
  get lastElementChild() {
    const children = this.children;
    return children[children.length - 1] || null;
  }
  matches(selector) {
    return matches(selector, this);
  }
  get nextElementSibling() {
    const parentElement = this.parentElement;
    if (parentElement != null &&
      (parentElement.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */ ||
        parentElement.nodeType === 11 /* NODE_TYPES.DOCUMENT_FRAGMENT_NODE */ ||
        parentElement.nodeType === 9 /* NODE_TYPES.DOCUMENT_NODE */)) {
      const children = parentElement.children;
      const index = children.indexOf(this) + 1;
      return parentElement.children[index] || null;
    }
    return null;
  }
  get outerHTML() {
    return serializeNodeToHtml(this, {
      newLines: false,
      outerHtml: true,
      indentSpaces: 0,
    });
  }
  get previousElementSibling() {
    const parentElement = this.parentElement;
    if (parentElement != null &&
      (parentElement.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */ ||
        parentElement.nodeType === 11 /* NODE_TYPES.DOCUMENT_FRAGMENT_NODE */ ||
        parentElement.nodeType === 9 /* NODE_TYPES.DOCUMENT_NODE */)) {
      const children = parentElement.children;
      const index = children.indexOf(this) - 1;
      return parentElement.children[index] || null;
    }
    return null;
  }
  getElementsByClassName(classNames) {
    const classes = classNames
      .trim()
      .split(' ')
      .filter((c) => c.length > 0);
    const results = [];
    getElementsByClassName(this, classes, results);
    return results;
  }
  getElementsByTagName(tagName) {
    const results = [];
    getElementsByTagName(this, tagName.toLowerCase(), results);
    return results;
  }
  querySelector(selector) {
    return selectOne(selector, this);
  }
  querySelectorAll(selector) {
    return selectAll(selector, this);
  }
  removeAttribute(attrName) {
    if (attrName === 'style') {
      delete this.__style;
    }
    else {
      const attr = this.attributes.getNamedItem(attrName);
      if (attr != null) {
        this.attributes.removeNamedItemNS(attr);
        if (checkAttributeChanged(this) === true) {
          attributeChanged(this, attrName, attr.value, null);
        }
      }
    }
  }
  removeAttributeNS(namespaceURI, attrName) {
    const attr = this.attributes.getNamedItemNS(namespaceURI, attrName);
    if (attr != null) {
      this.attributes.removeNamedItemNS(attr);
      if (checkAttributeChanged(this) === true) {
        attributeChanged(this, attrName, attr.value, null);
      }
    }
  }
  removeEventListener(type, handler) {
    removeEventListener(this, type, handler);
  }
  setAttribute(attrName, value) {
    if (attrName === 'style') {
      this.style = value;
    }
    else {
      const attributes = this.attributes;
      let attr = attributes.getNamedItem(attrName);
      const checkAttrChanged = checkAttributeChanged(this);
      if (attr != null) {
        if (checkAttrChanged === true) {
          const oldValue = attr.value;
          attr.value = value;
          if (oldValue !== attr.value) {
            attributeChanged(this, attr.name, oldValue, attr.value);
          }
        }
        else {
          attr.value = value;
        }
      }
      else {
        if (attributes.caseInsensitive) {
          attrName = attrName.toLowerCase();
        }
        attr = new MockAttr(attrName, value);
        attributes.__items.push(attr);
        if (checkAttrChanged === true) {
          attributeChanged(this, attrName, null, attr.value);
        }
      }
    }
  }
  setAttributeNS(namespaceURI, attrName, value) {
    const attributes = this.attributes;
    let attr = attributes.getNamedItemNS(namespaceURI, attrName);
    const checkAttrChanged = checkAttributeChanged(this);
    if (attr != null) {
      if (checkAttrChanged === true) {
        const oldValue = attr.value;
        attr.value = value;
        if (oldValue !== attr.value) {
          attributeChanged(this, attr.name, oldValue, attr.value);
        }
      }
      else {
        attr.value = value;
      }
    }
    else {
      attr = new MockAttr(attrName, value, namespaceURI);
      attributes.__items.push(attr);
      if (checkAttrChanged === true) {
        attributeChanged(this, attrName, null, attr.value);
      }
    }
  }
  get style() {
    if (this.__style == null) {
      this.__style = createCSSStyleDeclaration();
    }
    return this.__style;
  }
  set style(val) {
    if (typeof val === 'string') {
      if (this.__style == null) {
        this.__style = createCSSStyleDeclaration();
      }
      this.__style.cssText = val;
    }
    else {
      this.__style = val;
    }
  }
  get tabIndex() {
    return parseInt(this.getAttributeNS(null, 'tabindex') || '-1', 10);
  }
  set tabIndex(value) {
    this.setAttributeNS(null, 'tabindex', value);
  }
  get tagName() {
    var _a;
    return (_a = this.nodeName) !== null && _a !== void 0 ? _a : '';
  }
  set tagName(value) {
    this.nodeName = value;
  }
  get textContent() {
    const text = [];
    getTextContent(this.childNodes, text);
    return text.join('');
  }
  set textContent(value) {
    setTextContent(this, value);
  }
  get title() {
    return this.getAttributeNS(null, 'title') || '';
  }
  set title(value) {
    this.setAttributeNS(null, 'title', value);
  }
  animate() {
    /**/
  }
  onanimationstart() {
    /**/
  }
  onanimationend() {
    /**/
  }
  onanimationiteration() {
    /**/
  }
  onabort() {
    /**/
  }
  onauxclick() {
    /**/
  }
  onbeforecopy() {
    /**/
  }
  onbeforecut() {
    /**/
  }
  onbeforepaste() {
    /**/
  }
  onblur() {
    /**/
  }
  oncancel() {
    /**/
  }
  oncanplay() {
    /**/
  }
  oncanplaythrough() {
    /**/
  }
  onchange() {
    /**/
  }
  onclick() {
    /**/
  }
  onclose() {
    /**/
  }
  oncontextmenu() {
    /**/
  }
  oncopy() {
    /**/
  }
  oncuechange() {
    /**/
  }
  oncut() {
    /**/
  }
  ondblclick() {
    /**/
  }
  ondrag() {
    /**/
  }
  ondragend() {
    /**/
  }
  ondragenter() {
    /**/
  }
  ondragleave() {
    /**/
  }
  ondragover() {
    /**/
  }
  ondragstart() {
    /**/
  }
  ondrop() {
    /**/
  }
  ondurationchange() {
    /**/
  }
  onemptied() {
    /**/
  }
  onended() {
    /**/
  }
  onerror() {
    /**/
  }
  onfocus() {
    /**/
  }
  onfocusin() {
    /**/
  }
  onfocusout() {
    /**/
  }
  onformdata() {
    /**/
  }
  onfullscreenchange() {
    /**/
  }
  onfullscreenerror() {
    /**/
  }
  ongotpointercapture() {
    /**/
  }
  oninput() {
    /**/
  }
  oninvalid() {
    /**/
  }
  onkeydown() {
    /**/
  }
  onkeypress() {
    /**/
  }
  onkeyup() {
    /**/
  }
  onload() {
    /**/
  }
  onloadeddata() {
    /**/
  }
  onloadedmetadata() {
    /**/
  }
  onloadstart() {
    /**/
  }
  onlostpointercapture() {
    /**/
  }
  onmousedown() {
    /**/
  }
  onmouseenter() {
    /**/
  }
  onmouseleave() {
    /**/
  }
  onmousemove() {
    /**/
  }
  onmouseout() {
    /**/
  }
  onmouseover() {
    /**/
  }
  onmouseup() {
    /**/
  }
  onmousewheel() {
    /**/
  }
  onpaste() {
    /**/
  }
  onpause() {
    /**/
  }
  onplay() {
    /**/
  }
  onplaying() {
    /**/
  }
  onpointercancel() {
    /**/
  }
  onpointerdown() {
    /**/
  }
  onpointerenter() {
    /**/
  }
  onpointerleave() {
    /**/
  }
  onpointermove() {
    /**/
  }
  onpointerout() {
    /**/
  }
  onpointerover() {
    /**/
  }
  onpointerup() {
    /**/
  }
  onprogress() {
    /**/
  }
  onratechange() {
    /**/
  }
  onreset() {
    /**/
  }
  onresize() {
    /**/
  }
  onscroll() {
    /**/
  }
  onsearch() {
    /**/
  }
  onseeked() {
    /**/
  }
  onseeking() {
    /**/
  }
  onselect() {
    /**/
  }
  onselectstart() {
    /**/
  }
  onstalled() {
    /**/
  }
  onsubmit() {
    /**/
  }
  onsuspend() {
    /**/
  }
  ontimeupdate() {
    /**/
  }
  ontoggle() {
    /**/
  }
  onvolumechange() {
    /**/
  }
  onwaiting() {
    /**/
  }
  onwebkitfullscreenchange() {
    /**/
  }
  onwebkitfullscreenerror() {
    /**/
  }
  onwheel() {
    /**/
  }
  requestFullscreen() {
    /**/
  }
  scrollBy() {
    /**/
  }
  scrollTo() {
    /**/
  }
  scrollIntoView() {
    /**/
  }
  toString(opts) {
    return serializeNodeToHtml(this, opts);
  }
}
function getElementsByClassName(elm, classNames, foundElms) {
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    for (let j = 0, jj = classNames.length; j < jj; j++) {
      if (childElm.classList.contains(classNames[j])) {
        foundElms.push(childElm);
      }
    }
    getElementsByClassName(childElm, classNames, foundElms);
  }
}
function getElementsByTagName(elm, tagName, foundElms) {
  var _a;
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    if (tagName === '*' || ((_a = childElm.nodeName) !== null && _a !== void 0 ? _a : '').toLowerCase() === tagName) {
      foundElms.push(childElm);
    }
    getElementsByTagName(childElm, tagName, foundElms);
  }
}
function resetElement(elm) {
  resetEventListeners(elm);
  delete elm.__attributeMap;
  delete elm.__shadowRoot;
  delete elm.__style;
}
function insertBefore(parentNode, newNode, referenceNode) {
  if (newNode !== referenceNode) {
    newNode.remove();
    newNode.parentNode = parentNode;
    newNode.ownerDocument = parentNode.ownerDocument;
    if (referenceNode != null) {
      const index = parentNode.childNodes.indexOf(referenceNode);
      if (index > -1) {
        parentNode.childNodes.splice(index, 0, newNode);
      }
      else {
        throw new Error(`referenceNode not found in parentNode.childNodes`);
      }
    }
    else {
      parentNode.childNodes.push(newNode);
    }
    connectNode(parentNode.ownerDocument, newNode);
  }
  return newNode;
}
class MockHTMLElement extends MockElement {
  constructor(ownerDocument, nodeName) {
    super(ownerDocument, typeof nodeName === 'string' ? nodeName.toUpperCase() : null);
    this.namespaceURI = 'http://www.w3.org/1999/xhtml';
  }
  get tagName() {
    var _a;
    return (_a = this.nodeName) !== null && _a !== void 0 ? _a : '';
  }
  set tagName(value) {
    this.nodeName = value;
  }
  get attributes() {
    if (this.__attributeMap == null) {
      const attrMap = createAttributeProxy(true);
      this.__attributeMap = attrMap;
      return attrMap;
    }
    return this.__attributeMap;
  }
  set attributes(attrs) {
    this.__attributeMap = attrs;
  }
}
class MockTextNode extends MockNode {
  constructor(ownerDocument, text) {
    super(ownerDocument, 3 /* NODE_TYPES.TEXT_NODE */, "#text" /* NODE_NAMES.TEXT_NODE */, text);
  }
  cloneNode(_deep) {
    return new MockTextNode(null, this.nodeValue);
  }
  get textContent() {
    return this.nodeValue;
  }
  set textContent(text) {
    this.nodeValue = text;
  }
  get data() {
    return this.nodeValue;
  }
  set data(text) {
    this.nodeValue = text;
  }
  get wholeText() {
    if (this.parentNode != null) {
      const text = [];
      for (let i = 0, ii = this.parentNode.childNodes.length; i < ii; i++) {
        const childNode = this.parentNode.childNodes[i];
        if (childNode.nodeType === 3 /* NODE_TYPES.TEXT_NODE */) {
          text.push(childNode.nodeValue);
        }
      }
      return text.join('');
    }
    return this.nodeValue;
  }
}
function getTextContent(childNodes, text) {
  for (let i = 0, ii = childNodes.length; i < ii; i++) {
    const childNode = childNodes[i];
    if (childNode.nodeType === 3 /* NODE_TYPES.TEXT_NODE */) {
      text.push(childNode.nodeValue);
    }
    else if (childNode.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */) {
      getTextContent(childNode.childNodes, text);
    }
  }
}
function setTextContent(elm, text) {
  for (let i = elm.childNodes.length - 1; i >= 0; i--) {
    elm.removeChild(elm.childNodes[i]);
  }
  const textNode = new MockTextNode(elm.ownerDocument, text);
  elm.appendChild(textNode);
}

class MockComment extends MockNode {
  constructor(ownerDocument, data) {
    super(ownerDocument, 8 /* NODE_TYPES.COMMENT_NODE */, "#comment" /* NODE_NAMES.COMMENT_NODE */, data);
  }
  cloneNode(_deep) {
    return new MockComment(null, this.nodeValue);
  }
  get textContent() {
    return this.nodeValue;
  }
  set textContent(text) {
    this.nodeValue = text;
  }
}

class MockDocumentFragment extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, null);
    this.nodeName = "#document-fragment" /* NODE_NAMES.DOCUMENT_FRAGMENT_NODE */;
    this.nodeType = 11 /* NODE_TYPES.DOCUMENT_FRAGMENT_NODE */;
  }
  getElementById(id) {
    return getElementById(this, id);
  }
  cloneNode(deep) {
    const cloned = new MockDocumentFragment(null);
    if (deep) {
      for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
        const childNode = this.childNodes[i];
        if (childNode.nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */ ||
          childNode.nodeType === 3 /* NODE_TYPES.TEXT_NODE */ ||
          childNode.nodeType === 8 /* NODE_TYPES.COMMENT_NODE */) {
          const clonedChildNode = this.childNodes[i].cloneNode(true);
          cloned.appendChild(clonedChildNode);
        }
      }
    }
    return cloned;
  }
}

class MockDocumentTypeNode extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, '!DOCTYPE');
    this.nodeType = 10 /* NODE_TYPES.DOCUMENT_TYPE_NODE */;
    this.setAttribute('html', '');
  }
}

class MockCSSRule {
  constructor(parentStyleSheet) {
    this.parentStyleSheet = parentStyleSheet;
    this.cssText = '';
    this.type = 0;
  }
}
class MockCSSStyleSheet {
  constructor(ownerNode) {
    this.type = 'text/css';
    this.parentStyleSheet = null;
    this.cssRules = [];
    this.ownerNode = ownerNode;
  }
  get rules() {
    return this.cssRules;
  }
  set rules(rules) {
    this.cssRules = rules;
  }
  deleteRule(index) {
    if (index >= 0 && index < this.cssRules.length) {
      this.cssRules.splice(index, 1);
      updateStyleTextNode(this.ownerNode);
    }
  }
  insertRule(rule, index = 0) {
    if (typeof index !== 'number') {
      index = 0;
    }
    if (index < 0) {
      index = 0;
    }
    if (index > this.cssRules.length) {
      index = this.cssRules.length;
    }
    const cssRule = new MockCSSRule(this);
    cssRule.cssText = rule;
    this.cssRules.splice(index, 0, cssRule);
    updateStyleTextNode(this.ownerNode);
    return index;
  }
}
function getStyleElementText(styleElm) {
  const output = [];
  for (let i = 0; i < styleElm.childNodes.length; i++) {
    output.push(styleElm.childNodes[i].nodeValue);
  }
  return output.join('');
}
function setStyleElementText(styleElm, text) {
  // keeping the innerHTML and the sheet.cssRules connected
  // is not technically correct, but since we're doing
  // SSR we'll need to turn any assigned cssRules into
  // real text, not just properties that aren't rendered
  const sheet = styleElm.sheet;
  sheet.cssRules.length = 0;
  sheet.insertRule(text);
  updateStyleTextNode(styleElm);
}
function updateStyleTextNode(styleElm) {
  const childNodeLen = styleElm.childNodes.length;
  if (childNodeLen > 1) {
    for (let i = childNodeLen - 1; i >= 1; i--) {
      styleElm.removeChild(styleElm.childNodes[i]);
    }
  }
  else if (childNodeLen < 1) {
    styleElm.appendChild(styleElm.ownerDocument.createTextNode(''));
  }
  const textNode = styleElm.childNodes[0];
  textNode.nodeValue = styleElm.sheet.cssRules.map((r) => r.cssText).join('\n');
}

function createElement(ownerDocument, tagName) {
  if (typeof tagName !== 'string' || tagName === '' || !/^[a-z0-9-_:]+$/i.test(tagName)) {
    throw new Error(`The tag name provided (${tagName}) is not a valid name.`);
  }
  tagName = tagName.toLowerCase();
  switch (tagName) {
    case 'a':
      return new MockAnchorElement(ownerDocument);
    case 'base':
      return new MockBaseElement(ownerDocument);
    case 'button':
      return new MockButtonElement(ownerDocument);
    case 'canvas':
      return new MockCanvasElement(ownerDocument);
    case 'form':
      return new MockFormElement(ownerDocument);
    case 'img':
      return new MockImageElement(ownerDocument);
    case 'input':
      return new MockInputElement(ownerDocument);
    case 'link':
      return new MockLinkElement(ownerDocument);
    case 'meta':
      return new MockMetaElement(ownerDocument);
    case 'script':
      return new MockScriptElement(ownerDocument);
    case 'style':
      return new MockStyleElement(ownerDocument);
    case 'template':
      return new MockTemplateElement(ownerDocument);
    case 'title':
      return new MockTitleElement(ownerDocument);
  }
  if (ownerDocument != null && tagName.includes('-')) {
    const win = ownerDocument.defaultView;
    if (win != null && win.customElements != null) {
      return createCustomElement(win.customElements, ownerDocument, tagName);
    }
  }
  return new MockHTMLElement(ownerDocument, tagName);
}
function createElementNS(ownerDocument, namespaceURI, tagName) {
  if (namespaceURI === 'http://www.w3.org/1999/xhtml') {
    return createElement(ownerDocument, tagName);
  }
  else if (namespaceURI === 'http://www.w3.org/2000/svg') {
    switch (tagName.toLowerCase()) {
      case 'text':
      case 'tspan':
      case 'tref':
      case 'altglyph':
      case 'textpath':
        return new MockSVGTextContentElement(ownerDocument, tagName);
      case 'circle':
      case 'ellipse':
      case 'image':
      case 'line':
      case 'path':
      case 'polygon':
      case 'polyline':
      case 'rect':
      case 'use':
        return new MockSVGGraphicsElement(ownerDocument, tagName);
      case 'svg':
        return new MockSVGSVGElement(ownerDocument, tagName);
      default:
        return new MockSVGElement(ownerDocument, tagName);
    }
  }
  else {
    return new MockElement(ownerDocument, tagName);
  }
}
class MockAnchorElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'a');
  }
  get href() {
    return fullUrl(this, 'href');
  }
  set href(value) {
    this.setAttribute('href', value);
  }
  get pathname() {
    return new URL(this.href).pathname;
  }
}
class MockButtonElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'button');
  }
}
patchPropAttributes(MockButtonElement.prototype, {
  type: String,
}, {
  type: 'submit',
});
class MockImageElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'img');
  }
  get draggable() {
    return this.getAttributeNS(null, 'draggable') !== 'false';
  }
  set draggable(value) {
    this.setAttributeNS(null, 'draggable', value);
  }
  get src() {
    return fullUrl(this, 'src');
  }
  set src(value) {
    this.setAttribute('src', value);
  }
}
patchPropAttributes(MockImageElement.prototype, {
  height: Number,
  width: Number,
});
class MockInputElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'input');
  }
  get list() {
    const listId = this.getAttribute('list');
    if (listId) {
      return this.ownerDocument.getElementById(listId);
    }
    return null;
  }
}
patchPropAttributes(MockInputElement.prototype, {
  accept: String,
  autocomplete: String,
  autofocus: Boolean,
  capture: String,
  checked: Boolean,
  disabled: Boolean,
  form: String,
  formaction: String,
  formenctype: String,
  formmethod: String,
  formnovalidate: String,
  formtarget: String,
  height: Number,
  inputmode: String,
  max: String,
  maxLength: Number,
  min: String,
  minLength: Number,
  multiple: Boolean,
  name: String,
  pattern: String,
  placeholder: String,
  required: Boolean,
  readOnly: Boolean,
  size: Number,
  spellCheck: Boolean,
  src: String,
  step: String,
  type: String,
  value: String,
  width: Number,
}, {
  type: 'text',
});
class MockFormElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'form');
  }
}
patchPropAttributes(MockFormElement.prototype, {
  name: String,
});
class MockLinkElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'link');
  }
  get href() {
    return fullUrl(this, 'href');
  }
  set href(value) {
    this.setAttribute('href', value);
  }
}
patchPropAttributes(MockLinkElement.prototype, {
  crossorigin: String,
  media: String,
  rel: String,
  type: String,
});
class MockMetaElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'meta');
  }
}
patchPropAttributes(MockMetaElement.prototype, {
  charset: String,
  content: String,
  name: String,
});
class MockScriptElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'script');
  }
  get src() {
    return fullUrl(this, 'src');
  }
  set src(value) {
    this.setAttribute('src', value);
  }
}
patchPropAttributes(MockScriptElement.prototype, {
  type: String,
});
class MockDOMMatrix {
  constructor() {
    this.a = 1;
    this.b = 0;
    this.c = 0;
    this.d = 1;
    this.e = 0;
    this.f = 0;
    this.m11 = 1;
    this.m12 = 0;
    this.m13 = 0;
    this.m14 = 0;
    this.m21 = 0;
    this.m22 = 1;
    this.m23 = 0;
    this.m24 = 0;
    this.m31 = 0;
    this.m32 = 0;
    this.m33 = 1;
    this.m34 = 0;
    this.m41 = 0;
    this.m42 = 0;
    this.m43 = 0;
    this.m44 = 1;
    this.is2D = true;
    this.isIdentity = true;
  }
  static fromMatrix() {
    return new MockDOMMatrix();
  }
  inverse() {
    return new MockDOMMatrix();
  }
  flipX() {
    return new MockDOMMatrix();
  }
  flipY() {
    return new MockDOMMatrix();
  }
  multiply() {
    return new MockDOMMatrix();
  }
  rotate() {
    return new MockDOMMatrix();
  }
  rotateAxisAngle() {
    return new MockDOMMatrix();
  }
  rotateFromVector() {
    return new MockDOMMatrix();
  }
  scale() {
    return new MockDOMMatrix();
  }
  scaleNonUniform() {
    return new MockDOMMatrix();
  }
  skewX() {
    return new MockDOMMatrix();
  }
  skewY() {
    return new MockDOMMatrix();
  }
  toJSON() { }
  toString() { }
  transformPoint() {
    return new MockDOMPoint();
  }
  translate() {
    return new MockDOMMatrix();
  }
}
class MockDOMPoint {
  constructor() {
    this.w = 1;
    this.x = 0;
    this.y = 0;
    this.z = 0;
  }
  toJSON() { }
  matrixTransform() {
    return new MockDOMMatrix();
  }
}
class MockSVGRect {
  constructor() {
    this.height = 10;
    this.width = 10;
    this.x = 0;
    this.y = 0;
  }
}
class MockStyleElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'style');
    this.sheet = new MockCSSStyleSheet(this);
  }
  get innerHTML() {
    return getStyleElementText(this);
  }
  set innerHTML(value) {
    setStyleElementText(this, value);
  }
  get innerText() {
    return getStyleElementText(this);
  }
  set innerText(value) {
    setStyleElementText(this, value);
  }
  get textContent() {
    return getStyleElementText(this);
  }
  set textContent(value) {
    setStyleElementText(this, value);
  }
}
class MockSVGElement extends MockElement {
  // SVGElement properties and methods
  get ownerSVGElement() {
    return null;
  }
  get viewportElement() {
    return null;
  }
  onunload() {
    /**/
  }
  // SVGGeometryElement properties and methods
  get pathLength() {
    return 0;
  }
  isPointInFill(_pt) {
    return false;
  }
  isPointInStroke(_pt) {
    return false;
  }
  getTotalLength() {
    return 0;
  }
}
class MockSVGGraphicsElement extends MockSVGElement {
  getBBox(_options) {
    return new MockSVGRect();
  }
  getCTM() {
    return new MockDOMMatrix();
  }
  getScreenCTM() {
    return new MockDOMMatrix();
  }
}
class MockSVGSVGElement extends MockSVGGraphicsElement {
  createSVGPoint() {
    return new MockDOMPoint();
  }
}
class MockSVGTextContentElement extends MockSVGGraphicsElement {
  getComputedTextLength() {
    return 0;
  }
}
class MockBaseElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'base');
  }
  get href() {
    return fullUrl(this, 'href');
  }
  set href(value) {
    this.setAttribute('href', value);
  }
}
class MockTemplateElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'template');
    this.content = new MockDocumentFragment(ownerDocument);
  }
  get innerHTML() {
    return this.content.innerHTML;
  }
  set innerHTML(html) {
    this.content.innerHTML = html;
  }
  cloneNode(deep) {
    const cloned = new MockTemplateElement(null);
    cloned.attributes = cloneAttributes(this.attributes);
    const styleCssText = this.getAttribute('style');
    if (styleCssText != null && styleCssText.length > 0) {
      cloned.setAttribute('style', styleCssText);
    }
    cloned.content = this.content.cloneNode(deep);
    if (deep) {
      for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
        const clonedChildNode = this.childNodes[i].cloneNode(true);
        cloned.appendChild(clonedChildNode);
      }
    }
    return cloned;
  }
}
class MockTitleElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'title');
  }
  get text() {
    return this.textContent;
  }
  set text(value) {
    this.textContent = value;
  }
}
class MockCanvasElement extends MockHTMLElement {
  constructor(ownerDocument) {
    super(ownerDocument, 'canvas');
  }
  getContext() {
    return {
      fillRect() {
        return;
      },
      clearRect() { },
      getImageData: function (_, __, w, h) {
        return {
          data: new Array(w * h * 4),
        };
      },
      putImageData() { },
      createImageData: function () {
        return [];
      },
      setTransform() { },
      drawImage() { },
      save() { },
      fillText() { },
      restore() { },
      beginPath() { },
      moveTo() { },
      lineTo() { },
      closePath() { },
      stroke() { },
      translate() { },
      scale() { },
      rotate() { },
      arc() { },
      fill() { },
      measureText() {
        return { width: 0 };
      },
      transform() { },
      rect() { },
      clip() { },
    };
  }
}
function fullUrl(elm, attrName) {
  const val = elm.getAttribute(attrName) || '';
  if (elm.ownerDocument != null) {
    const win = elm.ownerDocument.defaultView;
    if (win != null) {
      const loc = win.location;
      if (loc != null) {
        try {
          const url = new URL(val, loc.href);
          return url.href;
        }
        catch (e) { }
      }
    }
  }
  return val.replace(/\'|\"/g, '').trim();
}
function patchPropAttributes(prototype, attrs, defaults = {}) {
  Object.keys(attrs).forEach((propName) => {
    const attr = attrs[propName];
    const defaultValue = defaults[propName];
    if (attr === Boolean) {
      Object.defineProperty(prototype, propName, {
        get() {
          return this.hasAttribute(propName);
        },
        set(value) {
          if (value) {
            this.setAttribute(propName, '');
          }
          else {
            this.removeAttribute(propName);
          }
        },
      });
    }
    else if (attr === Number) {
      Object.defineProperty(prototype, propName, {
        get() {
          const value = this.getAttribute(propName);
          return value ? parseInt(value, 10) : defaultValue === undefined ? 0 : defaultValue;
        },
        set(value) {
          this.setAttribute(propName, value);
        },
      });
    }
    else {
      Object.defineProperty(prototype, propName, {
        get() {
          return this.hasAttribute(propName) ? this.getAttribute(propName) : defaultValue || '';
        },
        set(value) {
          this.setAttribute(propName, value);
        },
      });
    }
  });
}
MockElement.prototype.cloneNode = function (deep) {
  // because we're creating elements, which extending specific HTML base classes there
  // is a MockElement circular reference that bundling has trouble dealing with so
  // the fix is to add cloneNode() to MockElement's prototype after the HTML classes
  const cloned = createElement(this.ownerDocument, this.nodeName);
  cloned.attributes = cloneAttributes(this.attributes);
  const styleCssText = this.getAttribute('style');
  if (styleCssText != null && styleCssText.length > 0) {
    cloned.setAttribute('style', styleCssText);
  }
  if (deep) {
    for (let i = 0, ii = this.childNodes.length; i < ii; i++) {
      const clonedChildNode = this.childNodes[i].cloneNode(true);
      cloned.appendChild(clonedChildNode);
    }
  }
  return cloned;
};

let sharedDocument;
function parseHtmlToDocument(html, ownerDocument = null) {
  if (ownerDocument == null) {
    if (sharedDocument == null) {
      sharedDocument = new MockDocument();
    }
    ownerDocument = sharedDocument;
  }
  return parseDocumentUtil(ownerDocument, html);
}
function parseHtmlToFragment(html, ownerDocument = null) {
  if (ownerDocument == null) {
    if (sharedDocument == null) {
      sharedDocument = new MockDocument();
    }
    ownerDocument = sharedDocument;
  }
  return parseFragmentUtil(ownerDocument, html);
}

const consoleNoop = () => {
  /**/
};
function createConsole() {
  return {
    debug: consoleNoop,
    error: consoleNoop,
    info: consoleNoop,
    log: consoleNoop,
    warn: consoleNoop,
    dir: consoleNoop,
    dirxml: consoleNoop,
    table: consoleNoop,
    trace: consoleNoop,
    group: consoleNoop,
    groupCollapsed: consoleNoop,
    groupEnd: consoleNoop,
    clear: consoleNoop,
    count: consoleNoop,
    countReset: consoleNoop,
    assert: consoleNoop,
    profile: consoleNoop,
    profileEnd: consoleNoop,
    time: consoleNoop,
    timeLog: consoleNoop,
    timeEnd: consoleNoop,
    timeStamp: consoleNoop,
    context: consoleNoop,
    memory: consoleNoop,
  };
}

class MockHeaders {
  constructor(init) {
    this._values = [];
    if (typeof init === 'object') {
      if (typeof init[Symbol.iterator] === 'function') {
        const kvs = [];
        for (const kv of init) {
          if (typeof kv[Symbol.iterator] === 'function') {
            kvs.push([...kv]);
          }
        }
        for (const kv of kvs) {
          this.append(kv[0], kv[1]);
        }
      }
      else {
        for (const key in init) {
          this.append(key, init[key]);
        }
      }
    }
  }
  append(key, value) {
    this._values.push([key, value + '']);
  }
  delete(key) {
    key = key.toLowerCase();
    for (let i = this._values.length - 1; i >= 0; i--) {
      if (this._values[i][0].toLowerCase() === key) {
        this._values.splice(i, 1);
      }
    }
  }
  entries() {
    const entries = [];
    for (const kv of this.keys()) {
      entries.push([kv, this.get(kv)]);
    }
    let index = -1;
    return {
      next() {
        index++;
        return {
          value: entries[index],
          done: !entries[index],
        };
      },
      [Symbol.iterator]() {
        return this;
      },
    };
  }
  forEach(cb) {
    for (const kv of this.entries()) {
      cb(kv[1], kv[0]);
    }
  }
  get(key) {
    const rtn = [];
    key = key.toLowerCase();
    for (const kv of this._values) {
      if (kv[0].toLowerCase() === key) {
        rtn.push(kv[1]);
      }
    }
    return rtn.length > 0 ? rtn.join(', ') : null;
  }
  has(key) {
    key = key.toLowerCase();
    for (const kv of this._values) {
      if (kv[0].toLowerCase() === key) {
        return true;
      }
    }
    return false;
  }
  keys() {
    const keys = [];
    for (const kv of this._values) {
      const key = kv[0].toLowerCase();
      if (!keys.includes(key)) {
        keys.push(key);
      }
    }
    let index = -1;
    return {
      next() {
        index++;
        return {
          value: keys[index],
          done: !keys[index],
        };
      },
      [Symbol.iterator]() {
        return this;
      },
    };
  }
  set(key, value) {
    for (const kv of this._values) {
      if (kv[0].toLowerCase() === key.toLowerCase()) {
        kv[1] = value + '';
        return;
      }
    }
    this.append(key, value);
  }
  values() {
    const values = this._values;
    let index = -1;
    return {
      next() {
        index++;
        const done = !values[index];
        return {
          value: done ? undefined : values[index][1],
          done,
        };
      },
      [Symbol.iterator]() {
        return this;
      },
    };
  }
  [Symbol.iterator]() {
    return this.entries();
  }
}

class MockDOMParser {
  parseFromString(htmlToParse, mimeType) {
    if (mimeType !== 'text/html') {
      console.error('XML parsing not implemented yet, continuing as html');
    }
    return parseHtmlToDocument(htmlToParse);
  }
}

class MockRequest {
  constructor(input, init = {}) {
    this._method = 'GET';
    this._url = '/';
    this.bodyUsed = false;
    this.cache = 'default';
    this.credentials = 'same-origin';
    this.integrity = '';
    this.keepalive = false;
    this.mode = 'cors';
    this.redirect = 'follow';
    this.referrer = 'about:client';
    this.referrerPolicy = '';
    if (typeof input === 'string') {
      this.url = input;
    }
    else if (input) {
      Object.assign(this, input);
      this.headers = new MockHeaders(input.headers);
    }
    Object.assign(this, init);
    if (init.headers) {
      this.headers = new MockHeaders(init.headers);
    }
    if (!this.headers) {
      this.headers = new MockHeaders();
    }
  }
  get url() {
    if (typeof this._url === 'string') {
      return new URL(this._url, location.href).href;
    }
    return new URL('/', location.href).href;
  }
  set url(value) {
    this._url = value;
  }
  get method() {
    if (typeof this._method === 'string') {
      return this._method.toUpperCase();
    }
    return 'GET';
  }
  set method(value) {
    this._method = value;
  }
  clone() {
    const clone = { ...this };
    clone.headers = new MockHeaders(this.headers);
    return new MockRequest(clone);
  }
}
class MockResponse {
  constructor(body, init = {}) {
    this.ok = true;
    this.status = 200;
    this.statusText = '';
    this.type = 'default';
    this.url = '';
    this._body = body;
    if (init) {
      Object.assign(this, init);
    }
    this.headers = new MockHeaders(init.headers);
  }
  async json() {
    return JSON.parse(this._body);
  }
  async text() {
    return this._body;
  }
  clone() {
    const initClone = { ...this };
    initClone.headers = new MockHeaders(this.headers);
    return new MockResponse(this._body, initClone);
  }
}

function setupGlobal(gbl) {
  if (gbl.window == null) {
    const win = (gbl.window = new MockWindow());
    WINDOW_FUNCTIONS.forEach((fnName) => {
      if (!(fnName in gbl)) {
        gbl[fnName] = win[fnName].bind(win);
      }
    });
    WINDOW_PROPS.forEach((propName) => {
      if (!(propName in gbl)) {
        Object.defineProperty(gbl, propName, {
          get() {
            return win[propName];
          },
          set(val) {
            win[propName] = val;
          },
          configurable: true,
          enumerable: true,
        });
      }
    });
    GLOBAL_CONSTRUCTORS.forEach(([cstrName]) => {
      gbl[cstrName] = win[cstrName];
    });
  }
  return gbl.window;
}
function teardownGlobal(gbl) {
  const win = gbl.window;
  if (win && typeof win.close === 'function') {
    win.close();
  }
}
function patchWindow(winToBePatched) {
  const mockWin = new MockWindow(false);
  WINDOW_FUNCTIONS.forEach((fnName) => {
    if (typeof winToBePatched[fnName] !== 'function') {
      winToBePatched[fnName] = mockWin[fnName].bind(mockWin);
    }
  });
  WINDOW_PROPS.forEach((propName) => {
    if (winToBePatched === undefined) {
      Object.defineProperty(winToBePatched, propName, {
        get() {
          return mockWin[propName];
        },
        set(val) {
          mockWin[propName] = val;
        },
        configurable: true,
        enumerable: true,
      });
    }
  });
}
function addGlobalsToWindowPrototype(mockWinPrototype) {
  GLOBAL_CONSTRUCTORS.forEach(([cstrName, Cstr]) => {
    Object.defineProperty(mockWinPrototype, cstrName, {
      get() {
        return this['__' + cstrName] || Cstr;
      },
      set(cstr) {
        this['__' + cstrName] = cstr;
      },
      configurable: true,
      enumerable: true,
    });
  });
}
const WINDOW_FUNCTIONS = [
  'addEventListener',
  'alert',
  'blur',
  'cancelAnimationFrame',
  'cancelIdleCallback',
  'clearInterval',
  'clearTimeout',
  'close',
  'confirm',
  'dispatchEvent',
  'focus',
  'getComputedStyle',
  'matchMedia',
  'open',
  'prompt',
  'removeEventListener',
  'requestAnimationFrame',
  'requestIdleCallback',
  'URL',
];
const WINDOW_PROPS = [
  'customElements',
  'devicePixelRatio',
  'document',
  'history',
  'innerHeight',
  'innerWidth',
  'localStorage',
  'location',
  'navigator',
  'pageXOffset',
  'pageYOffset',
  'performance',
  'screenLeft',
  'screenTop',
  'screenX',
  'screenY',
  'scrollX',
  'scrollY',
  'sessionStorage',
  'CSS',
  'CustomEvent',
  'Event',
  'Element',
  'HTMLElement',
  'Node',
  'NodeList',
  'FocusEvent',
  'KeyboardEvent',
  'MouseEvent',
];
const GLOBAL_CONSTRUCTORS = [
  ['CustomEvent', MockCustomEvent],
  ['Event', MockEvent],
  ['Headers', MockHeaders],
  ['FocusEvent', MockFocusEvent],
  ['KeyboardEvent', MockKeyboardEvent],
  ['MouseEvent', MockMouseEvent],
  ['Request', MockRequest],
  ['Response', MockResponse],
  ['DOMParser', MockDOMParser],
  ['HTMLAnchorElement', MockAnchorElement],
  ['HTMLBaseElement', MockBaseElement],
  ['HTMLButtonElement', MockButtonElement],
  ['HTMLCanvasElement', MockCanvasElement],
  ['HTMLFormElement', MockFormElement],
  ['HTMLImageElement', MockImageElement],
  ['HTMLInputElement', MockInputElement],
  ['HTMLLinkElement', MockLinkElement],
  ['HTMLMetaElement', MockMetaElement],
  ['HTMLScriptElement', MockScriptElement],
  ['HTMLStyleElement', MockStyleElement],
  ['HTMLTemplateElement', MockTemplateElement],
  ['HTMLTitleElement', MockTitleElement],
];

class MockHistory {
  constructor() {
    this.items = [];
  }
  get length() {
    return this.items.length;
  }
  back() {
    this.go(-1);
  }
  forward() {
    this.go(1);
  }
  go(_value) {
    //
  }
  pushState(_state, _title, _url) {
    //
  }
  replaceState(_state, _title, _url) {
    //
  }
}

class MockIntersectionObserver {
  constructor() {
    /**/
  }
  disconnect() {
    /**/
  }
  observe() {
    /**/
  }
  takeRecords() {
    return [];
  }
  unobserve() {
    /**/
  }
}

class MockLocation {
  constructor() {
    this.ancestorOrigins = null;
    this.protocol = '';
    this.host = '';
    this.hostname = '';
    this.port = '';
    this.pathname = '';
    this.search = '';
    this.hash = '';
    this.username = '';
    this.password = '';
    this.origin = '';
    this._href = '';
  }
  get href() {
    return this._href;
  }
  set href(value) {
    const url = new URL(value, 'http://mockdoc.stenciljs.com');
    this._href = url.href;
    this.protocol = url.protocol;
    this.host = url.host;
    this.hostname = url.hostname;
    this.port = url.port;
    this.pathname = url.pathname;
    this.search = url.search;
    this.hash = url.hash;
    this.username = url.username;
    this.password = url.password;
    this.origin = url.origin;
  }
  assign(_url) {
    //
  }
  reload(_forcedReload) {
    //
  }
  replace(_url) {
    //
  }
  toString() {
    return this.href;
  }
}

class MockNavigator {
  constructor() {
    this.appCodeName = 'MockNavigator';
    this.appName = 'MockNavigator';
    this.appVersion = 'MockNavigator';
    this.platform = 'MockNavigator';
    this.userAgent = 'MockNavigator';
  }
}

/**
 * https://developer.mozilla.org/en-US/docs/Web/API/Performance
 */
class MockPerformance {
  constructor() {
    this.timeOrigin = Date.now();
    this.eventCounts = new Map();
  }
  addEventListener() {
    //
  }
  clearMarks() {
    //
  }
  clearMeasures() {
    //
  }
  clearResourceTimings() {
    //
  }
  dispatchEvent() {
    return true;
  }
  getEntries() {
    return [];
  }
  getEntriesByName() {
    return [];
  }
  getEntriesByType() {
    return [];
  }
  // Stencil's implementation of `mark` is non-compliant with the `Performance` interface. Because Stencil will
  // instantiate an instance of this class and may attempt to assign it to a variable of type `Performance`, the return
  // type must match the `Performance` interface (rather than typing this function as returning `void` and ignoring the
  // associated errors returned by the type checker)
  // @ts-ignore
  mark() {
    //
  }
  // Stencil's implementation of `measure` is non-compliant with the `Performance` interface. Because Stencil will
  // instantiate an instance of this class and may attempt to assign it to a variable of type `Performance`, the return
  // type must match the `Performance` interface (rather than typing this function as returning `void` and ignoring the
  // associated errors returned by the type checker)
  // @ts-ignore
  measure() {
    //
  }
  get navigation() {
    return {};
  }
  now() {
    return Date.now() - this.timeOrigin;
  }
  get onresourcetimingbufferfull() {
    return null;
  }
  removeEventListener() {
    //
  }
  setResourceTimingBufferSize() {
    //
  }
  get timing() {
    return {};
  }
  toJSON() {
    //
  }
}
function resetPerformance(perf) {
  if (perf != null) {
    try {
      perf.timeOrigin = Date.now();
    }
    catch (e) { }
  }
}

class MockStorage {
  constructor() {
    this.items = new Map();
  }
  key(_value) {
    //
  }
  getItem(key) {
    key = String(key);
    if (this.items.has(key)) {
      return this.items.get(key);
    }
    return null;
  }
  setItem(key, value) {
    if (value == null) {
      value = 'null';
    }
    this.items.set(String(key), String(value));
  }
  removeItem(key) {
    this.items.delete(String(key));
  }
  clear() {
    this.items.clear();
  }
}

const nativeClearInterval = clearInterval;
const nativeClearTimeout = clearTimeout;
const nativeSetInterval = setInterval;
const nativeSetTimeout = setTimeout;
const nativeURL = URL;
class MockWindow {
  constructor(html = null) {
    if (html !== false) {
      this.document = new MockDocument(html, this);
    }
    else {
      this.document = null;
    }
    this.performance = new MockPerformance();
    this.customElements = new MockCustomElementRegistry(this);
    this.console = createConsole();
    resetWindowDefaults(this);
    resetWindowDimensions(this);
  }
  addEventListener(type, handler) {
    addEventListener(this, type, handler);
  }
  alert(msg) {
    if (this.console) {
      this.console.debug(msg);
    }
    else {
      console.debug(msg);
    }
  }
  blur() {
    /**/
  }
  cancelAnimationFrame(id) {
    this.__clearTimeout(id);
  }
  cancelIdleCallback(id) {
    this.__clearTimeout(id);
  }
  get CharacterData() {
    if (this.__charDataCstr == null) {
      const ownerDocument = this.document;
      this.__charDataCstr = class extends MockNode {
        constructor() {
          super(ownerDocument, 0, 'test', '');
          throw new Error('Illegal constructor: cannot construct CharacterData');
        }
      };
    }
    return this.__charDataCstr;
  }
  set CharacterData(charDataCstr) {
    this.__charDataCstr = charDataCstr;
  }
  clearInterval(id) {
    this.__clearInterval(id);
  }
  clearTimeout(id) {
    this.__clearTimeout(id);
  }
  close() {
    resetWindow(this);
  }
  confirm() {
    return false;
  }
  get CSS() {
    return {
      supports: () => true,
    };
  }
  get Document() {
    if (this.__docCstr == null) {
      const win = this;
      this.__docCstr = class extends MockDocument {
        constructor() {
          super(false, win);
          throw new Error('Illegal constructor: cannot construct Document');
        }
      };
    }
    return this.__docCstr;
  }
  set Document(docCstr) {
    this.__docCstr = docCstr;
  }
  get DocumentFragment() {
    if (this.__docFragCstr == null) {
      const ownerDocument = this.document;
      this.__docFragCstr = class extends MockDocumentFragment {
        constructor() {
          super(ownerDocument);
          throw new Error('Illegal constructor: cannot construct DocumentFragment');
        }
      };
    }
    return this.__docFragCstr;
  }
  set DocumentFragment(docFragCstr) {
    this.__docFragCstr = docFragCstr;
  }
  get DocumentType() {
    if (this.__docTypeCstr == null) {
      const ownerDocument = this.document;
      this.__docTypeCstr = class extends MockNode {
        constructor() {
          super(ownerDocument, 0, 'test', '');
          throw new Error('Illegal constructor: cannot construct DocumentType');
        }
      };
    }
    return this.__docTypeCstr;
  }
  set DocumentType(docTypeCstr) {
    this.__docTypeCstr = docTypeCstr;
  }
  get DOMTokenList() {
    if (this.__domTokenListCstr == null) {
      this.__domTokenListCstr = class MockDOMTokenList {
      };
    }
    return this.__domTokenListCstr;
  }
  set DOMTokenList(domTokenListCstr) {
    this.__domTokenListCstr = domTokenListCstr;
  }
  dispatchEvent(ev) {
    return dispatchEvent(this, ev);
  }
  get Element() {
    if (this.__elementCstr == null) {
      const ownerDocument = this.document;
      this.__elementCstr = class extends MockElement {
        constructor() {
          super(ownerDocument, '');
          throw new Error('Illegal constructor: cannot construct Element');
        }
      };
    }
    return this.__elementCstr;
  }
  fetch(input, init) {
    if (typeof fetch === 'function') {
      return fetch(input, init);
    }
    throw new Error(`fetch() not implemented`);
  }
  focus() {
    /**/
  }
  getComputedStyle(_) {
    return {
      cssText: '',
      length: 0,
      parentRule: null,
      getPropertyPriority() {
        return null;
      },
      getPropertyValue() {
        return '';
      },
      item() {
        return null;
      },
      removeProperty() {
        return null;
      },
      setProperty() {
        return null;
      },
    };
  }
  get globalThis() {
    return this;
  }
  get history() {
    if (this.__history == null) {
      this.__history = new MockHistory();
    }
    return this.__history;
  }
  set history(hsty) {
    this.__history = hsty;
  }
  get JSON() {
    return JSON;
  }
  get HTMLElement() {
    if (this.__htmlElementCstr == null) {
      const ownerDocument = this.document;
      this.__htmlElementCstr = class extends MockHTMLElement {
        constructor() {
          super(ownerDocument, '');
          const observedAttributes = this.constructor.observedAttributes;
          if (Array.isArray(observedAttributes) && typeof this.attributeChangedCallback === 'function') {
            observedAttributes.forEach((attrName) => {
              const attrValue = this.getAttribute(attrName);
              if (attrValue != null) {
                this.attributeChangedCallback(attrName, null, attrValue);
              }
            });
          }
        }
      };
    }
    return this.__htmlElementCstr;
  }
  set HTMLElement(htmlElementCstr) {
    this.__htmlElementCstr = htmlElementCstr;
  }
  get IntersectionObserver() {
    return MockIntersectionObserver;
  }
  get localStorage() {
    if (this.__localStorage == null) {
      this.__localStorage = new MockStorage();
    }
    return this.__localStorage;
  }
  set localStorage(locStorage) {
    this.__localStorage = locStorage;
  }
  get location() {
    if (this.__location == null) {
      this.__location = new MockLocation();
    }
    return this.__location;
  }
  set location(val) {
    if (typeof val === 'string') {
      if (this.__location == null) {
        this.__location = new MockLocation();
      }
      this.__location.href = val;
    }
    else {
      this.__location = val;
    }
  }
  matchMedia() {
    return {
      matches: false,
    };
  }
  get Node() {
    if (this.__nodeCstr == null) {
      const ownerDocument = this.document;
      this.__nodeCstr = class extends MockNode {
        constructor() {
          super(ownerDocument, 0, 'test', '');
          throw new Error('Illegal constructor: cannot construct Node');
        }
      };
    }
    return this.__nodeCstr;
  }
  get NodeList() {
    if (this.__nodeListCstr == null) {
      const ownerDocument = this.document;
      this.__nodeListCstr = class extends MockNodeList {
        constructor() {
          super(ownerDocument, [], 0);
          throw new Error('Illegal constructor: cannot construct NodeList');
        }
      };
    }
    return this.__nodeListCstr;
  }
  get navigator() {
    if (this.__navigator == null) {
      this.__navigator = new MockNavigator();
    }
    return this.__navigator;
  }
  set navigator(nav) {
    this.__navigator = nav;
  }
  get parent() {
    return null;
  }
  prompt() {
    return '';
  }
  open() {
    return null;
  }
  get origin() {
    return this.location.origin;
  }
  removeEventListener(type, handler) {
    removeEventListener(this, type, handler);
  }
  requestAnimationFrame(callback) {
    return this.setTimeout(() => {
      callback(Date.now());
    }, 0);
  }
  requestIdleCallback(callback) {
    return this.setTimeout(() => {
      callback({
        didTimeout: false,
        timeRemaining: () => 0,
      });
    }, 0);
  }
  scroll(_x, _y) {
    /**/
  }
  scrollBy(_x, _y) {
    /**/
  }
  scrollTo(_x, _y) {
    /**/
  }
  get self() {
    return this;
  }
  get sessionStorage() {
    if (this.__sessionStorage == null) {
      this.__sessionStorage = new MockStorage();
    }
    return this.__sessionStorage;
  }
  set sessionStorage(locStorage) {
    this.__sessionStorage = locStorage;
  }
  setInterval(callback, ms, ...args) {
    if (this.__timeouts == null) {
      this.__timeouts = new Set();
    }
    ms = Math.min(ms, this.__maxTimeout);
    if (this.__allowInterval) {
      const intervalId = this.__setInterval(() => {
        if (this.__timeouts) {
          this.__timeouts.delete(intervalId);
          try {
            callback(...args);
          }
          catch (e) {
            if (this.console) {
              this.console.error(e);
            }
            else {
              console.error(e);
            }
          }
        }
      }, ms);
      if (this.__timeouts) {
        this.__timeouts.add(intervalId);
      }
      return intervalId;
    }
    const timeoutId = this.__setTimeout(() => {
      if (this.__timeouts) {
        this.__timeouts.delete(timeoutId);
        try {
          callback(...args);
        }
        catch (e) {
          if (this.console) {
            this.console.error(e);
          }
          else {
            console.error(e);
          }
        }
      }
    }, ms);
    if (this.__timeouts) {
      this.__timeouts.add(timeoutId);
    }
    return timeoutId;
  }
  setTimeout(callback, ms, ...args) {
    if (this.__timeouts == null) {
      this.__timeouts = new Set();
    }
    ms = Math.min(ms, this.__maxTimeout);
    const timeoutId = this.__setTimeout(() => {
      if (this.__timeouts) {
        this.__timeouts.delete(timeoutId);
        try {
          callback(...args);
        }
        catch (e) {
          if (this.console) {
            this.console.error(e);
          }
          else {
            console.error(e);
          }
        }
      }
    }, ms);
    if (this.__timeouts) {
      this.__timeouts.add(timeoutId);
    }
    return timeoutId;
  }
  get top() {
    return this;
  }
  get window() {
    return this;
  }
  onanimationstart() {
    /**/
  }
  onanimationend() {
    /**/
  }
  onanimationiteration() {
    /**/
  }
  onabort() {
    /**/
  }
  onauxclick() {
    /**/
  }
  onbeforecopy() {
    /**/
  }
  onbeforecut() {
    /**/
  }
  onbeforepaste() {
    /**/
  }
  onblur() {
    /**/
  }
  oncancel() {
    /**/
  }
  oncanplay() {
    /**/
  }
  oncanplaythrough() {
    /**/
  }
  onchange() {
    /**/
  }
  onclick() {
    /**/
  }
  onclose() {
    /**/
  }
  oncontextmenu() {
    /**/
  }
  oncopy() {
    /**/
  }
  oncuechange() {
    /**/
  }
  oncut() {
    /**/
  }
  ondblclick() {
    /**/
  }
  ondrag() {
    /**/
  }
  ondragend() {
    /**/
  }
  ondragenter() {
    /**/
  }
  ondragleave() {
    /**/
  }
  ondragover() {
    /**/
  }
  ondragstart() {
    /**/
  }
  ondrop() {
    /**/
  }
  ondurationchange() {
    /**/
  }
  onemptied() {
    /**/
  }
  onended() {
    /**/
  }
  onerror() {
    /**/
  }
  onfocus() {
    /**/
  }
  onfocusin() {
    /**/
  }
  onfocusout() {
    /**/
  }
  onformdata() {
    /**/
  }
  onfullscreenchange() {
    /**/
  }
  onfullscreenerror() {
    /**/
  }
  ongotpointercapture() {
    /**/
  }
  oninput() {
    /**/
  }
  oninvalid() {
    /**/
  }
  onkeydown() {
    /**/
  }
  onkeypress() {
    /**/
  }
  onkeyup() {
    /**/
  }
  onload() {
    /**/
  }
  onloadeddata() {
    /**/
  }
  onloadedmetadata() {
    /**/
  }
  onloadstart() {
    /**/
  }
  onlostpointercapture() {
    /**/
  }
  onmousedown() {
    /**/
  }
  onmouseenter() {
    /**/
  }
  onmouseleave() {
    /**/
  }
  onmousemove() {
    /**/
  }
  onmouseout() {
    /**/
  }
  onmouseover() {
    /**/
  }
  onmouseup() {
    /**/
  }
  onmousewheel() {
    /**/
  }
  onpaste() {
    /**/
  }
  onpause() {
    /**/
  }
  onplay() {
    /**/
  }
  onplaying() {
    /**/
  }
  onpointercancel() {
    /**/
  }
  onpointerdown() {
    /**/
  }
  onpointerenter() {
    /**/
  }
  onpointerleave() {
    /**/
  }
  onpointermove() {
    /**/
  }
  onpointerout() {
    /**/
  }
  onpointerover() {
    /**/
  }
  onpointerup() {
    /**/
  }
  onprogress() {
    /**/
  }
  onratechange() {
    /**/
  }
  onreset() {
    /**/
  }
  onresize() {
    /**/
  }
  onscroll() {
    /**/
  }
  onsearch() {
    /**/
  }
  onseeked() {
    /**/
  }
  onseeking() {
    /**/
  }
  onselect() {
    /**/
  }
  onselectstart() {
    /**/
  }
  onstalled() {
    /**/
  }
  onsubmit() {
    /**/
  }
  onsuspend() {
    /**/
  }
  ontimeupdate() {
    /**/
  }
  ontoggle() {
    /**/
  }
  onvolumechange() {
    /**/
  }
  onwaiting() {
    /**/
  }
  onwebkitfullscreenchange() {
    /**/
  }
  onwebkitfullscreenerror() {
    /**/
  }
  onwheel() {
    /**/
  }
}
addGlobalsToWindowPrototype(MockWindow.prototype);
function resetWindowDefaults(win) {
  win.__clearInterval = nativeClearInterval;
  win.__clearTimeout = nativeClearTimeout;
  win.__setInterval = nativeSetInterval;
  win.__setTimeout = nativeSetTimeout;
  win.__maxTimeout = 30000;
  win.__allowInterval = true;
  win.URL = nativeURL;
}
function cloneWindow(srcWin, opts = {}) {
  if (srcWin == null) {
    return null;
  }
  const clonedWin = new MockWindow(false);
  if (!opts.customElementProxy) {
    // TODO(STENCIL-345) - Evaluate reconciling MockWindow, Window differences
    // @ts-ignore
    srcWin.customElements = null;
  }
  if (srcWin.document != null) {
    const clonedDoc = new MockDocument(false, clonedWin);
    clonedWin.document = clonedDoc;
    clonedDoc.documentElement = srcWin.document.documentElement.cloneNode(true);
  }
  else {
    clonedWin.document = new MockDocument(null, clonedWin);
  }
  return clonedWin;
}
function cloneDocument(srcDoc) {
  if (srcDoc == null) {
    return null;
  }
  const dstWin = cloneWindow(srcDoc.defaultView);
  return dstWin.document;
}
// TODO(STENCIL-345) - Evaluate reconciling MockWindow, Window differences
/**
 * Constrain setTimeout() to 1ms, but still async. Also
 * only allow setInterval() to fire once, also constrained to 1ms.
 * @param win the mock window instance to update
 */
function constrainTimeouts(win) {
  win.__allowInterval = false;
  win.__maxTimeout = 0;
}
function resetWindow(win) {
  if (win != null) {
    if (win.__timeouts) {
      win.__timeouts.forEach((timeoutId) => {
        nativeClearInterval(timeoutId);
        nativeClearTimeout(timeoutId);
      });
      win.__timeouts.clear();
    }
    if (win.customElements && win.customElements.clear) {
      win.customElements.clear();
    }
    resetDocument(win.document);
    resetPerformance(win.performance);
    for (const key in win) {
      if (win.hasOwnProperty(key) && key !== 'document' && key !== 'performance' && key !== 'customElements') {
        delete win[key];
      }
    }
    resetWindowDefaults(win);
    resetWindowDimensions(win);
    resetEventListeners(win);
    if (win.document != null) {
      try {
        win.document.defaultView = win;
      }
      catch (e) { }
    }
    // ensure we don't hold onto nodeFetch values
    win.fetch = null;
    win.Headers = null;
    win.Request = null;
    win.Response = null;
    win.FetchError = null;
  }
}
function resetWindowDimensions(win) {
  try {
    win.devicePixelRatio = 1;
    win.innerHeight = 768;
    win.innerWidth = 1366;
    win.pageXOffset = 0;
    win.pageYOffset = 0;
    win.screenLeft = 0;
    win.screenTop = 0;
    win.screenX = 0;
    win.screenY = 0;
    win.scrollX = 0;
    win.scrollY = 0;
    win.screen = {
      availHeight: win.innerHeight,
      availLeft: 0,
      availTop: 0,
      availWidth: win.innerWidth,
      colorDepth: 24,
      height: win.innerHeight,
      keepAwake: false,
      orientation: {
        angle: 0,
        type: 'portrait-primary',
      },
      pixelDepth: 24,
      width: win.innerWidth,
    };
  }
  catch (e) { }
}

class MockDocument extends MockHTMLElement {
  constructor(html = null, win = null) {
    super(null, null);
    this.nodeName = "#document" /* NODE_NAMES.DOCUMENT_NODE */;
    this.nodeType = 9 /* NODE_TYPES.DOCUMENT_NODE */;
    this.defaultView = win;
    this.cookie = '';
    this.referrer = '';
    this.appendChild(this.createDocumentTypeNode());
    if (typeof html === 'string') {
      const parsedDoc = parseDocumentUtil(this, html);
      const documentElement = parsedDoc.children.find((elm) => elm.nodeName === 'HTML');
      if (documentElement != null) {
        this.appendChild(documentElement);
        setOwnerDocument(documentElement, this);
      }
    }
    else if (html !== false) {
      const documentElement = new MockHTMLElement(this, 'html');
      this.appendChild(documentElement);
      documentElement.appendChild(new MockHTMLElement(this, 'head'));
      documentElement.appendChild(new MockHTMLElement(this, 'body'));
    }
  }
  get dir() {
    return this.documentElement.dir;
  }
  set dir(value) {
    this.documentElement.dir = value;
  }
  get location() {
    if (this.defaultView != null) {
      return this.defaultView.location;
    }
    return null;
  }
  set location(val) {
    if (this.defaultView != null) {
      this.defaultView.location = val;
    }
  }
  get baseURI() {
    const baseNode = this.head.childNodes.find((node) => node.nodeName === 'BASE');
    if (baseNode) {
      return baseNode.href;
    }
    return this.URL;
  }
  get URL() {
    return this.location.href;
  }
  get styleSheets() {
    return this.querySelectorAll('style');
  }
  get scripts() {
    return this.querySelectorAll('script');
  }
  get forms() {
    return this.querySelectorAll('form');
  }
  get images() {
    return this.querySelectorAll('img');
  }
  get scrollingElement() {
    return this.documentElement;
  }
  get documentElement() {
    for (let i = this.childNodes.length - 1; i >= 0; i--) {
      if (this.childNodes[i].nodeName === 'HTML') {
        return this.childNodes[i];
      }
    }
    const documentElement = new MockHTMLElement(this, 'html');
    this.appendChild(documentElement);
    return documentElement;
  }
  set documentElement(documentElement) {
    for (let i = this.childNodes.length - 1; i >= 0; i--) {
      if (this.childNodes[i].nodeType !== 10 /* NODE_TYPES.DOCUMENT_TYPE_NODE */) {
        this.childNodes[i].remove();
      }
    }
    if (documentElement != null) {
      this.appendChild(documentElement);
      setOwnerDocument(documentElement, this);
    }
  }
  get head() {
    const documentElement = this.documentElement;
    for (let i = 0; i < documentElement.childNodes.length; i++) {
      if (documentElement.childNodes[i].nodeName === 'HEAD') {
        return documentElement.childNodes[i];
      }
    }
    const head = new MockHTMLElement(this, 'head');
    documentElement.insertBefore(head, documentElement.firstChild);
    return head;
  }
  set head(head) {
    const documentElement = this.documentElement;
    for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
      if (documentElement.childNodes[i].nodeName === 'HEAD') {
        documentElement.childNodes[i].remove();
      }
    }
    if (head != null) {
      documentElement.insertBefore(head, documentElement.firstChild);
      setOwnerDocument(head, this);
    }
  }
  get body() {
    const documentElement = this.documentElement;
    for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
      if (documentElement.childNodes[i].nodeName === 'BODY') {
        return documentElement.childNodes[i];
      }
    }
    const body = new MockHTMLElement(this, 'body');
    documentElement.appendChild(body);
    return body;
  }
  set body(body) {
    const documentElement = this.documentElement;
    for (let i = documentElement.childNodes.length - 1; i >= 0; i--) {
      if (documentElement.childNodes[i].nodeName === 'BODY') {
        documentElement.childNodes[i].remove();
      }
    }
    if (body != null) {
      documentElement.appendChild(body);
      setOwnerDocument(body, this);
    }
  }
  appendChild(newNode) {
    newNode.remove();
    newNode.parentNode = this;
    this.childNodes.push(newNode);
    return newNode;
  }
  createComment(data) {
    return new MockComment(this, data);
  }
  createAttribute(attrName) {
    return new MockAttr(attrName.toLowerCase(), '');
  }
  createAttributeNS(namespaceURI, attrName) {
    return new MockAttr(attrName, '', namespaceURI);
  }
  createElement(tagName) {
    if (tagName === "#document" /* NODE_NAMES.DOCUMENT_NODE */) {
      const doc = new MockDocument(false);
      doc.nodeName = tagName;
      doc.parentNode = null;
      return doc;
    }
    return createElement(this, tagName);
  }
  createElementNS(namespaceURI, tagName) {
    const elmNs = createElementNS(this, namespaceURI, tagName);
    elmNs.namespaceURI = namespaceURI;
    return elmNs;
  }
  createTextNode(text) {
    return new MockTextNode(this, text);
  }
  createDocumentFragment() {
    return new MockDocumentFragment(this);
  }
  createDocumentTypeNode() {
    return new MockDocumentTypeNode(this);
  }
  getElementById(id) {
    return getElementById(this, id);
  }
  getElementsByName(elmName) {
    return getElementsByName(this, elmName.toLowerCase());
  }
  get title() {
    const title = this.head.childNodes.find((elm) => elm.nodeName === 'TITLE');
    if (title != null && typeof title.textContent === 'string') {
      return title.textContent.trim();
    }
    return '';
  }
  set title(value) {
    const head = this.head;
    let title = head.childNodes.find((elm) => elm.nodeName === 'TITLE');
    if (title == null) {
      title = this.createElement('title');
      head.appendChild(title);
    }
    title.textContent = value;
  }
}
function createDocument(html = null) {
  return new MockWindow(html).document;
}
function createFragment(html) {
  return parseHtmlToFragment(html, null);
}
function resetDocument(doc) {
  if (doc != null) {
    resetEventListeners(doc);
    const documentElement = doc.documentElement;
    if (documentElement != null) {
      resetElement(documentElement);
      for (let i = 0, ii = documentElement.childNodes.length; i < ii; i++) {
        const childNode = documentElement.childNodes[i];
        resetElement(childNode);
        childNode.childNodes.length = 0;
      }
    }
    for (const key in doc) {
      if (doc.hasOwnProperty(key) && !DOC_KEY_KEEPERS.has(key)) {
        delete doc[key];
      }
    }
    try {
      doc.nodeName = "#document" /* NODE_NAMES.DOCUMENT_NODE */;
    }
    catch (e) { }
    try {
      doc.nodeType = 9 /* NODE_TYPES.DOCUMENT_NODE */;
    }
    catch (e) { }
    try {
      doc.cookie = '';
    }
    catch (e) { }
    try {
      doc.referrer = '';
    }
    catch (e) { }
  }
}
const DOC_KEY_KEEPERS = new Set([
  'nodeName',
  'nodeType',
  'nodeValue',
  'ownerDocument',
  'parentNode',
  'childNodes',
  '_shadowRoot',
]);
function getElementById(elm, id) {
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    if (childElm.id === id) {
      return childElm;
    }
    const childElmFound = getElementById(childElm, id);
    if (childElmFound != null) {
      return childElmFound;
    }
  }
  return null;
}
function getElementsByName(elm, elmName, foundElms = []) {
  const children = elm.children;
  for (let i = 0, ii = children.length; i < ii; i++) {
    const childElm = children[i];
    if (childElm.name && childElm.name.toLowerCase() === elmName) {
      foundElms.push(childElm);
    }
    getElementsByName(childElm, elmName, foundElms);
  }
  return foundElms;
}
function setOwnerDocument(elm, ownerDocument) {
  for (let i = 0, ii = elm.childNodes.length; i < ii; i++) {
    elm.childNodes[i].ownerDocument = ownerDocument;
    if (elm.childNodes[i].nodeType === 1 /* NODE_TYPES.ELEMENT_NODE */) {
      setOwnerDocument(elm.childNodes[i], ownerDocument);
    }
  }
}

function hydrateFactory($stencilWindow, $stencilHydrateOpts, $stencilHydrateResults, $stencilAfterHydrate, $stencilHydrateResolve) {
  var globalThis = $stencilWindow;
  var self = $stencilWindow;
  var top = $stencilWindow;
  var parent = $stencilWindow;

  var addEventListener = $stencilWindow.addEventListener.bind($stencilWindow);
  var alert = $stencilWindow.alert.bind($stencilWindow);
  var blur = $stencilWindow.blur.bind($stencilWindow);
  var cancelAnimationFrame = $stencilWindow.cancelAnimationFrame.bind($stencilWindow);
  var cancelIdleCallback = $stencilWindow.cancelIdleCallback.bind($stencilWindow);
  var clearInterval = $stencilWindow.clearInterval.bind($stencilWindow);
  var clearTimeout = $stencilWindow.clearTimeout.bind($stencilWindow);
  var close = () => {};
  var confirm = $stencilWindow.confirm.bind($stencilWindow);
  var dispatchEvent = $stencilWindow.dispatchEvent.bind($stencilWindow);
  var focus = $stencilWindow.focus.bind($stencilWindow);
  var getComputedStyle = $stencilWindow.getComputedStyle.bind($stencilWindow);
  var matchMedia = $stencilWindow.matchMedia.bind($stencilWindow);
  var open = $stencilWindow.open.bind($stencilWindow);
  var prompt = $stencilWindow.prompt.bind($stencilWindow);
  var removeEventListener = $stencilWindow.removeEventListener.bind($stencilWindow);
  var requestAnimationFrame = $stencilWindow.requestAnimationFrame.bind($stencilWindow);
  var requestIdleCallback = $stencilWindow.requestIdleCallback.bind($stencilWindow);
  var setInterval = $stencilWindow.setInterval.bind($stencilWindow);
  var setTimeout = $stencilWindow.setTimeout.bind($stencilWindow);

  var CharacterData = $stencilWindow.CharacterData;
  var CSS = $stencilWindow.CSS;
  var CustomEvent = $stencilWindow.CustomEvent;
  var Document = $stencilWindow.Document;
  var DocumentFragment = $stencilWindow.DocumentFragment;
  var DocumentType = $stencilWindow.DocumentType;
  var DOMTokenList = $stencilWindow.DOMTokenList;
  var Element = $stencilWindow.Element;
  var Event = $stencilWindow.Event;
  var HTMLAnchorElement = $stencilWindow.HTMLAnchorElement;
  var HTMLBaseElement = $stencilWindow.HTMLBaseElement;
  var HTMLButtonElement = $stencilWindow.HTMLButtonElement;
  var HTMLCanvasElement = $stencilWindow.HTMLCanvasElement;
  var HTMLElement = $stencilWindow.HTMLElement;
  var HTMLFormElement = $stencilWindow.HTMLFormElement;
  var HTMLImageElement = $stencilWindow.HTMLImageElement;
  var HTMLInputElement = $stencilWindow.HTMLInputElement;
  var HTMLLinkElement = $stencilWindow.HTMLLinkElement;
  var HTMLMetaElement = $stencilWindow.HTMLMetaElement;
  var HTMLScriptElement = $stencilWindow.HTMLScriptElement;
  var HTMLStyleElement = $stencilWindow.HTMLStyleElement;
  var HTMLTemplateElement = $stencilWindow.HTMLTemplateElement;
  var HTMLTitleElement = $stencilWindow.HTMLTitleElement;
  var IntersectionObserver = $stencilWindow.IntersectionObserver;
  var KeyboardEvent = $stencilWindow.KeyboardEvent;
  var MouseEvent = $stencilWindow.MouseEvent;
  var Node = $stencilWindow.Node;
  var NodeList = $stencilWindow.NodeList;
  var URL = $stencilWindow.URL;

  var console = $stencilWindow.console;
  var customElements = $stencilWindow.customElements;
  var history = $stencilWindow.history;
  var localStorage = $stencilWindow.localStorage;
  var location = $stencilWindow.location;
  var navigator = $stencilWindow.navigator;
  var performance = $stencilWindow.performance;
  var sessionStorage = $stencilWindow.sessionStorage;

  var devicePixelRatio = $stencilWindow.devicePixelRatio;
  var innerHeight = $stencilWindow.innerHeight;
  var innerWidth = $stencilWindow.innerWidth;
  var origin = $stencilWindow.origin;
  var pageXOffset = $stencilWindow.pageXOffset;
  var pageYOffset = $stencilWindow.pageYOffset;
  var screen = $stencilWindow.screen;
  var screenLeft = $stencilWindow.screenLeft;
  var screenTop = $stencilWindow.screenTop;
  var screenX = $stencilWindow.screenX;
  var screenY = $stencilWindow.screenY;
  var scrollX = $stencilWindow.scrollX;
  var scrollY = $stencilWindow.scrollY;
  var exports = {};

  var fetch, FetchError, Headers, Request, Response;

  if (typeof $stencilWindow.fetch === 'function') {
  fetch = $stencilWindow.fetch;
  } else {
  fetch = $stencilWindow.fetch = function() { throw new Error('fetch() is not implemented'); };
  }

  if (typeof $stencilWindow.FetchError === 'function') {
  FetchError = $stencilWindow.FetchError;
  } else {
  FetchError = $stencilWindow.FetchError = class FetchError { constructor() { throw new Error('FetchError is not implemented'); } };
  }

  if (typeof $stencilWindow.Headers === 'function') {
  Headers = $stencilWindow.Headers;
  } else {
  Headers = $stencilWindow.Headers = class Headers { constructor() { throw new Error('Headers is not implemented'); } };
  }

  if (typeof $stencilWindow.Request === 'function') {
  Request = $stencilWindow.Request;
  } else {
  Request = $stencilWindow.Request = class Request { constructor() { throw new Error('Request is not implemented'); } };
  }

  if (typeof $stencilWindow.Response === 'function') {
  Response = $stencilWindow.Response;
  } else {
  Response = $stencilWindow.Response = class Response { constructor() { throw new Error('Response is not implemented'); } };
  }

  function hydrateAppClosure($stencilWindow) {
  const window = $stencilWindow;
  const document = $stencilWindow.document;
  /*hydrateAppClosure start*/


const NAMESPACE = 'webcomponents';
const BUILD = /* webcomponents */ { allRenderFn: true, appendChildSlotFix: false, asyncLoading: true, attachStyles: true, cloneNodeFix: false, cmpDidLoad: true, cmpDidRender: true, cmpDidUnload: false, cmpDidUpdate: true, cmpShouldUpdate: false, cmpWillLoad: true, cmpWillRender: false, cmpWillUpdate: true, connectedCallback: true, constructableCSS: false, cssAnnotations: true, cssVarShim: false, devTools: false, disconnectedCallback: true, dynamicImportShim: false, element: false, event: true, hasRenderFn: true, hostListener: true, hostListenerTarget: true, hostListenerTargetBody: false, hostListenerTargetDocument: false, hostListenerTargetParent: false, hostListenerTargetWindow: true, hotModuleReplacement: false, hydrateClientSide: true, hydrateServerSide: true, hydratedAttribute: false, hydratedClass: true, isDebug: false, isDev: false, isTesting: false, lazyLoad: true, lifecycle: true, lifecycleDOMEvents: false, member: true, method: true, mode: false, observeAttribute: true, profile: false, prop: true, propBoolean: true, propMutable: true, propNumber: true, propString: true, reflect: false, safari10: false, scoped: false, scriptDataOpts: false, shadowDelegatesFocus: false, shadowDom: true, shadowDomShim: true, slot: true, slotChildNodesFix: false, slotRelocation: true, state: true, style: true, svg: true, taskQueue: true, updatable: true, vdomAttribute: true, vdomClass: true, vdomFunctional: true, vdomKey: true, vdomListener: true, vdomPropOrAttr: true, vdomRef: true, vdomRender: true, vdomStyle: true, vdomText: true, vdomXlink: true, watchCallback: true };

function queryNonceMetaTagContent(e) {
 var t, o, n;
 return null !== (n = null === (o = null === (t = e.head) || void 0 === t ? void 0 : t.querySelector('meta[name="csp-nonce"]')) || void 0 === o ? void 0 : o.getAttribute("content")) && void 0 !== n ? n : void 0;
}

function componentOnReady() {
 return getHostRef(this).$onReadyPromise$;
}

function forceUpdate() {}

function hydrateApp(e, t, o, n, s) {
 function l() {
  if (global.clearTimeout(p), i.clear(), r.clear(), !h) {
   h = !0;
   try {
    t.clientHydrateAnnotations && insertVdomAnnotations(e.document, t.staticComponents), 
    e.dispatchEvent(new e.Event("DOMContentLoaded")), e.document.createElement = c, 
    e.document.createElementNS = $;
   } catch (e) {
    renderCatchError(t, o, e);
   }
  }
  n(e, t, o, s);
 }
 function a(e) {
  renderCatchError(t, o, e), l();
 }
 const r = new Set, i = new Set, d = new Set, c = e.document.createElement, $ = e.document.createElementNS, m = Promise.resolve();
 let p, h = !1;
 try {
  function u() {
   return g(this);
  }
  function f(e) {
   if (isValidComponent(e, t) && !getHostRef(e)) {
    const t = loadModule({
     $tagName$: e.nodeName.toLowerCase(),
     $flags$: null
    });
    null != t && null != t.cmpMeta && (i.add(e), e.connectedCallback = u, registerHost(e, t.cmpMeta), 
    function o(e, t) {
     if ("function" != typeof e.componentOnReady && (e.componentOnReady = componentOnReady), 
     "function" != typeof e.forceUpdate && (e.forceUpdate = forceUpdate), 1 & t.$flags$ && (e.shadowRoot = e), 
     null != t.$members$) {
      const o = getHostRef(e);
      Object.entries(t.$members$).forEach((([n, s]) => {
       const l = s[0];
       if (31 & l) {
        const a = s[1] || n, r = e.getAttribute(a);
        if (null != r) {
         const e = parsePropertyValue(r, l);
         o.$instanceValues$.set(n, e);
        }
        const i = e[n];
        void 0 !== i && (o.$instanceValues$.set(n, i), delete e[n]), Object.defineProperty(e, n, {
         get() {
          return getValue(this, n);
         },
         set(e) {
          setValue(this, n, e, t);
         },
         configurable: !0,
         enumerable: !0
        });
       } else 64 & l && Object.defineProperty(e, n, {
        value(...e) {
         const t = getHostRef(this);
         return t.$onInstancePromise$.then((() => t.$lazyInstance$[n](...e))).catch(consoleError);
        }
       });
      }));
     }
    }(e, t.cmpMeta));
   }
  }
  function g(n) {
   return i.delete(n), isValidComponent(n, t) && o.hydratedCount < t.maxHydrateCount && !r.has(n) && shouldHydrate(n) ? (r.add(n), 
   async function s(e, t, o, n, l) {
    o = o.toLowerCase();
    const a = loadModule({
     $tagName$: o,
     $flags$: null
    });
    if (null != a && null != a.cmpMeta) {
     l.add(n);
     try {
      connectedCallback(n), await n.componentOnReady(), t.hydratedCount++;
      const e = getHostRef(n), s = e.$modeName$ ? e.$modeName$ : "$";
      t.components.some((e => e.tag === o && e.mode === s)) || t.components.push({
       tag: o,
       mode: s,
       count: 0,
       depth: -1
      });
     } catch (t) {
      e.console.error(t);
     }
     l.delete(n);
    }
   }(e, o, n.nodeName, n, d)) : m;
  }
  e.document.createElement = function t(o) {
   const n = c.call(e.document, o);
   return f(n), n;
  }, e.document.createElementNS = function t(o, n) {
   const s = $.call(e.document, o, n);
   return f(s), s;
  }, p = global.setTimeout((function L() {
   a(`Hydrate exceeded timeout${function e(t) {
    return Array.from(t).map(waitingOnElementMsg);
   }(d)}`);
  }), t.timeout), plt.$resourcesUrl$ = new URL(t.resourcesUrl || "./", doc.baseURI).href, 
  function e(t) {
   if (null != t && 1 === t.nodeType) {
    f(t);
    const o = t.children;
    for (let t = 0, n = o.length; t < n; t++) e(o[t]);
   }
  }(e.document.body), function e() {
   const t = Array.from(i).filter((e => e.parentElement));
   return t.length > 0 ? Promise.all(t.map(g)).then(e) : m;
  }().then(l).catch(a);
 } catch (y) {
  a(y);
 }
}

function isValidComponent(e, t) {
 if (null != e && 1 === e.nodeType) {
  const o = e.nodeName;
  if ("string" == typeof o && o.includes("-")) return !t.excludeComponents.includes(o.toLowerCase());
 }
 return !1;
}

function shouldHydrate(e) {
 if (9 === e.nodeType) return !0;
 if (NO_HYDRATE_TAGS.has(e.nodeName)) return !1;
 if (e.hasAttribute("no-prerender")) return !1;
 const t = e.parentNode;
 return null == t || shouldHydrate(t);
}

function renderCatchError(e, t, o) {
 const n = {
  level: "error",
  type: "build",
  header: "Hydrate Error",
  messageText: "",
  relFilePath: null,
  absFilePath: null,
  lines: []
 };
 if (e.url) try {
  const t = new URL(e.url);
  "/" !== t.pathname && (n.header += ": " + t.pathname);
 } catch (e) {}
 null != o && (null != o.stack ? n.messageText = o.stack.toString() : null != o.message ? n.messageText = o.message.toString() : n.messageText = o.toString()), 
 t.diagnostics.push(n);
}

function printTag(e) {
 let t = `<${e.nodeName.toLowerCase()}`;
 if (Array.isArray(e.attributes)) for (let o = 0; o < e.attributes.length; o++) {
  const n = e.attributes[o];
  t += ` ${n.name}`, "" !== n.value && (t += `="${n.value}"`);
 }
 return t += ">", t;
}

function waitingOnElementMsg(e) {
 let t = "";
 if (e) {
  const o = [];
  t = " - waiting on:";
  let n = e;
  for (;n && 9 !== n.nodeType && "BODY" !== n.nodeName; ) o.unshift(printTag(n)), 
  n = n.parentElement;
  let s = "";
  for (const e of o) s += "  ", t += `\n${s}${e}`;
 }
 return t;
}

const getAssetPath = e => {
 const t = new URL(e, plt.$resourcesUrl$);
 return t.origin !== win.location.origin ? t.href : t.pathname;
};

const createTime = (e, t = "") => {
 return () => {};
}, XLINK_NS = "http://www.w3.org/1999/xlink", EMPTY_OBJ = {}, isComplexType = e => "object" == (e = typeof e) || "function" === e, isPromise = e => !!e && ("object" == typeof e || "function" == typeof e) && "function" == typeof e.then, h = (e, t, ...o) => {
 let n = null, s = null, l = null, a = !1, r = !1;
 const i = [], d = t => {
  for (let o = 0; o < t.length; o++) n = t[o], Array.isArray(n) ? d(n) : null != n && "boolean" != typeof n && ((a = "function" != typeof e && !isComplexType(n)) ? n = String(n) : BUILD.isDev  , 
  a && r ? i[i.length - 1].$text$ += n : i.push(a ? newVNode(null, n) : n), r = a);
 };
 if (d(o), t && (t.key && (s = t.key), 
 t.name && (l = t.name), BUILD.vdomClass)) {
  const e = t.className || t.class;
  e && (t.class = "object" != typeof e ? e : Object.keys(e).filter((t => e[t])).join(" "));
 }
 if ("function" == typeof e) return e(null === t ? {} : t, i, vdomFnUtils);
 const c = newVNode(e, null);
 return c.$attrs$ = t, i.length > 0 && (c.$children$ = i), (c.$key$ = s), 
 (c.$name$ = l), c;
}, newVNode = (e, t) => {
 const o = {
  $flags$: 0,
  $tag$: e,
  $text$: t,
  $elm$: null,
  $children$: null
 };
 return (o.$attrs$ = null), (o.$key$ = null), 
 (o.$name$ = null), o;
}, Host = {}, isHost = e => e && e.$tag$ === Host, vdomFnUtils = {
 forEach: (e, t) => e.map(convertToPublic).forEach(t),
 map: (e, t) => e.map(convertToPublic).map(t).map(convertToPrivate)
}, convertToPublic = e => ({
 vattrs: e.$attrs$,
 vchildren: e.$children$,
 vkey: e.$key$,
 vname: e.$name$,
 vtag: e.$tag$,
 vtext: e.$text$
}), convertToPrivate = e => {
 if ("function" == typeof e.vtag) {
  const t = {
   ...e.vattrs
  };
  return e.vkey && (t.key = e.vkey), e.vname && (t.name = e.vname), h(e.vtag, t, ...e.vchildren || []);
 }
 const t = newVNode(e.vtag, e.vtext);
 return t.$attrs$ = e.vattrs, t.$children$ = e.vchildren, t.$key$ = e.vkey, t.$name$ = e.vname, 
 t;
}, clientHydrate = (e, t, o, n, s, l, a) => {
 let r, i, d, c;
 if (1 === l.nodeType) {
  for (r = l.getAttribute("c-id"), r && (i = r.split("."), i[0] !== a && "0" !== i[0] || (d = {
   $flags$: 0,
   $hostId$: i[0],
   $nodeId$: i[1],
   $depth$: i[2],
   $index$: i[3],
   $tag$: l.tagName.toLowerCase(),
   $elm$: l,
   $attrs$: null,
   $children$: null,
   $key$: null,
   $name$: null,
   $text$: null
  }, t.push(d), l.removeAttribute("c-id"), e.$children$ || (e.$children$ = []), e.$children$[d.$index$] = d, 
  e = d, n && "0" === d.$depth$ && (n[d.$index$] = d.$elm$))), c = l.childNodes.length - 1; c >= 0; c--) clientHydrate(e, t, o, n, s, l.childNodes[c], a);
  if (l.shadowRoot) for (c = l.shadowRoot.childNodes.length - 1; c >= 0; c--) clientHydrate(e, t, o, n, s, l.shadowRoot.childNodes[c], a);
 } else if (8 === l.nodeType) i = l.nodeValue.split("."), i[1] !== a && "0" !== i[1] || (r = i[0], 
 d = {
  $flags$: 0,
  $hostId$: i[1],
  $nodeId$: i[2],
  $depth$: i[3],
  $index$: i[4],
  $elm$: l,
  $attrs$: null,
  $children$: null,
  $key$: null,
  $name$: null,
  $tag$: null,
  $text$: null
 }, "t" === r ? (d.$elm$ = l.nextSibling, d.$elm$ && 3 === d.$elm$.nodeType && (d.$text$ = d.$elm$.textContent, 
 t.push(d), l.remove(), e.$children$ || (e.$children$ = []), e.$children$[d.$index$] = d, 
 n && "0" === d.$depth$ && (n[d.$index$] = d.$elm$))) : d.$hostId$ === a && ("s" === r ? (d.$tag$ = "slot", 
 i[5] ? l["s-sn"] = d.$name$ = i[5] : l["s-sn"] = "", l["s-sr"] = !0, n && (d.$elm$ = doc.createElement(d.$tag$), 
 d.$name$ && d.$elm$.setAttribute("name", d.$name$), l.parentNode.insertBefore(d.$elm$, l), 
 l.remove(), "0" === d.$depth$ && (n[d.$index$] = d.$elm$)), o.push(d), e.$children$ || (e.$children$ = []), 
 e.$children$[d.$index$] = d) : "r" === r && (n ? l.remove() : (s["s-cr"] = l, 
 l["s-cn"] = !0)))); else if (e && "style" === e.$tag$) {
  const t = newVNode(null, l.textContent);
  t.$elm$ = l, t.$index$ = "0", e.$children$ = [ t ];
 }
}, initializeDocumentHydrate = (e, t) => {
 if (1 === e.nodeType) {
  let o = 0;
  for (;o < e.childNodes.length; o++) initializeDocumentHydrate(e.childNodes[o], t);
  if (e.shadowRoot) for (o = 0; o < e.shadowRoot.childNodes.length; o++) initializeDocumentHydrate(e.shadowRoot.childNodes[o], t);
 } else if (8 === e.nodeType) {
  const o = e.nodeValue.split(".");
  "o" === o[0] && (t.set(o[1] + "." + o[2], e), e.nodeValue = "", e["s-en"] = o[3]);
 }
}, parsePropertyValue = (e, t) => null == e || isComplexType(e) ? e : 4 & t ? "false" !== e && ("" === e || !!e) : 2 & t ? parseFloat(e) : 1 & t ? String(e) : e, getElement = e => getHostRef(e).$hostElement$ , createEvent = (e, t, o) => {
 const n = getElement(e);
 return {
  emit: e => (emitEvent(n, t, {
   bubbles: !!(4 & o),
   composed: !!(2 & o),
   cancelable: !!(1 & o),
   detail: e
  }))
 };
}, emitEvent = (e, t, o) => {
 const n = plt.ce(t, o);
 return e.dispatchEvent(n), n;
}, rootAppliedStyles = new WeakMap, registerStyle = (e, t, o) => {
 let n = styles.get(e);
 n = t, styles.set(e, n);
}, addStyle = (e, t, o, n) => {
 var s;
 let l = getScopeId(t);
 const a = styles.get(l);
 if (e = 11 === e.nodeType ? e : doc, a) if ("string" == typeof a) {
  e = e.head || e;
  let o, r = rootAppliedStyles.get(e);
  if (r || rootAppliedStyles.set(e, r = new Set), !r.has(l)) {
   if (e.host && (o = e.querySelector(`[sty-id="${l}"]`))) o.innerHTML = a; else {
    o = doc.createElement("style"), o.innerHTML = a;
    const i = null !== (s = plt.$nonce$) && void 0 !== s ? s : queryNonceMetaTagContent(doc);
    null != i && o.setAttribute("nonce", i), o.setAttribute("sty-id", l), 
    e.insertBefore(o, e.querySelector("link"));
   }
   r && r.add(l);
  }
 }
 return l;
}, attachStyles = e => {
 const t = e.$cmpMeta$, o = e.$hostElement$, n = t.$flags$, s = createTime("attachStyles", t.$tagName$), l = addStyle(o.getRootNode(), t);
 10 & n && (o["s-sc"] = l, 
 o.classList.add(l + "-h"), BUILD.scoped  ), 
 s();
}, getScopeId = (e, t) => "sc-" + (e.$tagName$), setAccessor = (e, t, o, n, s, l) => {
 if (o !== n) {
  let a = isMemberInElement(e, t), r = t.toLowerCase();
  if ("class" === t) {
   const t = e.classList, s = parseClassList(o), l = parseClassList(n);
   t.remove(...s.filter((e => e && !l.includes(e)))), t.add(...l.filter((e => e && !s.includes(e))));
  } else if ("style" === t) {
   for (const t in o) n && null != n[t] || (e.style[t] = "");
   for (const t in n) o && n[t] === o[t] || (e.style[t] = n[t]);
  } else if ("key" === t) ; else if ("ref" === t) n && n(e); else if ((a ) || "o" !== t[0] || "n" !== t[1]) {
   {
    const i = isComplexType(n);
    if ((a || i && null !== n) && !s) try {
     if (e.tagName.includes("-")) e[t] = n; else {
      const s = null == n ? "" : n;
      "list" === t ? a = !1 : null != o && e[t] == s || (e[t] = s);
     }
    } catch (e) {}
    let d = !1;
    r !== (r = r.replace(/^xlink\:?/, "")) && (t = r, d = !0), null == n || !1 === n ? !1 === n && "" !== e.getAttribute(t) || (d ? e.removeAttributeNS(XLINK_NS, t) : e.removeAttribute(t)) : (!a || 4 & l || s) && !i && (n = !0 === n ? "" : n, 
    d ? e.setAttributeNS(XLINK_NS, t, n) : e.setAttribute(t, n));
   }
  } else t = "-" === t[2] ? t.slice(3) : isMemberInElement(win, r) ? r.slice(2) : r[2] + t.slice(3), 
  o && plt.rel(e, t, o, !1), n && plt.ael(e, t, n, !1);
 }
}, parseClassListRegex = /\s/, parseClassList = e => e ? e.split(parseClassListRegex) : [], updateElement = (e, t, o, n) => {
 const s = 11 === t.$elm$.nodeType && t.$elm$.host ? t.$elm$.host : t.$elm$, l = e && e.$attrs$ || EMPTY_OBJ, a = t.$attrs$ || EMPTY_OBJ;
 for (n in l) n in a || setAccessor(s, n, l[n], void 0, o, t.$flags$);
 for (n in a) setAccessor(s, n, l[n], a[n], o, t.$flags$);
};

let scopeId, contentRef, hostTagName, useNativeShadowDom = !1, checkSlotFallbackVisibility = !1, checkSlotRelocate = !1, isSvgMode = !1;

const createElm = (e, t, o, n) => {
 const s = t.$children$[o];
 let l, a, r, i = 0;
 if (!useNativeShadowDom && (checkSlotRelocate = !0, "slot" === s.$tag$ && (scopeId && n.classList.add(scopeId + "-s"), 
 s.$flags$ |= s.$children$ ? 2 : 1)), null !== s.$text$) l = s.$elm$ = doc.createTextNode(s.$text$); else if (1 & s.$flags$) l = s.$elm$ = slotReferenceDebugNode(s) ; else {
  if (!isSvgMode && (isSvgMode = "svg" === s.$tag$), l = s.$elm$ = doc.createElementNS(isSvgMode ? "http://www.w3.org/2000/svg" : "http://www.w3.org/1999/xhtml", 2 & s.$flags$ ? "slot-fb" : s.$tag$) , 
  isSvgMode && "foreignObject" === s.$tag$ && (isSvgMode = !1), updateElement(null, s, isSvgMode), 
  null != scopeId && l["s-si"] !== scopeId && l.classList.add(l["s-si"] = scopeId), 
  s.$children$) for (i = 0; i < s.$children$.length; ++i) a = createElm(e, s, i, l), 
  a && l.appendChild(a);
  ("svg" === s.$tag$ ? isSvgMode = !1 : "foreignObject" === l.tagName && (isSvgMode = !0));
 }
 return (l["s-hn"] = hostTagName, 3 & s.$flags$ && (l["s-sr"] = !0, 
 l["s-cr"] = contentRef, l["s-sn"] = s.$name$ || "", r = e && e.$children$ && e.$children$[o], 
 r && r.$tag$ === s.$tag$ && e.$elm$ && putBackInOriginalLocation(e.$elm$, !1))), 
 l;
}, putBackInOriginalLocation = (e, t) => {
 plt.$flags$ |= 1;
 const o = e.childNodes;
 for (let e = o.length - 1; e >= 0; e--) {
  const n = o[e];
  n["s-hn"] !== hostTagName && n["s-ol"] && (parentReferenceNode(n).insertBefore(n, referenceNode(n)), 
  n["s-ol"].remove(), n["s-ol"] = void 0, checkSlotRelocate = !0), t && putBackInOriginalLocation(n, t);
 }
 plt.$flags$ &= -2;
}, addVnodes = (e, t, o, n, s, l) => {
 let a, r = e["s-cr"] && e["s-cr"].parentNode || e;
 for (r.shadowRoot && r.tagName === hostTagName && (r = r.shadowRoot); s <= l; ++s) n[s] && (a = createElm(null, o, s, e), 
 a && (n[s].$elm$ = a, r.insertBefore(a, referenceNode(t) )));
}, removeVnodes = (e, t, o, n, s) => {
 for (;t <= o; ++t) (n = e[t]) && (s = n.$elm$, callNodeRefs(n), (checkSlotFallbackVisibility = !0, 
 s["s-ol"] ? s["s-ol"].remove() : putBackInOriginalLocation(s, !0)), s.remove());
}, isSameVnode = (e, t) => e.$tag$ === t.$tag$ && ("slot" === e.$tag$ ? e.$name$ === t.$name$ : e.$key$ === t.$key$), referenceNode = e => e && e["s-ol"] || e, parentReferenceNode = e => (e["s-ol"] ? e["s-ol"] : e).parentNode, patch = (e, t) => {
 const o = t.$elm$ = e.$elm$, n = e.$children$, s = t.$children$, l = t.$tag$, a = t.$text$;
 let r;
 null !== a ? (r = o["s-cr"]) ? r.parentNode.textContent = a : e.$text$ !== a && (o.data = a) : ((isSvgMode = "svg" === l || "foreignObject" !== l && isSvgMode), 
 ("slot" === l || updateElement(e, t, isSvgMode)), 
 null !== n && null !== s ? ((e, t, o, n) => {
  let s, l, a = 0, r = 0, i = 0, d = 0, c = t.length - 1, $ = t[0], m = t[c], p = n.length - 1, h = n[0], u = n[p];
  for (;a <= c && r <= p; ) if (null == $) $ = t[++a]; else if (null == m) m = t[--c]; else if (null == h) h = n[++r]; else if (null == u) u = n[--p]; else if (isSameVnode($, h)) patch($, h), 
  $ = t[++a], h = n[++r]; else if (isSameVnode(m, u)) patch(m, u), m = t[--c], u = n[--p]; else if (isSameVnode($, u)) "slot" !== $.$tag$ && "slot" !== u.$tag$ || putBackInOriginalLocation($.$elm$.parentNode, !1), 
  patch($, u), e.insertBefore($.$elm$, m.$elm$.nextSibling), $ = t[++a], u = n[--p]; else if (isSameVnode(m, h)) "slot" !== $.$tag$ && "slot" !== u.$tag$ || putBackInOriginalLocation(m.$elm$.parentNode, !1), 
  patch(m, h), e.insertBefore(m.$elm$, $.$elm$), m = t[--c], h = n[++r]; else {
   if (i = -1, BUILD.vdomKey) for (d = a; d <= c; ++d) if (t[d] && null !== t[d].$key$ && t[d].$key$ === h.$key$) {
    i = d;
    break;
   }
   i >= 0 ? (l = t[i], l.$tag$ !== h.$tag$ ? s = createElm(t && t[r], o, i, e) : (patch(l, h), 
   t[i] = void 0, s = l.$elm$), h = n[++r]) : (s = createElm(t && t[r], o, r, e), h = n[++r]), 
   s && (parentReferenceNode($.$elm$).insertBefore(s, referenceNode($.$elm$)) );
  }
  a > c ? addVnodes(e, null == n[p + 1] ? null : n[p + 1].$elm$, o, n, r, p) : r > p && removeVnodes(t, a, c);
 })(o, n, t, s) : null !== s ? (null !== e.$text$ && (o.textContent = ""), 
 addVnodes(o, null, t, s, 0, s.length - 1)) : null !== n && removeVnodes(n, 0, n.length - 1), 
 isSvgMode && "svg" === l && (isSvgMode = !1));
}, updateFallbackSlotVisibility = e => {
 const t = e.childNodes;
 let o, n, s, l, a, r;
 for (n = 0, s = t.length; n < s; n++) if (o = t[n], 1 === o.nodeType) {
  if (o["s-sr"]) for (a = o["s-sn"], o.hidden = !1, l = 0; l < s; l++) if (r = t[l].nodeType, 
  t[l]["s-hn"] !== o["s-hn"] || "" !== a) {
   if (1 === r && a === t[l].getAttribute("slot")) {
    o.hidden = !0;
    break;
   }
  } else if (1 === r || 3 === r && "" !== t[l].textContent.trim()) {
   o.hidden = !0;
   break;
  }
  updateFallbackSlotVisibility(o);
 }
}, relocateNodes = [], relocateSlotContent = e => {
 let t, o, n, s, l, a, r = 0;
 const i = e.childNodes, d = i.length;
 for (;r < d; r++) {
  if (t = i[r], t["s-sr"] && (o = t["s-cr"]) && o.parentNode) for (n = o.parentNode.childNodes, 
  s = t["s-sn"], a = n.length - 1; a >= 0; a--) o = n[a], o["s-cn"] || o["s-nr"] || o["s-hn"] === t["s-hn"] || (isNodeLocatedInSlot(o, s) ? (l = relocateNodes.find((e => e.$nodeToRelocate$ === o)), 
  checkSlotFallbackVisibility = !0, o["s-sn"] = o["s-sn"] || s, l ? l.$slotRefNode$ = t : relocateNodes.push({
   $slotRefNode$: t,
   $nodeToRelocate$: o
  }), o["s-sr"] && relocateNodes.map((e => {
   isNodeLocatedInSlot(e.$nodeToRelocate$, o["s-sn"]) && (l = relocateNodes.find((e => e.$nodeToRelocate$ === o)), 
   l && !e.$slotRefNode$ && (e.$slotRefNode$ = l.$slotRefNode$));
  }))) : relocateNodes.some((e => e.$nodeToRelocate$ === o)) || relocateNodes.push({
   $nodeToRelocate$: o
  }));
  1 === t.nodeType && relocateSlotContent(t);
 }
}, isNodeLocatedInSlot = (e, t) => 1 === e.nodeType ? null === e.getAttribute("slot") && "" === t || e.getAttribute("slot") === t : e["s-sn"] === t || "" === t, callNodeRefs = e => {
 (e.$attrs$ && e.$attrs$.ref && e.$attrs$.ref(null), e.$children$ && e.$children$.map(callNodeRefs));
}, renderVdom = (e, t) => {
 const o = e.$hostElement$, s = e.$vnode$ || newVNode(null, null), l = isHost(t) ? t : h(null, null, t);
 if (hostTagName = o.tagName, BUILD.isDev  ) ;
 if (l.$tag$ = null, l.$flags$ |= 4, e.$vnode$ = l, l.$elm$ = s.$elm$ = o.shadowRoot || o, 
 (scopeId = o["s-sc"]), (contentRef = o["s-cr"], 
 useNativeShadowDom = supportsShadow, checkSlotFallbackVisibility = !1), patch(s, l), 
 BUILD.slotRelocation) {
  if (plt.$flags$ |= 1, checkSlotRelocate) {
   let e, t, o, n, s, a;
   relocateSlotContent(l.$elm$);
   let r = 0;
   for (;r < relocateNodes.length; r++) e = relocateNodes[r], t = e.$nodeToRelocate$, 
   t["s-ol"] || (o = originalLocationDebugNode(t) , 
   o["s-nr"] = t, t.parentNode.insertBefore(t["s-ol"] = o, t));
   for (r = 0; r < relocateNodes.length; r++) if (e = relocateNodes[r], t = e.$nodeToRelocate$, 
   e.$slotRefNode$) {
    for (n = e.$slotRefNode$.parentNode, s = e.$slotRefNode$.nextSibling, o = t["s-ol"]; o = o.previousSibling; ) if (a = o["s-nr"], 
    a && a["s-sn"] === t["s-sn"] && n === a.parentNode && (a = a.nextSibling, !a || !a["s-nr"])) {
     s = a;
     break;
    }
    (!s && n !== t.parentNode || t.nextSibling !== s) && t !== s && (!t["s-hn"] && t["s-ol"] && (t["s-hn"] = t["s-ol"].parentNode.nodeName), 
    n.insertBefore(t, s));
   } else 1 === t.nodeType && (t.hidden = !0);
  }
  checkSlotFallbackVisibility && updateFallbackSlotVisibility(l.$elm$), plt.$flags$ &= -2, 
  relocateNodes.length = 0;
 }
}, slotReferenceDebugNode = e => doc.createComment(`<slot${e.$name$ ? ' name="' + e.$name$ + '"' : ""}> (host=${hostTagName.toLowerCase()})`), originalLocationDebugNode = e => doc.createComment("org-location for " + (e.localName ? `<${e.localName}> (host=${e["s-hn"]})` : `[${e.textContent}]`)), attachToAncestor = (e, t) => {
 t && !e.$onRenderResolve$ && t["s-p"] && t["s-p"].push(new Promise((t => e.$onRenderResolve$ = t)));
}, scheduleUpdate = (e, t) => {
 if ((e.$flags$ |= 16), 4 & e.$flags$) return void (e.$flags$ |= 512);
 attachToAncestor(e, e.$ancestorComponent$);
 const o = () => dispatchHooks(e, t);
 return writeTask(o) ;
}, dispatchHooks = (e, t) => {
 const n = createTime("scheduleUpdate", e.$cmpMeta$.$tagName$), s = e.$lazyInstance$ ;
 let l;
 return t ? ((e.$flags$ |= 256, e.$queuedListeners$ && (e.$queuedListeners$.map((([e, t]) => safeCall(s, e, t))), 
 e.$queuedListeners$ = null)), (l = safeCall(s, "componentWillLoad"))) : ((l = safeCall(s, "componentWillUpdate"))), n(), then(l, (() => updateComponent(e, s, t)));
}, updateComponent = async (e, t, o) => {
 const n = e.$hostElement$, s = createTime("update", e.$cmpMeta$.$tagName$), l = n["s-rc"];
 o && attachStyles(e);
 const a = createTime("render", e.$cmpMeta$.$tagName$);
 if (await callRender(e, t) , 
 BUILD.hydrateServerSide) try {
  serverSideConnected(n), o && (1 & e.$cmpMeta$.$flags$ ? n["s-en"] = "" : 2 & e.$cmpMeta$.$flags$ && (n["s-en"] = "c"));
 } catch (e) {
  consoleError(e, n);
 }
 if (l && (l.map((e => e())), n["s-rc"] = void 0), a(), s(), 
 BUILD.asyncLoading) {
  const t = n["s-p"], o = () => postUpdateComponent(e);
  0 === t.length ? o() : (Promise.all(t).then(o), e.$flags$ |= 4, t.length = 0);
 }
};

const callRender = (e, t, o) => {
 try {
  if (t = t.render(), (e.$flags$ &= -17), 
  (e.$flags$ |= 2), BUILD.hasRenderFn ) {
   return Promise.resolve(t).then((t => renderVdom(e, t)));
  }
 } catch (t) {
  consoleError(t, e.$hostElement$);
 }
 return null;
}, postUpdateComponent = e => {
 const t = e.$cmpMeta$.$tagName$, o = e.$hostElement$, n = createTime("postUpdate", t), s = e.$lazyInstance$ , l = e.$ancestorComponent$;
 (safeCall(s, "componentDidRender"), 
 BUILD.isDev ), 64 & e.$flags$ ? ((safeCall(s, "componentDidUpdate"), 
 BUILD.isDev ), n()) : (e.$flags$ |= 64, addHydratedFlag(o), 
 (safeCall(s, "componentDidLoad"), 
 BUILD.isDev ), n(), (e.$onReadyResolve$(o), l || appDidLoad())), e.$onInstanceResolve$(o), (e.$onRenderResolve$ && (e.$onRenderResolve$(), 
 e.$onRenderResolve$ = void 0), 512 & e.$flags$ && nextTick((() => scheduleUpdate(e, !1))), 
 e.$flags$ &= -517);
}, forceUpdate$1 = e => {
 {
  const t = getHostRef(e), o = t.$hostElement$.isConnected;
  return o && 2 == (18 & t.$flags$) && scheduleUpdate(t, !1), o;
 }
}, appDidLoad = e => {
 addHydratedFlag(doc.documentElement), nextTick((() => emitEvent(win, "appload", {
  detail: {
   namespace: NAMESPACE
  }
 }))), BUILD.profile  ;
}, safeCall = (e, t, o) => {
 if (e && e[t]) try {
  return e[t](o);
 } catch (e) {
  consoleError(e);
 }
}, then = (e, t) => e && e.then ? e.then(t) : t(), addHydratedFlag = e => e.classList.add("hydrated") , serverSideConnected = e => {
 const t = e.children;
 if (null != t) for (let e = 0, o = t.length; e < o; e++) {
  const o = t[e];
  "function" == typeof o.connectedCallback && o.connectedCallback(), serverSideConnected(o);
 }
}, getValue = (e, t) => getHostRef(e).$instanceValues$.get(t), setValue = (e, t, o, n) => {
 const s = getHostRef(e), l = s.$hostElement$ , a = s.$instanceValues$.get(t), r = s.$flags$, i = s.$lazyInstance$ ;
 o = parsePropertyValue(o, n.$members$[t][0]);
 const d = Number.isNaN(a) && Number.isNaN(o), c = o !== a && !d;
 if ((!(8 & r) || void 0 === a) && c && (s.$instanceValues$.set(t, o), 
 i)) {
  if (n.$watchers$ && 128 & r) {
   const e = n.$watchers$[t];
   e && e.map((e => {
    try {
     i[e](o, a, t);
    } catch (e) {
     consoleError(e, l);
    }
   }));
  }
  if (2 == (18 & r)) {
   scheduleUpdate(s, !1);
  }
 }
}, proxyComponent = (e, t, o) => {
 if (t.$members$) {
  e.watchers && (t.$watchers$ = e.watchers);
  const n = Object.entries(t.$members$), s = e.prototype;
  if (n.map((([e, [n]]) => {
   (31 & n || (2 & o) && 32 & n) ? Object.defineProperty(s, e, {
    get() {
     return getValue(this, e);
    },
    set(s) {
     setValue(this, e, s, t);
    },
    configurable: !0,
    enumerable: !0
   }) : 1 & o && 64 & n && Object.defineProperty(s, e, {
    value(...t) {
     const o = getHostRef(this);
     return o.$onInstancePromise$.then((() => o.$lazyInstance$[e](...t)));
    }
   });
  })), (1 & o)) {
   const o = new Map;
   s.attributeChangedCallback = function(e, t, n) {
    plt.jmp((() => {
     const t = o.get(e);
     if (this.hasOwnProperty(t)) n = this[t], delete this[t]; else if (s.hasOwnProperty(t) && "number" == typeof this[t] && this[t] == n) return;
     this[t] = (null !== n || "boolean" != typeof this[t]) && n;
    }));
   }, e.observedAttributes = n.filter((([e, t]) => 15 & t[0])).map((([e, n]) => {
    const s = n[1] || e;
    return o.set(s, e), s;
   }));
  }
 }
 return e;
}, initializeComponent = async (e, t, o, n, s) => {
 if (0 == (32 & t.$flags$)) {
  {
   if (t.$flags$ |= 32, (s = loadModule(o)).then) {
    const e = (() => {});
    s = await s, e();
   }
   !s.isProxied && ((o.$watchers$ = s.watchers), 
   proxyComponent(s, o, 2), s.isProxied = !0);
   const e = createTime("createInstance", o.$tagName$);
   (t.$flags$ |= 8);
   try {
    new s(t);
   } catch (e) {
    consoleError(e);
   }
   (t.$flags$ &= -9), (t.$flags$ |= 128), e(), 
   fireConnectedCallback(t.$lazyInstance$);
  }
  if (s.style) {
   let n = s.style;
   const l = getScopeId(o);
   if (!styles.has(l)) {
    const e = createTime("registerStyles", o.$tagName$);
    registerStyle(l, n), e();
   }
  }
 }
 const r = t.$ancestorComponent$, i = () => scheduleUpdate(t, !0);
 r && r["s-rc"] ? r["s-rc"].push(i) : i();
}, fireConnectedCallback = e => {
 safeCall(e, "connectedCallback");
}, connectedCallback = e => {
 if (0 == (1 & plt.$flags$)) {
  const t = getHostRef(e), o = t.$cmpMeta$, n = createTime("connectedCallback", o.$tagName$);
  if (1 & t.$flags$) addHostEventListeners(e, t, o.$listeners$), fireConnectedCallback(t.$lazyInstance$); else {
   let n;
   if (t.$flags$ |= 1, (n = e.getAttribute("s-id"), n)) {
    ((e, t, o, n) => {
     const s = createTime("hydrateClient", t), l = e.shadowRoot, a = [], r = l ? [] : null, i = n.$vnode$ = newVNode(t, null);
     plt.$orgLocNodes$ || initializeDocumentHydrate(doc.body, plt.$orgLocNodes$ = new Map), 
     e["s-id"] = o, e.removeAttribute("s-id"), clientHydrate(i, a, [], r, e, e, o), a.map((e => {
      const o = e.$hostId$ + "." + e.$nodeId$, n = plt.$orgLocNodes$.get(o), s = e.$elm$;
      n && supportsShadow && "" === n["s-en"] && n.parentNode.insertBefore(s, n.nextSibling), 
      l || (s["s-hn"] = t, n && (s["s-ol"] = n, s["s-ol"]["s-nr"] = s)), plt.$orgLocNodes$.delete(o);
     })), l && r.map((e => {
      e && l.appendChild(e);
     })), s();
    })(e, o.$tagName$, n, t);
   }
   if (!n && (BUILD.hydrateServerSide ) && setContentReference(e), 
   BUILD.asyncLoading) {
    let o = e;
    for (;o = o.parentNode || o.host; ) if (1 === o.nodeType && o.hasAttribute("s-id") && o["s-p"] || o["s-p"]) {
     attachToAncestor(t, t.$ancestorComponent$ = o);
     break;
    }
   }
   initializeComponent(e, t, o);
  }
  n();
 }
}, setContentReference = e => {
 const t = e["s-cr"] = doc.createComment("");
 t["s-cn"] = !0, e.insertBefore(t, e.firstChild);
}, Fragment = (e, t) => t, addHostEventListeners = (e, t, o, n) => {
 o && (o.map((([o, n, s]) => {
  const l = getHostListenerTarget(e, o) , a = hostListenerProxy(t, s), r = hostListenerOpts(o);
  plt.ael(l, n, a, r), (t.$rmListeners$ = t.$rmListeners$ || []).push((() => plt.rel(l, n, a, r)));
 })));
}, hostListenerProxy = (e, t) => o => {
 try {
  256 & e.$flags$ ? e.$lazyInstance$[t](o) : (e.$queuedListeners$ = e.$queuedListeners$ || []).push([ t, o ]) ;
 } catch (e) {
  consoleError(e);
 }
}, getHostListenerTarget = (e, t) => 8 & t ? win : e, hostListenerOpts = e => 0 != (2 & e), insertVdomAnnotations = (e, t) => {
 if (null != e) {
  const o = {
   hostIds: 0,
   rootLevelIds: 0,
   staticComponents: new Set(t)
  }, n = [];
  parseVNodeAnnotations(e, e.body, o, n), n.forEach((t => {
   if (null != t) {
    const n = t["s-nr"];
    let s = n["s-host-id"], l = n["s-node-id"], a = `${s}.${l}`;
    if (null == s) if (s = 0, o.rootLevelIds++, l = o.rootLevelIds, a = `${s}.${l}`, 
    1 === n.nodeType) n.setAttribute("c-id", a); else if (3 === n.nodeType) {
     if (0 === s && "" === n.nodeValue.trim()) return void t.remove();
     const o = e.createComment(a);
     o.nodeValue = `t.${a}`, n.parentNode.insertBefore(o, n);
    }
    let r = `o.${a}`;
    const i = t.parentElement;
    i && ("" === i["s-en"] ? r += "." : "c" === i["s-en"] && (r += ".c")), t.nodeValue = r;
   }
  }));
 }
}, parseVNodeAnnotations = (e, t, o, n) => {
 null != t && (null != t["s-nr"] && n.push(t), 1 === t.nodeType && t.childNodes.forEach((t => {
  const s = getHostRef(t);
  if (null != s && !o.staticComponents.has(t.nodeName.toLowerCase())) {
   const n = {
    nodeIds: 0
   };
   insertVNodeAnnotations(e, t, s.$vnode$, o, n);
  }
  parseVNodeAnnotations(e, t, o, n);
 })));
}, insertVNodeAnnotations = (e, t, o, n, s) => {
 if (null != o) {
  const l = ++n.hostIds;
  if (t.setAttribute("s-id", l), null != t["s-cr"] && (t["s-cr"].nodeValue = `r.${l}`), 
  null != o.$children$) {
   const t = 0;
   o.$children$.forEach(((o, n) => {
    insertChildVNodeAnnotations(e, o, s, l, t, n);
   }));
  }
  if (t && o && o.$elm$ && !t.hasAttribute("c-id")) {
   const e = t.parentElement;
   if (e && e.childNodes) {
    const n = Array.from(e.childNodes), s = n.find((e => 8 === e.nodeType && e["s-sr"]));
    if (s) {
     const e = n.indexOf(t) - 1;
     o.$elm$.setAttribute("c-id", `${s["s-host-id"]}.${s["s-node-id"]}.0.${e}`);
    }
   }
  }
 }
}, insertChildVNodeAnnotations = (e, t, o, n, s, l) => {
 const a = t.$elm$;
 if (null == a) return;
 const r = o.nodeIds++, i = `${n}.${r}.${s}.${l}`;
 if (a["s-host-id"] = n, a["s-node-id"] = r, 1 === a.nodeType) a.setAttribute("c-id", i); else if (3 === a.nodeType) {
  const t = a.parentNode, o = t.nodeName;
  if ("STYLE" !== o && "SCRIPT" !== o) {
   const o = `t.${i}`, n = e.createComment(o);
   t.insertBefore(n, a);
  }
 } else if (8 === a.nodeType && a["s-sr"]) {
  const e = `s.${i}.${a["s-sn"] || ""}`;
  a.nodeValue = e;
 }
 if (null != t.$children$) {
  const l = s + 1;
  t.$children$.forEach(((t, s) => {
   insertChildVNodeAnnotations(e, t, o, n, l, s);
  }));
 }
}, hAsync = (e, t, ...o) => {
 if (Array.isArray(o) && o.length > 0) {
  const n = o.flat(1 / 0);
  return n.some(isPromise) ? Promise.all(n).then((o => h(e, t, ...o))).catch((o => h(e, t))) : h(e, t, ...o);
 }
 return h(e, t);
}, NO_HYDRATE_TAGS = new Set([ "CODE", "HEAD", "IFRAME", "INPUT", "OBJECT", "OUTPUT", "NOSCRIPT", "PRE", "SCRIPT", "SELECT", "STYLE", "TEMPLATE", "TEXTAREA" ]);

const cmpModules = new Map, getModule = e => {
 if ("string" == typeof e) {
  e = e.toLowerCase();
  const t = cmpModules.get(e);
  if (null != t) return t[e];
 }
 return null;
}, loadModule = (e, t, o) => getModule(e.$tagName$), isMemberInElement = (e, t) => {
 if (null != e) {
  if (t in e) return !0;
  const o = getModule(e.nodeName);
  if (null != o) {
   const e = o;
   if (null != e && null != e.cmpMeta && null != e.cmpMeta.$members$) return t in e.cmpMeta.$members$;
  }
 }
 return !1;
}, registerComponents = e => {
 for (const t of e) {
  const e = t.cmpMeta.$tagName$;
  cmpModules.set(e, {
   [e]: t
  });
 }
}, win = window, doc = win.document, writeTask = e => {
 process.nextTick((() => {
  try {
   e();
  } catch (e) {
   consoleError(e);
  }
 }));
}, resolved = Promise.resolve(), nextTick = e => resolved.then(e), defaultConsoleError = e => {
 null != e && console.error(e.stack || e.message || e);
}, consoleError = (e, t) => (defaultConsoleError)(e, t), plt = {
 $flags$: 0,
 $resourcesUrl$: "",
 jmp: e => e(),
 raf: e => requestAnimationFrame(e),
 ael: (e, t, o, n) => e.addEventListener(t, o, n),
 rel: (e, t, o, n) => e.removeEventListener(t, o, n),
 ce: (e, t) => new win.CustomEvent(e, t)
}, supportsShadow = !1, hostRefs = new WeakMap, getHostRef = e => hostRefs.get(e), registerInstance = (e, t) => hostRefs.set(t.$lazyInstance$ = e, t), registerHost = (e, t) => {
 const o = {
  $flags$: 0,
  $cmpMeta$: t,
  $hostElement$: e,
  $instanceValues$: new Map,
  $renderCount$: 0
 };
 return o.$onInstancePromise$ = new Promise((e => o.$onInstanceResolve$ = e)), o.$onReadyPromise$ = new Promise((e => o.$onReadyResolve$ = e)), 
 e["s-p"] = [], e["s-rc"] = [], addHostEventListeners(e, o, t.$listeners$), hostRefs.set(e, o);
}, styles = new Map;

/*
 * anime.js v3.2.1
 * (c) 2020 Julian Garnier
 * Released under the MIT license
 * animejs.com
 */

// Defaults

var defaultInstanceSettings = {
  update: null,
  begin: null,
  loopBegin: null,
  changeBegin: null,
  change: null,
  changeComplete: null,
  loopComplete: null,
  complete: null,
  loop: 1,
  direction: 'normal',
  autoplay: true,
  timelineOffset: 0
};

var defaultTweenSettings = {
  duration: 1000,
  delay: 0,
  endDelay: 0,
  easing: 'easeOutElastic(1, .5)',
  round: 0
};

var validTransforms = ['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'scale', 'scaleX', 'scaleY', 'scaleZ', 'skew', 'skewX', 'skewY', 'perspective', 'matrix', 'matrix3d'];

// Caching

var cache = {
  CSS: {},
  springs: {}
};

// Utils

function minMax(val, min, max) {
  return Math.min(Math.max(val, min), max);
}

function stringContains(str, text) {
  return str.indexOf(text) > -1;
}

function applyArguments(func, args) {
  return func.apply(null, args);
}

var is = {
  arr: function (a) { return Array.isArray(a); },
  obj: function (a) { return stringContains(Object.prototype.toString.call(a), 'Object'); },
  pth: function (a) { return is.obj(a) && a.hasOwnProperty('totalLength'); },
  svg: function (a) { return a instanceof SVGElement; },
  inp: function (a) { return a instanceof HTMLInputElement; },
  dom: function (a) { return a.nodeType || is.svg(a); },
  str: function (a) { return typeof a === 'string'; },
  fnc: function (a) { return typeof a === 'function'; },
  und: function (a) { return typeof a === 'undefined'; },
  nil: function (a) { return is.und(a) || a === null; },
  hex: function (a) { return /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i.test(a); },
  rgb: function (a) { return /^rgb/.test(a); },
  hsl: function (a) { return /^hsl/.test(a); },
  col: function (a) { return (is.hex(a) || is.rgb(a) || is.hsl(a)); },
  key: function (a) { return !defaultInstanceSettings.hasOwnProperty(a) && !defaultTweenSettings.hasOwnProperty(a) && a !== 'targets' && a !== 'keyframes'; },
};

// Easings

function parseEasingParameters(string) {
  var match = /\(([^)]+)\)/.exec(string);
  return match ? match[1].split(',').map(function (p) { return parseFloat(p); }) : [];
}

// Spring solver inspired by Webkit Copyright © 2016 Apple Inc. All rights reserved. https://webkit.org/demos/spring/spring.js

function spring(string, duration) {

  var params = parseEasingParameters(string);
  var mass = minMax(is.und(params[0]) ? 1 : params[0], .1, 100);
  var stiffness = minMax(is.und(params[1]) ? 100 : params[1], .1, 100);
  var damping = minMax(is.und(params[2]) ? 10 : params[2], .1, 100);
  var velocity =  minMax(is.und(params[3]) ? 0 : params[3], .1, 100);
  var w0 = Math.sqrt(stiffness / mass);
  var zeta = damping / (2 * Math.sqrt(stiffness * mass));
  var wd = zeta < 1 ? w0 * Math.sqrt(1 - zeta * zeta) : 0;
  var a = 1;
  var b = zeta < 1 ? (zeta * w0 + -velocity) / wd : -velocity + w0;

  function solver(t) {
    var progress = duration ? (duration * t) / 1000 : t;
    if (zeta < 1) {
      progress = Math.exp(-progress * zeta * w0) * (a * Math.cos(wd * progress) + b * Math.sin(wd * progress));
    } else {
      progress = (a + b * progress) * Math.exp(-progress * w0);
    }
    if (t === 0 || t === 1) { return t; }
    return 1 - progress;
  }

  function getDuration() {
    var cached = cache.springs[string];
    if (cached) { return cached; }
    var frame = 1/6;
    var elapsed = 0;
    var rest = 0;
    while(true) {
      elapsed += frame;
      if (solver(elapsed) === 1) {
        rest++;
        if (rest >= 16) { break; }
      } else {
        rest = 0;
      }
    }
    var duration = elapsed * frame * 1000;
    cache.springs[string] = duration;
    return duration;
  }

  return duration ? solver : getDuration;

}

// Basic steps easing implementation https://developer.mozilla.org/fr/docs/Web/CSS/transition-timing-function

function steps(steps) {
  if ( steps === void 0 ) steps = 10;

  return function (t) { return Math.ceil((minMax(t, 0.000001, 1)) * steps) * (1 / steps); };
}

// BezierEasing https://github.com/gre/bezier-easing

var bezier = (function () {

  var kSplineTableSize = 11;
  var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

  function A(aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1 }
  function B(aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1 }
  function C(aA1)      { return 3.0 * aA1 }

  function calcBezier(aT, aA1, aA2) { return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT }
  function getSlope(aT, aA1, aA2) { return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1) }

  function binarySubdivide(aX, aA, aB, mX1, mX2) {
    var currentX, currentT, i = 0;
    do {
      currentT = aA + (aB - aA) / 2.0;
      currentX = calcBezier(currentT, mX1, mX2) - aX;
      if (currentX > 0.0) { aB = currentT; } else { aA = currentT; }
    } while (Math.abs(currentX) > 0.0000001 && ++i < 10);
    return currentT;
  }

  function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
    for (var i = 0; i < 4; ++i) {
      var currentSlope = getSlope(aGuessT, mX1, mX2);
      if (currentSlope === 0.0) { return aGuessT; }
      var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
      aGuessT -= currentX / currentSlope;
    }
    return aGuessT;
  }

  function bezier(mX1, mY1, mX2, mY2) {

    if (!(0 <= mX1 && mX1 <= 1 && 0 <= mX2 && mX2 <= 1)) { return; }
    var sampleValues = new Float32Array(kSplineTableSize);

    if (mX1 !== mY1 || mX2 !== mY2) {
      for (var i = 0; i < kSplineTableSize; ++i) {
        sampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
      }
    }

    function getTForX(aX) {

      var intervalStart = 0;
      var currentSample = 1;
      var lastSample = kSplineTableSize - 1;

      for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
        intervalStart += kSampleStepSize;
      }

      --currentSample;

      var dist = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
      var guessForT = intervalStart + dist * kSampleStepSize;
      var initialSlope = getSlope(guessForT, mX1, mX2);

      if (initialSlope >= 0.001) {
        return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
      } else if (initialSlope === 0.0) {
        return guessForT;
      } else {
        return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
      }

    }

    return function (x) {
      if (mX1 === mY1 && mX2 === mY2) { return x; }
      if (x === 0 || x === 1) { return x; }
      return calcBezier(getTForX(x), mY1, mY2);
    }

  }

  return bezier;

})();

var penner = (function () {

  // Based on jQuery UI's implemenation of easing equations from Robert Penner (http://www.robertpenner.com/easing)

  var eases = { linear: function () { return function (t) { return t; }; } };

  var functionEasings = {
    Sine: function () { return function (t) { return 1 - Math.cos(t * Math.PI / 2); }; },
    Circ: function () { return function (t) { return 1 - Math.sqrt(1 - t * t); }; },
    Back: function () { return function (t) { return t * t * (3 * t - 2); }; },
    Bounce: function () { return function (t) {
      var pow2, b = 4;
      while (t < (( pow2 = Math.pow(2, --b)) - 1) / 11) {}
      return 1 / Math.pow(4, 3 - b) - 7.5625 * Math.pow(( pow2 * 3 - 2 ) / 22 - t, 2)
    }; },
    Elastic: function (amplitude, period) {
      if ( amplitude === void 0 ) amplitude = 1;
      if ( period === void 0 ) period = .5;

      var a = minMax(amplitude, 1, 10);
      var p = minMax(period, .1, 2);
      return function (t) {
        return (t === 0 || t === 1) ? t : 
          -a * Math.pow(2, 10 * (t - 1)) * Math.sin((((t - 1) - (p / (Math.PI * 2) * Math.asin(1 / a))) * (Math.PI * 2)) / p);
      }
    }
  };

  var baseEasings = ['Quad', 'Cubic', 'Quart', 'Quint', 'Expo'];

  baseEasings.forEach(function (name, i) {
    functionEasings[name] = function () { return function (t) { return Math.pow(t, i + 2); }; };
  });

  Object.keys(functionEasings).forEach(function (name) {
    var easeIn = functionEasings[name];
    eases['easeIn' + name] = easeIn;
    eases['easeOut' + name] = function (a, b) { return function (t) { return 1 - easeIn(a, b)(1 - t); }; };
    eases['easeInOut' + name] = function (a, b) { return function (t) { return t < 0.5 ? easeIn(a, b)(t * 2) / 2 : 
      1 - easeIn(a, b)(t * -2 + 2) / 2; }; };
    eases['easeOutIn' + name] = function (a, b) { return function (t) { return t < 0.5 ? (1 - easeIn(a, b)(1 - t * 2)) / 2 : 
      (easeIn(a, b)(t * 2 - 1) + 1) / 2; }; };
  });

  return eases;

})();

function parseEasings(easing, duration) {
  if (is.fnc(easing)) { return easing; }
  var name = easing.split('(')[0];
  var ease = penner[name];
  var args = parseEasingParameters(easing);
  switch (name) {
    case 'spring' : return spring(easing, duration);
    case 'cubicBezier' : return applyArguments(bezier, args);
    case 'steps' : return applyArguments(steps, args);
    default : return applyArguments(ease, args);
  }
}

// Strings

function selectString(str) {
  try {
    var nodes = document.querySelectorAll(str);
    return nodes;
  } catch(e) {
    return;
  }
}

// Arrays

function filterArray(arr, callback) {
  var len = arr.length;
  var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
  var result = [];
  for (var i = 0; i < len; i++) {
    if (i in arr) {
      var val = arr[i];
      if (callback.call(thisArg, val, i, arr)) {
        result.push(val);
      }
    }
  }
  return result;
}

function flattenArray(arr) {
  return arr.reduce(function (a, b) { return a.concat(is.arr(b) ? flattenArray(b) : b); }, []);
}

function toArray(o) {
  if (is.arr(o)) { return o; }
  if (is.str(o)) { o = selectString(o) || o; }
  if (o instanceof NodeList || o instanceof HTMLCollection) { return [].slice.call(o); }
  return [o];
}

function arrayContains(arr, val) {
  return arr.some(function (a) { return a === val; });
}

// Objects

function cloneObject(o) {
  var clone = {};
  for (var p in o) { clone[p] = o[p]; }
  return clone;
}

function replaceObjectProps(o1, o2) {
  var o = cloneObject(o1);
  for (var p in o1) { o[p] = o2.hasOwnProperty(p) ? o2[p] : o1[p]; }
  return o;
}

function mergeObjects(o1, o2) {
  var o = cloneObject(o1);
  for (var p in o2) { o[p] = is.und(o1[p]) ? o2[p] : o1[p]; }
  return o;
}

// Colors

function rgbToRgba(rgbValue) {
  var rgb = /rgb\((\d+,\s*[\d]+,\s*[\d]+)\)/g.exec(rgbValue);
  return rgb ? ("rgba(" + (rgb[1]) + ",1)") : rgbValue;
}

function hexToRgba(hexValue) {
  var rgx = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  var hex = hexValue.replace(rgx, function (m, r, g, b) { return r + r + g + g + b + b; } );
  var rgb = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  var r = parseInt(rgb[1], 16);
  var g = parseInt(rgb[2], 16);
  var b = parseInt(rgb[3], 16);
  return ("rgba(" + r + "," + g + "," + b + ",1)");
}

function hslToRgba(hslValue) {
  var hsl = /hsl\((\d+),\s*([\d.]+)%,\s*([\d.]+)%\)/g.exec(hslValue) || /hsla\((\d+),\s*([\d.]+)%,\s*([\d.]+)%,\s*([\d.]+)\)/g.exec(hslValue);
  var h = parseInt(hsl[1], 10) / 360;
  var s = parseInt(hsl[2], 10) / 100;
  var l = parseInt(hsl[3], 10) / 100;
  var a = hsl[4] || 1;
  function hue2rgb(p, q, t) {
    if (t < 0) { t += 1; }
    if (t > 1) { t -= 1; }
    if (t < 1/6) { return p + (q - p) * 6 * t; }
    if (t < 1/2) { return q; }
    if (t < 2/3) { return p + (q - p) * (2/3 - t) * 6; }
    return p;
  }
  var r, g, b;
  if (s == 0) {
    r = g = b = l;
  } else {
    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    var p = 2 * l - q;
    r = hue2rgb(p, q, h + 1/3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1/3);
  }
  return ("rgba(" + (r * 255) + "," + (g * 255) + "," + (b * 255) + "," + a + ")");
}

function colorToRgb(val) {
  if (is.rgb(val)) { return rgbToRgba(val); }
  if (is.hex(val)) { return hexToRgba(val); }
  if (is.hsl(val)) { return hslToRgba(val); }
}

// Units

function getUnit(val) {
  var split = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?(%|px|pt|em|rem|in|cm|mm|ex|ch|pc|vw|vh|vmin|vmax|deg|rad|turn)?$/.exec(val);
  if (split) { return split[1]; }
}

function getTransformUnit(propName) {
  if (stringContains(propName, 'translate') || propName === 'perspective') { return 'px'; }
  if (stringContains(propName, 'rotate') || stringContains(propName, 'skew')) { return 'deg'; }
}

// Values

function getFunctionValue(val, animatable) {
  if (!is.fnc(val)) { return val; }
  return val(animatable.target, animatable.id, animatable.total);
}

function getAttribute(el, prop) {
  return el.getAttribute(prop);
}

function convertPxToUnit(el, value, unit) {
  var valueUnit = getUnit(value);
  if (arrayContains([unit, 'deg', 'rad', 'turn'], valueUnit)) { return value; }
  var cached = cache.CSS[value + unit];
  if (!is.und(cached)) { return cached; }
  var baseline = 100;
  var tempEl = document.createElement(el.tagName);
  var parentEl = (el.parentNode && (el.parentNode !== document)) ? el.parentNode : document.body;
  parentEl.appendChild(tempEl);
  tempEl.style.position = 'absolute';
  tempEl.style.width = baseline + unit;
  var factor = baseline / tempEl.offsetWidth;
  parentEl.removeChild(tempEl);
  var convertedUnit = factor * parseFloat(value);
  cache.CSS[value + unit] = convertedUnit;
  return convertedUnit;
}

function getCSSValue(el, prop, unit) {
  if (prop in el.style) {
    var uppercasePropName = prop.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
    var value = el.style[prop] || getComputedStyle(el).getPropertyValue(uppercasePropName) || '0';
    return unit ? convertPxToUnit(el, value, unit) : value;
  }
}

function getAnimationType(el, prop) {
  if (is.dom(el) && !is.inp(el) && (!is.nil(getAttribute(el, prop)) || (is.svg(el) && el[prop]))) { return 'attribute'; }
  if (is.dom(el) && arrayContains(validTransforms, prop)) { return 'transform'; }
  if (is.dom(el) && (prop !== 'transform' && getCSSValue(el, prop))) { return 'css'; }
  if (el[prop] != null) { return 'object'; }
}

function getElementTransforms(el) {
  if (!is.dom(el)) { return; }
  var str = el.style.transform || '';
  var reg  = /(\w+)\(([^)]*)\)/g;
  var transforms = new Map();
  var m; while (m = reg.exec(str)) { transforms.set(m[1], m[2]); }
  return transforms;
}

function getTransformValue(el, propName, animatable, unit) {
  var defaultVal = stringContains(propName, 'scale') ? 1 : 0 + getTransformUnit(propName);
  var value = getElementTransforms(el).get(propName) || defaultVal;
  if (animatable) {
    animatable.transforms.list.set(propName, value);
    animatable.transforms['last'] = propName;
  }
  return unit ? convertPxToUnit(el, value, unit) : value;
}

function getOriginalTargetValue(target, propName, unit, animatable) {
  switch (getAnimationType(target, propName)) {
    case 'transform': return getTransformValue(target, propName, animatable, unit);
    case 'css': return getCSSValue(target, propName, unit);
    case 'attribute': return getAttribute(target, propName);
    default: return target[propName] || 0;
  }
}

function getRelativeValue(to, from) {
  var operator = /^(\*=|\+=|-=)/.exec(to);
  if (!operator) { return to; }
  var u = getUnit(to) || 0;
  var x = parseFloat(from);
  var y = parseFloat(to.replace(operator[0], ''));
  switch (operator[0][0]) {
    case '+': return x + y + u;
    case '-': return x - y + u;
    case '*': return x * y + u;
  }
}

function validateValue(val, unit) {
  if (is.col(val)) { return colorToRgb(val); }
  if (/\s/g.test(val)) { return val; }
  var originalUnit = getUnit(val);
  var unitLess = originalUnit ? val.substr(0, val.length - originalUnit.length) : val;
  if (unit) { return unitLess + unit; }
  return unitLess;
}

// getTotalLength() equivalent for circle, rect, polyline, polygon and line shapes
// adapted from https://gist.github.com/SebLambla/3e0550c496c236709744

function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

function getCircleLength(el) {
  return Math.PI * 2 * getAttribute(el, 'r');
}

function getRectLength(el) {
  return (getAttribute(el, 'width') * 2) + (getAttribute(el, 'height') * 2);
}

function getLineLength(el) {
  return getDistance(
    {x: getAttribute(el, 'x1'), y: getAttribute(el, 'y1')}, 
    {x: getAttribute(el, 'x2'), y: getAttribute(el, 'y2')}
  );
}

function getPolylineLength(el) {
  var points = el.points;
  var totalLength = 0;
  var previousPos;
  for (var i = 0 ; i < points.numberOfItems; i++) {
    var currentPos = points.getItem(i);
    if (i > 0) { totalLength += getDistance(previousPos, currentPos); }
    previousPos = currentPos;
  }
  return totalLength;
}

function getPolygonLength(el) {
  var points = el.points;
  return getPolylineLength(el) + getDistance(points.getItem(points.numberOfItems - 1), points.getItem(0));
}

// Path animation

function getTotalLength(el) {
  if (el.getTotalLength) { return el.getTotalLength(); }
  switch(el.tagName.toLowerCase()) {
    case 'circle': return getCircleLength(el);
    case 'rect': return getRectLength(el);
    case 'line': return getLineLength(el);
    case 'polyline': return getPolylineLength(el);
    case 'polygon': return getPolygonLength(el);
  }
}

function setDashoffset(el) {
  var pathLength = getTotalLength(el);
  el.setAttribute('stroke-dasharray', pathLength);
  return pathLength;
}

// Motion path

function getParentSvgEl(el) {
  var parentEl = el.parentNode;
  while (is.svg(parentEl)) {
    if (!is.svg(parentEl.parentNode)) { break; }
    parentEl = parentEl.parentNode;
  }
  return parentEl;
}

function getParentSvg(pathEl, svgData) {
  var svg = svgData || {};
  var parentSvgEl = svg.el || getParentSvgEl(pathEl);
  var rect = parentSvgEl.getBoundingClientRect();
  var viewBoxAttr = getAttribute(parentSvgEl, 'viewBox');
  var width = rect.width;
  var height = rect.height;
  var viewBox = svg.viewBox || (viewBoxAttr ? viewBoxAttr.split(' ') : [0, 0, width, height]);
  return {
    el: parentSvgEl,
    viewBox: viewBox,
    x: viewBox[0] / 1,
    y: viewBox[1] / 1,
    w: width,
    h: height,
    vW: viewBox[2],
    vH: viewBox[3]
  }
}

function getPath(path, percent) {
  var pathEl = is.str(path) ? selectString(path)[0] : path;
  var p = percent || 100;
  return function(property) {
    return {
      property: property,
      el: pathEl,
      svg: getParentSvg(pathEl),
      totalLength: getTotalLength(pathEl) * (p / 100)
    }
  }
}

function getPathProgress(path, progress, isPathTargetInsideSVG) {
  function point(offset) {
    if ( offset === void 0 ) offset = 0;

    var l = progress + offset >= 1 ? progress + offset : 0;
    return path.el.getPointAtLength(l);
  }
  var svg = getParentSvg(path.el, path.svg);
  var p = point();
  var p0 = point(-1);
  var p1 = point(+1);
  var scaleX = isPathTargetInsideSVG ? 1 : svg.w / svg.vW;
  var scaleY = isPathTargetInsideSVG ? 1 : svg.h / svg.vH;
  switch (path.property) {
    case 'x': return (p.x - svg.x) * scaleX;
    case 'y': return (p.y - svg.y) * scaleY;
    case 'angle': return Math.atan2(p1.y - p0.y, p1.x - p0.x) * 180 / Math.PI;
  }
}

// Decompose value

function decomposeValue(val, unit) {
  // const rgx = /-?\d*\.?\d+/g; // handles basic numbers
  // const rgx = /[+-]?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
  var rgx = /[+-]?\d*\.?\d+(?:\.\d+)?(?:[eE][+-]?\d+)?/g; // handles exponents notation
  var value = validateValue((is.pth(val) ? val.totalLength : val), unit) + '';
  return {
    original: value,
    numbers: value.match(rgx) ? value.match(rgx).map(Number) : [0],
    strings: (is.str(val) || unit) ? value.split(rgx) : []
  }
}

// Animatables

function parseTargets(targets) {
  var targetsArray = targets ? (flattenArray(is.arr(targets) ? targets.map(toArray) : toArray(targets))) : [];
  return filterArray(targetsArray, function (item, pos, self) { return self.indexOf(item) === pos; });
}

function getAnimatables(targets) {
  var parsed = parseTargets(targets);
  return parsed.map(function (t, i) {
    return {target: t, id: i, total: parsed.length, transforms: { list: getElementTransforms(t) } };
  });
}

// Properties

function normalizePropertyTweens(prop, tweenSettings) {
  var settings = cloneObject(tweenSettings);
  // Override duration if easing is a spring
  if (/^spring/.test(settings.easing)) { settings.duration = spring(settings.easing); }
  if (is.arr(prop)) {
    var l = prop.length;
    var isFromTo = (l === 2 && !is.obj(prop[0]));
    if (!isFromTo) {
      // Duration divided by the number of tweens
      if (!is.fnc(tweenSettings.duration)) { settings.duration = tweenSettings.duration / l; }
    } else {
      // Transform [from, to] values shorthand to a valid tween value
      prop = {value: prop};
    }
  }
  var propArray = is.arr(prop) ? prop : [prop];
  return propArray.map(function (v, i) {
    var obj = (is.obj(v) && !is.pth(v)) ? v : {value: v};
    // Default delay value should only be applied to the first tween
    if (is.und(obj.delay)) { obj.delay = !i ? tweenSettings.delay : 0; }
    // Default endDelay value should only be applied to the last tween
    if (is.und(obj.endDelay)) { obj.endDelay = i === propArray.length - 1 ? tweenSettings.endDelay : 0; }
    return obj;
  }).map(function (k) { return mergeObjects(k, settings); });
}


function flattenKeyframes(keyframes) {
  var propertyNames = filterArray(flattenArray(keyframes.map(function (key) { return Object.keys(key); })), function (p) { return is.key(p); })
  .reduce(function (a,b) { if (a.indexOf(b) < 0) { a.push(b); } return a; }, []);
  var properties = {};
  var loop = function ( i ) {
    var propName = propertyNames[i];
    properties[propName] = keyframes.map(function (key) {
      var newKey = {};
      for (var p in key) {
        if (is.key(p)) {
          if (p == propName) { newKey.value = key[p]; }
        } else {
          newKey[p] = key[p];
        }
      }
      return newKey;
    });
  };

  for (var i = 0; i < propertyNames.length; i++) loop( i );
  return properties;
}

function getProperties(tweenSettings, params) {
  var properties = [];
  var keyframes = params.keyframes;
  if (keyframes) { params = mergeObjects(flattenKeyframes(keyframes), params); }
  for (var p in params) {
    if (is.key(p)) {
      properties.push({
        name: p,
        tweens: normalizePropertyTweens(params[p], tweenSettings)
      });
    }
  }
  return properties;
}

// Tweens

function normalizeTweenValues(tween, animatable) {
  var t = {};
  for (var p in tween) {
    var value = getFunctionValue(tween[p], animatable);
    if (is.arr(value)) {
      value = value.map(function (v) { return getFunctionValue(v, animatable); });
      if (value.length === 1) { value = value[0]; }
    }
    t[p] = value;
  }
  t.duration = parseFloat(t.duration);
  t.delay = parseFloat(t.delay);
  return t;
}

function normalizeTweens(prop, animatable) {
  var previousTween;
  return prop.tweens.map(function (t) {
    var tween = normalizeTweenValues(t, animatable);
    var tweenValue = tween.value;
    var to = is.arr(tweenValue) ? tweenValue[1] : tweenValue;
    var toUnit = getUnit(to);
    var originalValue = getOriginalTargetValue(animatable.target, prop.name, toUnit, animatable);
    var previousValue = previousTween ? previousTween.to.original : originalValue;
    var from = is.arr(tweenValue) ? tweenValue[0] : previousValue;
    var fromUnit = getUnit(from) || getUnit(originalValue);
    var unit = toUnit || fromUnit;
    if (is.und(to)) { to = previousValue; }
    tween.from = decomposeValue(from, unit);
    tween.to = decomposeValue(getRelativeValue(to, from), unit);
    tween.start = previousTween ? previousTween.end : 0;
    tween.end = tween.start + tween.delay + tween.duration + tween.endDelay;
    tween.easing = parseEasings(tween.easing, tween.duration);
    tween.isPath = is.pth(tweenValue);
    tween.isPathTargetInsideSVG = tween.isPath && is.svg(animatable.target);
    tween.isColor = is.col(tween.from.original);
    if (tween.isColor) { tween.round = 1; }
    previousTween = tween;
    return tween;
  });
}

// Tween progress

var setProgressValue = {
  css: function (t, p, v) { return t.style[p] = v; },
  attribute: function (t, p, v) { return t.setAttribute(p, v); },
  object: function (t, p, v) { return t[p] = v; },
  transform: function (t, p, v, transforms, manual) {
    transforms.list.set(p, v);
    if (p === transforms.last || manual) {
      var str = '';
      transforms.list.forEach(function (value, prop) { str += prop + "(" + value + ") "; });
      t.style.transform = str;
    }
  }
};

// Set Value helper

function setTargetsValue(targets, properties) {
  var animatables = getAnimatables(targets);
  animatables.forEach(function (animatable) {
    for (var property in properties) {
      var value = getFunctionValue(properties[property], animatable);
      var target = animatable.target;
      var valueUnit = getUnit(value);
      var originalValue = getOriginalTargetValue(target, property, valueUnit, animatable);
      var unit = valueUnit || getUnit(originalValue);
      var to = getRelativeValue(validateValue(value, unit), originalValue);
      var animType = getAnimationType(target, property);
      setProgressValue[animType](target, property, to, animatable.transforms, true);
    }
  });
}

// Animations

function createAnimation(animatable, prop) {
  var animType = getAnimationType(animatable.target, prop.name);
  if (animType) {
    var tweens = normalizeTweens(prop, animatable);
    var lastTween = tweens[tweens.length - 1];
    return {
      type: animType,
      property: prop.name,
      animatable: animatable,
      tweens: tweens,
      duration: lastTween.end,
      delay: tweens[0].delay,
      endDelay: lastTween.endDelay
    }
  }
}

function getAnimations(animatables, properties) {
  return filterArray(flattenArray(animatables.map(function (animatable) {
    return properties.map(function (prop) {
      return createAnimation(animatable, prop);
    });
  })), function (a) { return !is.und(a); });
}

// Create Instance

function getInstanceTimings(animations, tweenSettings) {
  var animLength = animations.length;
  var getTlOffset = function (anim) { return anim.timelineOffset ? anim.timelineOffset : 0; };
  var timings = {};
  timings.duration = animLength ? Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration; })) : tweenSettings.duration;
  timings.delay = animLength ? Math.min.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.delay; })) : tweenSettings.delay;
  timings.endDelay = animLength ? timings.duration - Math.max.apply(Math, animations.map(function (anim) { return getTlOffset(anim) + anim.duration - anim.endDelay; })) : tweenSettings.endDelay;
  return timings;
}

var instanceID = 0;

function createNewInstance(params) {
  var instanceSettings = replaceObjectProps(defaultInstanceSettings, params);
  var tweenSettings = replaceObjectProps(defaultTweenSettings, params);
  var properties = getProperties(tweenSettings, params);
  var animatables = getAnimatables(params.targets);
  var animations = getAnimations(animatables, properties);
  var timings = getInstanceTimings(animations, tweenSettings);
  var id = instanceID;
  instanceID++;
  return mergeObjects(instanceSettings, {
    id: id,
    children: [],
    animatables: animatables,
    animations: animations,
    duration: timings.duration,
    delay: timings.delay,
    endDelay: timings.endDelay
  });
}

// Core

var activeInstances = [];

var engine = (function () {
  var raf;

  function play() {
    if (!raf && (!isDocumentHidden() || !anime.suspendWhenDocumentHidden) && activeInstances.length > 0) {
      raf = requestAnimationFrame(step);
    }
  }
  function step(t) {
    // memo on algorithm issue:
    // dangerous iteration over mutable `activeInstances`
    // (that collection may be updated from within callbacks of `tick`-ed animation instances)
    var activeInstancesLength = activeInstances.length;
    var i = 0;
    while (i < activeInstancesLength) {
      var activeInstance = activeInstances[i];
      if (!activeInstance.paused) {
        activeInstance.tick(t);
        i++;
      } else {
        activeInstances.splice(i, 1);
        activeInstancesLength--;
      }
    }
    raf = i > 0 ? requestAnimationFrame(step) : undefined;
  }

  function handleVisibilityChange() {
    if (!anime.suspendWhenDocumentHidden) { return; }

    if (isDocumentHidden()) {
      // suspend ticks
      raf = cancelAnimationFrame(raf);
    } else { // is back to active tab
      // first adjust animations to consider the time that ticks were suspended
      activeInstances.forEach(
        function (instance) { return instance ._onDocumentVisibility(); }
      );
      engine();
    }
  }
  if (typeof document !== 'undefined') {
    document.addEventListener('visibilitychange', handleVisibilityChange);
  }

  return play;
})();

function isDocumentHidden() {
  return !!document && document.hidden;
}

// Public Instance

function anime(params) {
  if ( params === void 0 ) params = {};


  var startTime = 0, lastTime = 0, now = 0;
  var children, childrenLength = 0;
  var resolve = null;

  function makePromise(instance) {
    var promise = window.Promise && new Promise(function (_resolve) { return resolve = _resolve; });
    instance.finished = promise;
    return promise;
  }

  var instance = createNewInstance(params);
  makePromise(instance);

  function toggleInstanceDirection() {
    var direction = instance.direction;
    if (direction !== 'alternate') {
      instance.direction = direction !== 'normal' ? 'normal' : 'reverse';
    }
    instance.reversed = !instance.reversed;
    children.forEach(function (child) { return child.reversed = instance.reversed; });
  }

  function adjustTime(time) {
    return instance.reversed ? instance.duration - time : time;
  }

  function resetTime() {
    startTime = 0;
    lastTime = adjustTime(instance.currentTime) * (1 / anime.speed);
  }

  function seekChild(time, child) {
    if (child) { child.seek(time - child.timelineOffset); }
  }

  function syncInstanceChildren(time) {
    if (!instance.reversePlayback) {
      for (var i = 0; i < childrenLength; i++) { seekChild(time, children[i]); }
    } else {
      for (var i$1 = childrenLength; i$1--;) { seekChild(time, children[i$1]); }
    }
  }

  function setAnimationsProgress(insTime) {
    var i = 0;
    var animations = instance.animations;
    var animationsLength = animations.length;
    while (i < animationsLength) {
      var anim = animations[i];
      var animatable = anim.animatable;
      var tweens = anim.tweens;
      var tweenLength = tweens.length - 1;
      var tween = tweens[tweenLength];
      // Only check for keyframes if there is more than one tween
      if (tweenLength) { tween = filterArray(tweens, function (t) { return (insTime < t.end); })[0] || tween; }
      var elapsed = minMax(insTime - tween.start - tween.delay, 0, tween.duration) / tween.duration;
      var eased = isNaN(elapsed) ? 1 : tween.easing(elapsed);
      var strings = tween.to.strings;
      var round = tween.round;
      var numbers = [];
      var toNumbersLength = tween.to.numbers.length;
      var progress = (void 0);
      for (var n = 0; n < toNumbersLength; n++) {
        var value = (void 0);
        var toNumber = tween.to.numbers[n];
        var fromNumber = tween.from.numbers[n] || 0;
        if (!tween.isPath) {
          value = fromNumber + (eased * (toNumber - fromNumber));
        } else {
          value = getPathProgress(tween.value, eased * toNumber, tween.isPathTargetInsideSVG);
        }
        if (round) {
          if (!(tween.isColor && n > 2)) {
            value = Math.round(value * round) / round;
          }
        }
        numbers.push(value);
      }
      // Manual Array.reduce for better performances
      var stringsLength = strings.length;
      if (!stringsLength) {
        progress = numbers[0];
      } else {
        progress = strings[0];
        for (var s = 0; s < stringsLength; s++) {
          var b = strings[s + 1];
          var n$1 = numbers[s];
          if (!isNaN(n$1)) {
            if (!b) {
              progress += n$1 + ' ';
            } else {
              progress += n$1 + b;
            }
          }
        }
      }
      setProgressValue[anim.type](animatable.target, anim.property, progress, animatable.transforms);
      anim.currentValue = progress;
      i++;
    }
  }

  function setCallback(cb) {
    if (instance[cb] && !instance.passThrough) { instance[cb](instance); }
  }

  function countIteration() {
    if (instance.remaining && instance.remaining !== true) {
      instance.remaining--;
    }
  }

  function setInstanceProgress(engineTime) {
    var insDuration = instance.duration;
    var insDelay = instance.delay;
    var insEndDelay = insDuration - instance.endDelay;
    var insTime = adjustTime(engineTime);
    instance.progress = minMax((insTime / insDuration) * 100, 0, 100);
    instance.reversePlayback = insTime < instance.currentTime;
    if (children) { syncInstanceChildren(insTime); }
    if (!instance.began && instance.currentTime > 0) {
      instance.began = true;
      setCallback('begin');
    }
    if (!instance.loopBegan && instance.currentTime > 0) {
      instance.loopBegan = true;
      setCallback('loopBegin');
    }
    if (insTime <= insDelay && instance.currentTime !== 0) {
      setAnimationsProgress(0);
    }
    if ((insTime >= insEndDelay && instance.currentTime !== insDuration) || !insDuration) {
      setAnimationsProgress(insDuration);
    }
    if (insTime > insDelay && insTime < insEndDelay) {
      if (!instance.changeBegan) {
        instance.changeBegan = true;
        instance.changeCompleted = false;
        setCallback('changeBegin');
      }
      setCallback('change');
      setAnimationsProgress(insTime);
    } else {
      if (instance.changeBegan) {
        instance.changeCompleted = true;
        instance.changeBegan = false;
        setCallback('changeComplete');
      }
    }
    instance.currentTime = minMax(insTime, 0, insDuration);
    if (instance.began) { setCallback('update'); }
    if (engineTime >= insDuration) {
      lastTime = 0;
      countIteration();
      if (!instance.remaining) {
        instance.paused = true;
        if (!instance.completed) {
          instance.completed = true;
          setCallback('loopComplete');
          setCallback('complete');
          if (!instance.passThrough && 'Promise' in window) {
            resolve();
            makePromise(instance);
          }
        }
      } else {
        startTime = now;
        setCallback('loopComplete');
        instance.loopBegan = false;
        if (instance.direction === 'alternate') {
          toggleInstanceDirection();
        }
      }
    }
  }

  instance.reset = function() {
    var direction = instance.direction;
    instance.passThrough = false;
    instance.currentTime = 0;
    instance.progress = 0;
    instance.paused = true;
    instance.began = false;
    instance.loopBegan = false;
    instance.changeBegan = false;
    instance.completed = false;
    instance.changeCompleted = false;
    instance.reversePlayback = false;
    instance.reversed = direction === 'reverse';
    instance.remaining = instance.loop;
    children = instance.children;
    childrenLength = children.length;
    for (var i = childrenLength; i--;) { instance.children[i].reset(); }
    if (instance.reversed && instance.loop !== true || (direction === 'alternate' && instance.loop === 1)) { instance.remaining++; }
    setAnimationsProgress(instance.reversed ? instance.duration : 0);
  };

  // internal method (for engine) to adjust animation timings before restoring engine ticks (rAF)
  instance._onDocumentVisibility = resetTime;

  // Set Value helper

  instance.set = function(targets, properties) {
    setTargetsValue(targets, properties);
    return instance;
  };

  instance.tick = function(t) {
    now = t;
    if (!startTime) { startTime = now; }
    setInstanceProgress((now + (lastTime - startTime)) * anime.speed);
  };

  instance.seek = function(time) {
    setInstanceProgress(adjustTime(time));
  };

  instance.pause = function() {
    instance.paused = true;
    resetTime();
  };

  instance.play = function() {
    if (!instance.paused) { return; }
    if (instance.completed) { instance.reset(); }
    instance.paused = false;
    activeInstances.push(instance);
    resetTime();
    engine();
  };

  instance.reverse = function() {
    toggleInstanceDirection();
    instance.completed = instance.reversed ? false : true;
    resetTime();
  };

  instance.restart = function() {
    instance.reset();
    instance.play();
  };

  instance.remove = function(targets) {
    var targetsArray = parseTargets(targets);
    removeTargetsFromInstance(targetsArray, instance);
  };

  instance.reset();

  if (instance.autoplay) { instance.play(); }

  return instance;

}

// Remove targets from animation

function removeTargetsFromAnimations(targetsArray, animations) {
  for (var a = animations.length; a--;) {
    if (arrayContains(targetsArray, animations[a].animatable.target)) {
      animations.splice(a, 1);
    }
  }
}

function removeTargetsFromInstance(targetsArray, instance) {
  var animations = instance.animations;
  var children = instance.children;
  removeTargetsFromAnimations(targetsArray, animations);
  for (var c = children.length; c--;) {
    var child = children[c];
    var childAnimations = child.animations;
    removeTargetsFromAnimations(targetsArray, childAnimations);
    if (!childAnimations.length && !child.children.length) { children.splice(c, 1); }
  }
  if (!animations.length && !children.length) { instance.pause(); }
}

function removeTargetsFromActiveInstances(targets) {
  var targetsArray = parseTargets(targets);
  for (var i = activeInstances.length; i--;) {
    var instance = activeInstances[i];
    removeTargetsFromInstance(targetsArray, instance);
  }
}

// Stagger helpers

function stagger(val, params) {
  if ( params === void 0 ) params = {};

  var direction = params.direction || 'normal';
  var easing = params.easing ? parseEasings(params.easing) : null;
  var grid = params.grid;
  var axis = params.axis;
  var fromIndex = params.from || 0;
  var fromFirst = fromIndex === 'first';
  var fromCenter = fromIndex === 'center';
  var fromLast = fromIndex === 'last';
  var isRange = is.arr(val);
  var val1 = isRange ? parseFloat(val[0]) : parseFloat(val);
  var val2 = isRange ? parseFloat(val[1]) : 0;
  var unit = getUnit(isRange ? val[1] : val) || 0;
  var start = params.start || 0 + (isRange ? val1 : 0);
  var values = [];
  var maxValue = 0;
  return function (el, i, t) {
    if (fromFirst) { fromIndex = 0; }
    if (fromCenter) { fromIndex = (t - 1) / 2; }
    if (fromLast) { fromIndex = t - 1; }
    if (!values.length) {
      for (var index = 0; index < t; index++) {
        if (!grid) {
          values.push(Math.abs(fromIndex - index));
        } else {
          var fromX = !fromCenter ? fromIndex%grid[0] : (grid[0]-1)/2;
          var fromY = !fromCenter ? Math.floor(fromIndex/grid[0]) : (grid[1]-1)/2;
          var toX = index%grid[0];
          var toY = Math.floor(index/grid[0]);
          var distanceX = fromX - toX;
          var distanceY = fromY - toY;
          var value = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
          if (axis === 'x') { value = -distanceX; }
          if (axis === 'y') { value = -distanceY; }
          values.push(value);
        }
        maxValue = Math.max.apply(Math, values);
      }
      if (easing) { values = values.map(function (val) { return easing(val / maxValue) * maxValue; }); }
      if (direction === 'reverse') { values = values.map(function (val) { return axis ? (val < 0) ? val * -1 : -val : Math.abs(maxValue - val); }); }
    }
    var spacing = isRange ? (val2 - val1) / maxValue : val1;
    return start + (spacing * (Math.round(values[i] * 100) / 100)) + unit;
  }
}

// Timeline

function timeline(params) {
  if ( params === void 0 ) params = {};

  var tl = anime(params);
  tl.duration = 0;
  tl.add = function(instanceParams, timelineOffset) {
    var tlIndex = activeInstances.indexOf(tl);
    var children = tl.children;
    if (tlIndex > -1) { activeInstances.splice(tlIndex, 1); }
    function passThrough(ins) { ins.passThrough = true; }
    for (var i = 0; i < children.length; i++) { passThrough(children[i]); }
    var insParams = mergeObjects(instanceParams, replaceObjectProps(defaultTweenSettings, params));
    insParams.targets = insParams.targets || params.targets;
    var tlDuration = tl.duration;
    insParams.autoplay = false;
    insParams.direction = tl.direction;
    insParams.timelineOffset = is.und(timelineOffset) ? tlDuration : getRelativeValue(timelineOffset, tlDuration);
    passThrough(tl);
    tl.seek(insParams.timelineOffset);
    var ins = anime(insParams);
    passThrough(ins);
    children.push(ins);
    var timings = getInstanceTimings(children, params);
    tl.delay = timings.delay;
    tl.endDelay = timings.endDelay;
    tl.duration = timings.duration;
    tl.seek(0);
    tl.reset();
    if (tl.autoplay) { tl.play(); }
    return tl;
  };
  return tl;
}

anime.version = '3.2.1';
anime.speed = 1;
// TODO:#review: naming, documentation
anime.suspendWhenDocumentHidden = true;
anime.running = activeInstances;
anime.remove = removeTargetsFromActiveInstances;
anime.get = getOriginalTargetValue;
anime.set = setTargetsValue;
anime.convertPx = convertPxToUnit;
anime.path = getPath;
anime.setDashoffset = setDashoffset;
anime.stagger = stagger;
anime.timeline = timeline;
anime.easing = parseEasings;
anime.penner = penner;
anime.random = function (min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; };

/**
 * Adapted from React: https://github.com/facebook/react/blob/master/packages/shared/formatProdErrorMessage.js
 *
 * Do not require this module directly! Use normal throw error calls. These messages will be replaced with error codes
 * during build.
 * @param {number} code
 */
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or " + 'use the non-minified dev environment for full errors. ';
}

// Inlined version of the `symbol-observable` polyfill
var $$observable = (function () {
  return typeof Symbol === 'function' && Symbol.observable || '@@observable';
})();

/**
 * These are private action types reserved by Redux.
 * For any unknown actions, you must return the current state.
 * If the current state is undefined, you must return the initial state.
 * Do not reference these action types directly in your code.
 */
var randomString = function randomString() {
  return Math.random().toString(36).substring(7).split('').join('.');
};

var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};

/**
 * @param {any} obj The object to inspect.
 * @returns {boolean} True if the argument appears to be a plain object.
 */
function isPlainObject(obj) {
  if (typeof obj !== 'object' || obj === null) return false;
  var proto = obj;

  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }

  return Object.getPrototypeOf(obj) === proto;
}

/**
 * @deprecated
 *
 * **We recommend using the `configureStore` method
 * of the `@reduxjs/toolkit` package**, which replaces `createStore`.
 *
 * Redux Toolkit is our recommended approach for writing Redux logic today,
 * including store setup, reducers, data fetching, and more.
 *
 * **For more details, please read this Redux docs page:**
 * **https://redux.js.org/introduction/why-rtk-is-redux-today**
 *
 * `configureStore` from Redux Toolkit is an improved version of `createStore` that
 * simplifies setup and helps avoid common bugs.
 *
 * You should not be using the `redux` core package by itself today, except for learning purposes.
 * The `createStore` method from the core `redux` package will not be removed, but we encourage
 * all users to migrate to using Redux Toolkit for all Redux code.
 *
 * If you want to use `createStore` without this visual deprecation warning, use
 * the `legacy_createStore` import instead:
 *
 * `import { legacy_createStore as createStore} from 'redux'`
 *
 */

function createStore(reducer, preloadedState, enhancer) {
  var _ref2;

  if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
    throw new Error(formatProdErrorMessage(0) );
  }

  if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
    enhancer = preloadedState;
    preloadedState = undefined;
  }

  if (typeof enhancer !== 'undefined') {
    if (typeof enhancer !== 'function') {
      throw new Error(formatProdErrorMessage(1) );
    }

    return enhancer(createStore)(reducer, preloadedState);
  }

  if (typeof reducer !== 'function') {
    throw new Error(formatProdErrorMessage(2) );
  }

  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  /**
   * This makes a shallow copy of currentListeners so we can use
   * nextListeners as a temporary list while dispatching.
   *
   * This prevents any bugs around consumers calling
   * subscribe/unsubscribe in the middle of a dispatch.
   */

  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  /**
   * Reads the state tree managed by the store.
   *
   * @returns {any} The current state tree of your application.
   */


  function getState() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(3) );
    }

    return currentState;
  }
  /**
   * Adds a change listener. It will be called any time an action is dispatched,
   * and some part of the state tree may potentially have changed. You may then
   * call `getState()` to read the current state tree inside the callback.
   *
   * You may call `dispatch()` from a change listener, with the following
   * caveats:
   *
   * 1. The subscriptions are snapshotted just before every `dispatch()` call.
   * If you subscribe or unsubscribe while the listeners are being invoked, this
   * will not have any effect on the `dispatch()` that is currently in progress.
   * However, the next `dispatch()` call, whether nested or not, will use a more
   * recent snapshot of the subscription list.
   *
   * 2. The listener should not expect to see all state changes, as the state
   * might have been updated multiple times during a nested `dispatch()` before
   * the listener is called. It is, however, guaranteed that all subscribers
   * registered before the `dispatch()` started will be called with the latest
   * state by the time it exits.
   *
   * @param {Function} listener A callback to be invoked on every dispatch.
   * @returns {Function} A function to remove this change listener.
   */


  function subscribe(listener) {
    if (typeof listener !== 'function') {
      throw new Error(formatProdErrorMessage(4) );
    }

    if (isDispatching) {
      throw new Error(formatProdErrorMessage(5) );
    }

    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }

      if (isDispatching) {
        throw new Error(formatProdErrorMessage(6) );
      }

      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index = nextListeners.indexOf(listener);
      nextListeners.splice(index, 1);
      currentListeners = null;
    };
  }
  /**
   * Dispatches an action. It is the only way to trigger a state change.
   *
   * The `reducer` function, used to create the store, will be called with the
   * current state tree and the given `action`. Its return value will
   * be considered the **next** state of the tree, and the change listeners
   * will be notified.
   *
   * The base implementation only supports plain object actions. If you want to
   * dispatch a Promise, an Observable, a thunk, or something else, you need to
   * wrap your store creating function into the corresponding middleware. For
   * example, see the documentation for the `redux-thunk` package. Even the
   * middleware will eventually dispatch plain object actions using this method.
   *
   * @param {Object} action A plain object representing “what changed”. It is
   * a good idea to keep actions serializable so you can record and replay user
   * sessions, or use the time travelling `redux-devtools`. An action must have
   * a `type` property which may not be `undefined`. It is a good idea to use
   * string constants for action types.
   *
   * @returns {Object} For convenience, the same action object you dispatched.
   *
   * Note that, if you use a custom middleware, it may wrap `dispatch()` to
   * return something else (for example, a Promise you can await).
   */


  function dispatch(action) {
    if (!isPlainObject(action)) {
      throw new Error(formatProdErrorMessage(7) );
    }

    if (typeof action.type === 'undefined') {
      throw new Error(formatProdErrorMessage(8) );
    }

    if (isDispatching) {
      throw new Error(formatProdErrorMessage(9) );
    }

    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }

    var listeners = currentListeners = nextListeners;

    for (var i = 0; i < listeners.length; i++) {
      var listener = listeners[i];
      listener();
    }

    return action;
  }
  /**
   * Replaces the reducer currently used by the store to calculate the state.
   *
   * You might need this if your app implements code splitting and you want to
   * load some of the reducers dynamically. You might also need this if you
   * implement a hot reloading mechanism for Redux.
   *
   * @param {Function} nextReducer The reducer for the store to use instead.
   * @returns {void}
   */


  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== 'function') {
      throw new Error(formatProdErrorMessage(10) );
    }

    currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
    // Any reducers that existed in both the new and old rootReducer
    // will receive the previous state. This effectively populates
    // the new state tree with any relevant data from the old one.

    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  /**
   * Interoperability point for observable/reactive libraries.
   * @returns {observable} A minimal observable of state changes.
   * For more information, see the observable proposal:
   * https://github.com/tc39/proposal-observable
   */


  function observable() {
    var _ref;

    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe(observer) {
        if (typeof observer !== 'object' || observer === null) {
          throw new Error(formatProdErrorMessage(11) );
        }

        function observeState() {
          if (observer.next) {
            observer.next(getState());
          }
        }

        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe: unsubscribe
        };
      }
    }, _ref[$$observable] = function () {
      return this;
    }, _ref;
  } // When a store is created, an "INIT" action is dispatched so that every
  // reducer returns their initial state. This effectively populates
  // the initial state tree.


  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch: dispatch,
    subscribe: subscribe,
    getState: getState,
    replaceReducer: replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}

// inspired by https://github.com/willmcpo/body-scroll-lock
const isIosDevice = typeof window !== "undefined" &&
  navigator &&
  navigator.platform &&
  (/iP(ad|hone|od)/.test(navigator.platform) ||
    (navigator.platform === "MacIntel" && navigator.maxTouchPoints > 1));
let initialScreenY;
let previousBodyOverflowSetting;
let previousBodyPaddingRight;
function onTouchStart(e) {
  initialScreenY = e.touches[0].screenY;
}
function onTouchMove(e) {
  const targetEl = e.composedPath()[0];
  const scrollContainerEl = getScrollContainerEl(targetEl);
  const isScrollingDown = initialScreenY > e.touches[0].screenY;
  const isScrollingUp = initialScreenY < e.touches[0].screenY;
  let abortTouchMove = false;
  if (scrollContainerEl) {
    const { scrollHeight, clientHeight, scrollTop } = scrollContainerEl;
    const hasReachedTop = scrollTop === 0;
    const hasReachedBottom = scrollHeight === clientHeight + scrollTop;
    if ((isScrollingDown && hasReachedBottom) ||
      (isScrollingUp && hasReachedTop)) {
      abortTouchMove = true;
    }
  }
  else {
    abortTouchMove = true;
  }
  if (abortTouchMove) {
    e.preventDefault();
    e.stopImmediatePropagation();
  }
}
function setOverflowHidden(options) {
  // If previousBodyPaddingRight is already set, don't set it again
  if (previousBodyPaddingRight === undefined) {
    const reserveScrollBarGap = !!options && options.reserveScrollBarGap === true;
    const scrollBarGap = innerWidth - document.documentElement.clientWidth;
    if (reserveScrollBarGap && scrollBarGap > 0) {
      previousBodyPaddingRight = document.body.style.paddingRight;
      document.body.style.paddingRight = `${scrollBarGap}px`;
    }
  }
  // If previousBodyOverflowSetting is already set, don't set it again
  if (previousBodyOverflowSetting === undefined) {
    previousBodyOverflowSetting = document.body.style.overflow;
    document.body.style.overflow = "hidden";
  }
}
function unsetOverflowHidden() {
  if (previousBodyPaddingRight !== undefined) {
    document.body.style.paddingRight = previousBodyPaddingRight;
    // Restore previousBodyPaddingRight to undefined so setOverflowHidden knows
    // it can be set again
    previousBodyPaddingRight = undefined;
  }
  if (previousBodyOverflowSetting !== undefined) {
    document.body.style.overflow = previousBodyOverflowSetting;
    // Restore previousBodyOverflowSetting to undefined so setOverflowHidden
    // knows it can be set again
    previousBodyOverflowSetting = undefined;
  }
}
function disableBodyScroll$1(options) {
  if (isIosDevice) {
    addEventListener("touchstart", onTouchStart, { passive: false });
    addEventListener("touchmove", onTouchMove, { passive: false });
  }
  else {
    setOverflowHidden(options);
  }
}
function enableBodyScroll$1() {
  if (isIosDevice) {
    removeEventListener("touchstart", onTouchStart);
    removeEventListener("touchmove", onTouchMove);
  }
  else {
    unsetOverflowHidden();
  }
}

var componentGraph = [
	[
		"sdx-accordion",
		"sdx-accordion-item-body",
		"sdx-accordion-item-header",
		"sdx-accordion-item-section",
		"sdx-accordion-item"
	],
	[
		"sdx-dialog",
		"sdx-dialog-content",
		"sdx-dialog-toggle"
	],
	[
		"sdx-header",
		"sdx-header-left-hand-menu",
		"sdx-header-menu"
	],
	[
		"sdx-input-group",
		"sdx-input-item"
	],
	[
		"sdx-menu-flyout",
		"sdx-menu-flyout-content",
		"sdx-menu-flyout-list-item",
		"sdx-menu-flyout-list",
		"sdx-menu-flyout-toggle"
	],
	[
		"sdx-progress-full",
		"sdx-progress-full-step"
	],
	[
		"sdx-select",
		"sdx-select-list",
		"sdx-select-optgroup",
		"sdx-select-option"
	],
	[
		"sdx-tabs",
		"sdx-tabs-item"
	]
];

// Under this key the store will be created (on a DOM node)
const storeKey = "__store";
// Under this key the name of the parent will be saved (e.g. sdx-select)
const parentKey = "__parent";
const NOOP = () => {
  // Do nothing
};
// Stack of all overlay elements that are currently appended (e.g. to document.body)
const openedEls = [];
function requestToCloseTopmostOverlayEl(e) {
  var _a;
  // Only react to end user initiated events (not programmatic ones)
  if (!e.isTrusted) {
    return;
  }
  (_a = openedEls[0]) === null || _a === void 0 ? void 0 : _a.requestToClose(e);
}
// Close on click outside
addEventListener("click", requestToCloseTopmostOverlayEl, true);
addEventListener("touchend", requestToCloseTopmostOverlayEl, true);
// Close on esc
addEventListener("keydown", requestToCloseTopmostOverlayEl);
function appendToOverlayOutlet(el, target, component) {
  const alreadyExistsAtIndex = openedEls.indexOf(component);
  if (alreadyExistsAtIndex > -1) {
    openedEls.splice(alreadyExistsAtIndex, 1);
  }
  else {
    openedEls.unshift(component);
  }
  target.append(el);
}
const animation = {
  set: anime.set,
  start(params) {
    const { duration, complete, targets } = params;
    // Ensure to abort potentially already-running animations to prevent race
    // condition side effects, like callbacks that were executed too late, see:
    // https://git.swisscom.com/projects/SDX/repos/sdx/pull-requests/923/overview?commentId=1094510
    anime.remove(targets);
    const overrides = {
      easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
    };
    // If the duration is 0 (which means it's not animated), make sure the cb
    // is executed immediately instead of next tick (which is Anime's default)
    // which sometimes leads to laggy or incomplete animations.
    if (duration === 0) {
      delete params.complete;
    }
    const instance = anime({ ...params, ...overrides });
    if (duration === 0) {
      complete === null || complete === void 0 ? void 0 : complete(instance);
    }
    return instance;
  },
};
/**
 * Provides a proxy object for a component to a store.
 * During construction, it installs a store on a given component (specifically
 * on its DOM node).
 * If the component is a child (e.g. "sdx-select-option"), it returns the
 * store of its parent (e.g. "sdx-select").
 * If no store is found, it creates a new one and installs it on the parent.
 * @param cmp Component that requests the store.
 * @param reducer Reducer function.
 * @param initialState Default state of this store.
 * @param properties List of properties that will be updated (if changed).
 */
class StoreConnection {
  constructor(cmp, reducer, initialState, properties = []) {
    this.cmp = cmp;
    this.reducer = reducer;
    this.history = [];
    this.properties = properties;
    const parentTagName = getParentTagName(cmp.el.tagName.toLowerCase());
    // Looking for existing store
    let currentEl = cmp.el;
    this.store = currentEl[storeKey];
    if (parentTagName) {
      currentEl = closest(parent(currentEl), (el) => 
      // Check if the parent was found (tagName match) or if a store exists
      el.matches(parentTagName) || el[parentKey] === parentTagName);
      this.store = currentEl[storeKey];
    }
    // Store does not exist, create one
    if (!this.store) {
      this.store = new Store(reducer, initialState);
      currentEl[storeKey] = this.store;
    }
    // Keep a reference to the store so that the children of this child don't
    // have to traverse up that far.
    // This enables that components can be created while the parent is
    // currently appended to document.body and their parent (the holder of the
    // store) can't be found.
    cmp.el[storeKey] = this.store;
    cmp.el[parentKey] = currentEl.tagName.toLowerCase();
    if (!parentTagName) {
      // this is a parent (e.g. sdx-select)
      this.store.connected = true;
    }
    const { reduxStore } = this.store;
    const state = reduxStore.getState();
    cmp.state = {
      get: reduxStore.getState,
    };
    this.history.push(state);
  }
  // Allows an individual property to be set on the store without having to
  // call dispatch()
  set(property, value) {
    // Automatically dispatches the action
    this.store.reduxStore.replaceReducer((state) => ({ ...state, [property]: value }));
    // Restore
    this.store.reduxStore.replaceReducer(this.reducer);
  }
  dispatch(action) {
    this.store.dispatch(action);
  }
  flush() {
    this.store.flush();
  }
  subscribe() {
    this.sync();
    this.store.reduxStore.subscribe(() => this.sync());
  }
  // "Pulls" the current state into the component (triggering its watchers)
  sync() {
    const { getState } = this.store.reduxStore;
    const state = getState();
    const prevState = this.history[this.history.length - 1];
    // When dispatch() calls another dispatch()...
    this.history.push(state);
    // If any of the listed properties has changed, set the store again
    // in order to trigger the component lifecycle including watchers
    for (const property of this.properties) {
      if (prevState[property] !== state[property]) {
        // Before writing the new state, point the function reference to the
        // prevState to ensure it can be accessed (needed by the watchers to
        // find out which property exactly has changed).
        this.cmp.state.get = () => {
          return this.history[this.history.length - 2];
        };
        // Write the store (triggers component lifecycle)
        this.cmp.state = {
          get: getState,
        };
        // Writing the store once is enough
        break;
      }
    }
    // Clear history
    this.history.shift();
  }
}
class Store {
  constructor(reducer, initialState) {
    this.connected = false;
    this.queue = [];
    this.reduxStore = createStore(reducer, initialState);
  }
  dispatch(action) {
    if (this.connected) {
      this.reduxStore.dispatch(action);
    }
    else {
      this.queue.push(action);
    }
  }
  flush() {
    this.queue.forEach((action) => {
      this.reduxStore.dispatch(action);
    });
    this.queue = [];
  }
}
function getParentTagName(tagName) {
  const group = componentGraph.find((groups) => groups.includes(tagName));
  if (group) {
    if (group[0] !== tagName) {
      return group[0];
    }
    else {
      // It *is* the parent
      return;
    }
  }
  else {
    // Warn if not found...
    // eslint-disable-next-line no-console
    console.warn(`Element with tagName ${tagName} not found in componentGraph`);
    return tagName;
  }
}
/**
 * Evaluates a function string and returns the result.
 * Do nothing if the passed parameter already is a function.
 * @param fn Function - either as a string or as a function itself
 */
function parseFunction(fn) {
  if (typeof fn === "string") {
    return new Function(fn);
  }
  else if (typeof fn === "function") {
    return fn;
  }
  else {
    return NOOP;
  }
}
/**
 * Returns the parent element of a given element.
 * Also checks shadow roots and slots.
 * @param el Element to read its parent from.
 */
function parent(el) {
  if (el.assignedSlot) {
    return el.assignedSlot;
  }
  if (el.parentElement) {
    return el.parentElement;
  }
  const rootNode = el.getRootNode();
  if (rootNode.host) {
    return rootNode.host;
  }
  return undefined;
}
/**
 * Traverses up from a given element and compares each parent until first match.
 * @param el Element to start from.
 * @param selector A selector (can be a string, an element or a function).
 */
function closest(el, selector) {
  let currentEl = el;
  while (currentEl) {
    if ((typeof selector === "string" && currentEl.matches(selector)) ||
      (typeof selector === "object" && currentEl === selector) ||
      (typeof selector === "function" && selector(currentEl))) {
      return currentEl;
    }
    currentEl = parent(currentEl);
  }
  return undefined;
}
/**
 * Returns the previous element of a list.
 * Restart from the end if the given element is the first on the list.
 * @param list Array to pick element from.
 * @param el Item that will be used to get the index.
 * @param loop Restart if end has reached.
 */
function getPreviousFromList(list, el, restart = true) {
  let index;
  let newIndex = 0;
  if (el) {
    index = list.indexOf(el);
  }
  if (index !== undefined) {
    if (index - 1 >= 0) {
      // previous exists
      newIndex = index - 1;
    }
    else if (restart) {
      // already at the beginning, jump to the end
      newIndex = list.length - 1;
    }
    else {
      newIndex = index;
    }
  }
  return list[newIndex];
}
/**
 * Returns the next element of a list.
 * Restart from the beginning if the given element is the last on the list.
 * @param list Array to pick element from.
 * @param el Item that will be used to get the index.
 * @param loop Restart if end has reached.
 */
function getNextFromList(list, el, restart = true) {
  let index;
  let newIndex = 0;
  if (el) {
    index = list.indexOf(el);
  }
  if (index !== undefined) {
    if (index + 1 < list.length) {
      // next exists
      newIndex = index + 1;
    }
    else if (restart) {
      newIndex = 0;
    }
    else {
      // already at the end, jump to the beginning
      newIndex = index;
    }
  }
  return list[newIndex];
}
/**
 * Sorts a list of DOM nodes by their appearance in the DOM tree.
 */
function sortByAppearanceInDomTree(a, b) {
  const position = a.compareDocumentPosition(b);
  return position <= Node.DOCUMENT_POSITION_PRECEDING
    ? position <= Node.DOCUMENT_POSITION_FOLLOWING
      ? 1
      : 0
    : -1;
}
/**
 * Builds an object with one property using a given name and sets it to true if truthy.
 * Example: "foo" => { foo: true },
 * Example: "" => {}
 * @param property Name of the property
 */
function computedProperty(property) {
  return property ? { [property]: true } : {};
}
/**
 * Tries to parse the argument (e.g. a JSON string) and return the result (e.g. an object).
 * Returns the argument if it's already an object.
 * Returns an empty object if argument is falsy.
 * @param json Something that will be parsed
 */
function parseJson(json) {
  if (json instanceof Object) {
    return json;
  }
  if (typeof json === "string") {
    try {
      return JSON.parse(json);
    }
    catch (e) {
      // eslint-disable-next-line no-console
      console.warn(e);
    }
  }
  return undefined;
}
/**
 * Checks if a given element or one of its parents has "display: none;".
 * It won't work for "position: fixed;" and is untested for other ways of
 * making elements invisible (such as modifying height or position).
 * @param el Element to check.
 */
function isHidden(el) {
  return el.offsetParent === null;
}
/**
 * Checks if a given element is an SDX web component by testing its
 * tagname to start with "sdx-".
 * @param el Element to check.
 */
function isSDXWebComponent(el) {
  return /^sdx-/.test(el.tagName.toLowerCase());
}
/**
 * Returns the element to which overlays are to be attached.
 */
function getOverlayOutletEl() {
  const overlayOutletEl = document.getElementById("sdx-overlay-outlet");
  // Make sure .sdx is present in case the it's used outside the container
  // and therefore misses font-face declarations, colors, etc.
  overlayOutletEl === null || overlayOutletEl === void 0 ? void 0 : overlayOutletEl.classList.add("sdx");
  return overlayOutletEl || document.body;
}
/**
 * Returns the width of an element, optionally with padding and margin.
 * To use if .offsetWidth does not suffice.
 * @param el Element to measure.
 * @param includeMargin If there's margin, add it to the width.
 * @param includePadding If there's padding, add it to the width.
 */
function width(el, includeMargin = false, includePadding = false) {
  if (!el) {
    return 0;
  }
  const style = getComputedStyle(el);
  const isHidden = style.display === "none";
  let width = el.offsetWidth;
  if (includeMargin) {
    width = width + parseFloat(style.marginLeft) + parseFloat(style.marginRight);
  }
  if (!includePadding) {
    width =
      width - parseFloat(style.paddingLeft) - parseFloat(style.paddingRight);
  }
  if (isHidden) {
    return 0;
  }
  return width;
}
function isTextNode(node) {
  return node.nodeType === Node.TEXT_NODE;
}
function isElementNode(node) {
  return node.nodeType === Node.ELEMENT_NODE;
}
/**
 * Checks if a given node has a child with a given slot name (if any).
 * @param el Parent element to check.
 * @param name Slot name to check.
 */
function hasSlot(el, name) {
  if (name) {
    // This also works when el has no shadow root (e.g. sdx-header-menu)
    return !!el.querySelector(`[slot=${name}]`);
  }
  else {
    // Warning: this only works when el has a shadow root
    return [...el.childNodes].some((node) => isTextNode(node) || (isElementNode(node) && !node.hasAttribute("slot")));
  }
}
/**
 * Flattens a recursively nested object.
 * @param data Array to be flattened.
 * @param property Property name of children.
 */
function flattenBy(data, property, accumulator = []) {
  accumulator.push(data);
  if (Array.isArray(data[property])) {
    data[property].forEach(
    // why isn't Array.isArray() enough for TS?
    (child) => flattenBy(child, property, accumulator));
  }
  return accumulator;
}
/**
 * Returns the numeric value of a computed style property.
 */
function getNumericValue(computedStyleProperty, el) {
  const style = getComputedStyle(el);
  return parseFloat(style.getPropertyValue(computedStyleProperty));
}
function isTouchscreen() {
  return "ontouchstart" in window;
}
function dispatchEvent(el, type) {
  el.dispatchEvent(new Event(type, { cancelable: true, bubbles: true, composed: true }));
}
function disableBodyScroll() {
  disableBodyScroll$1({
    reserveScrollBarGap: true,
  });
}
function enableBodyScroll() {
  enableBodyScroll$1();
}
function getScrollbarWidth() {
  // Same calculation that body-scroll-lock uses
  return window.innerWidth - document.documentElement.clientWidth;
}
/**
 * Finds and returns the first scrollable parent element of a given element.
 */
function getScrollContainerEl(el) {
  let currentEl = el;
  while (currentEl) {
    if (currentEl === document.body) {
      // Look no further
      return;
    }
    const { overflow } = getComputedStyle(currentEl);
    const hasOverflowScroll = overflow.includes("auto") || overflow.includes("scroll");
    const hasScrollbar = currentEl.scrollHeight > currentEl.clientHeight;
    // Just because an element has an "overflow" doesn't mean there's actually
    // a scrollbar. Therefore also check its scroll height.
    // Checking its scroll height alone doesn't work because in some cases,
    // the scrollHeight is larger than clientHeight even though it isn't
    // scrollable (e.g. for inline elements).
    if (hasOverflowScroll && hasScrollbar) {
      return currentEl;
    }
    currentEl = parent(currentEl);
  }
  return;
}
function setCssVariableWindowInnerHeight() {
  // innerHeight: that's the only way that respects iOS address bar (tested on iOS Safari 16.4)
  document.documentElement.style.setProperty("--sdx-dialog-window-inner-height", `${window.innerHeight}px`);
}
function translate(key, language) {
  const langs = ["de", "fr", "it"];
  const lang = language || document.documentElement.lang || "en";
  const dictionary = {
    DD: ["TT", "JJ", "GG"],
    MM: ["MM", "MM", "MM"],
    YYYY: ["JJJJ", "AAAA", "AAAA"],
    Day: ["Tag", "Jour", "Giorno"],
    Month: ["Monat", "Mois", "Mese"],
    Year: ["Jahr", "Année", "Anno"],
    "Please enter a valid day": [
      "Bitte geben Sie einen gültigen Tag ein",
      "Prière de saisir un jour valable",
      "Inserisca p.f. una data valida",
    ],
    "Please enter a valid month": [
      "Bitte geben Sie einen gültigen Monat ein",
      "Prière de saisir un mois valable",
      "Inserisca p.f. un mese valido",
    ],
    "Please enter a valid year": [
      "Bitte geben Sie ein gültiges Jahr ein",
      "Prière de saisir une année valable",
      "Inserisca p.f. un anno valido",
    ],
    "Please enter a valid date": [
      "Bitte geben Sie ein gültiges Datum ein",
      "Prière de saisir une date valable",
      "Inserisca p.f. una data valida",
    ],
    "Start of dialog": [
      "Anfang des Dialogfensters",
      "Début de la fenêtre de dialogue",
      "Inizio della finestra di dialogo",
    ],
    "End of dialog": [
      "Ende des Dialogfensters",
      "Fin de la fenêtre de dialogue",
      "Fine della finestra di dialogo",
    ],
    "Open dialog": ["Dialog öffnen", "Ouvrir dialogue", "Apri dialogo"],
    "Show more filters": [
      "Zeige mehr Filter",
      "Montrer plus de filtres",
      "Mostra altri filtri",
    ],
    "Show less filters": [
      "Zeige weniger Filter",
      "Montrer moins de filtres",
      "Mostra meno filtri",
    ],
    "Reset all filters": [
      "Alle Filter entfernen",
      "Réinitialiser tous les filtres",
      "Rimuovi tutti i filtri",
    ],
  };
  return dictionary[key][langs.indexOf(lang)] || key;
}
function getAppearance(el) {
  const elWithDarkTheme = closest(el, ".sdx--dark-theme");
  if (elWithDarkTheme) {
    return "sdx--dark-theme";
  }
  return "sdx--light-theme";
}
function getScreenOrientationAngle() {
  var _a;
  // iOS just uses deprecated "window.orientation"
  return window.orientation || ((_a = screen === null || screen === void 0 ? void 0 : screen.orientation) === null || _a === void 0 ? void 0 : _a.angle) || 0;
}
/**
 * Tests an expression every n ms and resolves once true.
 * @param expression Expression to test.
 */
function waitFor(fn) {
  return new Promise((resolve) => {
    const interval = setInterval(() => {
      if (fn()) {
        clearInterval(interval);
        resolve();
      }
    }, 10);
  });
}
/**
 * Get correct scrolling values, even for Safari 12.
 */
function getScrollTopLeft(elementWithPossiblyWrongScrollValues) {
  if (elementWithPossiblyWrongScrollValues !== document.documentElement) {
    // values are ok
    return {
      scrollTop: elementWithPossiblyWrongScrollValues.scrollTop,
      scrollLeft: elementWithPossiblyWrongScrollValues.scrollLeft,
    };
  }
  const elementWithCorrectScrollValues = document.scrollingElement || document.documentElement;
  return {
    scrollTop: elementWithCorrectScrollValues.scrollTop,
    scrollLeft: elementWithCorrectScrollValues.scrollLeft,
  };
}

/**
 * Adds an item to a list, if it does not exist, yet.
 * @param list The array that might contain the given item.
 * @param item The element that should be added.
 */
function add(list, item) {
  if (!list.includes(item)) {
    return [...list, item];
  }
  return list;
}
/**
 * Removes an item from a list, if it exists.
 * @param list The array that might contain the given item.
 * @param item The element that should be removed.
 */
function remove(list, item) {
  if (list.includes(item)) {
    return list.filter((currentItem) => currentItem !== item);
  }
  return list;
}
/**
 * Adds an item to a list, if it does not exist, yet.
 * If it does exist, however, it removes it.
 * @param list The array that might contain the given item.
 * @param item The element that should be added or removed.
 */
function toggle(list, item) {
  if (!list.includes(item)) {
    return add(list, item);
  }
  return remove(list, item);
}
/**
 * Like Array map() but for objects.
 * Example: { foo: "bar" } => { foo1: "bar1" }
 * @param obj Object to iterate.
 * @param cb Callback that transforms key and value.
 */
function objectMap(obj, cb) {
  let newObj = {};
  for (const key in obj) {
    newObj = { ...newObj, ...cb(key, obj[key]) };
  }
  return newObj;
}

function open(state, accordionItemEl) {
  // Do nothing if it's already open
  if (state.openAccordionItemEls.includes(accordionItemEl)) {
    return state;
  }
  return {
    ...state,
    openAccordionItemEls: state.keepOpen
      ? [...state.openAccordionItemEls, accordionItemEl]
      : [accordionItemEl],
  };
}
function close(state, accordionItemEl) {
  // Do nothing if it's already closed
  if (!state.openAccordionItemEls.includes(accordionItemEl)) {
    return state;
  }
  return {
    ...state,
    openAccordionItemEls: state.openAccordionItemEls.filter((el) => el !== accordionItemEl),
  };
}
const accordionReducer = (state = {}, action) => {
  switch (action.type) {
    case "ADD_ACCORDION_ITEM_EL":
      return {
        ...state,
        accordionItemEls: add(state.accordionItemEls, action.accordionItemEl).sort(sortByAppearanceInDomTree),
      };
    case "REMOVE_ACCORDION_ITEM_EL":
      return {
        ...state,
        accordionItemEls: remove(state.accordionItemEls, action.accordionItemEl).sort(sortByAppearanceInDomTree),
      };
    case "UPDATE_REAPPENDING":
      const reappendedItems = state.reappendedItems + 1;
      const reappending = reappendedItems !== state.accordionItemEls.length;
      return {
        ...state,
        reappending,
        reappendedItems: reappending ? reappendedItems : 0,
      };
    case "OPEN_ACCORDION_ITEM_EL":
      return open(state, action.accordionItemEl);
    case "OPEN_ALL_ACCORDION_ITEM_ELS":
      return { ...state, openAccordionItemEls: state.accordionItemEls };
    case "CLOSE_ACCORDION_ITEM_EL":
      return close(state, action.accordionItemEl);
    case "CLOSE_ALL_ACCORDION_ITEM_ELS":
      return { ...state, openAccordionItemEls: [] };
    case "TOGGLE_ACCORDION_ITEM_EL":
      const isOpen = state.openAccordionItemEls.includes(action.accordionItemEl);
      return isOpen
        ? close(state, action.accordionItemEl)
        : open(state, action.accordionItemEl);
    default:
      return state;
  }
};
function getInitialState$6() {
  return {
    accordionItemEls: [],
    openAccordionItemEls: [],
    arrowPosition: "right",
    keepOpen: false,
    reappending: false,
    reappendedItems: 0,
    userInteractionInProgress: false,
  };
}

const accordionCss = "/*!@:root*/.sc-sdx-accordion:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-accordion-h,*.sc-sdx-accordion,*.sc-sdx-accordion:before,*.sc-sdx-accordion:after{box-sizing:border-box}/*!@:host*/.sc-sdx-accordion-h{display:block}/*!@.component*/.component.sc-sdx-accordion{background:transparent;border:1px solid #d6d6d6;border-radius:6px;overflow:hidden}/*!@.component.sdx--dark-theme*/.component.sdx--dark-theme.sc-sdx-accordion{border-color:#707070}";

class Accordion {
  arrowPositionChanged() {
    this.store.set("arrowPosition", this.arrowPosition);
  }
  keepOpenChanged() {
    this.store.set("keepOpen", this.keepOpen);
  }
  /**
   * Opens a specific accordion item.
   * @param index Index of the accordion item to be opened.
   */
  async open(index) {
    const accordionItemEl = this.state.get().accordionItemEls[index];
    this.store.dispatch({ type: "OPEN_ACCORDION_ITEM_EL", accordionItemEl });
  }
  /**
   * Opens all accordion items.
   */
  async openAll() {
    this.store.dispatch({ type: "OPEN_ALL_ACCORDION_ITEM_ELS" });
  }
  /**
   * Closes a specific accordion item.
   * @param index Index of the accordion item to be closed.
   */
  async close(index) {
    const accordionItemEl = this.state.get().accordionItemEls[index];
    this.store.dispatch({ type: "CLOSE_ACCORDION_ITEM_EL", accordionItemEl });
  }
  /**
   * Closes all accordion items.
   */
  async closeAll() {
    this.store.dispatch({ type: "CLOSE_ALL_ACCORDION_ITEM_ELS" });
  }
  /**
   * Toggles a specific accordion item.
   * @param index Index of the accordion item to be toggled.
   */
  async toggle(index) {
    const accordionItemEl = this.state.get().accordionItemEls[index];
    this.store.dispatch({ type: "TOGGLE_ACCORDION_ITEM_EL", accordionItemEl });
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.isReappending = false;
    this.state = undefined;
    this.keepOpen = false;
    this.arrowPosition = "right";
    this.componentStyle = {};
    this.store = new StoreConnection(this, accordionReducer, getInitialState$6(), ["accordionItemEls"]);
    this.store.set("arrowPosition", this.arrowPosition);
    this.store.set("keepOpen", this.keepOpen);
    this.store.flush();
  }
  connectedCallback() {
    // The component is being reappended
    if (this.isReappending) {
      this.store.set("reappending", true);
      this.isReappending = false;
    }
  }
  disconnectedCallback() {
    // Know that a disconnection happened, maybe because the component was
    // removed, cached or it's being appended to document.body
    const isStillInDocument = closest(this.el, document.documentElement);
    if (isStillInDocument) {
      this.isReappending = true;
    }
  }
  componentDidLoad() {
    this.store.subscribe();
  }
  getComponentClassNames() {
    return {
      component: true,
      [getAppearance(this.el)]: true,
    };
  }
  render() {
    return (hAsync("div", { class: this.getComponentClassNames(), style: this.componentStyle }, hAsync("slot", null)));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "arrowPosition": ["arrowPositionChanged"],
    "keepOpen": ["keepOpenChanged"]
  }; }
  static get style() { return accordionCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-accordion",
    "$members$": {
      "keepOpen": [4, "keep-open"],
      "arrowPosition": [1, "arrow-position"],
      "componentStyle": [16],
      "state": [32],
      "open": [64],
      "openAll": [64],
      "close": [64],
      "closeAll": [64],
      "toggle": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const accordionItemCss = "/*!@:root*/.sc-sdx-accordion-item:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-accordion-item-h,*.sc-sdx-accordion-item,*.sc-sdx-accordion-item:before,*.sc-sdx-accordion-item:after{box-sizing:border-box}/*!@:host*/.sc-sdx-accordion-item-h{display:block}/*!@:host p*/.sc-sdx-accordion-item-h p.sc-sdx-accordion-item{padding:12px 16px}/*!@:host(.center)*/.center.sc-sdx-accordion-item-h{padding:0}/*!@:host(:not(:last-of-type)) .component*/.sc-sdx-accordion-item-h:not(:last-of-type) .component.sc-sdx-accordion-item{border-bottom:1px solid #d6d6d6}/*!@.component*/.component.sc-sdx-accordion-item{position:relative}/*!@:host(:not(:last-of-type).sdx--dark-theme) .component*/.sc-sdx-accordion-item-h:not(:last-of-type).sdx--dark-theme .component.sc-sdx-accordion-item{border-color:#707070}";

class AccordionItem {
  openChanged() {
    this.open
      ? this.store.dispatch({
        type: "OPEN_ACCORDION_ITEM_EL",
        accordionItemEl: this.el,
      })
      : this.store.dispatch({
        type: "CLOSE_ACCORDION_ITEM_EL",
        accordionItemEl: this.el,
      });
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.state = undefined;
    this.open = false;
    this.store = new StoreConnection(this, accordionReducer, getInitialState$6(), ["openAccordionItemEls", "arrowPosition", "reappending"]);
  }
  connectedCallback() {
    var _a;
    // Don't do anything while the component is being reappended (maybe
    // because it's being appended to document.body), but send a "ping" for
    // each child (sdx-accordion-item).
    // After each child is has finished, "reappending" will be marked "done" by
    // the store.
    if (this.state.get().reappending) {
      (_a = this.store) === null || _a === void 0 ? void 0 : _a.dispatch({ type: "UPDATE_REAPPENDING" });
      return;
    }
    // Register self
    this.store.dispatch({
      type: "ADD_ACCORDION_ITEM_EL",
      accordionItemEl: this.el,
    });
    if (this.open) {
      this.store.dispatch({
        type: "OPEN_ACCORDION_ITEM_EL",
        accordionItemEl: this.el,
      });
    }
  }
  disconnectedCallback() {
    // See connectedCallback() for explanation
    if (this.state.get().reappending) {
      return;
    }
    // Unregister self
    this.store.dispatch({
      type: "REMOVE_ACCORDION_ITEM_EL",
      accordionItemEl: this.el,
    });
    if (this.open) {
      this.store.dispatch({
        type: "CLOSE_ACCORDION_ITEM_EL",
        accordionItemEl: this.el,
      });
    }
  }
  componentDidLoad() {
    this.store.subscribe();
  }
  getHostClassNames() {
    const { arrowPosition } = this.state.get();
    return {
      [getAppearance(this.el)]: true,
      [arrowPosition]: true,
    };
  }
  render() {
    return (hAsync(Host, { class: this.getHostClassNames() }, hAsync("div", { class: "component" }, hAsync("slot", null))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "open": ["openChanged"]
  }; }
  static get style() { return accordionItemCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-accordion-item",
    "$members$": {
      "open": [4],
      "state": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const accordionItemBodyCss = "/*!@:root*/.sc-sdx-accordion-item-body:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-accordion-item-body-h,*.sc-sdx-accordion-item-body,*.sc-sdx-accordion-item-body:before,*.sc-sdx-accordion-item-body:after{box-sizing:border-box}/*!@:host*/.sc-sdx-accordion-item-body-h{display:none;overflow:hidden}/*!@.component*/.component.sc-sdx-accordion-item-body{margin:0 16px 16px}";

class AccordionItemBody {
  stateChanged({}, prev) {
    const state = this.state.get();
    const prevState = prev.get();
    if (state.openAccordionItemEls !== prevState.openAccordionItemEls) {
      this.openAccordionItemElsChanged(state, prevState);
    }
  }
  /**
   * Toggles body directly when initial load or with an animation.
   * @param isOpen Open state of the accordion item.
   * @private
   */
  async toggle(isOpen) {
    if (isOpen) {
      this.store.dispatch({
        type: "OPEN_ACCORDION_ITEM_EL",
        accordionItemEl: this.getParent(),
      });
    }
    else {
      this.store.dispatch({
        type: "CLOSE_ACCORDION_ITEM_EL",
        accordionItemEl: this.getParent(),
      });
    }
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.sdxdisplaychange = createEvent(this, "sdxdisplaychange", 7);
    this.animationDuration = 300;
    this.componentDidLoadComplete = false;
    this.state = undefined;
    this.display = undefined;
    this.componentStyle = {};
    this.store = new StoreConnection(this, accordionReducer, getInitialState$6(), ["accordionItemEls", "openAccordionItemEls", "arrowPosition"]);
  }
  componentWillLoad() {
    if (this.isOpen()) {
      this.open();
    }
    else {
      this.close();
    }
  }
  componentDidLoad() {
    this.store.subscribe();
    this.componentDidLoadComplete = true;
  }
  setDisplay(display, userInteractionInProgress) {
    this.display = display;
    // Only fire events on end user interaction
    if (!userInteractionInProgress) {
      return;
    }
    this.sdxdisplaychange.emit({ display });
  }
  openAccordionItemElsChanged({}, prevState) {
    const isOpen = this.isOpen();
    const wasOpen = this.isOpen(prevState.openAccordionItemEls);
    if (isOpen && !wasOpen) {
      this.open();
    }
    else if (!isOpen && wasOpen) {
      this.close();
    }
  }
  /**
   * Opens item with an animation.
   */
  open() {
    const { userInteractionInProgress } = this.state.get();
    this.setDisplay("opening", userInteractionInProgress);
    anime.set(this.el, {
      display: "block",
      height: 0,
    });
    anime({
      targets: this.el,
      duration: this.componentDidLoadComplete ? this.animationDuration : 0,
      height: this.el.scrollHeight,
      opacity: 1,
      easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
      complete: () => {
        // "auto" can't be set using anime.set(), see:
        // https://github.com/juliangarnier/anime/issues/758
        this.el.style.height = "auto";
        this.setDisplay("open", userInteractionInProgress);
      },
    });
  }
  /**
   * Closes item with an animation.
   */
  close() {
    const { userInteractionInProgress } = this.state.get();
    this.setDisplay("closing", userInteractionInProgress);
    // Can't animate "auto", therefore update to current height.
    // Note: the height can't be overwritten by anime.set() because it was set
    // using "this.el.style.height" in "open()", see:
    // https://github.com/juliangarnier/anime/issues/758
    this.el.style.height = `${this.el.scrollHeight}px`;
    anime({
      targets: this.el,
      duration: this.componentDidLoadComplete ? this.animationDuration : 0,
      height: 0,
      opacity: 0,
      easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
      complete: () => {
        anime.set(this.el, { display: "none" });
        this.setDisplay("closed", userInteractionInProgress);
      },
    });
  }
  getParent() {
    const { accordionItemEls } = this.state.get();
    return accordionItemEls.find((el) => closest(this.el, el));
  }
  isOpen(openAccordionItemEls) {
    if (!openAccordionItemEls) {
      openAccordionItemEls = this.state.get().openAccordionItemEls;
    }
    return openAccordionItemEls.some((el) => closest(this.el, el));
  }
  getComponentClassNames() {
    return {
      component: true,
      [this.state.get().arrowPosition]: true,
    };
  }
  render() {
    return (hAsync(Host, { "aria-expanded": (this.display === "open").toString() }, hAsync("div", { class: this.getComponentClassNames(), style: this.componentStyle }, hAsync("slot", null))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "state": ["stateChanged"]
  }; }
  static get style() { return accordionItemBodyCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-accordion-item-body",
    "$members$": {
      "componentStyle": [16],
      "state": [32],
      "display": [32],
      "toggle": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const accordionItemHeaderCss = "/*!@:root*/.sc-sdx-accordion-item-header:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-accordion-item-header-h,*.sc-sdx-accordion-item-header,*.sc-sdx-accordion-item-header:before,*.sc-sdx-accordion-item-header:after{box-sizing:border-box}/*!@.component*/.component.sc-sdx-accordion-item-header{display:flex;align-items:center;width:100%;margin:0;padding:12px 16px;border:0;cursor:pointer;outline:none;font-family:inherit;background:transparent;text-align:left}/*!@.component:hover .arrow*/.component.sc-sdx-accordion-item-header:hover .arrow.sc-sdx-accordion-item-header{position:relative}/*!@.component:hover .arrow::before, .component:hover .arrow::after*/.component.sc-sdx-accordion-item-header:hover .arrow.sc-sdx-accordion-item-header::before,.component.sc-sdx-accordion-item-header:hover .arrow.sc-sdx-accordion-item-header::after{position:absolute;top:50%;transition:all 200ms cubic-bezier(0.4, 0, 0.2, 1);border-radius:2px;background:#0048cf;width:10px;height:2px;backface-visibility:hidden;content:\"\"}/*!@.component:hover .arrow::before*/.component.sc-sdx-accordion-item-header:hover .arrow.sc-sdx-accordion-item-header::before{left:0}/*!@.component:hover .arrow::after*/.component.sc-sdx-accordion-item-header:hover .arrow.sc-sdx-accordion-item-header::after{left:6px}/*!@.component.open .arrow::before*/.component.open.sc-sdx-accordion-item-header .arrow.sc-sdx-accordion-item-header::before{transform:rotate(-45deg)}/*!@.component.open .arrow::after*/.component.open.sc-sdx-accordion-item-header .arrow.sc-sdx-accordion-item-header::after{transform:rotate(45deg)}/*!@.component.left*/.component.left.sc-sdx-accordion-item-header{flex-direction:row-reverse}/*!@.component.left .header*/.component.left.sc-sdx-accordion-item-header .header.sc-sdx-accordion-item-header{padding-left:8px}/*!@.component.right .header*/.component.right.sc-sdx-accordion-item-header .header.sc-sdx-accordion-item-header{padding-right:8px}/*!@.component.center*/.component.center.sc-sdx-accordion-item-header{justify-content:center;min-height:32px;border-top:1px solid #d6d6d6}/*!@.component.center .header*/.component.center.sc-sdx-accordion-item-header .header.sc-sdx-accordion-item-header{display:none}/*!@.component .header*/.component.sc-sdx-accordion-item-header .header.sc-sdx-accordion-item-header{flex:1}/*!@.component .arrow*/.component.sc-sdx-accordion-item-header .arrow.sc-sdx-accordion-item-header{position:relative;width:15px;background:#086adb}/*!@.component .arrow::before, .component .arrow::after*/.component.sc-sdx-accordion-item-header .arrow.sc-sdx-accordion-item-header::before,.component.sc-sdx-accordion-item-header .arrow.sc-sdx-accordion-item-header::after{position:absolute;top:50%;transition:all 200ms cubic-bezier(0.4, 0, 0.2, 1);border-radius:2px;background:inherit;width:10px;height:2px;backface-visibility:hidden;content:\"\"}/*!@.component .arrow::before*/.component.sc-sdx-accordion-item-header .arrow.sc-sdx-accordion-item-header::before{left:0}/*!@.component .arrow::after*/.component.sc-sdx-accordion-item-header .arrow.sc-sdx-accordion-item-header::after{left:6px}/*!@.component .arrow::before*/.component.sc-sdx-accordion-item-header .arrow.sc-sdx-accordion-item-header::before{transform:rotate(45deg)}/*!@.component .arrow::after*/.component.sc-sdx-accordion-item-header .arrow.sc-sdx-accordion-item-header::after{transform:rotate(-45deg)}/*!@.component.sdx--dark-theme*/.component.sdx--dark-theme.sc-sdx-accordion-item-header{color:#e6e6e6}/*!@.component.sdx--dark-theme:hover .arrow*/.component.sdx--dark-theme.sc-sdx-accordion-item-header:hover .arrow.sc-sdx-accordion-item-header{position:relative}/*!@.component.sdx--dark-theme:hover .arrow::before, .component.sdx--dark-theme:hover .arrow::after*/.component.sdx--dark-theme.sc-sdx-accordion-item-header:hover .arrow.sc-sdx-accordion-item-header::before,.component.sdx--dark-theme.sc-sdx-accordion-item-header:hover .arrow.sc-sdx-accordion-item-header::after{position:absolute;top:50%;transition:all 200ms cubic-bezier(0.4, 0, 0.2, 1);border-radius:2px;background:#5ca3ff;width:10px;height:2px;backface-visibility:hidden;content:\"\"}/*!@.component.sdx--dark-theme:hover .arrow::before*/.component.sdx--dark-theme.sc-sdx-accordion-item-header:hover .arrow.sc-sdx-accordion-item-header::before{left:0}/*!@.component.sdx--dark-theme:hover .arrow::after*/.component.sdx--dark-theme.sc-sdx-accordion-item-header:hover .arrow.sc-sdx-accordion-item-header::after{left:6px}/*!@.component.sdx--dark-theme .arrow*/.component.sdx--dark-theme.sc-sdx-accordion-item-header .arrow.sc-sdx-accordion-item-header{background:#4294ff}/*!@.component.sdx--dark-theme.center*/.component.sdx--dark-theme.center.sc-sdx-accordion-item-header{border-top-color:#707070}";

class AccordionItemHeader {
  onClick() {
    this.store.set("userInteractionInProgress", true);
    this.store.dispatch({
      type: "TOGGLE_ACCORDION_ITEM_EL",
      accordionItemEl: this.getParent(),
    });
    this.store.set("userInteractionInProgress", false);
  }
  /**
   * Closes this accordion item.
   */
  async closeItem() {
    this.store.dispatch({
      type: "CLOSE_ACCORDION_ITEM_EL",
      accordionItemEl: this.getParent(),
    });
  }
  /**
   * Opens this accordion item.
   */
  async openItem() {
    this.store.dispatch({
      type: "OPEN_ACCORDION_ITEM_EL",
      accordionItemEl: this.getParent(),
    });
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.state = undefined;
    this.buttonStyle = {};
    this.arrowStyle = {};
    this.store = new StoreConnection(this, accordionReducer, getInitialState$6(), ["accordionItemEls", "openAccordionItemEls", "arrowPosition"]);
  }
  componentDidLoad() {
    this.store.subscribe();
  }
  getParent() {
    const { accordionItemEls } = this.state.get();
    return accordionItemEls.find((el) => closest(this.el, el));
  }
  isOpen() {
    const { openAccordionItemEls } = this.state.get();
    return openAccordionItemEls.some((el) => closest(this.el, el));
  }
  getComponentClassNames() {
    const { arrowPosition } = this.state.get();
    return {
      component: true,
      [getAppearance(this.el)]: true,
      open: this.isOpen(),
      [arrowPosition]: true,
    };
  }
  render() {
    return (hAsync("button", { type: "button", class: this.getComponentClassNames(), style: this.buttonStyle, "aria-expanded": this.isOpen().toString() }, hAsync("div", { class: "header" }, hAsync("slot", null)), hAsync("div", { class: "arrow", style: this.arrowStyle })));
  }
  get el() { return getElement(this); }
  static get style() { return accordionItemHeaderCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-accordion-item-header",
    "$members$": {
      "buttonStyle": [16],
      "arrowStyle": [16],
      "state": [32],
      "closeItem": [64],
      "openItem": [64]
    },
    "$listeners$": [[0, "click", "onClick"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const accordionItemSectionCss = "/*!@:root*/.sc-sdx-accordion-item-section:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-accordion-item-section-h,*.sc-sdx-accordion-item-section,*.sc-sdx-accordion-item-section:before,*.sc-sdx-accordion-item-section:after{box-sizing:border-box}/*!@:host*/.sc-sdx-accordion-item-section-h{padding-top:16px;padding-bottom:16px;padding-left:15px;padding-right:15px;display:inline-block;position:relative}";

class AccordionItemSection {
  constructor(hostRef) {
    registerInstance(this, hostRef);
  }
  render() {
    return hAsync("slot", null);
  }
  static get style() { return accordionItemSectionCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-accordion-item-section",
    "$members$": undefined,
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

class Animation {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.animationName = undefined;
    this.animationNameFirstRender = undefined;
    this.animationDuration = 200;
  }
  animationNameChanged() {
    this.runAnimation(this.animationName);
  }
  componentWillLoad() {
    // Set initial values to be ready for an animation
    switch (this.animationName) {
      case "scale-in":
        this.el.style.transform = "scale(1)";
        break;
      case "scale-out":
        this.el.style.transform = "scale(0)";
        this.el.style.display = "none";
        break;
      case "fade-in":
        this.el.style.opacity = "1";
        this.el.style.display = "inline-block";
        break;
      case "fade-out":
        this.el.style.opacity = "0";
        this.el.style.display = "none";
        break;
    }
  }
  componentDidLoad() {
    this.runAnimation(this.animationNameFirstRender);
  }
  async runAnimation(animationName) {
    if (!animationName) {
      return;
    }
    this.el.style.display = "inline-block";
    // Prepare the animation
    let animeParams = {
      targets: this.el,
      duration: this.animationDuration,
      easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
    };
    switch (animationName) {
      case "scale-in":
        animeParams = { ...animeParams, scale: 1 };
        break;
      case "scale-out":
        animeParams = { ...animeParams, scale: 0 };
        break;
      case "fade-in":
        animeParams = { ...animeParams, opacity: 1 };
        break;
      case "fade-out":
        animeParams = {
          ...animeParams,
          opacity: 0,
          complete: () => (this.el.style.display = "none"),
        };
        break;
    }
    // Run the animation
    return anime(animeParams).finished;
  }
  render() {
    return hAsync("slot", null);
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "animationName": ["animationNameChanged"]
  }; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-animation",
    "$members$": {
      "animationName": [1, "animation-name"],
      "animationNameFirstRender": [1, "animation-name-first-render"],
      "animationDuration": [2, "animation-duration"],
      "runAnimation": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const arrowCss = "/*!@:root*/.sc-sdx-arrow:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-arrow-h,*.sc-sdx-arrow,*.sc-sdx-arrow:before,*.sc-sdx-arrow:after{box-sizing:border-box}/*!@:host*/.sc-sdx-arrow-h{display:flex;width:100%;height:100%}/*!@.component*/.component.sc-sdx-arrow{cursor:pointer;height:inherit;display:flex;flex:1}/*!@.component:hover .background .arrow*/.component.sc-sdx-arrow:hover .background.sc-sdx-arrow .arrow.sc-sdx-arrow{position:relative}/*!@.component:hover .background .arrow::before, .component:hover .background .arrow::after*/.component.sc-sdx-arrow:hover .background.sc-sdx-arrow .arrow.sc-sdx-arrow::before,.component.sc-sdx-arrow:hover .background.sc-sdx-arrow .arrow.sc-sdx-arrow::after{position:absolute;top:50%;transition:all 200ms cubic-bezier(0.4, 0, 0.2, 1);border-radius:2px;background:#0048cf;width:10px;height:2px;backface-visibility:hidden;content:\"\"}/*!@.component:hover .background .arrow::before*/.component.sc-sdx-arrow:hover .background.sc-sdx-arrow .arrow.sc-sdx-arrow::before{left:0}/*!@.component:hover .background .arrow::after*/.component.sc-sdx-arrow:hover .background.sc-sdx-arrow .arrow.sc-sdx-arrow::after{left:6px}/*!@.component.left*/.component.left.sc-sdx-arrow{justify-content:flex-start;background:linear-gradient(to left, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.85), white)}/*!@.component.left .background*/.component.left.sc-sdx-arrow .background.sc-sdx-arrow{transform-origin:left;left:2px}/*!@.component.left .background .arrow::before*/.component.left.sc-sdx-arrow .background.sc-sdx-arrow .arrow.sc-sdx-arrow::before{top:6px;transform:rotate(45deg)}/*!@.component.left .background .arrow::after*/.component.left.sc-sdx-arrow .background.sc-sdx-arrow .arrow.sc-sdx-arrow::after{left:0;transform:rotate(-45deg)}/*!@.component.right*/.component.right.sc-sdx-arrow{justify-content:flex-end;background:linear-gradient(to right, rgba(255, 255, 255, 0), rgba(255, 255, 255, 0.85), white)}/*!@.component.right .background*/.component.right.sc-sdx-arrow .background.sc-sdx-arrow{transform-origin:right;right:2px}/*!@.component.right .background .arrow::before*/.component.right.sc-sdx-arrow .background.sc-sdx-arrow .arrow.sc-sdx-arrow::before{right:0;top:6px;transform:rotate(-45deg)}/*!@.component.right .background .arrow::after*/.component.right.sc-sdx-arrow .background.sc-sdx-arrow .arrow.sc-sdx-arrow::after{left:0;right:0;transform:rotate(45deg)}/*!@.component .background*/.component.sc-sdx-arrow .background.sc-sdx-arrow{width:10px;display:flex;align-items:center;position:relative}/*!@.component .background .arrow*/.component.sc-sdx-arrow .background.sc-sdx-arrow .arrow.sc-sdx-arrow{position:relative;top:-3px}/*!@.component .background .arrow::before, .component .background .arrow::after*/.component.sc-sdx-arrow .background.sc-sdx-arrow .arrow.sc-sdx-arrow::before,.component.sc-sdx-arrow .background.sc-sdx-arrow .arrow.sc-sdx-arrow::after{position:absolute;top:50%;transition:all 200ms cubic-bezier(0.4, 0, 0.2, 1);border-radius:2px;background:#086adb;width:10px;height:2px;backface-visibility:hidden;content:\"\"}/*!@.component .background .arrow::before*/.component.sc-sdx-arrow .background.sc-sdx-arrow .arrow.sc-sdx-arrow::before{left:0}/*!@.component .background .arrow::after*/.component.sc-sdx-arrow .background.sc-sdx-arrow .arrow.sc-sdx-arrow::after{left:6px}/*!@.component.sdx--dark-theme:hover .background .arrow*/.component.sdx--dark-theme.sc-sdx-arrow:hover .background.sc-sdx-arrow .arrow.sc-sdx-arrow{background:#5ca3ff}/*!@.component.sdx--dark-theme.left*/.component.sdx--dark-theme.left.sc-sdx-arrow{background:linear-gradient(to left, rgba(20, 20, 20, 0), rgba(20, 20, 20, 0.85), rgb(20, 20, 20))}/*!@.component.sdx--dark-theme.right*/.component.sdx--dark-theme.right.sc-sdx-arrow{background:linear-gradient(to right, rgba(20, 20, 20, 0), rgba(20, 20, 20, 0.85), rgb(20, 20, 20))}/*!@.component.sdx--dark-theme .background .arrow*/.component.sdx--dark-theme.sc-sdx-arrow .background.sc-sdx-arrow .arrow.sc-sdx-arrow{background:#4294ff}";

class Arrow {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.direction = "left";
    this.hidden = false;
    this.arrowHidden = false;
    this.animationDuration = 200;
  }
  hiddenChanged() {
    this.animate(this.el, this.hidden ? "fade-out" : "fade-in");
  }
  arrowHiddenChanged() {
    this.animate(this.arrowContainerEl, this.arrowHidden ? "scale-out" : "scale-in");
  }
  componentDidLoad() {
    this.animate(this.el, this.hidden ? "fade-out" : "fade-in");
    this.animate(this.arrowContainerEl, this.arrowHidden ? "scale-out" : "scale-in");
  }
  animate(el, effect) {
    switch (effect) {
      case "fade-in":
        animation.set(el, { display: "block", opacity: 0 });
        animation.start({
          targets: el,
          opacity: 1,
          duration: this.animationDuration,
        });
        break;
      case "fade-out":
        animation.set(el, { opacity: 1 });
        animation.start({
          targets: el,
          opacity: 0,
          duration: this.animationDuration,
          complete: () => animation.set(el, { display: "none" }),
        });
        break;
      case "scale-in":
        animation.set(el, { scale: 0 });
        animation.start({
          targets: el,
          scale: 1,
          duration: this.animationDuration,
        });
        break;
      case "scale-out":
        animation.set(el, { scale: 1 });
        animation.start({
          targets: el,
          scale: 0,
          duration: this.animationDuration,
        });
        break;
    }
  }
  getComponentClassNames() {
    return {
      component: true,
      [this.direction]: true,
      [getAppearance(this.el)]: true,
    };
  }
  render() {
    return (hAsync("div", { class: this.getComponentClassNames() }, hAsync("div", { class: "background", ref: (el) => (this.arrowContainerEl = el) }, hAsync("div", { class: "arrow" }))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "hidden": ["hiddenChanged"],
    "arrowHidden": ["arrowHiddenChanged"]
  }; }
  static get style() { return arrowCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-arrow",
    "$members$": {
      "direction": [1],
      "hidden": [4],
      "arrowHidden": [4, "arrow-hidden"],
      "animationDuration": [2, "animation-duration"]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const backdropCss = "/*!@:root*/.sc-sdx-backdrop:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-backdrop-h,*.sc-sdx-backdrop,*.sc-sdx-backdrop:before,*.sc-sdx-backdrop:after{box-sizing:border-box}@media (min-width: 0){/*!@.flex-xs-first*/.flex-xs-first.sc-sdx-backdrop{order:-1}/*!@.flex-xs-last*/.flex-xs-last.sc-sdx-backdrop{order:1}/*!@.flex-xs-unordered*/.flex-xs-unordered.sc-sdx-backdrop{order:0}/*!@.flex-items-xs-top*/.flex-items-xs-top.sc-sdx-backdrop{align-items:flex-start}/*!@.flex-items-xs-middle*/.flex-items-xs-middle.sc-sdx-backdrop{align-items:center}/*!@.flex-items-xs-bottom*/.flex-items-xs-bottom.sc-sdx-backdrop{align-items:flex-end}/*!@.flex-xs-top*/.flex-xs-top.sc-sdx-backdrop{align-self:flex-start}/*!@.flex-xs-middle*/.flex-xs-middle.sc-sdx-backdrop{align-self:center}/*!@.flex-xs-bottom*/.flex-xs-bottom.sc-sdx-backdrop{align-self:flex-end}/*!@.flex-items-xs-left*/.flex-items-xs-left.sc-sdx-backdrop{justify-content:flex-start}/*!@.flex-items-xs-center*/.flex-items-xs-center.sc-sdx-backdrop{justify-content:center}/*!@.flex-items-xs-right*/.flex-items-xs-right.sc-sdx-backdrop{justify-content:flex-end}/*!@.flex-items-xs-around*/.flex-items-xs-around.sc-sdx-backdrop{justify-content:space-around}/*!@.flex-items-xs-between*/.flex-items-xs-between.sc-sdx-backdrop{justify-content:space-between}}@media (min-width: 480px){/*!@.flex-sm-first*/.flex-sm-first.sc-sdx-backdrop{order:-1}/*!@.flex-sm-last*/.flex-sm-last.sc-sdx-backdrop{order:1}/*!@.flex-sm-unordered*/.flex-sm-unordered.sc-sdx-backdrop{order:0}/*!@.flex-items-sm-top*/.flex-items-sm-top.sc-sdx-backdrop{align-items:flex-start}/*!@.flex-items-sm-middle*/.flex-items-sm-middle.sc-sdx-backdrop{align-items:center}/*!@.flex-items-sm-bottom*/.flex-items-sm-bottom.sc-sdx-backdrop{align-items:flex-end}/*!@.flex-sm-top*/.flex-sm-top.sc-sdx-backdrop{align-self:flex-start}/*!@.flex-sm-middle*/.flex-sm-middle.sc-sdx-backdrop{align-self:center}/*!@.flex-sm-bottom*/.flex-sm-bottom.sc-sdx-backdrop{align-self:flex-end}/*!@.flex-items-sm-left*/.flex-items-sm-left.sc-sdx-backdrop{justify-content:flex-start}/*!@.flex-items-sm-center*/.flex-items-sm-center.sc-sdx-backdrop{justify-content:center}/*!@.flex-items-sm-right*/.flex-items-sm-right.sc-sdx-backdrop{justify-content:flex-end}/*!@.flex-items-sm-around*/.flex-items-sm-around.sc-sdx-backdrop{justify-content:space-around}/*!@.flex-items-sm-between*/.flex-items-sm-between.sc-sdx-backdrop{justify-content:space-between}}@media (min-width: 768px){/*!@.flex-md-first*/.flex-md-first.sc-sdx-backdrop{order:-1}/*!@.flex-md-last*/.flex-md-last.sc-sdx-backdrop{order:1}/*!@.flex-md-unordered*/.flex-md-unordered.sc-sdx-backdrop{order:0}/*!@.flex-items-md-top*/.flex-items-md-top.sc-sdx-backdrop{align-items:flex-start}/*!@.flex-items-md-middle*/.flex-items-md-middle.sc-sdx-backdrop{align-items:center}/*!@.flex-items-md-bottom*/.flex-items-md-bottom.sc-sdx-backdrop{align-items:flex-end}/*!@.flex-md-top*/.flex-md-top.sc-sdx-backdrop{align-self:flex-start}/*!@.flex-md-middle*/.flex-md-middle.sc-sdx-backdrop{align-self:center}/*!@.flex-md-bottom*/.flex-md-bottom.sc-sdx-backdrop{align-self:flex-end}/*!@.flex-items-md-left*/.flex-items-md-left.sc-sdx-backdrop{justify-content:flex-start}/*!@.flex-items-md-center*/.flex-items-md-center.sc-sdx-backdrop{justify-content:center}/*!@.flex-items-md-right*/.flex-items-md-right.sc-sdx-backdrop{justify-content:flex-end}/*!@.flex-items-md-around*/.flex-items-md-around.sc-sdx-backdrop{justify-content:space-around}/*!@.flex-items-md-between*/.flex-items-md-between.sc-sdx-backdrop{justify-content:space-between}}@media (min-width: 1024px){/*!@.flex-lg-first*/.flex-lg-first.sc-sdx-backdrop{order:-1}/*!@.flex-lg-last*/.flex-lg-last.sc-sdx-backdrop{order:1}/*!@.flex-lg-unordered*/.flex-lg-unordered.sc-sdx-backdrop{order:0}/*!@.flex-items-lg-top*/.flex-items-lg-top.sc-sdx-backdrop{align-items:flex-start}/*!@.flex-items-lg-middle*/.flex-items-lg-middle.sc-sdx-backdrop{align-items:center}/*!@.flex-items-lg-bottom*/.flex-items-lg-bottom.sc-sdx-backdrop{align-items:flex-end}/*!@.flex-lg-top*/.flex-lg-top.sc-sdx-backdrop{align-self:flex-start}/*!@.flex-lg-middle*/.flex-lg-middle.sc-sdx-backdrop{align-self:center}/*!@.flex-lg-bottom*/.flex-lg-bottom.sc-sdx-backdrop{align-self:flex-end}/*!@.flex-items-lg-left*/.flex-items-lg-left.sc-sdx-backdrop{justify-content:flex-start}/*!@.flex-items-lg-center*/.flex-items-lg-center.sc-sdx-backdrop{justify-content:center}/*!@.flex-items-lg-right*/.flex-items-lg-right.sc-sdx-backdrop{justify-content:flex-end}/*!@.flex-items-lg-around*/.flex-items-lg-around.sc-sdx-backdrop{justify-content:space-around}/*!@.flex-items-lg-between*/.flex-items-lg-between.sc-sdx-backdrop{justify-content:space-between}}@media (min-width: 1280px){/*!@.flex-xl-first*/.flex-xl-first.sc-sdx-backdrop{order:-1}/*!@.flex-xl-last*/.flex-xl-last.sc-sdx-backdrop{order:1}/*!@.flex-xl-unordered*/.flex-xl-unordered.sc-sdx-backdrop{order:0}/*!@.flex-items-xl-top*/.flex-items-xl-top.sc-sdx-backdrop{align-items:flex-start}/*!@.flex-items-xl-middle*/.flex-items-xl-middle.sc-sdx-backdrop{align-items:center}/*!@.flex-items-xl-bottom*/.flex-items-xl-bottom.sc-sdx-backdrop{align-items:flex-end}/*!@.flex-xl-top*/.flex-xl-top.sc-sdx-backdrop{align-self:flex-start}/*!@.flex-xl-middle*/.flex-xl-middle.sc-sdx-backdrop{align-self:center}/*!@.flex-xl-bottom*/.flex-xl-bottom.sc-sdx-backdrop{align-self:flex-end}/*!@.flex-items-xl-left*/.flex-items-xl-left.sc-sdx-backdrop{justify-content:flex-start}/*!@.flex-items-xl-center*/.flex-items-xl-center.sc-sdx-backdrop{justify-content:center}/*!@.flex-items-xl-right*/.flex-items-xl-right.sc-sdx-backdrop{justify-content:flex-end}/*!@.flex-items-xl-around*/.flex-items-xl-around.sc-sdx-backdrop{justify-content:space-around}/*!@.flex-items-xl-between*/.flex-items-xl-between.sc-sdx-backdrop{justify-content:space-between}}@media (min-width: 1440px){/*!@.flex-ul-first*/.flex-ul-first.sc-sdx-backdrop{order:-1}/*!@.flex-ul-last*/.flex-ul-last.sc-sdx-backdrop{order:1}/*!@.flex-ul-unordered*/.flex-ul-unordered.sc-sdx-backdrop{order:0}/*!@.flex-items-ul-top*/.flex-items-ul-top.sc-sdx-backdrop{align-items:flex-start}/*!@.flex-items-ul-middle*/.flex-items-ul-middle.sc-sdx-backdrop{align-items:center}/*!@.flex-items-ul-bottom*/.flex-items-ul-bottom.sc-sdx-backdrop{align-items:flex-end}/*!@.flex-ul-top*/.flex-ul-top.sc-sdx-backdrop{align-self:flex-start}/*!@.flex-ul-middle*/.flex-ul-middle.sc-sdx-backdrop{align-self:center}/*!@.flex-ul-bottom*/.flex-ul-bottom.sc-sdx-backdrop{align-self:flex-end}/*!@.flex-items-ul-left*/.flex-items-ul-left.sc-sdx-backdrop{justify-content:flex-start}/*!@.flex-items-ul-center*/.flex-items-ul-center.sc-sdx-backdrop{justify-content:center}/*!@.flex-items-ul-right*/.flex-items-ul-right.sc-sdx-backdrop{justify-content:flex-end}/*!@.flex-items-ul-around*/.flex-items-ul-around.sc-sdx-backdrop{justify-content:space-around}/*!@.flex-items-ul-between*/.flex-items-ul-between.sc-sdx-backdrop{justify-content:space-between}}@media (min-width: 0){/*!@.container*/.container.sc-sdx-backdrop{margin-left:calc(24px - 4px);margin-right:calc(24px - 4px);padding-left:4px;padding-right:4px;width:auto}}@media (min-width: 480px){/*!@.container*/.container.sc-sdx-backdrop{margin-left:auto;margin-right:auto;padding-left:4px;padding-right:4px;width:444px}}@media (min-width: 768px){/*!@.container*/.container.sc-sdx-backdrop{margin-left:auto;margin-right:auto;padding-left:8px;padding-right:8px;width:744px}}@media (min-width: 1024px){/*!@.container*/.container.sc-sdx-backdrop{margin-left:auto;margin-right:auto;padding-left:12px;padding-right:12px;width:972px}}@media (min-width: 1280px){/*!@.container*/.container.sc-sdx-backdrop{margin-left:auto;margin-right:auto;padding-left:12px;padding-right:12px;width:1224px}}@media (min-width: 1440px){/*!@.container*/.container.sc-sdx-backdrop{margin-left:auto;margin-right:auto;padding-left:12px;padding-right:12px;width:1380px}}@media (min-width: 0){/*!@.container-fluid*/.container-fluid.sc-sdx-backdrop{margin-left:calc(24px - 4px);margin-right:calc(24px - 4px);padding-left:4px;padding-right:4px;width:auto}}@media (min-width: 0){/*!@.container-page*/.container-page.sc-sdx-backdrop{margin-left:calc(24px - 4px);margin-right:calc(24px - 4px);padding-left:4px;padding-right:4px;width:auto}}@media (min-width: 1440px){/*!@.container-page*/.container-page.sc-sdx-backdrop{margin-left:auto;margin-right:auto;padding-left:12px;padding-right:12px;width:1380px}}/*!@.row*/.row.sc-sdx-backdrop{display:flex;flex-wrap:wrap}@media (min-width: 0){/*!@.row*/.row.sc-sdx-backdrop{margin-left:-4px;margin-right:-4px}}@media (min-width: 480px){/*!@.row*/.row.sc-sdx-backdrop{margin-left:-4px;margin-right:-4px}}@media (min-width: 768px){/*!@.row*/.row.sc-sdx-backdrop{margin-left:-8px;margin-right:-8px}}@media (min-width: 1024px){/*!@.row*/.row.sc-sdx-backdrop{margin-left:-12px;margin-right:-12px}}@media (min-width: 1280px){/*!@.row*/.row.sc-sdx-backdrop{margin-left:-12px;margin-right:-12px}}@media (min-width: 1440px){/*!@.row*/.row.sc-sdx-backdrop{margin-left:-12px;margin-right:-12px}}/*!@.no-gutters*/.no-gutters.sc-sdx-backdrop{margin-right:0;margin-left:0}/*!@.no-gutters > .col,\n.no-gutters > [class*=col-]*/.no-gutters.sc-sdx-backdrop>.col.sc-sdx-backdrop,.no-gutters.sc-sdx-backdrop>[class*=col-].sc-sdx-backdrop{padding-right:0;padding-left:0}/*!@.col,\n[class*=col-]*/.col.sc-sdx-backdrop,[class*=col-].sc-sdx-backdrop{position:relative;width:100%;min-height:1px}@media (min-width: 0){/*!@.col,\n  [class*=col-]*/.col.sc-sdx-backdrop,[class*=col-].sc-sdx-backdrop{padding-left:4px;padding-right:4px}/*!@.col-xs*/.col-xs.sc-sdx-backdrop{flex-grow:1;flex-basis:0;max-width:100%}/*!@.col-xs-auto*/.col-xs-auto.sc-sdx-backdrop{flex:0 0 auto;width:auto}/*!@.col-xs-1*/.col-xs-1.sc-sdx-backdrop{flex:0 0 8.3333333333%;max-width:8.3333333333%}/*!@.col-xs-2*/.col-xs-2.sc-sdx-backdrop{flex:0 0 16.6666666667%;max-width:16.6666666667%}/*!@.col-xs-3*/.col-xs-3.sc-sdx-backdrop{flex:0 0 25%;max-width:25%}/*!@.col-xs-4*/.col-xs-4.sc-sdx-backdrop{flex:0 0 33.3333333333%;max-width:33.3333333333%}/*!@.col-xs-5*/.col-xs-5.sc-sdx-backdrop{flex:0 0 41.6666666667%;max-width:41.6666666667%}/*!@.col-xs-6*/.col-xs-6.sc-sdx-backdrop{flex:0 0 50%;max-width:50%}/*!@.col-xs-7*/.col-xs-7.sc-sdx-backdrop{flex:0 0 58.3333333333%;max-width:58.3333333333%}/*!@.col-xs-8*/.col-xs-8.sc-sdx-backdrop{flex:0 0 66.6666666667%;max-width:66.6666666667%}/*!@.col-xs-9*/.col-xs-9.sc-sdx-backdrop{flex:0 0 75%;max-width:75%}/*!@.col-xs-10*/.col-xs-10.sc-sdx-backdrop{flex:0 0 83.3333333333%;max-width:83.3333333333%}/*!@.col-xs-11*/.col-xs-11.sc-sdx-backdrop{flex:0 0 91.6666666667%;max-width:91.6666666667%}/*!@.col-xs-12*/.col-xs-12.sc-sdx-backdrop{flex:0 0 100%;max-width:100%}/*!@.pull-xs-0*/.pull-xs-0.sc-sdx-backdrop{right:auto}/*!@.pull-xs-1*/.pull-xs-1.sc-sdx-backdrop{right:8.3333333333%}/*!@.pull-xs-2*/.pull-xs-2.sc-sdx-backdrop{right:16.6666666667%}/*!@.pull-xs-3*/.pull-xs-3.sc-sdx-backdrop{right:25%}/*!@.pull-xs-4*/.pull-xs-4.sc-sdx-backdrop{right:33.3333333333%}/*!@.pull-xs-5*/.pull-xs-5.sc-sdx-backdrop{right:41.6666666667%}/*!@.pull-xs-6*/.pull-xs-6.sc-sdx-backdrop{right:50%}/*!@.pull-xs-7*/.pull-xs-7.sc-sdx-backdrop{right:58.3333333333%}/*!@.pull-xs-8*/.pull-xs-8.sc-sdx-backdrop{right:66.6666666667%}/*!@.pull-xs-9*/.pull-xs-9.sc-sdx-backdrop{right:75%}/*!@.pull-xs-10*/.pull-xs-10.sc-sdx-backdrop{right:83.3333333333%}/*!@.pull-xs-11*/.pull-xs-11.sc-sdx-backdrop{right:91.6666666667%}/*!@.pull-xs-12*/.pull-xs-12.sc-sdx-backdrop{right:100%}/*!@.push-xs-0*/.push-xs-0.sc-sdx-backdrop{left:auto}/*!@.push-xs-1*/.push-xs-1.sc-sdx-backdrop{left:8.3333333333%}/*!@.push-xs-2*/.push-xs-2.sc-sdx-backdrop{left:16.6666666667%}/*!@.push-xs-3*/.push-xs-3.sc-sdx-backdrop{left:25%}/*!@.push-xs-4*/.push-xs-4.sc-sdx-backdrop{left:33.3333333333%}/*!@.push-xs-5*/.push-xs-5.sc-sdx-backdrop{left:41.6666666667%}/*!@.push-xs-6*/.push-xs-6.sc-sdx-backdrop{left:50%}/*!@.push-xs-7*/.push-xs-7.sc-sdx-backdrop{left:58.3333333333%}/*!@.push-xs-8*/.push-xs-8.sc-sdx-backdrop{left:66.6666666667%}/*!@.push-xs-9*/.push-xs-9.sc-sdx-backdrop{left:75%}/*!@.push-xs-10*/.push-xs-10.sc-sdx-backdrop{left:83.3333333333%}/*!@.push-xs-11*/.push-xs-11.sc-sdx-backdrop{left:91.6666666667%}/*!@.push-xs-12*/.push-xs-12.sc-sdx-backdrop{left:100%}/*!@.offset-xs-1*/.offset-xs-1.sc-sdx-backdrop{margin-left:8.3333333333%}/*!@.offset-xs-2*/.offset-xs-2.sc-sdx-backdrop{margin-left:16.6666666667%}/*!@.offset-xs-3*/.offset-xs-3.sc-sdx-backdrop{margin-left:25%}/*!@.offset-xs-4*/.offset-xs-4.sc-sdx-backdrop{margin-left:33.3333333333%}/*!@.offset-xs-5*/.offset-xs-5.sc-sdx-backdrop{margin-left:41.6666666667%}/*!@.offset-xs-6*/.offset-xs-6.sc-sdx-backdrop{margin-left:50%}/*!@.offset-xs-7*/.offset-xs-7.sc-sdx-backdrop{margin-left:58.3333333333%}/*!@.offset-xs-8*/.offset-xs-8.sc-sdx-backdrop{margin-left:66.6666666667%}/*!@.offset-xs-9*/.offset-xs-9.sc-sdx-backdrop{margin-left:75%}/*!@.offset-xs-10*/.offset-xs-10.sc-sdx-backdrop{margin-left:83.3333333333%}/*!@.offset-xs-11*/.offset-xs-11.sc-sdx-backdrop{margin-left:91.6666666667%}}@media (min-width: 480px){/*!@.col,\n  [class*=col-]*/.col.sc-sdx-backdrop,[class*=col-].sc-sdx-backdrop{padding-left:4px;padding-right:4px}/*!@.col-sm*/.col-sm.sc-sdx-backdrop{flex-grow:1;flex-basis:0;max-width:100%}/*!@.col-sm-auto*/.col-sm-auto.sc-sdx-backdrop{flex:0 0 auto;width:auto}/*!@.col-sm-1*/.col-sm-1.sc-sdx-backdrop{flex:0 0 8.3333333333%;max-width:8.3333333333%}/*!@.col-sm-2*/.col-sm-2.sc-sdx-backdrop{flex:0 0 16.6666666667%;max-width:16.6666666667%}/*!@.col-sm-3*/.col-sm-3.sc-sdx-backdrop{flex:0 0 25%;max-width:25%}/*!@.col-sm-4*/.col-sm-4.sc-sdx-backdrop{flex:0 0 33.3333333333%;max-width:33.3333333333%}/*!@.col-sm-5*/.col-sm-5.sc-sdx-backdrop{flex:0 0 41.6666666667%;max-width:41.6666666667%}/*!@.col-sm-6*/.col-sm-6.sc-sdx-backdrop{flex:0 0 50%;max-width:50%}/*!@.col-sm-7*/.col-sm-7.sc-sdx-backdrop{flex:0 0 58.3333333333%;max-width:58.3333333333%}/*!@.col-sm-8*/.col-sm-8.sc-sdx-backdrop{flex:0 0 66.6666666667%;max-width:66.6666666667%}/*!@.col-sm-9*/.col-sm-9.sc-sdx-backdrop{flex:0 0 75%;max-width:75%}/*!@.col-sm-10*/.col-sm-10.sc-sdx-backdrop{flex:0 0 83.3333333333%;max-width:83.3333333333%}/*!@.col-sm-11*/.col-sm-11.sc-sdx-backdrop{flex:0 0 91.6666666667%;max-width:91.6666666667%}/*!@.col-sm-12*/.col-sm-12.sc-sdx-backdrop{flex:0 0 100%;max-width:100%}/*!@.pull-sm-0*/.pull-sm-0.sc-sdx-backdrop{right:auto}/*!@.pull-sm-1*/.pull-sm-1.sc-sdx-backdrop{right:8.3333333333%}/*!@.pull-sm-2*/.pull-sm-2.sc-sdx-backdrop{right:16.6666666667%}/*!@.pull-sm-3*/.pull-sm-3.sc-sdx-backdrop{right:25%}/*!@.pull-sm-4*/.pull-sm-4.sc-sdx-backdrop{right:33.3333333333%}/*!@.pull-sm-5*/.pull-sm-5.sc-sdx-backdrop{right:41.6666666667%}/*!@.pull-sm-6*/.pull-sm-6.sc-sdx-backdrop{right:50%}/*!@.pull-sm-7*/.pull-sm-7.sc-sdx-backdrop{right:58.3333333333%}/*!@.pull-sm-8*/.pull-sm-8.sc-sdx-backdrop{right:66.6666666667%}/*!@.pull-sm-9*/.pull-sm-9.sc-sdx-backdrop{right:75%}/*!@.pull-sm-10*/.pull-sm-10.sc-sdx-backdrop{right:83.3333333333%}/*!@.pull-sm-11*/.pull-sm-11.sc-sdx-backdrop{right:91.6666666667%}/*!@.pull-sm-12*/.pull-sm-12.sc-sdx-backdrop{right:100%}/*!@.push-sm-0*/.push-sm-0.sc-sdx-backdrop{left:auto}/*!@.push-sm-1*/.push-sm-1.sc-sdx-backdrop{left:8.3333333333%}/*!@.push-sm-2*/.push-sm-2.sc-sdx-backdrop{left:16.6666666667%}/*!@.push-sm-3*/.push-sm-3.sc-sdx-backdrop{left:25%}/*!@.push-sm-4*/.push-sm-4.sc-sdx-backdrop{left:33.3333333333%}/*!@.push-sm-5*/.push-sm-5.sc-sdx-backdrop{left:41.6666666667%}/*!@.push-sm-6*/.push-sm-6.sc-sdx-backdrop{left:50%}/*!@.push-sm-7*/.push-sm-7.sc-sdx-backdrop{left:58.3333333333%}/*!@.push-sm-8*/.push-sm-8.sc-sdx-backdrop{left:66.6666666667%}/*!@.push-sm-9*/.push-sm-9.sc-sdx-backdrop{left:75%}/*!@.push-sm-10*/.push-sm-10.sc-sdx-backdrop{left:83.3333333333%}/*!@.push-sm-11*/.push-sm-11.sc-sdx-backdrop{left:91.6666666667%}/*!@.push-sm-12*/.push-sm-12.sc-sdx-backdrop{left:100%}/*!@.offset-sm-1*/.offset-sm-1.sc-sdx-backdrop{margin-left:8.3333333333%}/*!@.offset-sm-2*/.offset-sm-2.sc-sdx-backdrop{margin-left:16.6666666667%}/*!@.offset-sm-3*/.offset-sm-3.sc-sdx-backdrop{margin-left:25%}/*!@.offset-sm-4*/.offset-sm-4.sc-sdx-backdrop{margin-left:33.3333333333%}/*!@.offset-sm-5*/.offset-sm-5.sc-sdx-backdrop{margin-left:41.6666666667%}/*!@.offset-sm-6*/.offset-sm-6.sc-sdx-backdrop{margin-left:50%}/*!@.offset-sm-7*/.offset-sm-7.sc-sdx-backdrop{margin-left:58.3333333333%}/*!@.offset-sm-8*/.offset-sm-8.sc-sdx-backdrop{margin-left:66.6666666667%}/*!@.offset-sm-9*/.offset-sm-9.sc-sdx-backdrop{margin-left:75%}/*!@.offset-sm-10*/.offset-sm-10.sc-sdx-backdrop{margin-left:83.3333333333%}/*!@.offset-sm-11*/.offset-sm-11.sc-sdx-backdrop{margin-left:91.6666666667%}}@media (min-width: 768px){/*!@.col,\n  [class*=col-]*/.col.sc-sdx-backdrop,[class*=col-].sc-sdx-backdrop{padding-left:8px;padding-right:8px}/*!@.col-md*/.col-md.sc-sdx-backdrop{flex-grow:1;flex-basis:0;max-width:100%}/*!@.col-md-auto*/.col-md-auto.sc-sdx-backdrop{flex:0 0 auto;width:auto}/*!@.col-md-1*/.col-md-1.sc-sdx-backdrop{flex:0 0 8.3333333333%;max-width:8.3333333333%}/*!@.col-md-2*/.col-md-2.sc-sdx-backdrop{flex:0 0 16.6666666667%;max-width:16.6666666667%}/*!@.col-md-3*/.col-md-3.sc-sdx-backdrop{flex:0 0 25%;max-width:25%}/*!@.col-md-4*/.col-md-4.sc-sdx-backdrop{flex:0 0 33.3333333333%;max-width:33.3333333333%}/*!@.col-md-5*/.col-md-5.sc-sdx-backdrop{flex:0 0 41.6666666667%;max-width:41.6666666667%}/*!@.col-md-6*/.col-md-6.sc-sdx-backdrop{flex:0 0 50%;max-width:50%}/*!@.col-md-7*/.col-md-7.sc-sdx-backdrop{flex:0 0 58.3333333333%;max-width:58.3333333333%}/*!@.col-md-8*/.col-md-8.sc-sdx-backdrop{flex:0 0 66.6666666667%;max-width:66.6666666667%}/*!@.col-md-9*/.col-md-9.sc-sdx-backdrop{flex:0 0 75%;max-width:75%}/*!@.col-md-10*/.col-md-10.sc-sdx-backdrop{flex:0 0 83.3333333333%;max-width:83.3333333333%}/*!@.col-md-11*/.col-md-11.sc-sdx-backdrop{flex:0 0 91.6666666667%;max-width:91.6666666667%}/*!@.col-md-12*/.col-md-12.sc-sdx-backdrop{flex:0 0 100%;max-width:100%}/*!@.pull-md-0*/.pull-md-0.sc-sdx-backdrop{right:auto}/*!@.pull-md-1*/.pull-md-1.sc-sdx-backdrop{right:8.3333333333%}/*!@.pull-md-2*/.pull-md-2.sc-sdx-backdrop{right:16.6666666667%}/*!@.pull-md-3*/.pull-md-3.sc-sdx-backdrop{right:25%}/*!@.pull-md-4*/.pull-md-4.sc-sdx-backdrop{right:33.3333333333%}/*!@.pull-md-5*/.pull-md-5.sc-sdx-backdrop{right:41.6666666667%}/*!@.pull-md-6*/.pull-md-6.sc-sdx-backdrop{right:50%}/*!@.pull-md-7*/.pull-md-7.sc-sdx-backdrop{right:58.3333333333%}/*!@.pull-md-8*/.pull-md-8.sc-sdx-backdrop{right:66.6666666667%}/*!@.pull-md-9*/.pull-md-9.sc-sdx-backdrop{right:75%}/*!@.pull-md-10*/.pull-md-10.sc-sdx-backdrop{right:83.3333333333%}/*!@.pull-md-11*/.pull-md-11.sc-sdx-backdrop{right:91.6666666667%}/*!@.pull-md-12*/.pull-md-12.sc-sdx-backdrop{right:100%}/*!@.push-md-0*/.push-md-0.sc-sdx-backdrop{left:auto}/*!@.push-md-1*/.push-md-1.sc-sdx-backdrop{left:8.3333333333%}/*!@.push-md-2*/.push-md-2.sc-sdx-backdrop{left:16.6666666667%}/*!@.push-md-3*/.push-md-3.sc-sdx-backdrop{left:25%}/*!@.push-md-4*/.push-md-4.sc-sdx-backdrop{left:33.3333333333%}/*!@.push-md-5*/.push-md-5.sc-sdx-backdrop{left:41.6666666667%}/*!@.push-md-6*/.push-md-6.sc-sdx-backdrop{left:50%}/*!@.push-md-7*/.push-md-7.sc-sdx-backdrop{left:58.3333333333%}/*!@.push-md-8*/.push-md-8.sc-sdx-backdrop{left:66.6666666667%}/*!@.push-md-9*/.push-md-9.sc-sdx-backdrop{left:75%}/*!@.push-md-10*/.push-md-10.sc-sdx-backdrop{left:83.3333333333%}/*!@.push-md-11*/.push-md-11.sc-sdx-backdrop{left:91.6666666667%}/*!@.push-md-12*/.push-md-12.sc-sdx-backdrop{left:100%}/*!@.offset-md-1*/.offset-md-1.sc-sdx-backdrop{margin-left:8.3333333333%}/*!@.offset-md-2*/.offset-md-2.sc-sdx-backdrop{margin-left:16.6666666667%}/*!@.offset-md-3*/.offset-md-3.sc-sdx-backdrop{margin-left:25%}/*!@.offset-md-4*/.offset-md-4.sc-sdx-backdrop{margin-left:33.3333333333%}/*!@.offset-md-5*/.offset-md-5.sc-sdx-backdrop{margin-left:41.6666666667%}/*!@.offset-md-6*/.offset-md-6.sc-sdx-backdrop{margin-left:50%}/*!@.offset-md-7*/.offset-md-7.sc-sdx-backdrop{margin-left:58.3333333333%}/*!@.offset-md-8*/.offset-md-8.sc-sdx-backdrop{margin-left:66.6666666667%}/*!@.offset-md-9*/.offset-md-9.sc-sdx-backdrop{margin-left:75%}/*!@.offset-md-10*/.offset-md-10.sc-sdx-backdrop{margin-left:83.3333333333%}/*!@.offset-md-11*/.offset-md-11.sc-sdx-backdrop{margin-left:91.6666666667%}}@media (min-width: 1024px){/*!@.col,\n  [class*=col-]*/.col.sc-sdx-backdrop,[class*=col-].sc-sdx-backdrop{padding-left:12px;padding-right:12px}/*!@.col-lg*/.col-lg.sc-sdx-backdrop{flex-grow:1;flex-basis:0;max-width:100%}/*!@.col-lg-auto*/.col-lg-auto.sc-sdx-backdrop{flex:0 0 auto;width:auto}/*!@.col-lg-1*/.col-lg-1.sc-sdx-backdrop{flex:0 0 8.3333333333%;max-width:8.3333333333%}/*!@.col-lg-2*/.col-lg-2.sc-sdx-backdrop{flex:0 0 16.6666666667%;max-width:16.6666666667%}/*!@.col-lg-3*/.col-lg-3.sc-sdx-backdrop{flex:0 0 25%;max-width:25%}/*!@.col-lg-4*/.col-lg-4.sc-sdx-backdrop{flex:0 0 33.3333333333%;max-width:33.3333333333%}/*!@.col-lg-5*/.col-lg-5.sc-sdx-backdrop{flex:0 0 41.6666666667%;max-width:41.6666666667%}/*!@.col-lg-6*/.col-lg-6.sc-sdx-backdrop{flex:0 0 50%;max-width:50%}/*!@.col-lg-7*/.col-lg-7.sc-sdx-backdrop{flex:0 0 58.3333333333%;max-width:58.3333333333%}/*!@.col-lg-8*/.col-lg-8.sc-sdx-backdrop{flex:0 0 66.6666666667%;max-width:66.6666666667%}/*!@.col-lg-9*/.col-lg-9.sc-sdx-backdrop{flex:0 0 75%;max-width:75%}/*!@.col-lg-10*/.col-lg-10.sc-sdx-backdrop{flex:0 0 83.3333333333%;max-width:83.3333333333%}/*!@.col-lg-11*/.col-lg-11.sc-sdx-backdrop{flex:0 0 91.6666666667%;max-width:91.6666666667%}/*!@.col-lg-12*/.col-lg-12.sc-sdx-backdrop{flex:0 0 100%;max-width:100%}/*!@.pull-lg-0*/.pull-lg-0.sc-sdx-backdrop{right:auto}/*!@.pull-lg-1*/.pull-lg-1.sc-sdx-backdrop{right:8.3333333333%}/*!@.pull-lg-2*/.pull-lg-2.sc-sdx-backdrop{right:16.6666666667%}/*!@.pull-lg-3*/.pull-lg-3.sc-sdx-backdrop{right:25%}/*!@.pull-lg-4*/.pull-lg-4.sc-sdx-backdrop{right:33.3333333333%}/*!@.pull-lg-5*/.pull-lg-5.sc-sdx-backdrop{right:41.6666666667%}/*!@.pull-lg-6*/.pull-lg-6.sc-sdx-backdrop{right:50%}/*!@.pull-lg-7*/.pull-lg-7.sc-sdx-backdrop{right:58.3333333333%}/*!@.pull-lg-8*/.pull-lg-8.sc-sdx-backdrop{right:66.6666666667%}/*!@.pull-lg-9*/.pull-lg-9.sc-sdx-backdrop{right:75%}/*!@.pull-lg-10*/.pull-lg-10.sc-sdx-backdrop{right:83.3333333333%}/*!@.pull-lg-11*/.pull-lg-11.sc-sdx-backdrop{right:91.6666666667%}/*!@.pull-lg-12*/.pull-lg-12.sc-sdx-backdrop{right:100%}/*!@.push-lg-0*/.push-lg-0.sc-sdx-backdrop{left:auto}/*!@.push-lg-1*/.push-lg-1.sc-sdx-backdrop{left:8.3333333333%}/*!@.push-lg-2*/.push-lg-2.sc-sdx-backdrop{left:16.6666666667%}/*!@.push-lg-3*/.push-lg-3.sc-sdx-backdrop{left:25%}/*!@.push-lg-4*/.push-lg-4.sc-sdx-backdrop{left:33.3333333333%}/*!@.push-lg-5*/.push-lg-5.sc-sdx-backdrop{left:41.6666666667%}/*!@.push-lg-6*/.push-lg-6.sc-sdx-backdrop{left:50%}/*!@.push-lg-7*/.push-lg-7.sc-sdx-backdrop{left:58.3333333333%}/*!@.push-lg-8*/.push-lg-8.sc-sdx-backdrop{left:66.6666666667%}/*!@.push-lg-9*/.push-lg-9.sc-sdx-backdrop{left:75%}/*!@.push-lg-10*/.push-lg-10.sc-sdx-backdrop{left:83.3333333333%}/*!@.push-lg-11*/.push-lg-11.sc-sdx-backdrop{left:91.6666666667%}/*!@.push-lg-12*/.push-lg-12.sc-sdx-backdrop{left:100%}/*!@.offset-lg-1*/.offset-lg-1.sc-sdx-backdrop{margin-left:8.3333333333%}/*!@.offset-lg-2*/.offset-lg-2.sc-sdx-backdrop{margin-left:16.6666666667%}/*!@.offset-lg-3*/.offset-lg-3.sc-sdx-backdrop{margin-left:25%}/*!@.offset-lg-4*/.offset-lg-4.sc-sdx-backdrop{margin-left:33.3333333333%}/*!@.offset-lg-5*/.offset-lg-5.sc-sdx-backdrop{margin-left:41.6666666667%}/*!@.offset-lg-6*/.offset-lg-6.sc-sdx-backdrop{margin-left:50%}/*!@.offset-lg-7*/.offset-lg-7.sc-sdx-backdrop{margin-left:58.3333333333%}/*!@.offset-lg-8*/.offset-lg-8.sc-sdx-backdrop{margin-left:66.6666666667%}/*!@.offset-lg-9*/.offset-lg-9.sc-sdx-backdrop{margin-left:75%}/*!@.offset-lg-10*/.offset-lg-10.sc-sdx-backdrop{margin-left:83.3333333333%}/*!@.offset-lg-11*/.offset-lg-11.sc-sdx-backdrop{margin-left:91.6666666667%}}@media (min-width: 1280px){/*!@.col,\n  [class*=col-]*/.col.sc-sdx-backdrop,[class*=col-].sc-sdx-backdrop{padding-left:12px;padding-right:12px}/*!@.col-xl*/.col-xl.sc-sdx-backdrop{flex-grow:1;flex-basis:0;max-width:100%}/*!@.col-xl-auto*/.col-xl-auto.sc-sdx-backdrop{flex:0 0 auto;width:auto}/*!@.col-xl-1*/.col-xl-1.sc-sdx-backdrop{flex:0 0 8.3333333333%;max-width:8.3333333333%}/*!@.col-xl-2*/.col-xl-2.sc-sdx-backdrop{flex:0 0 16.6666666667%;max-width:16.6666666667%}/*!@.col-xl-3*/.col-xl-3.sc-sdx-backdrop{flex:0 0 25%;max-width:25%}/*!@.col-xl-4*/.col-xl-4.sc-sdx-backdrop{flex:0 0 33.3333333333%;max-width:33.3333333333%}/*!@.col-xl-5*/.col-xl-5.sc-sdx-backdrop{flex:0 0 41.6666666667%;max-width:41.6666666667%}/*!@.col-xl-6*/.col-xl-6.sc-sdx-backdrop{flex:0 0 50%;max-width:50%}/*!@.col-xl-7*/.col-xl-7.sc-sdx-backdrop{flex:0 0 58.3333333333%;max-width:58.3333333333%}/*!@.col-xl-8*/.col-xl-8.sc-sdx-backdrop{flex:0 0 66.6666666667%;max-width:66.6666666667%}/*!@.col-xl-9*/.col-xl-9.sc-sdx-backdrop{flex:0 0 75%;max-width:75%}/*!@.col-xl-10*/.col-xl-10.sc-sdx-backdrop{flex:0 0 83.3333333333%;max-width:83.3333333333%}/*!@.col-xl-11*/.col-xl-11.sc-sdx-backdrop{flex:0 0 91.6666666667%;max-width:91.6666666667%}/*!@.col-xl-12*/.col-xl-12.sc-sdx-backdrop{flex:0 0 100%;max-width:100%}/*!@.pull-xl-0*/.pull-xl-0.sc-sdx-backdrop{right:auto}/*!@.pull-xl-1*/.pull-xl-1.sc-sdx-backdrop{right:8.3333333333%}/*!@.pull-xl-2*/.pull-xl-2.sc-sdx-backdrop{right:16.6666666667%}/*!@.pull-xl-3*/.pull-xl-3.sc-sdx-backdrop{right:25%}/*!@.pull-xl-4*/.pull-xl-4.sc-sdx-backdrop{right:33.3333333333%}/*!@.pull-xl-5*/.pull-xl-5.sc-sdx-backdrop{right:41.6666666667%}/*!@.pull-xl-6*/.pull-xl-6.sc-sdx-backdrop{right:50%}/*!@.pull-xl-7*/.pull-xl-7.sc-sdx-backdrop{right:58.3333333333%}/*!@.pull-xl-8*/.pull-xl-8.sc-sdx-backdrop{right:66.6666666667%}/*!@.pull-xl-9*/.pull-xl-9.sc-sdx-backdrop{right:75%}/*!@.pull-xl-10*/.pull-xl-10.sc-sdx-backdrop{right:83.3333333333%}/*!@.pull-xl-11*/.pull-xl-11.sc-sdx-backdrop{right:91.6666666667%}/*!@.pull-xl-12*/.pull-xl-12.sc-sdx-backdrop{right:100%}/*!@.push-xl-0*/.push-xl-0.sc-sdx-backdrop{left:auto}/*!@.push-xl-1*/.push-xl-1.sc-sdx-backdrop{left:8.3333333333%}/*!@.push-xl-2*/.push-xl-2.sc-sdx-backdrop{left:16.6666666667%}/*!@.push-xl-3*/.push-xl-3.sc-sdx-backdrop{left:25%}/*!@.push-xl-4*/.push-xl-4.sc-sdx-backdrop{left:33.3333333333%}/*!@.push-xl-5*/.push-xl-5.sc-sdx-backdrop{left:41.6666666667%}/*!@.push-xl-6*/.push-xl-6.sc-sdx-backdrop{left:50%}/*!@.push-xl-7*/.push-xl-7.sc-sdx-backdrop{left:58.3333333333%}/*!@.push-xl-8*/.push-xl-8.sc-sdx-backdrop{left:66.6666666667%}/*!@.push-xl-9*/.push-xl-9.sc-sdx-backdrop{left:75%}/*!@.push-xl-10*/.push-xl-10.sc-sdx-backdrop{left:83.3333333333%}/*!@.push-xl-11*/.push-xl-11.sc-sdx-backdrop{left:91.6666666667%}/*!@.push-xl-12*/.push-xl-12.sc-sdx-backdrop{left:100%}/*!@.offset-xl-1*/.offset-xl-1.sc-sdx-backdrop{margin-left:8.3333333333%}/*!@.offset-xl-2*/.offset-xl-2.sc-sdx-backdrop{margin-left:16.6666666667%}/*!@.offset-xl-3*/.offset-xl-3.sc-sdx-backdrop{margin-left:25%}/*!@.offset-xl-4*/.offset-xl-4.sc-sdx-backdrop{margin-left:33.3333333333%}/*!@.offset-xl-5*/.offset-xl-5.sc-sdx-backdrop{margin-left:41.6666666667%}/*!@.offset-xl-6*/.offset-xl-6.sc-sdx-backdrop{margin-left:50%}/*!@.offset-xl-7*/.offset-xl-7.sc-sdx-backdrop{margin-left:58.3333333333%}/*!@.offset-xl-8*/.offset-xl-8.sc-sdx-backdrop{margin-left:66.6666666667%}/*!@.offset-xl-9*/.offset-xl-9.sc-sdx-backdrop{margin-left:75%}/*!@.offset-xl-10*/.offset-xl-10.sc-sdx-backdrop{margin-left:83.3333333333%}/*!@.offset-xl-11*/.offset-xl-11.sc-sdx-backdrop{margin-left:91.6666666667%}}@media (min-width: 1440px){/*!@.col,\n  [class*=col-]*/.col.sc-sdx-backdrop,[class*=col-].sc-sdx-backdrop{padding-left:12px;padding-right:12px}/*!@.col-ul*/.col-ul.sc-sdx-backdrop{flex-grow:1;flex-basis:0;max-width:100%}/*!@.col-ul-auto*/.col-ul-auto.sc-sdx-backdrop{flex:0 0 auto;width:auto}/*!@.col-ul-1*/.col-ul-1.sc-sdx-backdrop{flex:0 0 8.3333333333%;max-width:8.3333333333%}/*!@.col-ul-2*/.col-ul-2.sc-sdx-backdrop{flex:0 0 16.6666666667%;max-width:16.6666666667%}/*!@.col-ul-3*/.col-ul-3.sc-sdx-backdrop{flex:0 0 25%;max-width:25%}/*!@.col-ul-4*/.col-ul-4.sc-sdx-backdrop{flex:0 0 33.3333333333%;max-width:33.3333333333%}/*!@.col-ul-5*/.col-ul-5.sc-sdx-backdrop{flex:0 0 41.6666666667%;max-width:41.6666666667%}/*!@.col-ul-6*/.col-ul-6.sc-sdx-backdrop{flex:0 0 50%;max-width:50%}/*!@.col-ul-7*/.col-ul-7.sc-sdx-backdrop{flex:0 0 58.3333333333%;max-width:58.3333333333%}/*!@.col-ul-8*/.col-ul-8.sc-sdx-backdrop{flex:0 0 66.6666666667%;max-width:66.6666666667%}/*!@.col-ul-9*/.col-ul-9.sc-sdx-backdrop{flex:0 0 75%;max-width:75%}/*!@.col-ul-10*/.col-ul-10.sc-sdx-backdrop{flex:0 0 83.3333333333%;max-width:83.3333333333%}/*!@.col-ul-11*/.col-ul-11.sc-sdx-backdrop{flex:0 0 91.6666666667%;max-width:91.6666666667%}/*!@.col-ul-12*/.col-ul-12.sc-sdx-backdrop{flex:0 0 100%;max-width:100%}/*!@.pull-ul-0*/.pull-ul-0.sc-sdx-backdrop{right:auto}/*!@.pull-ul-1*/.pull-ul-1.sc-sdx-backdrop{right:8.3333333333%}/*!@.pull-ul-2*/.pull-ul-2.sc-sdx-backdrop{right:16.6666666667%}/*!@.pull-ul-3*/.pull-ul-3.sc-sdx-backdrop{right:25%}/*!@.pull-ul-4*/.pull-ul-4.sc-sdx-backdrop{right:33.3333333333%}/*!@.pull-ul-5*/.pull-ul-5.sc-sdx-backdrop{right:41.6666666667%}/*!@.pull-ul-6*/.pull-ul-6.sc-sdx-backdrop{right:50%}/*!@.pull-ul-7*/.pull-ul-7.sc-sdx-backdrop{right:58.3333333333%}/*!@.pull-ul-8*/.pull-ul-8.sc-sdx-backdrop{right:66.6666666667%}/*!@.pull-ul-9*/.pull-ul-9.sc-sdx-backdrop{right:75%}/*!@.pull-ul-10*/.pull-ul-10.sc-sdx-backdrop{right:83.3333333333%}/*!@.pull-ul-11*/.pull-ul-11.sc-sdx-backdrop{right:91.6666666667%}/*!@.pull-ul-12*/.pull-ul-12.sc-sdx-backdrop{right:100%}/*!@.push-ul-0*/.push-ul-0.sc-sdx-backdrop{left:auto}/*!@.push-ul-1*/.push-ul-1.sc-sdx-backdrop{left:8.3333333333%}/*!@.push-ul-2*/.push-ul-2.sc-sdx-backdrop{left:16.6666666667%}/*!@.push-ul-3*/.push-ul-3.sc-sdx-backdrop{left:25%}/*!@.push-ul-4*/.push-ul-4.sc-sdx-backdrop{left:33.3333333333%}/*!@.push-ul-5*/.push-ul-5.sc-sdx-backdrop{left:41.6666666667%}/*!@.push-ul-6*/.push-ul-6.sc-sdx-backdrop{left:50%}/*!@.push-ul-7*/.push-ul-7.sc-sdx-backdrop{left:58.3333333333%}/*!@.push-ul-8*/.push-ul-8.sc-sdx-backdrop{left:66.6666666667%}/*!@.push-ul-9*/.push-ul-9.sc-sdx-backdrop{left:75%}/*!@.push-ul-10*/.push-ul-10.sc-sdx-backdrop{left:83.3333333333%}/*!@.push-ul-11*/.push-ul-11.sc-sdx-backdrop{left:91.6666666667%}/*!@.push-ul-12*/.push-ul-12.sc-sdx-backdrop{left:100%}/*!@.offset-ul-1*/.offset-ul-1.sc-sdx-backdrop{margin-left:8.3333333333%}/*!@.offset-ul-2*/.offset-ul-2.sc-sdx-backdrop{margin-left:16.6666666667%}/*!@.offset-ul-3*/.offset-ul-3.sc-sdx-backdrop{margin-left:25%}/*!@.offset-ul-4*/.offset-ul-4.sc-sdx-backdrop{margin-left:33.3333333333%}/*!@.offset-ul-5*/.offset-ul-5.sc-sdx-backdrop{margin-left:41.6666666667%}/*!@.offset-ul-6*/.offset-ul-6.sc-sdx-backdrop{margin-left:50%}/*!@.offset-ul-7*/.offset-ul-7.sc-sdx-backdrop{margin-left:58.3333333333%}/*!@.offset-ul-8*/.offset-ul-8.sc-sdx-backdrop{margin-left:66.6666666667%}/*!@.offset-ul-9*/.offset-ul-9.sc-sdx-backdrop{margin-left:75%}/*!@.offset-ul-10*/.offset-ul-10.sc-sdx-backdrop{margin-left:83.3333333333%}/*!@.offset-ul-11*/.offset-ul-11.sc-sdx-backdrop{margin-left:91.6666666667%}}/*!@:host*/.sc-sdx-backdrop-h{display:none;position:fixed;top:0;left:0;height:100vh;width:100vw;z-index:999998;-webkit-backdrop-filter:blur(4px) brightness(50%)}/*!@.component*/.component.sc-sdx-backdrop{height:var(--sdx-dialog-window-inner-height, 100%)}/*!@.component .background*/.component.sc-sdx-backdrop .background.sc-sdx-backdrop{position:absolute;height:100%;width:100%}/*!@.component .slot*/.component.sc-sdx-backdrop .slot.sc-sdx-backdrop{position:relative;height:100%}";

class Backdrop {
  constructor(hostRef) {
    registerInstance(this, hostRef);
  }
  getComponentClassNames() {
    return {
      component: true,
      [getAppearance(this.el)]: true,
    };
  }
  render() {
    return (hAsync("div", { class: this.getComponentClassNames() }, hAsync("div", { class: "background" }), hAsync("div", { class: "slot row no-gutters flex-items-xs-center flex-items-xs-bottom flex-items-sm-middle" }, hAsync("slot", null))));
  }
  get el() { return getElement(this); }
  static get style() { return backdropCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-backdrop",
    "$members$": undefined,
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const buttonCss = "/*!@:root*/.sc-sdx-button:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-button-h,*.sc-sdx-button,*.sc-sdx-button:before,*.sc-sdx-button:after{box-sizing:border-box}/*!@.sr-only*/.sr-only.sc-sdx-button{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);border:0}/*!@.sr-only-focusable:active, .component:active button.sr-only-focusable.chip, .sr-only-focusable:focus*/.sr-only-focusable.sc-sdx-button:active,.component.sc-sdx-button:active button.sr-only-focusable.chip.sc-sdx-button,.sr-only-focusable.sc-sdx-button:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}/*!@.button-reset*/.button-reset.sc-sdx-button{font-family:TheSans, sans-serif;font-weight:500;line-height:24px;letter-spacing:-0.1px;font-size:18px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;vertical-align:middle;text-decoration:none;text-align:center;color:inherit;margin:0;cursor:pointer;transition:all 70ms cubic-bezier(0.4, 0, 0.6, 1);-webkit-tap-highlight-color:transparent}/*!@.button-reset:focus*/.button-reset.sc-sdx-button:focus{outline:0}/*!@.button-reset::-moz-focus-inner*/.button-reset.sc-sdx-button::-moz-focus-inner{border:0}/*!@:host*/.sc-sdx-button-h{display:inline-block;outline:none;width:auto;min-width:160px}/*!@:host(.chip)*/.chip.sc-sdx-button-h{min-width:48px;cursor:pointer}/*!@:host(.chip) .component*/.chip.sc-sdx-button-h .component.sc-sdx-button{height:48px}/*!@:host(.transparent)*/.transparent.sc-sdx-button-h{min-width:0;color:#086adb}/*!@:host(.disabled),\n:host(.loading)*/.disabled.sc-sdx-button-h,.loading.sc-sdx-button-h{pointer-events:none}/*!@:host(.disabled) .component.disabled, :host(.disabled) .component:disabled,\n:host(.loading) .component.disabled,\n:host(.loading) .component:disabled*/.disabled.sc-sdx-button-h .component.disabled.sc-sdx-button,.disabled.sc-sdx-button-h .component.sc-sdx-button:disabled,.loading.sc-sdx-button-h .component.disabled.sc-sdx-button,.loading.sc-sdx-button-h .component.sc-sdx-button:disabled{cursor:not-allowed}/*!@:host(.disabled) .component.disabled:active, :host(.disabled) .component:active button.component.disabled.chip, :host(.disabled) .component:disabled:active, :host(.disabled) .component:active button.component.chip:disabled,\n:host(.loading) .component.disabled:active,\n:host(.loading) .component:active button.component.disabled.chip,\n:host(.loading) .component:disabled:active,\n:host(.loading) .component:active button.component.chip:disabled*/.disabled.sc-sdx-button-h .component.disabled.sc-sdx-button:active,.disabled.sc-sdx-button-h .component.sc-sdx-button:active button.component.disabled.chip.sc-sdx-button,.disabled.sc-sdx-button-h .component.sc-sdx-button:disabled:active,.disabled.sc-sdx-button-h .component.sc-sdx-button:active button.component.chip.sc-sdx-button:disabled,.loading.sc-sdx-button-h .component.disabled.sc-sdx-button:active,.loading.sc-sdx-button-h .component.sc-sdx-button:active button.component.disabled.chip.sc-sdx-button,.loading.sc-sdx-button-h .component.sc-sdx-button:disabled:active,.loading.sc-sdx-button-h .component.sc-sdx-button:active button.component.chip.sc-sdx-button:disabled{pointer-events:none;transform:none}/*!@:host(.loading) .icon,\n:host(.loading) .label*/.loading.sc-sdx-button-h .icon.sc-sdx-button,.loading.sc-sdx-button-h .label.sc-sdx-button{visibility:hidden}/*!@.component*/.component.sc-sdx-button{position:relative;display:flex;align-items:center;justify-content:center}/*!@.component:hover .badge, .component:hover button.component.chip .badge*/.component.sc-sdx-button:hover .badge.sc-sdx-button,.component.sc-sdx-button:hover button.component.chip.sc-sdx-button .badge.sc-sdx-button{background:#ba3e06}/*!@.component .badge*/.component.sc-sdx-button .badge.sc-sdx-button{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-weight:600;border-radius:18px;color:#fff;font-size:13px;height:18px;line-height:18px;min-width:18px;max-width:50px;text-align:center;padding:0 5px;user-select:none;animation:badge 300ms linear both;background:#cf4a0c;pointer-events:none;transition:background 70ms cubic-bezier(0.4, 0, 0.6, 1);position:absolute;bottom:calc(100% - 13px);left:calc(100% - 9px)}@keyframes badge{0%{transform:scale(1)}25%{transform:scale(1.15)}50%{transform:scale(1)}75%{transform:scale(0.85)}100%{transform:scale(1)}}/*!@.component .clickable*/.component.sc-sdx-button .clickable.sc-sdx-button{display:flex;justify-content:center;align-items:center}/*!@.component .clickable .icon + .label*/.component.sc-sdx-button .clickable.sc-sdx-button .icon.sc-sdx-button+.label.sc-sdx-button{margin-left:8px}/*!@.primary,\n.secondary,\n.confirm,\n.cancel,\n.chip*/.primary.sc-sdx-button,.secondary.sc-sdx-button,.confirm.sc-sdx-button,.cancel.sc-sdx-button,.chip.sc-sdx-button{width:100%;height:48px;margin:0;padding:0 23px;border:1px solid #086adb;border-radius:5px;background-color:transparent;outline:none;user-select:none;transform-origin:50% 50%}/*!@.primary:active,\n.secondary:active,\n.confirm:active,\n.cancel:active,\n.chip:active,\n.component:active button.chip*/.primary.sc-sdx-button:active,.secondary.sc-sdx-button:active,.confirm.sc-sdx-button:active,.cancel.sc-sdx-button:active,.chip.sc-sdx-button:active,.component.sc-sdx-button:active button.chip.sc-sdx-button{transform:scale(0.98)}/*!@.primary*/.primary.sc-sdx-button{border-color:#086adb;background-color:#086adb;color:#fff}/*!@.primary:focus, .primary:active, .component:active button.primary.chip*/.primary.sc-sdx-button:focus,.primary.sc-sdx-button:active,.component.sc-sdx-button:active button.primary.chip.sc-sdx-button{border-color:#0048cf;background-color:#0048cf}@media (hover: hover){/*!@.primary:hover, .component:hover button.primary.chip*/.primary.sc-sdx-button:hover,.component.sc-sdx-button:hover button.primary.chip.sc-sdx-button{border-color:#0048cf;background-color:#0048cf}}/*!@.primary.disabled*/.primary.disabled.sc-sdx-button{border-color:transparent;background-color:rgba(8, 106, 219, 0.4);color:rgba(255, 255, 255, 0.6)}/*!@.secondary*/.secondary.sc-sdx-button{border-color:#086adb;background-color:#fff;color:#086adb}/*!@.secondary:focus, .secondary:active, .component:active button.secondary.chip*/.secondary.sc-sdx-button:focus,.secondary.sc-sdx-button:active,.component.sc-sdx-button:active button.secondary.chip.sc-sdx-button{border-color:#0048cf;background-color:#d1e6f9;color:#0048cf}@media (hover: hover){/*!@.secondary:hover, .component:hover button.secondary.chip*/.secondary.sc-sdx-button:hover,.component.sc-sdx-button:hover button.secondary.chip.sc-sdx-button{border-color:#0048cf;background-color:#d1e6f9;color:#0048cf}}/*!@.secondary.disabled*/.secondary.disabled.sc-sdx-button{border-color:rgba(8, 106, 219, 0.4);background-color:rgba(255, 255, 255, 0.4);color:rgba(8, 106, 219, 0.4)}/*!@.confirm*/.confirm.sc-sdx-button{border-color:#1b8712;background-color:#1b8712;color:#fff}/*!@.confirm:focus, .confirm:active, .component:active button.confirm.chip*/.confirm.sc-sdx-button:focus,.confirm.sc-sdx-button:active,.component.sc-sdx-button:active button.confirm.chip.sc-sdx-button{border-color:#0d6f2c;background-color:#0d6f2c}@media (hover: hover){/*!@.confirm:hover, .component:hover button.confirm.chip*/.confirm.sc-sdx-button:hover,.component.sc-sdx-button:hover button.confirm.chip.sc-sdx-button{border-color:#0d6f2c;background-color:#0d6f2c}}/*!@.confirm.disabled*/.confirm.disabled.sc-sdx-button{border-color:transparent;background-color:rgba(27, 135, 18, 0.4)}/*!@.transparent*/.transparent.sc-sdx-button{padding:0;margin:0;border:none;outline:none;user-select:none;background-color:transparent;color:inherit}/*!@.transparent.invalid*/.transparent.invalid.sc-sdx-button{color:#d12}/*!@.transparent:focus, .transparent:active, .component:active button.transparent.chip*/.transparent.sc-sdx-button:focus,.transparent.sc-sdx-button:active,.component.sc-sdx-button:active button.transparent.chip.sc-sdx-button{color:#0048cf}/*!@.transparent:focus.invalid, .transparent:active.invalid, .component:active button.transparent.invalid.chip*/.transparent.sc-sdx-button:focus.invalid,.transparent.sc-sdx-button:active.invalid,.component.sc-sdx-button:active button.transparent.invalid.chip.sc-sdx-button{color:#be0000}@media (hover: hover){/*!@.transparent:hover, .component:hover button.transparent.chip*/.transparent.sc-sdx-button:hover,.component.sc-sdx-button:hover button.transparent.chip.sc-sdx-button{color:#0048cf}/*!@.transparent:hover.invalid, .component:hover button.transparent.invalid.chip*/.transparent.sc-sdx-button:hover.invalid,.component.sc-sdx-button:hover button.transparent.invalid.chip.sc-sdx-button{color:#be0000}}/*!@.transparent.disabled, .transparent.disabled.invalid*/.transparent.disabled.sc-sdx-button,.transparent.disabled.invalid.sc-sdx-button{color:rgba(51, 51, 51, 0.4)}/*!@.cancel*/.cancel.sc-sdx-button{border-color:transparent;background-color:transparent;color:#086adb}/*!@.cancel:focus, .cancel:active, .component:active button.cancel.chip*/.cancel.sc-sdx-button:focus,.cancel.sc-sdx-button:active,.component.sc-sdx-button:active button.cancel.chip.sc-sdx-button{border-color:#d1e6f9;background-color:#d1e6f9;color:#0048cf}@media (hover: hover){/*!@.cancel:hover, .component:hover button.cancel.chip*/.cancel.sc-sdx-button:hover,.component.sc-sdx-button:hover button.cancel.chip.sc-sdx-button{border-color:#d1e6f9;background-color:#d1e6f9;color:#0048cf}}/*!@.chip*/.chip.sc-sdx-button{font-weight:400;font-size:16px;border-color:#dde3e7;background-color:#dde3e7;width:auto;height:32px;padding:10px}/*!@.chip:focus, .chip:active, .component:active button.chip*/.chip.sc-sdx-button:focus,.chip.sc-sdx-button:active,.component.sc-sdx-button:active button.chip.sc-sdx-button{border-color:#b1b9be;background-color:#b1b9be}@media (hover: hover){/*!@.chip:hover, .component:hover button.chip*/.chip.sc-sdx-button:hover,.component.sc-sdx-button:hover button.chip.sc-sdx-button{border-color:#b1b9be;background-color:#b1b9be}}/*!@.chip .label ~ .icon*/.chip.sc-sdx-button .label.sc-sdx-button~.icon.sc-sdx-button{margin-left:8px}/*!@.loading-spinner-container*/.loading-spinner-container.sc-sdx-button{position:absolute;left:0;right:0;display:flex;justify-content:center}/*!@.h4*/.h4.sc-sdx-button{line-height:24px;letter-spacing:-0.1px;font-size:20px}@media (min-width: 1024px){/*!@.h4*/.h4.sc-sdx-button{line-height:32px;letter-spacing:-0.35px;font-size:24px}}/*!@:host(.sdx--dark-theme) .primary.no-background, :host(.sdx--dark-theme) .primary.no-background.invalid,\n:host(.sdx--dark-theme) .secondary.no-background,\n:host(.sdx--dark-theme) .secondary.no-background.invalid,\n:host(.sdx--dark-theme) .confirm.no-background,\n:host(.sdx--dark-theme) .confirm.no-background.invalid,\n:host(.sdx--dark-theme) .transparent.no-background,\n:host(.sdx--dark-theme) .transparent.no-background.invalid,\n:host(.sdx--light-theme) .primary.no-background,\n:host(.sdx--light-theme) .primary.no-background.invalid,\n:host(.sdx--light-theme) .secondary.no-background,\n:host(.sdx--light-theme) .secondary.no-background.invalid,\n:host(.sdx--light-theme) .confirm.no-background,\n:host(.sdx--light-theme) .confirm.no-background.invalid,\n:host(.sdx--light-theme) .transparent.no-background,\n:host(.sdx--light-theme) .transparent.no-background.invalid*/.sdx--dark-theme.sc-sdx-button-h .primary.no-background.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .primary.no-background.invalid.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .secondary.no-background.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .secondary.no-background.invalid.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .confirm.no-background.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .confirm.no-background.invalid.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .transparent.no-background.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .transparent.no-background.invalid.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .primary.no-background.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .primary.no-background.invalid.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .secondary.no-background.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .secondary.no-background.invalid.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .confirm.no-background.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .confirm.no-background.invalid.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .transparent.no-background.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .transparent.no-background.invalid.sc-sdx-button{border-color:#fff;background-color:transparent;color:#fff}/*!@:host(.sdx--dark-theme) .primary.no-background:focus, :host(.sdx--dark-theme) .primary.no-background:active, :host(.sdx--dark-theme) .component:active button.primary.no-background.chip, :host(.sdx--dark-theme) .primary.no-background.invalid:focus, :host(.sdx--dark-theme) .primary.no-background.invalid:active,\n:host(.sdx--dark-theme) .secondary.no-background:focus,\n:host(.sdx--dark-theme) .secondary.no-background:active,\n:host(.sdx--dark-theme) .component:active button.secondary.no-background.chip,\n:host(.sdx--dark-theme) .secondary.no-background.invalid:focus,\n:host(.sdx--dark-theme) .secondary.no-background.invalid:active,\n:host(.sdx--dark-theme) .confirm.no-background:focus,\n:host(.sdx--dark-theme) .confirm.no-background:active,\n:host(.sdx--dark-theme) .component:active button.confirm.no-background.chip,\n:host(.sdx--dark-theme) .confirm.no-background.invalid:focus,\n:host(.sdx--dark-theme) .confirm.no-background.invalid:active,\n:host(.sdx--dark-theme) .transparent.no-background:focus,\n:host(.sdx--dark-theme) .transparent.no-background:active,\n:host(.sdx--dark-theme) .component:active button.transparent.no-background.chip,\n:host(.sdx--dark-theme) .transparent.no-background.invalid:focus,\n:host(.sdx--dark-theme) .transparent.no-background.invalid:active,\n:host(.sdx--light-theme) .primary.no-background:focus,\n:host(.sdx--light-theme) .primary.no-background:active,\n:host(.sdx--light-theme) .component:active button.primary.no-background.chip,\n:host(.sdx--light-theme) .primary.no-background.invalid:focus,\n:host(.sdx--light-theme) .primary.no-background.invalid:active,\n:host(.sdx--light-theme) .secondary.no-background:focus,\n:host(.sdx--light-theme) .secondary.no-background:active,\n:host(.sdx--light-theme) .component:active button.secondary.no-background.chip,\n:host(.sdx--light-theme) .secondary.no-background.invalid:focus,\n:host(.sdx--light-theme) .secondary.no-background.invalid:active,\n:host(.sdx--light-theme) .confirm.no-background:focus,\n:host(.sdx--light-theme) .confirm.no-background:active,\n:host(.sdx--light-theme) .component:active button.confirm.no-background.chip,\n:host(.sdx--light-theme) .confirm.no-background.invalid:focus,\n:host(.sdx--light-theme) .confirm.no-background.invalid:active,\n:host(.sdx--light-theme) .transparent.no-background:focus,\n:host(.sdx--light-theme) .transparent.no-background:active,\n:host(.sdx--light-theme) .component:active button.transparent.no-background.chip,\n:host(.sdx--light-theme) .transparent.no-background.invalid:focus,\n:host(.sdx--light-theme) .transparent.no-background.invalid:active*/.sdx--dark-theme.sc-sdx-button-h .primary.no-background.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .primary.no-background.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:active button.primary.no-background.chip.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .primary.no-background.invalid.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .primary.no-background.invalid.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .secondary.no-background.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .secondary.no-background.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:active button.secondary.no-background.chip.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .secondary.no-background.invalid.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .secondary.no-background.invalid.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .confirm.no-background.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .confirm.no-background.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:active button.confirm.no-background.chip.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .confirm.no-background.invalid.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .confirm.no-background.invalid.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .transparent.no-background.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .transparent.no-background.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:active button.transparent.no-background.chip.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .transparent.no-background.invalid.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .transparent.no-background.invalid.sc-sdx-button:active,.sdx--light-theme.sc-sdx-button-h .primary.no-background.sc-sdx-button:focus,.sdx--light-theme.sc-sdx-button-h .primary.no-background.sc-sdx-button:active,.sdx--light-theme.sc-sdx-button-h .component.sc-sdx-button:active button.primary.no-background.chip.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .primary.no-background.invalid.sc-sdx-button:focus,.sdx--light-theme.sc-sdx-button-h .primary.no-background.invalid.sc-sdx-button:active,.sdx--light-theme.sc-sdx-button-h .secondary.no-background.sc-sdx-button:focus,.sdx--light-theme.sc-sdx-button-h .secondary.no-background.sc-sdx-button:active,.sdx--light-theme.sc-sdx-button-h .component.sc-sdx-button:active button.secondary.no-background.chip.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .secondary.no-background.invalid.sc-sdx-button:focus,.sdx--light-theme.sc-sdx-button-h .secondary.no-background.invalid.sc-sdx-button:active,.sdx--light-theme.sc-sdx-button-h .confirm.no-background.sc-sdx-button:focus,.sdx--light-theme.sc-sdx-button-h .confirm.no-background.sc-sdx-button:active,.sdx--light-theme.sc-sdx-button-h .component.sc-sdx-button:active button.confirm.no-background.chip.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .confirm.no-background.invalid.sc-sdx-button:focus,.sdx--light-theme.sc-sdx-button-h .confirm.no-background.invalid.sc-sdx-button:active,.sdx--light-theme.sc-sdx-button-h .transparent.no-background.sc-sdx-button:focus,.sdx--light-theme.sc-sdx-button-h .transparent.no-background.sc-sdx-button:active,.sdx--light-theme.sc-sdx-button-h .component.sc-sdx-button:active button.transparent.no-background.chip.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .transparent.no-background.invalid.sc-sdx-button:focus,.sdx--light-theme.sc-sdx-button-h .transparent.no-background.invalid.sc-sdx-button:active{background-color:rgba(255, 255, 255, 0.15)}@media (hover: hover){/*!@:host(.sdx--dark-theme) .primary.no-background:hover, :host(.sdx--dark-theme) .component:hover button.primary.no-background.chip, :host(.sdx--dark-theme) .primary.no-background.invalid:hover,\n  :host(.sdx--dark-theme) .secondary.no-background:hover,\n  :host(.sdx--dark-theme) .component:hover button.secondary.no-background.chip,\n  :host(.sdx--dark-theme) .secondary.no-background.invalid:hover,\n  :host(.sdx--dark-theme) .confirm.no-background:hover,\n  :host(.sdx--dark-theme) .component:hover button.confirm.no-background.chip,\n  :host(.sdx--dark-theme) .confirm.no-background.invalid:hover,\n  :host(.sdx--dark-theme) .transparent.no-background:hover,\n  :host(.sdx--dark-theme) .component:hover button.transparent.no-background.chip,\n  :host(.sdx--dark-theme) .transparent.no-background.invalid:hover,\n  :host(.sdx--light-theme) .primary.no-background:hover,\n  :host(.sdx--light-theme) .component:hover button.primary.no-background.chip,\n  :host(.sdx--light-theme) .primary.no-background.invalid:hover,\n  :host(.sdx--light-theme) .secondary.no-background:hover,\n  :host(.sdx--light-theme) .component:hover button.secondary.no-background.chip,\n  :host(.sdx--light-theme) .secondary.no-background.invalid:hover,\n  :host(.sdx--light-theme) .confirm.no-background:hover,\n  :host(.sdx--light-theme) .component:hover button.confirm.no-background.chip,\n  :host(.sdx--light-theme) .confirm.no-background.invalid:hover,\n  :host(.sdx--light-theme) .transparent.no-background:hover,\n  :host(.sdx--light-theme) .component:hover button.transparent.no-background.chip,\n  :host(.sdx--light-theme) .transparent.no-background.invalid:hover*/.sdx--dark-theme.sc-sdx-button-h .primary.no-background.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.primary.no-background.chip.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .primary.no-background.invalid.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .secondary.no-background.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.secondary.no-background.chip.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .secondary.no-background.invalid.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .confirm.no-background.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.confirm.no-background.chip.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .confirm.no-background.invalid.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .transparent.no-background.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.transparent.no-background.chip.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .transparent.no-background.invalid.sc-sdx-button:hover,.sdx--light-theme.sc-sdx-button-h .primary.no-background.sc-sdx-button:hover,.sdx--light-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.primary.no-background.chip.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .primary.no-background.invalid.sc-sdx-button:hover,.sdx--light-theme.sc-sdx-button-h .secondary.no-background.sc-sdx-button:hover,.sdx--light-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.secondary.no-background.chip.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .secondary.no-background.invalid.sc-sdx-button:hover,.sdx--light-theme.sc-sdx-button-h .confirm.no-background.sc-sdx-button:hover,.sdx--light-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.confirm.no-background.chip.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .confirm.no-background.invalid.sc-sdx-button:hover,.sdx--light-theme.sc-sdx-button-h .transparent.no-background.sc-sdx-button:hover,.sdx--light-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.transparent.no-background.chip.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .transparent.no-background.invalid.sc-sdx-button:hover{background-color:rgba(255, 255, 255, 0.15)}}/*!@:host(.sdx--dark-theme) .primary.no-background.disabled, :host(.sdx--dark-theme) .primary.no-background.invalid.disabled,\n:host(.sdx--dark-theme) .secondary.no-background.disabled,\n:host(.sdx--dark-theme) .secondary.no-background.invalid.disabled,\n:host(.sdx--dark-theme) .confirm.no-background.disabled,\n:host(.sdx--dark-theme) .confirm.no-background.invalid.disabled,\n:host(.sdx--dark-theme) .transparent.no-background.disabled,\n:host(.sdx--dark-theme) .transparent.no-background.invalid.disabled,\n:host(.sdx--light-theme) .primary.no-background.disabled,\n:host(.sdx--light-theme) .primary.no-background.invalid.disabled,\n:host(.sdx--light-theme) .secondary.no-background.disabled,\n:host(.sdx--light-theme) .secondary.no-background.invalid.disabled,\n:host(.sdx--light-theme) .confirm.no-background.disabled,\n:host(.sdx--light-theme) .confirm.no-background.invalid.disabled,\n:host(.sdx--light-theme) .transparent.no-background.disabled,\n:host(.sdx--light-theme) .transparent.no-background.invalid.disabled*/.sdx--dark-theme.sc-sdx-button-h .primary.no-background.disabled.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .primary.no-background.invalid.disabled.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .secondary.no-background.disabled.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .secondary.no-background.invalid.disabled.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .confirm.no-background.disabled.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .confirm.no-background.invalid.disabled.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .transparent.no-background.disabled.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .transparent.no-background.invalid.disabled.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .primary.no-background.disabled.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .primary.no-background.invalid.disabled.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .secondary.no-background.disabled.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .secondary.no-background.invalid.disabled.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .confirm.no-background.disabled.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .confirm.no-background.invalid.disabled.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .transparent.no-background.disabled.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .transparent.no-background.invalid.disabled.sc-sdx-button{border-color:rgba(255, 255, 255, 0.4);color:rgba(255, 255, 255, 0.4)}/*!@:host(.sdx--dark-theme) .primary.no-background.invalid:focus, :host(.sdx--dark-theme) .primary.no-background.invalid:active, :host(.sdx--dark-theme) .component:active button.primary.no-background.invalid.chip, :host(.sdx--dark-theme) .primary.no-background.invalid.invalid:focus, :host(.sdx--dark-theme) .primary.no-background.invalid.invalid:active,\n:host(.sdx--dark-theme) .secondary.no-background.invalid:focus,\n:host(.sdx--dark-theme) .secondary.no-background.invalid:active,\n:host(.sdx--dark-theme) .component:active button.secondary.no-background.invalid.chip,\n:host(.sdx--dark-theme) .secondary.no-background.invalid.invalid:focus,\n:host(.sdx--dark-theme) .secondary.no-background.invalid.invalid:active,\n:host(.sdx--dark-theme) .confirm.no-background.invalid:focus,\n:host(.sdx--dark-theme) .confirm.no-background.invalid:active,\n:host(.sdx--dark-theme) .component:active button.confirm.no-background.invalid.chip,\n:host(.sdx--dark-theme) .confirm.no-background.invalid.invalid:focus,\n:host(.sdx--dark-theme) .confirm.no-background.invalid.invalid:active,\n:host(.sdx--dark-theme) .transparent.no-background.invalid:focus,\n:host(.sdx--dark-theme) .transparent.no-background.invalid:active,\n:host(.sdx--dark-theme) .component:active button.transparent.no-background.invalid.chip,\n:host(.sdx--dark-theme) .transparent.no-background.invalid.invalid:focus,\n:host(.sdx--dark-theme) .transparent.no-background.invalid.invalid:active,\n:host(.sdx--light-theme) .primary.no-background.invalid:focus,\n:host(.sdx--light-theme) .primary.no-background.invalid:active,\n:host(.sdx--light-theme) .component:active button.primary.no-background.invalid.chip,\n:host(.sdx--light-theme) .primary.no-background.invalid.invalid:focus,\n:host(.sdx--light-theme) .primary.no-background.invalid.invalid:active,\n:host(.sdx--light-theme) .secondary.no-background.invalid:focus,\n:host(.sdx--light-theme) .secondary.no-background.invalid:active,\n:host(.sdx--light-theme) .component:active button.secondary.no-background.invalid.chip,\n:host(.sdx--light-theme) .secondary.no-background.invalid.invalid:focus,\n:host(.sdx--light-theme) .secondary.no-background.invalid.invalid:active,\n:host(.sdx--light-theme) .confirm.no-background.invalid:focus,\n:host(.sdx--light-theme) .confirm.no-background.invalid:active,\n:host(.sdx--light-theme) .component:active button.confirm.no-background.invalid.chip,\n:host(.sdx--light-theme) .confirm.no-background.invalid.invalid:focus,\n:host(.sdx--light-theme) .confirm.no-background.invalid.invalid:active,\n:host(.sdx--light-theme) .transparent.no-background.invalid:focus,\n:host(.sdx--light-theme) .transparent.no-background.invalid:active,\n:host(.sdx--light-theme) .component:active button.transparent.no-background.invalid.chip,\n:host(.sdx--light-theme) .transparent.no-background.invalid.invalid:focus,\n:host(.sdx--light-theme) .transparent.no-background.invalid.invalid:active*/.sdx--dark-theme.sc-sdx-button-h .primary.no-background.invalid.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .primary.no-background.invalid.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:active button.primary.no-background.invalid.chip.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .primary.no-background.invalid.invalid.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .primary.no-background.invalid.invalid.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .secondary.no-background.invalid.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .secondary.no-background.invalid.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:active button.secondary.no-background.invalid.chip.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .secondary.no-background.invalid.invalid.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .secondary.no-background.invalid.invalid.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .confirm.no-background.invalid.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .confirm.no-background.invalid.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:active button.confirm.no-background.invalid.chip.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .confirm.no-background.invalid.invalid.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .confirm.no-background.invalid.invalid.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .transparent.no-background.invalid.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .transparent.no-background.invalid.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:active button.transparent.no-background.invalid.chip.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .transparent.no-background.invalid.invalid.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .transparent.no-background.invalid.invalid.sc-sdx-button:active,.sdx--light-theme.sc-sdx-button-h .primary.no-background.invalid.sc-sdx-button:focus,.sdx--light-theme.sc-sdx-button-h .primary.no-background.invalid.sc-sdx-button:active,.sdx--light-theme.sc-sdx-button-h .component.sc-sdx-button:active button.primary.no-background.invalid.chip.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .primary.no-background.invalid.invalid.sc-sdx-button:focus,.sdx--light-theme.sc-sdx-button-h .primary.no-background.invalid.invalid.sc-sdx-button:active,.sdx--light-theme.sc-sdx-button-h .secondary.no-background.invalid.sc-sdx-button:focus,.sdx--light-theme.sc-sdx-button-h .secondary.no-background.invalid.sc-sdx-button:active,.sdx--light-theme.sc-sdx-button-h .component.sc-sdx-button:active button.secondary.no-background.invalid.chip.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .secondary.no-background.invalid.invalid.sc-sdx-button:focus,.sdx--light-theme.sc-sdx-button-h .secondary.no-background.invalid.invalid.sc-sdx-button:active,.sdx--light-theme.sc-sdx-button-h .confirm.no-background.invalid.sc-sdx-button:focus,.sdx--light-theme.sc-sdx-button-h .confirm.no-background.invalid.sc-sdx-button:active,.sdx--light-theme.sc-sdx-button-h .component.sc-sdx-button:active button.confirm.no-background.invalid.chip.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .confirm.no-background.invalid.invalid.sc-sdx-button:focus,.sdx--light-theme.sc-sdx-button-h .confirm.no-background.invalid.invalid.sc-sdx-button:active,.sdx--light-theme.sc-sdx-button-h .transparent.no-background.invalid.sc-sdx-button:focus,.sdx--light-theme.sc-sdx-button-h .transparent.no-background.invalid.sc-sdx-button:active,.sdx--light-theme.sc-sdx-button-h .component.sc-sdx-button:active button.transparent.no-background.invalid.chip.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .transparent.no-background.invalid.invalid.sc-sdx-button:focus,.sdx--light-theme.sc-sdx-button-h .transparent.no-background.invalid.invalid.sc-sdx-button:active{color:rgba(255, 255, 255, 0.8)}@media (hover: hover){/*!@:host(.sdx--dark-theme) .primary.no-background.invalid:hover, :host(.sdx--dark-theme) .component:hover button.primary.no-background.invalid.chip, :host(.sdx--dark-theme) .primary.no-background.invalid.invalid:hover,\n  :host(.sdx--dark-theme) .secondary.no-background.invalid:hover,\n  :host(.sdx--dark-theme) .component:hover button.secondary.no-background.invalid.chip,\n  :host(.sdx--dark-theme) .secondary.no-background.invalid.invalid:hover,\n  :host(.sdx--dark-theme) .confirm.no-background.invalid:hover,\n  :host(.sdx--dark-theme) .component:hover button.confirm.no-background.invalid.chip,\n  :host(.sdx--dark-theme) .confirm.no-background.invalid.invalid:hover,\n  :host(.sdx--dark-theme) .transparent.no-background.invalid:hover,\n  :host(.sdx--dark-theme) .component:hover button.transparent.no-background.invalid.chip,\n  :host(.sdx--dark-theme) .transparent.no-background.invalid.invalid:hover,\n  :host(.sdx--light-theme) .primary.no-background.invalid:hover,\n  :host(.sdx--light-theme) .component:hover button.primary.no-background.invalid.chip,\n  :host(.sdx--light-theme) .primary.no-background.invalid.invalid:hover,\n  :host(.sdx--light-theme) .secondary.no-background.invalid:hover,\n  :host(.sdx--light-theme) .component:hover button.secondary.no-background.invalid.chip,\n  :host(.sdx--light-theme) .secondary.no-background.invalid.invalid:hover,\n  :host(.sdx--light-theme) .confirm.no-background.invalid:hover,\n  :host(.sdx--light-theme) .component:hover button.confirm.no-background.invalid.chip,\n  :host(.sdx--light-theme) .confirm.no-background.invalid.invalid:hover,\n  :host(.sdx--light-theme) .transparent.no-background.invalid:hover,\n  :host(.sdx--light-theme) .component:hover button.transparent.no-background.invalid.chip,\n  :host(.sdx--light-theme) .transparent.no-background.invalid.invalid:hover*/.sdx--dark-theme.sc-sdx-button-h .primary.no-background.invalid.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.primary.no-background.invalid.chip.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .primary.no-background.invalid.invalid.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .secondary.no-background.invalid.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.secondary.no-background.invalid.chip.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .secondary.no-background.invalid.invalid.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .confirm.no-background.invalid.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.confirm.no-background.invalid.chip.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .confirm.no-background.invalid.invalid.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .transparent.no-background.invalid.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.transparent.no-background.invalid.chip.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .transparent.no-background.invalid.invalid.sc-sdx-button:hover,.sdx--light-theme.sc-sdx-button-h .primary.no-background.invalid.sc-sdx-button:hover,.sdx--light-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.primary.no-background.invalid.chip.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .primary.no-background.invalid.invalid.sc-sdx-button:hover,.sdx--light-theme.sc-sdx-button-h .secondary.no-background.invalid.sc-sdx-button:hover,.sdx--light-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.secondary.no-background.invalid.chip.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .secondary.no-background.invalid.invalid.sc-sdx-button:hover,.sdx--light-theme.sc-sdx-button-h .confirm.no-background.invalid.sc-sdx-button:hover,.sdx--light-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.confirm.no-background.invalid.chip.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .confirm.no-background.invalid.invalid.sc-sdx-button:hover,.sdx--light-theme.sc-sdx-button-h .transparent.no-background.invalid.sc-sdx-button:hover,.sdx--light-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.transparent.no-background.invalid.chip.sc-sdx-button,.sdx--light-theme.sc-sdx-button-h .transparent.no-background.invalid.invalid.sc-sdx-button:hover{color:rgba(255, 255, 255, 0.8)}}/*!@:host(.sdx--dark-theme) .component .badge*/.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button .badge.sc-sdx-button{background-color:#ce4a0c}/*!@:host(.sdx--dark-theme) .component .badge:hover, :host(.sdx--dark-theme) .component:hover button.badge.chip*/.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button .badge.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.badge.chip.sc-sdx-button{background-color:#de4f0d}/*!@:host(.sdx--dark-theme) .primary*/.sdx--dark-theme.sc-sdx-button-h .primary.sc-sdx-button{border-color:#0a71e9;background-color:#0a71e9}/*!@:host(.sdx--dark-theme) .primary:focus, :host(.sdx--dark-theme) .primary:active, :host(.sdx--dark-theme) .component:active button.primary.chip*/.sdx--dark-theme.sc-sdx-button-h .primary.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .primary.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:active button.primary.chip.sc-sdx-button{border-color:#147df5;background-color:#147df5}@media (hover: hover){/*!@:host(.sdx--dark-theme) .primary:hover, :host(.sdx--dark-theme) .component:hover button.primary.chip*/.sdx--dark-theme.sc-sdx-button-h .primary.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.primary.chip.sc-sdx-button{border-color:#147df5;background-color:#147df5}}/*!@:host(.sdx--dark-theme) .primary.disabled*/.sdx--dark-theme.sc-sdx-button-h .primary.disabled.sc-sdx-button{background-color:rgba(10, 113, 233, 0.4);border-color:transparent}/*!@:host(.sdx--dark-theme) .secondary*/.sdx--dark-theme.sc-sdx-button-h .secondary.sc-sdx-button{border-color:#4294ff;background-color:transparent;color:#4294ff}/*!@:host(.sdx--dark-theme) .secondary:focus, :host(.sdx--dark-theme) .secondary:active, :host(.sdx--dark-theme) .component:active button.secondary.chip*/.sdx--dark-theme.sc-sdx-button-h .secondary.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .secondary.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:active button.secondary.chip.sc-sdx-button{border-color:#5ca3ff;background-color:rgba(66, 148, 255, 0.15);color:#5ca3ff}@media (hover: hover){/*!@:host(.sdx--dark-theme) .secondary:hover, :host(.sdx--dark-theme) .component:hover button.secondary.chip*/.sdx--dark-theme.sc-sdx-button-h .secondary.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.secondary.chip.sc-sdx-button{border-color:#5ca3ff;background-color:rgba(66, 148, 255, 0.15);color:#5ca3ff}}/*!@:host(.sdx--dark-theme) .secondary.disabled*/.sdx--dark-theme.sc-sdx-button-h .secondary.disabled.sc-sdx-button{border-color:rgba(66, 148, 255, 0.4);color:rgba(66, 148, 255, 0.4)}/*!@:host(.sdx--dark-theme) .confirm*/.sdx--dark-theme.sc-sdx-button-h .confirm.sc-sdx-button{border-color:#1c8912;background-color:#1c8912}/*!@:host(.sdx--dark-theme) .confirm:focus, :host(.sdx--dark-theme) .confirm:active, :host(.sdx--dark-theme) .component:active button.confirm.chip*/.sdx--dark-theme.sc-sdx-button-h .confirm.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .confirm.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:active button.confirm.chip.sc-sdx-button{border-color:#1f9414;background-color:#1f9414}@media (hover: hover){/*!@:host(.sdx--dark-theme) .confirm:hover, :host(.sdx--dark-theme) .component:hover button.confirm.chip*/.sdx--dark-theme.sc-sdx-button-h .confirm.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.confirm.chip.sc-sdx-button{border-color:#1f9414;background-color:#1f9414}}/*!@:host(.sdx--dark-theme) .confirm.disabled*/.sdx--dark-theme.sc-sdx-button-h .confirm.disabled.sc-sdx-button{background-color:rgba(28, 137, 18, 0.4);border-color:transparent}/*!@:host(.sdx--dark-theme) .transparent.invalid*/.sdx--dark-theme.sc-sdx-button-h .transparent.invalid.sc-sdx-button{color:#f35d6a}/*!@:host(.sdx--dark-theme) .transparent:focus, :host(.sdx--dark-theme) .transparent:active, :host(.sdx--dark-theme) .component:active button.transparent.chip*/.sdx--dark-theme.sc-sdx-button-h .transparent.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .transparent.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:active button.transparent.chip.sc-sdx-button{color:#5ca3ff}/*!@:host(.sdx--dark-theme) .transparent:focus.invalid, :host(.sdx--dark-theme) .transparent:active.invalid, :host(.sdx--dark-theme) .component:active button.transparent.invalid.chip*/.sdx--dark-theme.sc-sdx-button-h .transparent.sc-sdx-button:focus.invalid,.sdx--dark-theme.sc-sdx-button-h .transparent.sc-sdx-button:active.invalid,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:active button.transparent.invalid.chip.sc-sdx-button{color:#fe7e89}@media (hover: hover){/*!@:host(.sdx--dark-theme) .transparent:hover, :host(.sdx--dark-theme) .component:hover button.transparent.chip*/.sdx--dark-theme.sc-sdx-button-h .transparent.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.transparent.chip.sc-sdx-button{color:#5ca3ff}/*!@:host(.sdx--dark-theme) .transparent:hover.invalid, :host(.sdx--dark-theme) .component:hover button.transparent.invalid.chip*/.sdx--dark-theme.sc-sdx-button-h .transparent.sc-sdx-button:hover.invalid,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.transparent.invalid.chip.sc-sdx-button{color:#fe7e89}}/*!@:host(.sdx--dark-theme) .transparent.disabled, :host(.sdx--dark-theme) .transparent.disabled.invalid*/.sdx--dark-theme.sc-sdx-button-h .transparent.disabled.sc-sdx-button,.sdx--dark-theme.sc-sdx-button-h .transparent.disabled.invalid.sc-sdx-button{color:rgba(92, 92, 92, 0.8)}/*!@:host(.sdx--dark-theme) .cancel*/.sdx--dark-theme.sc-sdx-button-h .cancel.sc-sdx-button{color:#4294ff}/*!@:host(.sdx--dark-theme) .cancel:focus, :host(.sdx--dark-theme) .cancel:active, :host(.sdx--dark-theme) .component:active button.cancel.chip*/.sdx--dark-theme.sc-sdx-button-h .cancel.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .cancel.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:active button.cancel.chip.sc-sdx-button{border-color:transparent;background-color:rgba(66, 148, 255, 0.15);color:#5ca3ff}@media (hover: hover){/*!@:host(.sdx--dark-theme) .cancel:hover, :host(.sdx--dark-theme) .component:hover button.cancel.chip*/.sdx--dark-theme.sc-sdx-button-h .cancel.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.cancel.chip.sc-sdx-button{border-color:transparent;background-color:rgba(66, 148, 255, 0.15);color:#5ca3ff}}/*!@:host(.sdx--dark-theme) .chip*/.sdx--dark-theme.sc-sdx-button-h .chip.sc-sdx-button{border-color:#5c5c5c;background-color:#5c5c5c}/*!@:host(.sdx--dark-theme) .chip:focus, :host(.sdx--dark-theme) .chip:active, :host(.sdx--dark-theme) .component:active button.chip*/.sdx--dark-theme.sc-sdx-button-h .chip.sc-sdx-button:focus,.sdx--dark-theme.sc-sdx-button-h .chip.sc-sdx-button:active,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:active button.chip.sc-sdx-button{border-color:#8c8c8c;background-color:#8c8c8c}@media (hover: hover){/*!@:host(.sdx--dark-theme) .chip:hover, :host(.sdx--dark-theme) .component:hover button.chip*/.sdx--dark-theme.sc-sdx-button-h .chip.sc-sdx-button:hover,.sdx--dark-theme.sc-sdx-button-h .component.sc-sdx-button:hover button.chip.sc-sdx-button{border-color:#8c8c8c;background-color:#8c8c8c}}/*!@:host(.transparent.sdx--dark-theme)*/.transparent.sdx--dark-theme.sc-sdx-button-h{color:#4294ff}";

class Button {
  disabledChanged() {
    if (this.lightDOMHiddenSubmitEl) {
      this.lightDOMHiddenSubmitEl.disabled = this.disabled;
    }
  }
  /**
   * Set focus to element.
   */
  async doFocus() {
    var _a;
    (_a = this.focusableEl) === null || _a === void 0 ? void 0 : _a.focus();
  }
  onTouchStart() {
    // NOP - make sure touchstart is noticed. touchstart event needed for the animations (note: tracking on prod)
  }
  onClick() {
    var _a;
    (_a = this.lightDOMHiddenSubmitEl) === null || _a === void 0 ? void 0 : _a.click();
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.theme = "primary";
    this.background = "light";
    this.disabled = false;
    this.href = "";
    this.target = undefined;
    this.label = "";
    this.iconName = undefined;
    this.iconSize = undefined;
    this.srHint = "";
    this.ariaExpandedOnButton = undefined;
    this.badge = "";
    this.type = "button";
    this.loading = false;
    this.valid = undefined;
    if (this.type === "submit") {
      this.lightDOMHiddenSubmitEl = document.createElement("input");
      this.lightDOMHiddenSubmitEl.type = this.type;
      this.lightDOMHiddenSubmitEl.disabled = this.disabled;
      this.lightDOMHiddenSubmitEl.hidden = true;
      // otherwise consumer will get a second click event
      this.lightDOMHiddenSubmitEl.onclick = (e) => e.stopPropagation();
      this.el.append(this.lightDOMHiddenSubmitEl);
    }
  }
  getHostClassNames() {
    return {
      [this.theme]: true,
      disabled: this.disabled,
      loading: this.loading,
      [getAppearance(this.el)]: true,
    };
  }
  getButtonClassNames() {
    const iconSize = this.getIconSize() || 1;
    return {
      clickable: true,
      "button-reset": true,
      [this.theme]: true,
      "no-background": this.background === "dark",
      disabled: this.disabled,
      invalid: this.valid === false,
      h4: iconSize > 4, // icons with size 5+ have a larger font-size
    };
  }
  getAriaExpanded() {
    if (this.ariaExpandedOnButton === true) {
      return "true";
    }
    else if (this.ariaExpandedOnButton === false) {
      return "false";
    }
    else {
      return;
    }
  }
  // Make sure that only theme="transparent" allows other sizes
  getIconSize() {
    if (this.theme === "transparent") {
      return this.iconSize;
    }
    return;
  }
  isBadgeDisplayed() {
    return !!this.badge && this.theme === "transparent" && !this.label;
  }
  createLabel(label) {
    if (label) {
      return hAsync("span", { class: "label" }, label);
    }
  }
  render() {
    const Tag = this.href ? "a" : "button";
    return (hAsync(Host, { class: this.getHostClassNames() }, hAsync("div", { class: "component" }, hAsync(Tag, { ref: (el) => (this.focusableEl = el), class: this.getButtonClassNames(), href: this.href, target: this.target, disabled: this.disabled, type: this.type, "aria-expanded": this.getAriaExpanded() }, this.loading && (hAsync("div", { class: "loading-spinner-container", "aria-live": "polite" }, hAsync("sdx-loading-spinner", { srHint: this.srHint || undefined, strokeInherit: true }))), this.theme === "chip" && this.createLabel(this.label), (this.theme === "chip" || this.iconName) && (hAsync("sdx-icon", { class: "icon", size: this.getIconSize(), iconName: this.theme === "chip" ? "icon-clear-circle" : this.iconName })), this.theme !== "chip" && this.createLabel(this.label), this.srHint && hAsync("span", { class: "sr-only" }, this.srHint)), this.isBadgeDisplayed() && hAsync("span", { class: "badge" }, this.badge))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "disabled": ["disabledChanged"]
  }; }
  static get style() { return buttonCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-button",
    "$members$": {
      "theme": [1],
      "background": [1],
      "disabled": [4],
      "href": [1],
      "target": [1],
      "label": [1],
      "iconName": [1, "icon-name"],
      "iconSize": [2, "icon-size"],
      "srHint": [1, "sr-hint"],
      "ariaExpandedOnButton": [4, "aria-expanded-on-button"],
      "badge": [1],
      "type": [1],
      "loading": [4],
      "valid": [4],
      "doFocus": [64]
    },
    "$listeners$": [[1, "touchstart", "onTouchStart"], [0, "click", "onClick"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const buttonGroupCss = "/*!@:root*/.sc-sdx-button-group:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-button-group-h,*.sc-sdx-button-group,*.sc-sdx-button-group:before,*.sc-sdx-button-group:after{box-sizing:border-box}/*!@:host .component*/.sc-sdx-button-group-h .component.sc-sdx-button-group{display:flex;flex-wrap:wrap;flex-direction:row-reverse;margin:-8px -8px}/*!@:host ::slotted(sdx-button)*/.sc-sdx-button-group-h .sc-sdx-button-group-s>sdx-button{margin:8px 8px}@media (max-width: 479px){/*!@:host ::slotted(sdx-button)*/.sc-sdx-button-group-h .sc-sdx-button-group-s>sdx-button{width:100%}}/*!@:host .fixed,\n:host .fullwidth*/.sc-sdx-button-group-h .fixed.sc-sdx-button-group,.sc-sdx-button-group-h .fullwidth.sc-sdx-button-group{flex-direction:row}/*!@:host .fill*/.sc-sdx-button-group-h .fill.sc-sdx-button-group{flex-wrap:nowrap}@media (min-width: 480px){/*!@:host .responsive-fill*/.sc-sdx-button-group-h .responsive-fill.sc-sdx-button-group{flex-wrap:nowrap}}/*!@:host(.fill) ::slotted(sdx-button)*/.sc-sdx-button-group-h.fill .sc-sdx-button-group-s>sdx-button{width:100%;min-width:0}@media (min-width: 480px){/*!@:host(.responsive-fill) ::slotted(sdx-button)*/.sc-sdx-button-group-h.responsive-fill .sc-sdx-button-group-s>sdx-button{width:100%;min-width:0}}@media (max-width: 479px){/*!@:host(.fixed) ::slotted(sdx-button)*/.sc-sdx-button-group-h.fixed .sc-sdx-button-group-s>sdx-button{width:auto}}/*!@:host(.fullwidth) ::slotted(sdx-button)*/.sc-sdx-button-group-h.fullwidth .sc-sdx-button-group-s>sdx-button{width:100%}";

class ButtonGroup {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.layout = "responsive";
  }
  getComponentClassNames() {
    return {
      component: true,
      [this.layout]: true,
    };
  }
  render() {
    return (hAsync(Host, { class: this.layout }, hAsync("div", { class: this.getComponentClassNames() }, hAsync("slot", null))));
  }
  static get style() { return buttonGroupCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-button-group",
    "$members$": {
      "layout": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const cardCss = "/*!@:root*/.sc-sdx-card:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-card-h,*.sc-sdx-card,*.sc-sdx-card:before,*.sc-sdx-card:after{box-sizing:border-box}/*!@.text-body-1,\n.text-standard*/.text-body-1.sc-sdx-card,.text-standard.sc-sdx-card{line-height:24px;letter-spacing:-0.1px;font-size:18px}/*!@.text-body-2,\n.text-small*/.text-body-2.sc-sdx-card,.text-small.sc-sdx-card{line-height:21px;letter-spacing:0;font-size:16px}/*!@h1,\nh2,\nh3,\nh4,\nh5,\nh6,\np*/h1.sc-sdx-card,h2.sc-sdx-card,h3.sc-sdx-card,h4.sc-sdx-card,h5.sc-sdx-card,h6.sc-sdx-card,p.sc-sdx-card{margin:0;text-align:left;word-wrap:break-word}/*!@.h1,\n.h2,\n.h3,\n.h4,\n.h5,\n.h6,\n.hero,\n.d1,\n.d2,\n.d3*/.h1.sc-sdx-card,.h2.sc-sdx-card,.h3.sc-sdx-card,.h4.sc-sdx-card,.h5.sc-sdx-card,.h6.sc-sdx-card,.hero.sc-sdx-card,.d1.sc-sdx-card,.d2.sc-sdx-card,.d3.sc-sdx-card{color:#015}/*!@.h1,\n.h2,\n.text-h1,\n.text-h2,\nh1,\nh2*/.h1.sc-sdx-card,.h2.sc-sdx-card,.text-h1.sc-sdx-card,.text-h2.sc-sdx-card,h1.sc-sdx-card,h2.sc-sdx-card{margin-bottom:32px}/*!@.h1,\n.text-h1,\nh1*/.h1.sc-sdx-card,.text-h1.sc-sdx-card,h1.sc-sdx-card{line-height:40px;letter-spacing:-1px;font-size:32px;font-weight:700}@media (min-width: 1024px){/*!@.h1,\n  .text-h1,\n  h1*/.h1.sc-sdx-card,.text-h1.sc-sdx-card,h1.sc-sdx-card{line-height:48px;letter-spacing:-1.2px;font-size:40px}}/*!@.h2,\n.text-h2,\nh2*/.h2.sc-sdx-card,.text-h2.sc-sdx-card,h2.sc-sdx-card{line-height:32px;letter-spacing:-0.75px;font-size:28px;font-weight:700}@media (min-width: 1024px){/*!@.h2,\n  .text-h2,\n  h2*/.h2.sc-sdx-card,.text-h2.sc-sdx-card,h2.sc-sdx-card{line-height:40px;letter-spacing:-1px;font-size:32px}}/*!@.h3,\n.h4,\n.text-h3,\n.text-h4,\nh3,\nh4*/.h3.sc-sdx-card,.h4.sc-sdx-card,.text-h3.sc-sdx-card,.text-h4.sc-sdx-card,h3.sc-sdx-card,h4.sc-sdx-card{margin-bottom:24px}/*!@.h3,\n.text-h3,\nh3*/.h3.sc-sdx-card,.text-h3.sc-sdx-card,h3.sc-sdx-card{line-height:32px;letter-spacing:-0.35px;font-size:24px;font-weight:600}@media (min-width: 1024px){/*!@.h3,\n  .text-h3,\n  h3*/.h3.sc-sdx-card,.text-h3.sc-sdx-card,h3.sc-sdx-card{line-height:32px;letter-spacing:-0.75px;font-size:28px}}/*!@.h4,\n.text-h4,\nh4*/.h4.sc-sdx-card,.text-h4.sc-sdx-card,h4.sc-sdx-card{line-height:24px;letter-spacing:-0.1px;font-size:20px;font-weight:600}@media (min-width: 1024px){/*!@.h4,\n  .text-h4,\n  h4*/.h4.sc-sdx-card,.text-h4.sc-sdx-card,h4.sc-sdx-card{line-height:32px;letter-spacing:-0.35px;font-size:24px}}/*!@.text-h3.text-compact*/.text-h3.text-compact.sc-sdx-card{line-height:31px}/*!@.text-h4.text-compact*/.text-h4.text-compact.sc-sdx-card{line-height:27px}/*!@.h5,\n.h6,\n.text-h5,\n.text-h6,\nh5,\nh6*/.h5.sc-sdx-card,.h6.sc-sdx-card,.text-h5.sc-sdx-card,.text-h6.sc-sdx-card,h5.sc-sdx-card,h6.sc-sdx-card{margin-bottom:8px}/*!@.h5,\n.text-h5,\nh5*/.h5.sc-sdx-card,.text-h5.sc-sdx-card,h5.sc-sdx-card{line-height:24px;letter-spacing:-0.1px;font-size:18px;font-weight:600}/*!@.h6,\n.text-h6,\nh6*/.h6.sc-sdx-card,.text-h6.sc-sdx-card,h6.sc-sdx-card{line-height:24px;letter-spacing:-0.1px;font-size:16px;font-weight:600}/*!@.paragraph,\np*/.paragraph.sc-sdx-card,p.sc-sdx-card{line-height:24px;letter-spacing:-0.1px;font-size:18px;margin-bottom:32px}/*!@.paragraph:last-child,\np:last-child*/.paragraph.sc-sdx-card:last-child,p.sc-sdx-card:last-child{margin-bottom:0}/*!@.hero,\n.text-hero,\n.d1,\n.text-d1,\n.d2,\n.text-d2,\n.d3,\n.text-d3*/.hero.sc-sdx-card,.text-hero.sc-sdx-card,.d1.sc-sdx-card,.text-d1.sc-sdx-card,.d2.sc-sdx-card,.text-d2.sc-sdx-card,.d3.sc-sdx-card,.text-d3.sc-sdx-card{font-weight:700}/*!@.hero,\n.text-hero*/.hero.sc-sdx-card,.text-hero.sc-sdx-card{line-height:80px;letter-spacing:-1.75px;font-size:70px}@media (min-width: 1024px){/*!@.hero,\n  .text-hero*/.hero.sc-sdx-card,.text-hero.sc-sdx-card{line-height:104px;letter-spacing:-2px;font-size:96px}}/*!@.d1,\n.text-d1*/.d1.sc-sdx-card,.text-d1.sc-sdx-card{line-height:64px;letter-spacing:-1.35px;font-size:54px}@media (min-width: 1024px){/*!@.d1,\n  .text-d1*/.d1.sc-sdx-card,.text-d1.sc-sdx-card{line-height:80px;letter-spacing:-1.75px;font-size:70px}}/*!@.d2,\n.text-d2*/.d2.sc-sdx-card,.text-d2.sc-sdx-card{line-height:56px;letter-spacing:-1.2px;font-size:48px}@media (min-width: 1024px){/*!@.d2,\n  .text-d2*/.d2.sc-sdx-card,.text-d2.sc-sdx-card{line-height:64px;letter-spacing:-1.35px;font-size:54px}}/*!@.d3,\n.text-d3*/.d3.sc-sdx-card,.text-d3.sc-sdx-card{line-height:48px;letter-spacing:-1.2px;font-size:40px}@media (min-width: 1024px){/*!@.d3,\n  .text-d3*/.d3.sc-sdx-card,.text-d3.sc-sdx-card{line-height:56px;letter-spacing:-1.2px;font-size:48px}}/*!@.text-b1*/.text-b1.sc-sdx-card{line-height:24px;letter-spacing:-0.1px;font-size:18px;font-weight:400}/*!@.text-b2*/.text-b2.sc-sdx-card{line-height:21px;letter-spacing:0;font-size:16px;font-weight:400}/*!@.text-sm,\n.text-smaller*/.text-sm.sc-sdx-card,.text-smaller.sc-sdx-card{line-height:18px;letter-spacing:0.1px;font-size:14px;font-weight:400}/*!@.text-compact*/.text-compact.sc-sdx-card{line-height:21px}/*!@.figcaption*/.figcaption.sc-sdx-card{line-height:18px;letter-spacing:0.1px;font-size:14px}/*!@.code*/.code.sc-sdx-card{font-family:monospace;background-color:#f8fafb;border-radius:4px;border:1px solid #d6d6d6;color:#474747;font-size:16px;padding:0 6px}/*!@address*/address.sc-sdx-card{font-style:normal}/*!@strong*/strong.sc-sdx-card{font-weight:600}/*!@em*/em.sc-sdx-card{font-style:italic}/*!@.sdx--dark-theme .code*/.sdx--dark-theme.sc-sdx-card .code.sc-sdx-card{background-color:#242424;color:#d6d6d6}/*!@.font*/.font.sc-sdx-card{font-family:TheSans, sans-serif}/*!@.font--sans*/.font--sans.sc-sdx-card{font-family:TheSans, sans-serif}/*!@.font--serif*/.font--serif.sc-sdx-card{font-family:TheSerif, serif}/*!@.font--light*/.font--light.sc-sdx-card{font-weight:300}/*!@.font--semi-light*/.font--semi-light.sc-sdx-card{font-weight:400}/*!@.font--semi-bold*/.font--semi-bold.sc-sdx-card{font-weight:600}/*!@.sdx--dark-theme .h1,\n.sdx--dark-theme .h2,\n.sdx--dark-theme .h3,\n.sdx--dark-theme .h4,\n.sdx--dark-theme .h5,\n.sdx--dark-theme .h6,\n.sdx--dark-theme .hero,\n.sdx--dark-theme .d1,\n.sdx--dark-theme .d2,\n.sdx--dark-theme .d3*/.sdx--dark-theme.sc-sdx-card .h1.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .h2.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .h3.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .h4.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .h5.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .h6.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .hero.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .d1.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .d2.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .d3.sc-sdx-card{color:unset}/*!@.sdx--dark-theme .h1,\n.sdx--dark-theme .text-h1,\n.sdx--dark-theme h1,\n.sdx--dark-theme .h2,\n.sdx--dark-theme .text-h2,\n.sdx--dark-theme h2,\n.sdx--dark-theme .h3,\n.sdx--dark-theme .text-h3,\n.sdx--dark-theme h3,\n.sdx--dark-theme .h4,\n.sdx--dark-theme .text-h4,\n.sdx--dark-theme h4,\n.sdx--dark-theme .d1,\n.sdx--dark-theme .text-d1,\n.sdx--dark-theme .d2,\n.sdx--dark-theme .text-d2,\n.sdx--dark-theme .d3,\n.sdx--dark-theme .text-d3*/.sdx--dark-theme.sc-sdx-card .h1.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .text-h1.sc-sdx-card,.sdx--dark-theme.sc-sdx-card h1.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .h2.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .text-h2.sc-sdx-card,.sdx--dark-theme.sc-sdx-card h2.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .h3.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .text-h3.sc-sdx-card,.sdx--dark-theme.sc-sdx-card h3.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .h4.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .text-h4.sc-sdx-card,.sdx--dark-theme.sc-sdx-card h4.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .d1.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .text-d1.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .d2.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .text-d2.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .d3.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .text-d3.sc-sdx-card{font-weight:600}/*!@.sdx--dark-theme .p,\n.sdx--dark-theme .paragraph,\n.sdx--dark-theme p*/.sdx--dark-theme.sc-sdx-card .p.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .paragraph.sc-sdx-card,.sdx--dark-theme.sc-sdx-card p.sc-sdx-card{font-weight:500}/*!@.sdx--dark-theme .h1,\n.sdx--dark-theme .text-h1,\n.sdx--dark-theme h1*/.sdx--dark-theme.sc-sdx-card .h1.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .text-h1.sc-sdx-card,.sdx--dark-theme.sc-sdx-card h1.sc-sdx-card{letter-spacing:-0.8px}/*!@.sdx--dark-theme .h2,\n.sdx--dark-theme .text-h2,\n.sdx--dark-theme h2*/.sdx--dark-theme.sc-sdx-card .h2.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .text-h2.sc-sdx-card,.sdx--dark-theme.sc-sdx-card h2.sc-sdx-card{letter-spacing:-0.6px}/*!@.sdx--dark-theme .h3,\n.sdx--dark-theme .text-h3,\n.sdx--dark-theme h3*/.sdx--dark-theme.sc-sdx-card .h3.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .text-h3.sc-sdx-card,.sdx--dark-theme.sc-sdx-card h3.sc-sdx-card{letter-spacing:-0.5px}/*!@.sdx--dark-theme .h4,\n.sdx--dark-theme .text-h4,\n.sdx--dark-theme h4*/.sdx--dark-theme.sc-sdx-card .h4.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .text-h4.sc-sdx-card,.sdx--dark-theme.sc-sdx-card h4.sc-sdx-card{letter-spacing:-0.2px}/*!@.sdx--dark-theme .h5,\n.sdx--dark-theme .text-h5,\n.sdx--dark-theme h5*/.sdx--dark-theme.sc-sdx-card .h5.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .text-h5.sc-sdx-card,.sdx--dark-theme.sc-sdx-card h5.sc-sdx-card{letter-spacing:-0.1px}/*!@.sdx--dark-theme .h6,\n.sdx--dark-theme .text-h6,\n.sdx--dark-theme h6*/.sdx--dark-theme.sc-sdx-card .h6.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .text-h6.sc-sdx-card,.sdx--dark-theme.sc-sdx-card h6.sc-sdx-card{letter-spacing:0px}/*!@.sdx--dark-theme .d1,\n.sdx--dark-theme .text-d1*/.sdx--dark-theme.sc-sdx-card .d1.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .text-d1.sc-sdx-card{letter-spacing:-1.4px}/*!@.sdx--dark-theme .d2,\n.sdx--dark-theme .text-d2*/.sdx--dark-theme.sc-sdx-card .d2.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .text-d2.sc-sdx-card{letter-spacing:-1px}/*!@.sdx--dark-theme .d3,\n.sdx--dark-theme .text-d3*/.sdx--dark-theme.sc-sdx-card .d3.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .text-d3.sc-sdx-card{letter-spacing:-0.9px}/*!@.sdx--dark-theme strong,\n.sdx--dark-theme b*/.sdx--dark-theme.sc-sdx-card strong.sc-sdx-card,.sdx--dark-theme.sc-sdx-card b.sc-sdx-card{color:#fff}/*!@.sdx--dark-theme code*/.sdx--dark-theme.sc-sdx-card code.sc-sdx-card{background-color:#242424;border:1px solid #b1b9be;border-radius:4px;color:#cfd5d9;font-size:16px}/*!@a,\na.link,\nbutton.link*/a.sc-sdx-card,a.link.sc-sdx-card,button.link.sc-sdx-card{position:relative;transition:color 200ms cubic-bezier(0.4, 0, 0.6, 1);outline:none;text-decoration:underline;text-underline-offset:5px;cursor:pointer;color:#086adb}/*!@a:hover, .component.sdx--dark-theme.interaction:hover a.link, .component.interaction:hover .component.sdx--dark-theme.interaction.link a.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron a.link,\n.component.sdx--dark-theme.interaction:hover a.chevron,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link a.chevron,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron a.chevron, .component.interaction:hover a.link,\n.component.interaction:hover a.chevron, a:focus,\na.link:hover,\na.link:focus,\nbutton.link:hover,\n.component.sdx--dark-theme.interaction:hover button.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link button.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron button.link,\n.component.interaction:hover button.link,\nbutton.link:focus*/a.sc-sdx-card:hover,.component.sdx--dark-theme.interaction.sc-sdx-card:hover a.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card a.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card a.link.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover a.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card a.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card a.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover a.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover a.chevron.sc-sdx-card,a.sc-sdx-card:focus,a.link.sc-sdx-card:hover,a.link.sc-sdx-card:focus,button.link.sc-sdx-card:hover,.component.sdx--dark-theme.interaction.sc-sdx-card:hover button.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card button.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card button.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover button.link.sc-sdx-card,button.link.sc-sdx-card:focus{text-decoration-thickness:2px;color:#0048cf}/*!@a:focus,\na.link:focus,\nbutton.link:focus*/a.sc-sdx-card:focus,a.link.sc-sdx-card:focus,button.link.sc-sdx-card:focus{outline:none}/*!@a + a, a + a.link, a + button.link,\na.link + a,\na.link + a.link,\na.link + button.link,\nbutton.link + a,\nbutton.link + a.link,\nbutton.link + button.link*/a.sc-sdx-card+a.sc-sdx-card,a.sc-sdx-card+a.link.sc-sdx-card,a.sc-sdx-card+button.link.sc-sdx-card,a.link.sc-sdx-card+a.sc-sdx-card,a.link.sc-sdx-card+a.link.sc-sdx-card,a.link.sc-sdx-card+button.link.sc-sdx-card,button.link.sc-sdx-card+a.sc-sdx-card,button.link.sc-sdx-card+a.link.sc-sdx-card,button.link.sc-sdx-card+button.link.sc-sdx-card{margin-left:24px}/*!@a[class*=icon-],\na.link[class*=icon-],\nbutton.link[class*=icon-]*/a[class*=icon-].sc-sdx-card,a.link[class*=icon-].sc-sdx-card,button.link[class*=icon-].sc-sdx-card{display:inline-block;text-decoration:none;margin-left:24px}/*!@a[class*=icon-]:hover, .component.interaction:hover a[class*=icon-].link,\n.component.interaction:hover a[class*=icon-].chevron, a[class*=icon-]:focus,\na.link[class*=icon-]:hover,\na.link[class*=icon-]:focus,\nbutton.link[class*=icon-]:hover,\n.component.interaction:hover button.link[class*=icon-],\nbutton.link[class*=icon-]:focus*/a[class*=icon-].sc-sdx-card:hover,.component.interaction.sc-sdx-card:hover a[class*=icon-].link.sc-sdx-card,.component.interaction.sc-sdx-card:hover a[class*=icon-].chevron.sc-sdx-card,a[class*=icon-].sc-sdx-card:focus,a.link[class*=icon-].sc-sdx-card:hover,a.link[class*=icon-].sc-sdx-card:focus,button.link[class*=icon-].sc-sdx-card:hover,.component.interaction.sc-sdx-card:hover button.link[class*=icon-].sc-sdx-card,button.link[class*=icon-].sc-sdx-card:focus{text-decoration:underline;text-decoration-thickness:2px}/*!@a[class*=icon-]::before,\na.link[class*=icon-]::before,\nbutton.link[class*=icon-]::before*/a[class*=icon-].sc-sdx-card::before,a.link[class*=icon-].sc-sdx-card::before,button.link[class*=icon-].sc-sdx-card::before{margin-left:-24px;display:inline-block;font-family:sdx-icons;padding-right:6px;position:relative}/*!@a:not([href])*/a.sc-sdx-card:not([href]){text-decoration:none}/*!@p a + a, p a + a.link, p a + button.link,\np a.link + a,\np a.link + a.link,\np a.link + button.link,\np button.link + a,\np button.link + a.link,\np button.link + button.link,\n.list a + a,\n.list a + a.link,\n.list a + button.link,\n.list a.link + a,\n.list a.link + a.link,\n.list a.link + button.link,\n.list button.link + a,\n.list button.link + a.link,\n.list button.link + button.link*/p.sc-sdx-card a.sc-sdx-card+a.sc-sdx-card,p.sc-sdx-card a.sc-sdx-card+a.link.sc-sdx-card,p.sc-sdx-card a.sc-sdx-card+button.link.sc-sdx-card,p.sc-sdx-card a.link.sc-sdx-card+a.sc-sdx-card,p.sc-sdx-card a.link.sc-sdx-card+a.link.sc-sdx-card,p.sc-sdx-card a.link.sc-sdx-card+button.link.sc-sdx-card,p.sc-sdx-card button.link.sc-sdx-card+a.sc-sdx-card,p.sc-sdx-card button.link.sc-sdx-card+a.link.sc-sdx-card,p.sc-sdx-card button.link.sc-sdx-card+button.link.sc-sdx-card,.list.sc-sdx-card a.sc-sdx-card+a.sc-sdx-card,.list.sc-sdx-card a.sc-sdx-card+a.link.sc-sdx-card,.list.sc-sdx-card a.sc-sdx-card+button.link.sc-sdx-card,.list.sc-sdx-card a.link.sc-sdx-card+a.sc-sdx-card,.list.sc-sdx-card a.link.sc-sdx-card+a.link.sc-sdx-card,.list.sc-sdx-card a.link.sc-sdx-card+button.link.sc-sdx-card,.list.sc-sdx-card button.link.sc-sdx-card+a.sc-sdx-card,.list.sc-sdx-card button.link.sc-sdx-card+a.link.sc-sdx-card,.list.sc-sdx-card button.link.sc-sdx-card+button.link.sc-sdx-card{margin-left:0}/*!@a.link--white, a.link--white:hover, .component.interaction:hover a.link--white.link,\n.component.interaction:hover a.link--white.chevron, a.link--white:focus,\nbutton.link--white,\nbutton.link--white:hover,\n.component.interaction:hover button.link--white.link,\n.component.interaction:hover button.link--white.chevron,\nbutton.link--white:focus*/a.link--white.sc-sdx-card,a.link--white.sc-sdx-card:hover,.component.interaction.sc-sdx-card:hover a.link--white.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover a.link--white.chevron.sc-sdx-card,a.link--white.sc-sdx-card:focus,button.link--white.sc-sdx-card,button.link--white.sc-sdx-card:hover,.component.interaction.sc-sdx-card:hover button.link--white.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover button.link--white.chevron.sc-sdx-card,button.link--white.sc-sdx-card:focus{color:#fff;border-color:#fff}/*!@.link--dark,\n.bg--dark a,\n.bg--dark a.link,\n.bg--dark button.link*/.link--dark.sc-sdx-card,.bg--dark.sc-sdx-card a.sc-sdx-card,.bg--dark.sc-sdx-card a.link.sc-sdx-card,.bg--dark.sc-sdx-card button.link.sc-sdx-card{color:#fff}/*!@.link--dark:hover, .component.sdx--dark-theme.interaction:hover .link--dark.link, .component.interaction:hover .component.sdx--dark-theme.interaction.link .link--dark.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .link--dark.link,\n.component.sdx--dark-theme.interaction:hover .link--dark.chevron,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .link--dark.chevron,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .link--dark.chevron, .component.interaction:hover .link--dark.link, .component.sdx--dark-theme.interaction:hover .component.interaction.link .link--dark.link, .component.interaction:hover .component.sdx--dark-theme.interaction.link .component.interaction.link .link--dark.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .component.interaction.link .link--dark.link,\n.component.sdx--dark-theme.interaction:hover .component.interaction.chevron .link--dark.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .component.interaction.chevron .link--dark.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .component.interaction.chevron .link--dark.link,\n.component.interaction:hover .link--dark.chevron,\n.component.sdx--dark-theme.interaction:hover .component.interaction.link .link--dark.chevron,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .component.interaction.link .link--dark.chevron,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .component.interaction.link .link--dark.chevron,\n.component.sdx--dark-theme.interaction:hover .component.interaction.chevron .link--dark.chevron,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .component.interaction.chevron .link--dark.chevron,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .component.interaction.chevron .link--dark.chevron, .link--dark:focus,\n.bg--dark a:hover,\n.bg--dark .component.sdx--dark-theme.interaction:hover a.link,\n.component.sdx--dark-theme.interaction:hover .bg--dark a.link,\n.bg--dark .component.interaction:hover .component.sdx--dark-theme.interaction.link a.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .bg--dark a.link,\n.bg--dark .component.interaction:hover .component.sdx--dark-theme.interaction.chevron a.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .bg--dark a.link,\n.bg--dark .component.sdx--dark-theme.interaction:hover a.chevron,\n.component.sdx--dark-theme.interaction:hover .bg--dark a.chevron,\n.bg--dark .component.interaction:hover .component.sdx--dark-theme.interaction.link a.chevron,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .bg--dark a.chevron,\n.bg--dark .component.interaction:hover .component.sdx--dark-theme.interaction.chevron a.chevron,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .bg--dark a.chevron,\n.bg--dark .component.interaction:hover a.link,\n.bg--dark .component.sdx--dark-theme.interaction:hover .component.interaction.link a.link,\n.component.sdx--dark-theme.interaction:hover .bg--dark .component.interaction.link a.link,\n.bg--dark .component.interaction:hover .component.sdx--dark-theme.interaction.link .component.interaction.link a.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .bg--dark .component.interaction.link a.link,\n.bg--dark .component.interaction:hover .component.sdx--dark-theme.interaction.chevron .component.interaction.link a.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .bg--dark .component.interaction.link a.link,\n.bg--dark .component.sdx--dark-theme.interaction:hover .component.interaction.chevron a.link,\n.component.sdx--dark-theme.interaction:hover .bg--dark .component.interaction.chevron a.link,\n.bg--dark .component.interaction:hover .component.sdx--dark-theme.interaction.link .component.interaction.chevron a.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .bg--dark .component.interaction.chevron a.link,\n.bg--dark .component.interaction:hover .component.sdx--dark-theme.interaction.chevron .component.interaction.chevron a.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .bg--dark .component.interaction.chevron a.link,\n.component.interaction:hover .bg--dark a.link,\n.component.sdx--dark-theme.interaction:hover .component.interaction.link .bg--dark a.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .component.interaction.link .bg--dark a.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .component.interaction.link .bg--dark a.link,\n.component.sdx--dark-theme.interaction:hover .component.interaction.chevron .bg--dark a.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .component.interaction.chevron .bg--dark a.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .component.interaction.chevron .bg--dark a.link,\n.bg--dark .component.interaction:hover a.chevron,\n.bg--dark .component.sdx--dark-theme.interaction:hover .component.interaction.link a.chevron,\n.component.sdx--dark-theme.interaction:hover .bg--dark .component.interaction.link a.chevron,\n.bg--dark .component.interaction:hover .component.sdx--dark-theme.interaction.link .component.interaction.link a.chevron,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .bg--dark .component.interaction.link a.chevron,\n.bg--dark .component.interaction:hover .component.sdx--dark-theme.interaction.chevron .component.interaction.link a.chevron,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .bg--dark .component.interaction.link a.chevron,\n.bg--dark .component.sdx--dark-theme.interaction:hover .component.interaction.chevron a.chevron,\n.component.sdx--dark-theme.interaction:hover .bg--dark .component.interaction.chevron a.chevron,\n.bg--dark .component.interaction:hover .component.sdx--dark-theme.interaction.link .component.interaction.chevron a.chevron,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .bg--dark .component.interaction.chevron a.chevron,\n.bg--dark .component.interaction:hover .component.sdx--dark-theme.interaction.chevron .component.interaction.chevron a.chevron,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .bg--dark .component.interaction.chevron a.chevron,\n.component.interaction:hover .bg--dark a.chevron,\n.component.sdx--dark-theme.interaction:hover .component.interaction.link .bg--dark a.chevron,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .component.interaction.link .bg--dark a.chevron,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .component.interaction.link .bg--dark a.chevron,\n.component.sdx--dark-theme.interaction:hover .component.interaction.chevron .bg--dark a.chevron,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .component.interaction.chevron .bg--dark a.chevron,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .component.interaction.chevron .bg--dark a.chevron,\n.bg--dark button.link:hover,\n.bg--dark .component.sdx--dark-theme.interaction:hover button.link,\n.component.sdx--dark-theme.interaction:hover .bg--dark button.link,\n.bg--dark .component.interaction:hover .component.sdx--dark-theme.interaction.link button.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .bg--dark button.link,\n.bg--dark .component.interaction:hover .component.sdx--dark-theme.interaction.chevron button.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .bg--dark button.link,\n.bg--dark .component.interaction:hover button.link,\n.bg--dark .component.sdx--dark-theme.interaction:hover .component.interaction.link button.link,\n.component.sdx--dark-theme.interaction:hover .bg--dark .component.interaction.link button.link,\n.bg--dark .component.interaction:hover .component.sdx--dark-theme.interaction.link .component.interaction.link button.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .bg--dark .component.interaction.link button.link,\n.bg--dark .component.interaction:hover .component.sdx--dark-theme.interaction.chevron .component.interaction.link button.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .bg--dark .component.interaction.link button.link,\n.bg--dark .component.sdx--dark-theme.interaction:hover .component.interaction.chevron button.link,\n.component.sdx--dark-theme.interaction:hover .bg--dark .component.interaction.chevron button.link,\n.bg--dark .component.interaction:hover .component.sdx--dark-theme.interaction.link .component.interaction.chevron button.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .bg--dark .component.interaction.chevron button.link,\n.bg--dark .component.interaction:hover .component.sdx--dark-theme.interaction.chevron .component.interaction.chevron button.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .bg--dark .component.interaction.chevron button.link,\n.component.interaction:hover .bg--dark button.link,\n.component.sdx--dark-theme.interaction:hover .component.interaction.link .bg--dark button.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .component.interaction.link .bg--dark button.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .component.interaction.link .bg--dark button.link,\n.component.sdx--dark-theme.interaction:hover .component.interaction.chevron .bg--dark button.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.link .component.interaction.chevron .bg--dark button.link,\n.component.interaction:hover .component.sdx--dark-theme.interaction.chevron .component.interaction.chevron .bg--dark button.link,\n.bg--dark a:focus,\n.bg--dark button.link:focus*/.link--dark.sc-sdx-card:hover,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .link--dark.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .link--dark.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .link--dark.link.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .link--dark.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .link--dark.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .link--dark.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .link--dark.link.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .component.interaction.link.sc-sdx-card .link--dark.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .component.interaction.link.sc-sdx-card .link--dark.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .component.interaction.link.sc-sdx-card .link--dark.link.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .component.interaction.chevron.sc-sdx-card .link--dark.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .component.interaction.chevron.sc-sdx-card .link--dark.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .component.interaction.chevron.sc-sdx-card .link--dark.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .link--dark.chevron.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .component.interaction.link.sc-sdx-card .link--dark.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .component.interaction.link.sc-sdx-card .link--dark.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .component.interaction.link.sc-sdx-card .link--dark.chevron.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .component.interaction.chevron.sc-sdx-card .link--dark.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .component.interaction.chevron.sc-sdx-card .link--dark.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .component.interaction.chevron.sc-sdx-card .link--dark.chevron.sc-sdx-card,.link--dark.sc-sdx-card:focus,.bg--dark.sc-sdx-card a.sc-sdx-card:hover,.bg--dark.sc-sdx-card .component.sdx--dark-theme.interaction.sc-sdx-card:hover a.link.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .bg--dark.sc-sdx-card a.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card a.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .bg--dark.sc-sdx-card a.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card a.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .bg--dark.sc-sdx-card a.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.sdx--dark-theme.interaction.sc-sdx-card:hover a.chevron.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .bg--dark.sc-sdx-card a.chevron.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card a.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .bg--dark.sc-sdx-card a.chevron.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card a.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .bg--dark.sc-sdx-card a.chevron.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover a.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.sdx--dark-theme.interaction.sc-sdx-card:hover .component.interaction.link.sc-sdx-card a.link.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .bg--dark.sc-sdx-card .component.interaction.link.sc-sdx-card a.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .component.interaction.link.sc-sdx-card a.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .bg--dark.sc-sdx-card .component.interaction.link.sc-sdx-card a.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .component.interaction.link.sc-sdx-card a.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .bg--dark.sc-sdx-card .component.interaction.link.sc-sdx-card a.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.sdx--dark-theme.interaction.sc-sdx-card:hover .component.interaction.chevron.sc-sdx-card a.link.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .bg--dark.sc-sdx-card .component.interaction.chevron.sc-sdx-card a.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .component.interaction.chevron.sc-sdx-card a.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .bg--dark.sc-sdx-card .component.interaction.chevron.sc-sdx-card a.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .component.interaction.chevron.sc-sdx-card a.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .bg--dark.sc-sdx-card .component.interaction.chevron.sc-sdx-card a.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .bg--dark.sc-sdx-card a.link.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .component.interaction.link.sc-sdx-card .bg--dark.sc-sdx-card a.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .component.interaction.link.sc-sdx-card .bg--dark.sc-sdx-card a.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .component.interaction.link.sc-sdx-card .bg--dark.sc-sdx-card a.link.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .component.interaction.chevron.sc-sdx-card .bg--dark.sc-sdx-card a.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .component.interaction.chevron.sc-sdx-card .bg--dark.sc-sdx-card a.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .component.interaction.chevron.sc-sdx-card .bg--dark.sc-sdx-card a.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover a.chevron.sc-sdx-card,.bg--dark.sc-sdx-card .component.sdx--dark-theme.interaction.sc-sdx-card:hover .component.interaction.link.sc-sdx-card a.chevron.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .bg--dark.sc-sdx-card .component.interaction.link.sc-sdx-card a.chevron.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .component.interaction.link.sc-sdx-card a.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .bg--dark.sc-sdx-card .component.interaction.link.sc-sdx-card a.chevron.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .component.interaction.link.sc-sdx-card a.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .bg--dark.sc-sdx-card .component.interaction.link.sc-sdx-card a.chevron.sc-sdx-card,.bg--dark.sc-sdx-card .component.sdx--dark-theme.interaction.sc-sdx-card:hover .component.interaction.chevron.sc-sdx-card a.chevron.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .bg--dark.sc-sdx-card .component.interaction.chevron.sc-sdx-card a.chevron.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .component.interaction.chevron.sc-sdx-card a.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .bg--dark.sc-sdx-card .component.interaction.chevron.sc-sdx-card a.chevron.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .component.interaction.chevron.sc-sdx-card a.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .bg--dark.sc-sdx-card .component.interaction.chevron.sc-sdx-card a.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .bg--dark.sc-sdx-card a.chevron.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .component.interaction.link.sc-sdx-card .bg--dark.sc-sdx-card a.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .component.interaction.link.sc-sdx-card .bg--dark.sc-sdx-card a.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .component.interaction.link.sc-sdx-card .bg--dark.sc-sdx-card a.chevron.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .component.interaction.chevron.sc-sdx-card .bg--dark.sc-sdx-card a.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .component.interaction.chevron.sc-sdx-card .bg--dark.sc-sdx-card a.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .component.interaction.chevron.sc-sdx-card .bg--dark.sc-sdx-card a.chevron.sc-sdx-card,.bg--dark.sc-sdx-card button.link.sc-sdx-card:hover,.bg--dark.sc-sdx-card .component.sdx--dark-theme.interaction.sc-sdx-card:hover button.link.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .bg--dark.sc-sdx-card button.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card button.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .bg--dark.sc-sdx-card button.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card button.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .bg--dark.sc-sdx-card button.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover button.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.sdx--dark-theme.interaction.sc-sdx-card:hover .component.interaction.link.sc-sdx-card button.link.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .bg--dark.sc-sdx-card .component.interaction.link.sc-sdx-card button.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .component.interaction.link.sc-sdx-card button.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .bg--dark.sc-sdx-card .component.interaction.link.sc-sdx-card button.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .component.interaction.link.sc-sdx-card button.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .bg--dark.sc-sdx-card .component.interaction.link.sc-sdx-card button.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.sdx--dark-theme.interaction.sc-sdx-card:hover .component.interaction.chevron.sc-sdx-card button.link.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .bg--dark.sc-sdx-card .component.interaction.chevron.sc-sdx-card button.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .component.interaction.chevron.sc-sdx-card button.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .bg--dark.sc-sdx-card .component.interaction.chevron.sc-sdx-card button.link.sc-sdx-card,.bg--dark.sc-sdx-card .component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .component.interaction.chevron.sc-sdx-card button.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .bg--dark.sc-sdx-card .component.interaction.chevron.sc-sdx-card button.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .bg--dark.sc-sdx-card button.link.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .component.interaction.link.sc-sdx-card .bg--dark.sc-sdx-card button.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .component.interaction.link.sc-sdx-card .bg--dark.sc-sdx-card button.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .component.interaction.link.sc-sdx-card .bg--dark.sc-sdx-card button.link.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .component.interaction.chevron.sc-sdx-card .bg--dark.sc-sdx-card button.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.link.sc-sdx-card .component.interaction.chevron.sc-sdx-card .bg--dark.sc-sdx-card button.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.interaction.chevron.sc-sdx-card .component.interaction.chevron.sc-sdx-card .bg--dark.sc-sdx-card button.link.sc-sdx-card,.bg--dark.sc-sdx-card a.sc-sdx-card:focus,.bg--dark.sc-sdx-card button.link.sc-sdx-card:focus{color:#fff}/*!@.sdx--dark-theme a,\n.sdx--dark-theme a.link,\n.sdx--dark-theme button.link*/.sdx--dark-theme.sc-sdx-card a.sc-sdx-card,.sdx--dark-theme.sc-sdx-card a.link.sc-sdx-card,.sdx--dark-theme.sc-sdx-card button.link.sc-sdx-card{color:#4294ff}/*!@.sdx--dark-theme a:hover, .component.sdx--dark-theme.interaction:hover a.link,\n.component.sdx--dark-theme.interaction:hover a.chevron, .sdx--dark-theme .component.interaction:hover a.link, .component.interaction:hover .sdx--dark-theme a.link,\n.sdx--dark-theme .component.interaction:hover a.chevron,\n.component.interaction:hover .sdx--dark-theme a.chevron, .sdx--dark-theme a:focus,\n.sdx--dark-theme a.link:hover,\n.sdx--dark-theme a.link:focus,\n.sdx--dark-theme button.link:hover,\n.component.sdx--dark-theme.interaction:hover button.link,\n.sdx--dark-theme .component.interaction:hover button.link,\n.component.interaction:hover .sdx--dark-theme button.link,\n.sdx--dark-theme button.link:focus*/.sdx--dark-theme.sc-sdx-card a.sc-sdx-card:hover,.component.sdx--dark-theme.interaction.sc-sdx-card:hover a.link.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover a.chevron.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .component.interaction.sc-sdx-card:hover a.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .sdx--dark-theme.sc-sdx-card a.link.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .component.interaction.sc-sdx-card:hover a.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .sdx--dark-theme.sc-sdx-card a.chevron.sc-sdx-card,.sdx--dark-theme.sc-sdx-card a.sc-sdx-card:focus,.sdx--dark-theme.sc-sdx-card a.link.sc-sdx-card:hover,.sdx--dark-theme.sc-sdx-card a.link.sc-sdx-card:focus,.sdx--dark-theme.sc-sdx-card button.link.sc-sdx-card:hover,.component.sdx--dark-theme.interaction.sc-sdx-card:hover button.link.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .component.interaction.sc-sdx-card:hover button.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .sdx--dark-theme.sc-sdx-card button.link.sc-sdx-card,.sdx--dark-theme.sc-sdx-card button.link.sc-sdx-card:focus{color:#5ca3ff}/*!@.sdx--dark-theme a.link--white, .sdx--dark-theme a.link--white:hover, .component.sdx--dark-theme.interaction:hover a.link--white.link,\n.component.sdx--dark-theme.interaction:hover a.link--white.chevron, .sdx--dark-theme .component.interaction:hover a.link--white.link, .component.interaction:hover .sdx--dark-theme a.link--white.link,\n.sdx--dark-theme .component.interaction:hover a.link--white.chevron,\n.component.interaction:hover .sdx--dark-theme a.link--white.chevron, .sdx--dark-theme a.link--white:focus,\n.sdx--dark-theme button.link--white,\n.sdx--dark-theme button.link--white:hover,\n.component.sdx--dark-theme.interaction:hover button.link--white.link,\n.component.sdx--dark-theme.interaction:hover button.link--white.chevron,\n.sdx--dark-theme .component.interaction:hover button.link--white.link,\n.component.interaction:hover .sdx--dark-theme button.link--white.link,\n.sdx--dark-theme .component.interaction:hover button.link--white.chevron,\n.component.interaction:hover .sdx--dark-theme button.link--white.chevron,\n.sdx--dark-theme button.link--white:focus*/.sdx--dark-theme.sc-sdx-card a.link--white.sc-sdx-card,.sdx--dark-theme.sc-sdx-card a.link--white.sc-sdx-card:hover,.component.sdx--dark-theme.interaction.sc-sdx-card:hover a.link--white.link.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover a.link--white.chevron.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .component.interaction.sc-sdx-card:hover a.link--white.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .sdx--dark-theme.sc-sdx-card a.link--white.link.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .component.interaction.sc-sdx-card:hover a.link--white.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .sdx--dark-theme.sc-sdx-card a.link--white.chevron.sc-sdx-card,.sdx--dark-theme.sc-sdx-card a.link--white.sc-sdx-card:focus,.sdx--dark-theme.sc-sdx-card button.link--white.sc-sdx-card,.sdx--dark-theme.sc-sdx-card button.link--white.sc-sdx-card:hover,.component.sdx--dark-theme.interaction.sc-sdx-card:hover button.link--white.link.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover button.link--white.chevron.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .component.interaction.sc-sdx-card:hover button.link--white.link.sc-sdx-card,.component.interaction.sc-sdx-card:hover .sdx--dark-theme.sc-sdx-card button.link--white.link.sc-sdx-card,.sdx--dark-theme.sc-sdx-card .component.interaction.sc-sdx-card:hover button.link--white.chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .sdx--dark-theme.sc-sdx-card button.link--white.chevron.sc-sdx-card,.sdx--dark-theme.sc-sdx-card button.link--white.sc-sdx-card:focus{color:#fff;border-color:#fff}/*!@.bg-white*/.bg-white.sc-sdx-card{background-color:#fff}/*!@.bg-navy*/.bg-navy.sc-sdx-card{background-color:#015}/*!@.bg-blue*/.bg-blue.sc-sdx-card{background-color:#086adb}/*!@.bg-blue-tint-2, .bg-blue-40*/.bg-blue-tint-2.sc-sdx-card,.bg-blue-40.sc-sdx-card{background-color:#a2cdf4}/*!@.bg-blue-tint-3, .bg-blue-20*/.bg-blue-tint-3.sc-sdx-card,.bg-blue-20.sc-sdx-card{background-color:#d1e6f9}/*!@.bg-aluminium,\n.bg-aluminum*/.bg-aluminium.sc-sdx-card,.bg-aluminum.sc-sdx-card{background-color:#dde3e7}/*!@.bg-aluminium-80, .bg-aluminium-tint-2,\n.bg-aluminum-80,\n.bg-aluminum-tint-2*/.bg-aluminium-80.sc-sdx-card,.bg-aluminium-tint-2.sc-sdx-card,.bg-aluminum-80.sc-sdx-card,.bg-aluminum-tint-2.sc-sdx-card{background-color:#e4e9ec}/*!@.bg-horizon*/.bg-horizon.sc-sdx-card{background-color:#eef3f6}/*!@.bg-horizon-40, .bg-horizon-tint-2*/.bg-horizon-40.sc-sdx-card,.bg-horizon-tint-2.sc-sdx-card{background-color:#f8fafb}/*!@.bg-gray*/.bg-gray.sc-sdx-card{background-color:#333}/*!@.bg-gray-90, .bg-gray-tint-2*/.bg-gray-90.sc-sdx-card,.bg-gray-tint-2.sc-sdx-card{background-color:#474747}/*!@.bg-gray-80, .bg-gray-tint-3*/.bg-gray-80.sc-sdx-card,.bg-gray-tint-3.sc-sdx-card{background-color:#5c5c5c}/*!@.bg-gray-mid, .bg-gray-tint-4*/.bg-gray-mid.sc-sdx-card,.bg-gray-tint-4.sc-sdx-card{background-color:#666}/*!@.bg-gray-60, .bg-gray-tint-5*/.bg-gray-60.sc-sdx-card,.bg-gray-tint-5.sc-sdx-card{background-color:#858585}/*!@.bg-gray-40, .bg-gray-tint-6*/.bg-gray-40.sc-sdx-card,.bg-gray-tint-6.sc-sdx-card{background-color:#adadad}/*!@.bg-gray-light, .bg-gray-tint-7*/.bg-gray-light.sc-sdx-card,.bg-gray-tint-7.sc-sdx-card{background-color:#bbb}/*!@.bg-gray-20, .bg-gray-tint-8*/.bg-gray-20.sc-sdx-card,.bg-gray-tint-8.sc-sdx-card{background-color:#d6d6d6}/*!@.bg-sc-blue*/.bg-sc-blue.sc-sdx-card{background-color:#1af}/*!@.bg-sc-red*/.bg-sc-red.sc-sdx-card{background-color:#d12}/*!@.bg-sc-navy*/.bg-sc-navy.sc-sdx-card{background-color:#015}/*!@.bg-sc-white*/.bg-sc-white.sc-sdx-card{background-color:#fff}/*!@.bg-gradient-1, .component.split.gradient-1 .first*/.bg-gradient-1.sc-sdx-card,.component.split.gradient-1.sc-sdx-card .first.sc-sdx-card{background:radial-gradient(110% 240% at 0% 130%, rgba(19, 163, 244, 0.9) 0%, rgba(22, 158, 255, 0.5) 55%, rgba(16, 136, 222, 0) 130%), #001155}/*!@.bg-gradient-2, .component.gradient .first*/.bg-gradient-2.sc-sdx-card,.component.gradient.sc-sdx-card .first.sc-sdx-card{background:radial-gradient(110% 220% at 0% 140%, #13a3f4 0%, rgba(22, 158, 255, 0.5) 40%, rgba(16, 136, 222, 0) 100%), radial-gradient(290% 800% at 220% -440%, #dd1122 30%, #001155 100%)}/*!@.bg-cloud*/.bg-cloud.sc-sdx-card{background:#f9f9f9}/*!@.bg-int-blue*/.bg-int-blue.sc-sdx-card{background-color:#086adb}/*!@.bg-int-blue--active*/.bg-int-blue--active.sc-sdx-card{background-color:#0048cf}/*!@.bg-int-gray*/.bg-int-gray.sc-sdx-card{background-color:#cfd5d9}/*!@.bg-int-gray--active*/.bg-int-gray--active.sc-sdx-card{background-color:#b1b9be}/*!@.bg-int-green*/.bg-int-green.sc-sdx-card{background-color:#1b8712}/*!@.bg-int-green--active*/.bg-int-green--active.sc-sdx-card{background-color:#0d6f2c}/*!@.bg-int-red*/.bg-int-red.sc-sdx-card{background-color:#d12}/*!@.bg-int-red--active*/.bg-int-red--active.sc-sdx-card{background-color:#be0000}/*!@.bg-int-orange*/.bg-int-orange.sc-sdx-card{background-color:#cf4a0c}/*!@.bg-int-orange--active*/.bg-int-orange--active.sc-sdx-card{background-color:#ba3e06}/*!@.bg-azure*/.bg-azure.sc-sdx-card{background-color:#1781e3}/*!@.bg-azure--active*/.bg-azure--active.sc-sdx-card{background-color:#0851da}/*!@.bg-orchid*/.bg-orchid.sc-sdx-card{background-color:#a63297}/*!@.bg-orchid--active*/.bg-orchid--active.sc-sdx-card{background-color:#7f2879}/*!@.bg-iris*/.bg-iris.sc-sdx-card{background-color:#5944c6}/*!@.bg-iris--active*/.bg-iris--active.sc-sdx-card{background-color:#42389e}/*!@.bg-pink*/.bg-pink.sc-sdx-card{background-color:#e61e64}/*!@.bg-pink--active*/.bg-pink--active.sc-sdx-card{background-color:#bf1b5a}/*!@.bg-apple,\n.bg-petrol,\n.bg-turquoise*/.bg-apple.sc-sdx-card,.bg-petrol.sc-sdx-card,.bg-turquoise.sc-sdx-card{background-color:#0eaba9}/*!@.bg-apple--active,\n.bg-petrol--active,\n.bg-turquoise--active*/.bg-apple--active.sc-sdx-card,.bg-petrol--active.sc-sdx-card,.bg-turquoise--active.sc-sdx-card{background-color:#0c847e}/*!@.sdx--dark-theme .bg-dusk*/.sdx--dark-theme.sc-sdx-card .bg-dusk.sc-sdx-card{background-color:#141414}/*!@.sdx--dark-theme .bg-dusk-tint-2*/.sdx--dark-theme.sc-sdx-card .bg-dusk-tint-2.sc-sdx-card{background-color:#1d1d1d}/*!@.sdx--dark-theme .bg-dusk-tint-3*/.sdx--dark-theme.sc-sdx-card .bg-dusk-tint-3.sc-sdx-card{background-color:#222}/*!@.sdx--dark-theme .bg-dusk-tint-4*/.sdx--dark-theme.sc-sdx-card .bg-dusk-tint-4.sc-sdx-card{background-color:#242424}/*!@.sdx--dark-theme .bg-gray*/.sdx--dark-theme.sc-sdx-card .bg-gray.sc-sdx-card{background-color:#e6e6e6}/*!@.sdx--dark-theme .bg-gray-tint-3*/.sdx--dark-theme.sc-sdx-card .bg-gray-tint-3.sc-sdx-card{background-color:#cfd5d9}/*!@.sdx--dark-theme .bg-gray-tint-4*/.sdx--dark-theme.sc-sdx-card .bg-gray-tint-4.sc-sdx-card{background-color:#b1b9be}/*!@.sdx--dark-theme .bg-gray-tint-6*/.sdx--dark-theme.sc-sdx-card .bg-gray-tint-6.sc-sdx-card{background-color:#8c8c8c}/*!@.sdx--dark-theme .bg-gray-tint-7*/.sdx--dark-theme.sc-sdx-card .bg-gray-tint-7.sc-sdx-card{background-color:#707070}/*!@.sdx--dark-theme .bg-gray-tint-8*/.sdx--dark-theme.sc-sdx-card .bg-gray-tint-8.sc-sdx-card{background-color:#5c5c5c}/*!@.sdx--dark-theme .bg-azure*/.sdx--dark-theme.sc-sdx-card .bg-azure.sc-sdx-card{background-color:#136fc3}/*!@.sdx--dark-theme .bg-azure--active*/.sdx--dark-theme.sc-sdx-card .bg-azure--active.sc-sdx-card{background-color:#1578d3}/*!@.sdx--dark-theme .bg-turquoise*/.sdx--dark-theme.sc-sdx-card .bg-turquoise.sc-sdx-card{background-color:#0a7b7a}/*!@.sdx--dark-theme .bg-turquoise--active*/.sdx--dark-theme.sc-sdx-card .bg-turquoise--active.sc-sdx-card{background-color:#0b8483}/*!@.sdx--dark-theme .bg-iris*/.sdx--dark-theme.sc-sdx-card .bg-iris.sc-sdx-card{background-color:#6f5ccb}/*!@.sdx--dark-theme .bg-iris--active*/.sdx--dark-theme.sc-sdx-card .bg-iris--active.sc-sdx-card{background-color:#7867ce}/*!@.sdx--dark-theme .bg-orchid*/.sdx--dark-theme.sc-sdx-card .bg-orchid.sc-sdx-card{background-color:#a54c9b}/*!@.sdx--dark-theme .bg-orchid--active*/.sdx--dark-theme.sc-sdx-card .bg-orchid--active.sc-sdx-card{background-color:#b053a5}/*!@.sdx--dark-theme .bg-pink*/.sdx--dark-theme.sc-sdx-card .bg-pink.sc-sdx-card{background-color:#d41d56}/*!@.sdx--dark-theme .bg-pink--active*/.sdx--dark-theme.sc-sdx-card .bg-pink--active.sc-sdx-card{background-color:#e1245f}/*!@.sdx--dark-theme .bg-int-blue*/.sdx--dark-theme.sc-sdx-card .bg-int-blue.sc-sdx-card{background-color:#0a71e9}/*!@.sdx--dark-theme .bg-int-blue--active*/.sdx--dark-theme.sc-sdx-card .bg-int-blue--active.sc-sdx-card{background-color:#147df5}/*!@.sdx--dark-theme .bg-int-blue2*/.sdx--dark-theme.sc-sdx-card .bg-int-blue2.sc-sdx-card{background-color:#4294ff}/*!@.sdx--dark-theme .bg-int-blue2--active*/.sdx--dark-theme.sc-sdx-card .bg-int-blue2--active.sc-sdx-card{background-color:#5ca3ff}/*!@.sdx--dark-theme .bg-int-gray*/.sdx--dark-theme.sc-sdx-card .bg-int-gray.sc-sdx-card{background-color:#adadad}/*!@.sdx--dark-theme .bg-int-gray--active*/.sdx--dark-theme.sc-sdx-card .bg-int-gray--active.sc-sdx-card{background-color:#d6d6d6}/*!@.sdx--dark-theme .bg-int-green*/.sdx--dark-theme.sc-sdx-card .bg-int-green.sc-sdx-card{background-color:#1c8912}/*!@.sdx--dark-theme .bg-int-green--active*/.sdx--dark-theme.sc-sdx-card .bg-int-green--active.sc-sdx-card{background-color:#1f9414}/*!@.sdx--dark-theme .bg-int-green2*/.sdx--dark-theme.sc-sdx-card .bg-int-green2.sc-sdx-card{background-color:#21a716}/*!@.sdx--dark-theme .bg-int-green2--active*/.sdx--dark-theme.sc-sdx-card .bg-int-green2--active.sc-sdx-card{background-color:#55c24a}/*!@.sdx--dark-theme .bg-int-red*/.sdx--dark-theme.sc-sdx-card .bg-int-red.sc-sdx-card{background-color:#eb1224}/*!@.sdx--dark-theme .bg-int-red--active*/.sdx--dark-theme.sc-sdx-card .bg-int-red--active.sc-sdx-card{background-color:#ef2e3e}/*!@.sdx--dark-theme .bg-int-red2*/.sdx--dark-theme.sc-sdx-card .bg-int-red2.sc-sdx-card{background-color:#f35d6a}/*!@.sdx--dark-theme .bg-int-red2--active*/.sdx--dark-theme.sc-sdx-card .bg-int-red2--active.sc-sdx-card{background-color:#fe7e89}/*!@.sdx--dark-theme .bg-int-orange*/.sdx--dark-theme.sc-sdx-card .bg-int-orange.sc-sdx-card{background-color:#ce4a0c}/*!@.sdx--dark-theme .bg-int-orange--active*/.sdx--dark-theme.sc-sdx-card .bg-int-orange--active.sc-sdx-card{background-color:#de4f0d}/*!@.sdx--dark-theme .bg-int-orange2*/.sdx--dark-theme.sc-sdx-card .bg-int-orange2.sc-sdx-card{background-color:#f26726}/*!@.sdx--dark-theme .bg-int-orange2--active*/.sdx--dark-theme.sc-sdx-card .bg-int-orange2--active.sc-sdx-card{background-color:#f37b46}/*!@.component*/.component.sc-sdx-card{display:flex;flex-direction:column;height:100%;background:#fff;border:1px solid #dde3e7;border-radius:5px;overflow:hidden;box-shadow:0 4px 16px 0 rgba(51, 51, 51, 0.08)}/*!@.component.notification, .component.inline-notification*/.component.notification.sc-sdx-card,.component.inline-notification.sc-sdx-card{flex-direction:row;gap:16px}/*!@.component.notification:not(.has-label) .label, .component.inline-notification:not(.has-label) .label*/.component.notification.sc-sdx-card:not(.has-label) .label.sc-sdx-card,.component.inline-notification.sc-sdx-card:not(.has-label) .label.sc-sdx-card{display:none}/*!@.component.notification.alert::before, .component.inline-notification.alert::before*/.component.notification.alert.sc-sdx-card::before,.component.inline-notification.alert.sc-sdx-card::before{background:#d12}/*!@.component.notification.alert .icon, .component.inline-notification.alert .icon*/.component.notification.alert.sc-sdx-card .icon.sc-sdx-card,.component.inline-notification.alert.sc-sdx-card .icon.sc-sdx-card{color:#d12}/*!@.component.notification.warning::before, .component.inline-notification.warning::before*/.component.notification.warning.sc-sdx-card::before,.component.inline-notification.warning.sc-sdx-card::before{background:#cf4a0c}/*!@.component.notification.warning .icon, .component.inline-notification.warning .icon*/.component.notification.warning.sc-sdx-card .icon.sc-sdx-card,.component.inline-notification.warning.sc-sdx-card .icon.sc-sdx-card{color:#cf4a0c}/*!@.component.notification.general::before, .component.inline-notification.general::before*/.component.notification.general.sc-sdx-card::before,.component.inline-notification.general.sc-sdx-card::before{background:#086adb}/*!@.component.notification.general .icon, .component.inline-notification.general .icon*/.component.notification.general.sc-sdx-card .icon.sc-sdx-card,.component.inline-notification.general.sc-sdx-card .icon.sc-sdx-card{color:#086adb}/*!@.component.notification.confirm::before, .component.notification.confirmation::before, .component.inline-notification.confirm::before, .component.inline-notification.confirmation::before*/.component.notification.confirm.sc-sdx-card::before,.component.notification.confirmation.sc-sdx-card::before,.component.inline-notification.confirm.sc-sdx-card::before,.component.inline-notification.confirmation.sc-sdx-card::before{background:#1b8712}/*!@.component.notification.confirm .icon, .component.notification.confirmation .icon, .component.inline-notification.confirm .icon, .component.inline-notification.confirmation .icon*/.component.notification.confirm.sc-sdx-card .icon.sc-sdx-card,.component.notification.confirmation.sc-sdx-card .icon.sc-sdx-card,.component.inline-notification.confirm.sc-sdx-card .icon.sc-sdx-card,.component.inline-notification.confirmation.sc-sdx-card .icon.sc-sdx-card{color:#1b8712}/*!@.component.notification .first,\n.component.notification .second, .component.inline-notification .first,\n.component.inline-notification .second*/.component.notification.sc-sdx-card .first.sc-sdx-card,.component.notification.sc-sdx-card .second.sc-sdx-card,.component.inline-notification.sc-sdx-card .first.sc-sdx-card,.component.inline-notification.sc-sdx-card .second.sc-sdx-card{padding:unset}/*!@.component.notification .first .icon, .component.inline-notification .first .icon*/.component.notification.sc-sdx-card .first.sc-sdx-card .icon.sc-sdx-card,.component.inline-notification.sc-sdx-card .first.sc-sdx-card .icon.sc-sdx-card{display:block;position:relative;left:3px}/*!@.component.notification .label, .component.inline-notification .label*/.component.notification.sc-sdx-card .label.sc-sdx-card,.component.inline-notification.sc-sdx-card .label.sc-sdx-card{flex-direction:row-reverse;justify-content:left}/*!@.component.notification .label .icon, .component.inline-notification .label .icon*/.component.notification.sc-sdx-card .label.sc-sdx-card .icon.sc-sdx-card,.component.inline-notification.sc-sdx-card .label.sc-sdx-card .icon.sc-sdx-card{visibility:hidden}/*!@.component.notification*/.component.notification.sc-sdx-card{padding:16px;position:relative;border-left:none}/*!@.component.notification::before*/.component.notification.sc-sdx-card::before{content:\"\";position:absolute;top:0;left:0;width:4px;height:100%}/*!@.component.notification .icon*/.component.notification.sc-sdx-card .icon.sc-sdx-card{font-size:24px}/*!@.component.inline-notification*/.component.inline-notification.sc-sdx-card{border:unset;border-radius:unset;box-shadow:unset;background:unset}/*!@.component.inline-notification:not(.has-label) .slot*/.component.inline-notification.sc-sdx-card:not(.has-label) .slot.sc-sdx-card{margin-top:3px}/*!@.component.interaction*/.component.interaction.sc-sdx-card{flex-direction:row;align-items:center;min-height:112px;text-decoration:none}/*!@.component.interaction .first*/.component.interaction.sc-sdx-card .first.sc-sdx-card{height:100%}/*!@.component.interaction .image*/.component.interaction.sc-sdx-card .image.sc-sdx-card{width:112px;height:100%}/*!@.component.interaction .label*/.component.interaction.sc-sdx-card .label.sc-sdx-card{align-items:center}/*!@.component.grey*/.component.grey.sc-sdx-card{background:#eef3f6}/*!@.component.orchid, .component.blue*/.component.orchid.sc-sdx-card,.component.blue.sc-sdx-card{border:none}/*!@.component.orchid,\n.component.orchid .label, .component.blue,\n.component.blue .label*/.component.orchid.sc-sdx-card,.component.orchid.sc-sdx-card .label.sc-sdx-card,.component.blue.sc-sdx-card,.component.blue.sc-sdx-card .label.sc-sdx-card{color:#fff}/*!@.component.orchid*/.component.orchid.sc-sdx-card{background:#a63297;box-shadow:0px 4px 16px 0px rgba(166, 50, 151, 0.25)}/*!@.component.blue*/.component.blue.sc-sdx-card{background:#086adb;box-shadow:0px 4px 16px 0px rgba(8, 106, 219, 0.25)}/*!@.component.gradient .first*/.component.gradient.sc-sdx-card .first.sc-sdx-card{-webkit-mask-image:url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" viewBox=\"0 0 360 122\" fill=\"rgb(0, 0, 0)\"><path d=\"M0,83.9V0h360v84.5C319,107.3,253.9,122,180.5,122C106.5,122,40.9,107,0,83.9z\"/></svg>');mask-image:url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" viewBox=\"0 0 360 122\" fill=\"rgb(0, 0, 0)\"><path d=\"M0,83.9V0h360v84.5C319,107.3,253.9,122,180.5,122C106.5,122,40.9,107,0,83.9z\"/></svg>');mask-size:100% 100%;display:flex;height:122px;color:#fff;align-items:center;justify-content:center}/*!@.component.gradient .first .icon*/.component.gradient.sc-sdx-card .first.sc-sdx-card .icon.sc-sdx-card{display:block;font-size:56px}/*!@.component.gradient .second*/.component.gradient.sc-sdx-card .second.sc-sdx-card{align-items:center}/*!@.component.gradient .label .icon*/.component.gradient.sc-sdx-card .label.sc-sdx-card .icon.sc-sdx-card{display:none}/*!@.component.split*/.component.split.sc-sdx-card{flex-direction:column-reverse}@media (min-width: 1024px){/*!@.component.split*/.component.split.sc-sdx-card{flex-direction:row}}/*!@.component.split.gradient-1 .first*/.component.split.gradient-1.sc-sdx-card .first.sc-sdx-card{color:#fff}/*!@.component.split .first,\n.component.split .second*/.component.split.sc-sdx-card .first.sc-sdx-card,.component.split.sc-sdx-card .second.sc-sdx-card{padding:16px;gap:16px;flex-basis:50%}@media (min-width: 1024px){/*!@.component.split .first,\n  .component.split .second*/.component.split.sc-sdx-card .first.sc-sdx-card,.component.split.sc-sdx-card .second.sc-sdx-card{padding:24px;gap:24px}}/*!@.component .first .icon*/.component.sc-sdx-card .first.sc-sdx-card .icon.sc-sdx-card{display:none}/*!@.component .second*/.component.sc-sdx-card .second.sc-sdx-card{padding:16px;gap:16px;flex:1;display:flex;flex-direction:column}@media (min-width: 1024px){/*!@.component .second*/.component.sc-sdx-card .second.sc-sdx-card{padding:24px;gap:24px}}/*!@.component .image*/.component.sc-sdx-card .image.sc-sdx-card{width:100%;height:180px;object-position:center;object-fit:cover;vertical-align:bottom}/*!@.component .label*/.component.sc-sdx-card .label.sc-sdx-card{font-weight:600;margin-bottom:0;display:flex;gap:8px;color:#015}/*!@.component .label .chevron*/.component.sc-sdx-card .label.sc-sdx-card .chevron.sc-sdx-card{color:#086adb;margin-left:auto;margin-right:-8px}/*!@.component .label .chevron:hover,\n.component.interaction:hover .label .chevron*/.component.sc-sdx-card .label.sc-sdx-card .chevron.sc-sdx-card:hover,.component.interaction.sc-sdx-card:hover .label.sc-sdx-card .chevron.sc-sdx-card{color:#0048cf}/*!@.component .icon*/.component.sc-sdx-card .icon.sc-sdx-card{font-size:24px}@media (min-width: 1024px){/*!@.component .icon*/.component.sc-sdx-card .icon.sc-sdx-card{font-size:32px}}/*!@.component .slot*/.component.sc-sdx-card .slot.sc-sdx-card{flex-grow:1}/*!@.component .link::before*/.component.sc-sdx-card .link.sc-sdx-card::before{font-family:sdx-icons;content:\"\\e00f\"}/*!@.component.sdx--dark-theme*/.component.sdx--dark-theme.sc-sdx-card{border-color:#5c5c5c;box-shadow:none;background:#222}/*!@.component.sdx--dark-theme.inline-notification.alert, .component.sdx--dark-theme.inline-notification.warning, .component.sdx--dark-theme.inline-notification.general, .component.sdx--dark-theme.inline-notification.confirm*/.component.sdx--dark-theme.inline-notification.alert.sc-sdx-card,.component.sdx--dark-theme.inline-notification.warning.sc-sdx-card,.component.sdx--dark-theme.inline-notification.general.sc-sdx-card,.component.sdx--dark-theme.inline-notification.confirm.sc-sdx-card{background-color:transparent}/*!@.component.sdx--dark-theme.notification.alert::before, .component.sdx--dark-theme.inline-notification.alert::before*/.component.sdx--dark-theme.notification.alert.sc-sdx-card::before,.component.sdx--dark-theme.inline-notification.alert.sc-sdx-card::before{background:#eb1224}/*!@.component.sdx--dark-theme.notification.alert .icon, .component.sdx--dark-theme.inline-notification.alert .icon*/.component.sdx--dark-theme.notification.alert.sc-sdx-card .icon.sc-sdx-card,.component.sdx--dark-theme.inline-notification.alert.sc-sdx-card .icon.sc-sdx-card{color:#eb1224}/*!@.component.sdx--dark-theme.notification.warning::before, .component.sdx--dark-theme.inline-notification.warning::before*/.component.sdx--dark-theme.notification.warning.sc-sdx-card::before,.component.sdx--dark-theme.inline-notification.warning.sc-sdx-card::before{background:#ce4a0c}/*!@.component.sdx--dark-theme.notification.warning .icon, .component.sdx--dark-theme.inline-notification.warning .icon*/.component.sdx--dark-theme.notification.warning.sc-sdx-card .icon.sc-sdx-card,.component.sdx--dark-theme.inline-notification.warning.sc-sdx-card .icon.sc-sdx-card{color:#ce4a0c}/*!@.component.sdx--dark-theme.notification.general::before, .component.sdx--dark-theme.inline-notification.general::before*/.component.sdx--dark-theme.notification.general.sc-sdx-card::before,.component.sdx--dark-theme.inline-notification.general.sc-sdx-card::before{background:#0a71e9}/*!@.component.sdx--dark-theme.notification.general .icon, .component.sdx--dark-theme.inline-notification.general .icon*/.component.sdx--dark-theme.notification.general.sc-sdx-card .icon.sc-sdx-card,.component.sdx--dark-theme.inline-notification.general.sc-sdx-card .icon.sc-sdx-card{color:#0a71e9}/*!@.component.sdx--dark-theme.notification.confirm::before, .component.sdx--dark-theme.notification.confirmation::before, .component.sdx--dark-theme.inline-notification.confirm::before, .component.sdx--dark-theme.inline-notification.confirmation::before*/.component.sdx--dark-theme.notification.confirm.sc-sdx-card::before,.component.sdx--dark-theme.notification.confirmation.sc-sdx-card::before,.component.sdx--dark-theme.inline-notification.confirm.sc-sdx-card::before,.component.sdx--dark-theme.inline-notification.confirmation.sc-sdx-card::before{background:#1c8912}/*!@.component.sdx--dark-theme.notification.confirm .icon, .component.sdx--dark-theme.notification.confirmation .icon, .component.sdx--dark-theme.inline-notification.confirm .icon, .component.sdx--dark-theme.inline-notification.confirmation .icon*/.component.sdx--dark-theme.notification.confirm.sc-sdx-card .icon.sc-sdx-card,.component.sdx--dark-theme.notification.confirmation.sc-sdx-card .icon.sc-sdx-card,.component.sdx--dark-theme.inline-notification.confirm.sc-sdx-card .icon.sc-sdx-card,.component.sdx--dark-theme.inline-notification.confirmation.sc-sdx-card .icon.sc-sdx-card{color:#1c8912}/*!@.component.sdx--dark-theme.grey*/.component.sdx--dark-theme.grey.sc-sdx-card{background:#222}/*!@.component.sdx--dark-theme.orchid*/.component.sdx--dark-theme.orchid.sc-sdx-card{background:#a54c9b;box-shadow:rgba(165, 76, 155, 0.25)}/*!@.component.sdx--dark-theme.blue*/.component.sdx--dark-theme.blue.sc-sdx-card{background:#0a71e9;box-shadow:rgba(10, 113, 233, 0.25)}/*!@.component.sdx--dark-theme .label*/.component.sdx--dark-theme.sc-sdx-card .label.sc-sdx-card{color:#e6e6e6}/*!@.component.sdx--dark-theme .label .chevron*/.component.sdx--dark-theme.sc-sdx-card .label.sc-sdx-card .chevron.sc-sdx-card{color:#4294ff}/*!@.component.sdx--dark-theme .label .chevron:hover,\n.component.sdx--dark-theme .label .component.interaction:hover .chevron,\n.component.interaction:hover .component.sdx--dark-theme .label .chevron,\n.component.sdx--dark-theme.interaction:hover .label .chevron*/.component.sdx--dark-theme.sc-sdx-card .label.sc-sdx-card .chevron.sc-sdx-card:hover,.component.sdx--dark-theme.sc-sdx-card .label.sc-sdx-card .component.interaction.sc-sdx-card:hover .chevron.sc-sdx-card,.component.interaction.sc-sdx-card:hover .component.sdx--dark-theme.sc-sdx-card .label.sc-sdx-card .chevron.sc-sdx-card,.component.sdx--dark-theme.interaction.sc-sdx-card:hover .label.sc-sdx-card .chevron.sc-sdx-card{color:#5ca3ff}";

class Card {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.layout = "default";
    this.background = undefined;
    this.label = "";
    this.labelAriaLevel = undefined;
    this.iconName = undefined;
    this.imageSrc = "";
    this.imageAlt = "";
    this.objectFit = undefined;
    this.notificationType = "general";
    this.href = undefined;
    this.hrefLabel = undefined;
    this.hrefAriaLabel = undefined;
    this.gradient = undefined;
  }
  hasInteractionArea() {
    if (this.isInteractionCardWithoutLabel()) {
      return false;
    }
    return hasSlot(this.el, "interaction") || (!!this.href && !!this.hrefLabel);
  }
  isNotificationishCard() {
    const layout = this.getLayout();
    return layout === "notification" || layout === "inline-notification";
  }
  isInteractionCardWithoutLabel() {
    return this.getLayout() === "interaction" && !this.label && !this.iconName;
  }
  getLayout() {
    return this.gradient ? "gradient" : this.layout;
  }
  getIconName() {
    // The icon can be overwritten, but if none is set, fall back to the
    // associated default
    if (this.iconName) {
      return this.iconName;
    }
    if (!this.isNotificationishCard()) {
      return this.iconName;
    }
    switch (this.notificationType) {
      case "confirm":
      case "confirmation":
        return "icon-check-mark-2-circle";
      case "warning":
      case "alert":
        return "icon-exclamation-mark-circle";
      default:
        return "icon-information-circle";
    }
  }
  getSrHint() {
    const layout = this.getLayout();
    if (layout !== "notification" && layout !== "inline-notification") {
      return;
    }
    switch (this.notificationType) {
      case "confirm":
      case "confirmation":
        return "This is a confirmation message.";
      case "alert":
        return "This is an alert message.";
      case "warning":
        return "This is a warning message.";
      default:
        return "This is an information message.";
    }
  }
  createIcon(srHint) {
    const iconName = this.getIconName();
    if (!iconName) {
      return;
    }
    return hAsync("sdx-icon", { class: "icon", iconName: iconName, "sr-hint": srHint });
  }
  getComponentClassNames() {
    return {
      component: true,
      "has-label": !!this.label,
      [getAppearance(this.el)]: true,
      [this.getLayout()]: true,
      [this.notificationType]: true,
      [this.background || ""]: true,
    };
  }
  getLabelClassNames() {
    const layout = this.getLayout();
    return {
      label: true,
      h4: true,
      h5: layout === "notification" || this.isInteractionCardWithoutLabel(),
    };
  }
  getLinkClassNames() {
    return {
      link: true,
      "link--white": this.background === "orchid" || this.background === "blue",
      "icon-chevron-normal-right": true,
    };
  }
  render() {
    const { label } = this;
    const layout = this.getLayout();
    const iconName = this.getIconName();
    const Tag = layout === "interaction" ? "a" : "div";
    return (hAsync(Tag, { class: this.getComponentClassNames(), href: this.href }, hAsync("div", { class: "first" }, this.imageSrc && (hAsync("img", { class: "image", src: this.imageSrc, alt: this.imageAlt, style: { objectFit: this.objectFit } })), this.createIcon(this.getSrHint()), hAsync("slot", { name: "first" })), hAsync("div", { class: "second" }, (label ||
      iconName ||
      this.isInteractionCardWithoutLabel()) /* for chevron */ && (hAsync("div", { class: this.getLabelClassNames(), role: !this.isInteractionCardWithoutLabel() && this.labelAriaLevel
        ? "heading"
        : undefined, "aria-level": !this.isInteractionCardWithoutLabel()
        ? this.labelAriaLevel
        : undefined }, this.createIcon(), label, this.isInteractionCardWithoutLabel() && (hAsync(Fragment, null, this.hrefLabel, hAsync("sdx-icon", { class: "chevron", iconName: "icon-chevron-normal-right", size: 2 }))))), hasSlot(this.el) && (hAsync("div", { class: "slot" }, hAsync("slot", null))), this.hasInteractionArea() && (hAsync("div", { class: "interaction-area" }, hAsync("slot", { name: "interaction" }), this.href && this.hrefLabel && (hAsync("a", { href: this.href, class: this.getLinkClassNames(), "aria-label": this.hrefAriaLabel }, this.hrefLabel)))))));
  }
  get el() { return getElement(this); }
  static get style() { return cardCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-card",
    "$members$": {
      "layout": [1],
      "background": [1],
      "label": [1],
      "labelAriaLevel": [2, "label-aria-level"],
      "iconName": [1, "icon-name"],
      "imageSrc": [1, "image-src"],
      "imageAlt": [1, "image-alt"],
      "objectFit": [1, "object-fit"],
      "notificationType": [1, "notification-type"],
      "href": [1],
      "hrefLabel": [1, "href-label"],
      "hrefAriaLabel": [1, "href-aria-label"],
      "gradient": [4]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire();
		}
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var codemirror = createCommonjsModule(function (module, exports) {
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

// This is CodeMirror (https://codemirror.net), a code editor
// implemented in JavaScript on top of the browser's DOM.
//
// You can find some technical background for some of the code below
// at http://marijnhaverbeke.nl/blog/#cm-internals .

(function (global, factory) {
  module.exports = factory() ;
}(commonjsGlobal, (function () {
  // Kludges for bugs and behavior differences that can't be feature
  // detected are enabled based on userAgent etc sniffing.
  var userAgent = navigator.userAgent;
  var platform = navigator.platform;

  var gecko = /gecko\/\d/i.test(userAgent);
  var ie_upto10 = /MSIE \d/.test(userAgent);
  var ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent);
  var edge = /Edge\/(\d+)/.exec(userAgent);
  var ie = ie_upto10 || ie_11up || edge;
  var ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]);
  var webkit = !edge && /WebKit\//.test(userAgent);
  var qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent);
  var chrome = !edge && /Chrome\//.test(userAgent);
  var presto = /Opera\//.test(userAgent);
  var safari = /Apple Computer/.test(navigator.vendor);
  var mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent);
  var phantom = /PhantomJS/.test(userAgent);

  var ios = safari && (/Mobile\/\w+/.test(userAgent) || navigator.maxTouchPoints > 2);
  var android = /Android/.test(userAgent);
  // This is woefully incomplete. Suggestions for alternative methods welcome.
  var mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent);
  var mac = ios || /Mac/.test(platform);
  var chromeOS = /\bCrOS\b/.test(userAgent);
  var windows = /win/i.test(platform);

  var presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
  if (presto_version) { presto_version = Number(presto_version[1]); }
  if (presto_version && presto_version >= 15) { presto = false; webkit = true; }
  // Some browsers use the wrong event properties to signal cmd/ctrl on OS X
  var flipCtrlCmd = mac && (qtwebkit || presto && (presto_version == null || presto_version < 12.11));
  var captureRightClick = gecko || (ie && ie_version >= 9);

  function classTest(cls) { return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*") }

  var rmClass = function(node, cls) {
    var current = node.className;
    var match = classTest(cls).exec(current);
    if (match) {
      var after = current.slice(match.index + match[0].length);
      node.className = current.slice(0, match.index) + (after ? match[1] + after : "");
    }
  };

  function removeChildren(e) {
    for (var count = e.childNodes.length; count > 0; --count)
      { e.removeChild(e.firstChild); }
    return e
  }

  function removeChildrenAndAdd(parent, e) {
    return removeChildren(parent).appendChild(e)
  }

  function elt(tag, content, className, style) {
    var e = document.createElement(tag);
    if (className) { e.className = className; }
    if (style) { e.style.cssText = style; }
    if (typeof content == "string") { e.appendChild(document.createTextNode(content)); }
    else if (content) { for (var i = 0; i < content.length; ++i) { e.appendChild(content[i]); } }
    return e
  }
  // wrapper for elt, which removes the elt from the accessibility tree
  function eltP(tag, content, className, style) {
    var e = elt(tag, content, className, style);
    e.setAttribute("role", "presentation");
    return e
  }

  var range;
  if (document.createRange) { range = function(node, start, end, endNode) {
    var r = document.createRange();
    r.setEnd(endNode || node, end);
    r.setStart(node, start);
    return r
  }; }
  else { range = function(node, start, end) {
    var r = document.body.createTextRange();
    try { r.moveToElementText(node.parentNode); }
    catch(e) { return r }
    r.collapse(true);
    r.moveEnd("character", end);
    r.moveStart("character", start);
    return r
  }; }

  function contains(parent, child) {
    if (child.nodeType == 3) // Android browser always returns false when child is a textnode
      { child = child.parentNode; }
    if (parent.contains)
      { return parent.contains(child) }
    do {
      if (child.nodeType == 11) { child = child.host; }
      if (child == parent) { return true }
    } while (child = child.parentNode)
  }

  function activeElt() {
    // IE and Edge may throw an "Unspecified Error" when accessing document.activeElement.
    // IE < 10 will throw when accessed while the page is loading or in an iframe.
    // IE > 9 and Edge will throw when accessed in an iframe if document.body is unavailable.
    var activeElement;
    try {
      activeElement = document.activeElement;
    } catch(e) {
      activeElement = document.body || null;
    }
    while (activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement)
      { activeElement = activeElement.shadowRoot.activeElement; }
    return activeElement
  }

  function addClass(node, cls) {
    var current = node.className;
    if (!classTest(cls).test(current)) { node.className += (current ? " " : "") + cls; }
  }
  function joinClasses(a, b) {
    var as = a.split(" ");
    for (var i = 0; i < as.length; i++)
      { if (as[i] && !classTest(as[i]).test(b)) { b += " " + as[i]; } }
    return b
  }

  var selectInput = function(node) { node.select(); };
  if (ios) // Mobile Safari apparently has a bug where select() is broken.
    { selectInput = function(node) { node.selectionStart = 0; node.selectionEnd = node.value.length; }; }
  else if (ie) // Suppress mysterious IE10 errors
    { selectInput = function(node) { try { node.select(); } catch(_e) {} }; }

  function bind(f) {
    var args = Array.prototype.slice.call(arguments, 1);
    return function(){return f.apply(null, args)}
  }

  function copyObj(obj, target, overwrite) {
    if (!target) { target = {}; }
    for (var prop in obj)
      { if (obj.hasOwnProperty(prop) && (overwrite !== false || !target.hasOwnProperty(prop)))
        { target[prop] = obj[prop]; } }
    return target
  }

  // Counts the column offset in a string, taking tabs into account.
  // Used mostly to find indentation.
  function countColumn(string, end, tabSize, startIndex, startValue) {
    if (end == null) {
      end = string.search(/[^\s\u00a0]/);
      if (end == -1) { end = string.length; }
    }
    for (var i = startIndex || 0, n = startValue || 0;;) {
      var nextTab = string.indexOf("\t", i);
      if (nextTab < 0 || nextTab >= end)
        { return n + (end - i) }
      n += nextTab - i;
      n += tabSize - (n % tabSize);
      i = nextTab + 1;
    }
  }

  var Delayed = function() {
    this.id = null;
    this.f = null;
    this.time = 0;
    this.handler = bind(this.onTimeout, this);
  };
  Delayed.prototype.onTimeout = function (self) {
    self.id = 0;
    if (self.time <= +new Date) {
      self.f();
    } else {
      setTimeout(self.handler, self.time - +new Date);
    }
  };
  Delayed.prototype.set = function (ms, f) {
    this.f = f;
    var time = +new Date + ms;
    if (!this.id || time < this.time) {
      clearTimeout(this.id);
      this.id = setTimeout(this.handler, ms);
      this.time = time;
    }
  };

  function indexOf(array, elt) {
    for (var i = 0; i < array.length; ++i)
      { if (array[i] == elt) { return i } }
    return -1
  }

  // Number of pixels added to scroller and sizer to hide scrollbar
  var scrollerGap = 50;

  // Returned or thrown by various protocols to signal 'I'm not
  // handling this'.
  var Pass = {toString: function(){return "CodeMirror.Pass"}};

  // Reused option objects for setSelection & friends
  var sel_dontScroll = {scroll: false}, sel_mouse = {origin: "*mouse"}, sel_move = {origin: "+move"};

  // The inverse of countColumn -- find the offset that corresponds to
  // a particular column.
  function findColumn(string, goal, tabSize) {
    for (var pos = 0, col = 0;;) {
      var nextTab = string.indexOf("\t", pos);
      if (nextTab == -1) { nextTab = string.length; }
      var skipped = nextTab - pos;
      if (nextTab == string.length || col + skipped >= goal)
        { return pos + Math.min(skipped, goal - col) }
      col += nextTab - pos;
      col += tabSize - (col % tabSize);
      pos = nextTab + 1;
      if (col >= goal) { return pos }
    }
  }

  var spaceStrs = [""];
  function spaceStr(n) {
    while (spaceStrs.length <= n)
      { spaceStrs.push(lst(spaceStrs) + " "); }
    return spaceStrs[n]
  }

  function lst(arr) { return arr[arr.length-1] }

  function map(array, f) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = f(array[i], i); }
    return out
  }

  function insertSorted(array, value, score) {
    var pos = 0, priority = score(value);
    while (pos < array.length && score(array[pos]) <= priority) { pos++; }
    array.splice(pos, 0, value);
  }

  function nothing() {}

  function createObj(base, props) {
    var inst;
    if (Object.create) {
      inst = Object.create(base);
    } else {
      nothing.prototype = base;
      inst = new nothing();
    }
    if (props) { copyObj(props, inst); }
    return inst
  }

  var nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/;
  function isWordCharBasic(ch) {
    return /\w/.test(ch) || ch > "\x80" &&
      (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
  }
  function isWordChar(ch, helper) {
    if (!helper) { return isWordCharBasic(ch) }
    if (helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) { return true }
    return helper.test(ch)
  }

  function isEmpty(obj) {
    for (var n in obj) { if (obj.hasOwnProperty(n) && obj[n]) { return false } }
    return true
  }

  // Extending unicode characters. A series of a non-extending char +
  // any number of extending chars is treated as a single unit as far
  // as editing and measuring is concerned. This is not fully correct,
  // since some scripts/fonts/browsers also treat other configurations
  // of code points as a group.
  var extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/;
  function isExtendingChar(ch) { return ch.charCodeAt(0) >= 768 && extendingChars.test(ch) }

  // Returns a number from the range [`0`; `str.length`] unless `pos` is outside that range.
  function skipExtendingChars(str, pos, dir) {
    while ((dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos))) { pos += dir; }
    return pos
  }

  // Returns the value from the range [`from`; `to`] that satisfies
  // `pred` and is closest to `from`. Assumes that at least `to`
  // satisfies `pred`. Supports `from` being greater than `to`.
  function findFirst(pred, from, to) {
    // At any point we are certain `to` satisfies `pred`, don't know
    // whether `from` does.
    var dir = from > to ? -1 : 1;
    for (;;) {
      if (from == to) { return from }
      var midF = (from + to) / 2, mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
      if (mid == from) { return pred(mid) ? from : to }
      if (pred(mid)) { to = mid; }
      else { from = mid + dir; }
    }
  }

  // BIDI HELPERS

  function iterateBidiSections(order, from, to, f) {
    if (!order) { return f(from, to, "ltr", 0) }
    var found = false;
    for (var i = 0; i < order.length; ++i) {
      var part = order[i];
      if (part.from < to && part.to > from || from == to && part.to == from) {
        f(Math.max(part.from, from), Math.min(part.to, to), part.level == 1 ? "rtl" : "ltr", i);
        found = true;
      }
    }
    if (!found) { f(from, to, "ltr"); }
  }

  var bidiOther = null;
  function getBidiPartAt(order, ch, sticky) {
    var found;
    bidiOther = null;
    for (var i = 0; i < order.length; ++i) {
      var cur = order[i];
      if (cur.from < ch && cur.to > ch) { return i }
      if (cur.to == ch) {
        if (cur.from != cur.to && sticky == "before") { found = i; }
        else { bidiOther = i; }
      }
      if (cur.from == ch) {
        if (cur.from != cur.to && sticky != "before") { found = i; }
        else { bidiOther = i; }
      }
    }
    return found != null ? found : bidiOther
  }

  // Bidirectional ordering algorithm
  // See http://unicode.org/reports/tr9/tr9-13.html for the algorithm
  // that this (partially) implements.

  // One-char codes used for character types:
  // L (L):   Left-to-Right
  // R (R):   Right-to-Left
  // r (AL):  Right-to-Left Arabic
  // 1 (EN):  European Number
  // + (ES):  European Number Separator
  // % (ET):  European Number Terminator
  // n (AN):  Arabic Number
  // , (CS):  Common Number Separator
  // m (NSM): Non-Spacing Mark
  // b (BN):  Boundary Neutral
  // s (B):   Paragraph Separator
  // t (S):   Segment Separator
  // w (WS):  Whitespace
  // N (ON):  Other Neutrals

  // Returns null if characters are ordered as they appear
  // (left-to-right), or an array of sections ({from, to, level}
  // objects) in the order in which they occur visually.
  var bidiOrdering = (function() {
    // Character types for codepoints 0 to 0xff
    var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN";
    // Character types for codepoints 0x600 to 0x6f9
    var arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111";
    function charType(code) {
      if (code <= 0xf7) { return lowTypes.charAt(code) }
      else if (0x590 <= code && code <= 0x5f4) { return "R" }
      else if (0x600 <= code && code <= 0x6f9) { return arabicTypes.charAt(code - 0x600) }
      else if (0x6ee <= code && code <= 0x8ac) { return "r" }
      else if (0x2000 <= code && code <= 0x200b) { return "w" }
      else if (code == 0x200c) { return "b" }
      else { return "L" }
    }

    var bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
    var isNeutral = /[stwN]/, isStrong = /[LRr]/, countsAsLeft = /[Lb1n]/, countsAsNum = /[1n]/;

    function BidiSpan(level, from, to) {
      this.level = level;
      this.from = from; this.to = to;
    }

    return function(str, direction) {
      var outerType = direction == "ltr" ? "L" : "R";

      if (str.length == 0 || direction == "ltr" && !bidiRE.test(str)) { return false }
      var len = str.length, types = [];
      for (var i = 0; i < len; ++i)
        { types.push(charType(str.charCodeAt(i))); }

      // W1. Examine each non-spacing mark (NSM) in the level run, and
      // change the type of the NSM to the type of the previous
      // character. If the NSM is at the start of the level run, it will
      // get the type of sor.
      for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
        var type = types[i$1];
        if (type == "m") { types[i$1] = prev; }
        else { prev = type; }
      }

      // W2. Search backwards from each instance of a European number
      // until the first strong type (R, L, AL, or sor) is found. If an
      // AL is found, change the type of the European number to Arabic
      // number.
      // W3. Change all ALs to R.
      for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
        var type$1 = types[i$2];
        if (type$1 == "1" && cur == "r") { types[i$2] = "n"; }
        else if (isStrong.test(type$1)) { cur = type$1; if (type$1 == "r") { types[i$2] = "R"; } }
      }

      // W4. A single European separator between two European numbers
      // changes to a European number. A single common separator between
      // two numbers of the same type changes to that type.
      for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
        var type$2 = types[i$3];
        if (type$2 == "+" && prev$1 == "1" && types[i$3+1] == "1") { types[i$3] = "1"; }
        else if (type$2 == "," && prev$1 == types[i$3+1] &&
                 (prev$1 == "1" || prev$1 == "n")) { types[i$3] = prev$1; }
        prev$1 = type$2;
      }

      // W5. A sequence of European terminators adjacent to European
      // numbers changes to all European numbers.
      // W6. Otherwise, separators and terminators change to Other
      // Neutral.
      for (var i$4 = 0; i$4 < len; ++i$4) {
        var type$3 = types[i$4];
        if (type$3 == ",") { types[i$4] = "N"; }
        else if (type$3 == "%") {
          var end = (void 0);
          for (end = i$4 + 1; end < len && types[end] == "%"; ++end) {}
          var replace = (i$4 && types[i$4-1] == "!") || (end < len && types[end] == "1") ? "1" : "N";
          for (var j = i$4; j < end; ++j) { types[j] = replace; }
          i$4 = end - 1;
        }
      }

      // W7. Search backwards from each instance of a European number
      // until the first strong type (R, L, or sor) is found. If an L is
      // found, then change the type of the European number to L.
      for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
        var type$4 = types[i$5];
        if (cur$1 == "L" && type$4 == "1") { types[i$5] = "L"; }
        else if (isStrong.test(type$4)) { cur$1 = type$4; }
      }

      // N1. A sequence of neutrals takes the direction of the
      // surrounding strong text if the text on both sides has the same
      // direction. European and Arabic numbers act as if they were R in
      // terms of their influence on neutrals. Start-of-level-run (sor)
      // and end-of-level-run (eor) are used at level run boundaries.
      // N2. Any remaining neutrals take the embedding direction.
      for (var i$6 = 0; i$6 < len; ++i$6) {
        if (isNeutral.test(types[i$6])) {
          var end$1 = (void 0);
          for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1) {}
          var before = (i$6 ? types[i$6-1] : outerType) == "L";
          var after = (end$1 < len ? types[end$1] : outerType) == "L";
          var replace$1 = before == after ? (before ? "L" : "R") : outerType;
          for (var j$1 = i$6; j$1 < end$1; ++j$1) { types[j$1] = replace$1; }
          i$6 = end$1 - 1;
        }
      }

      // Here we depart from the documented algorithm, in order to avoid
      // building up an actual levels array. Since there are only three
      // levels (0, 1, 2) in an implementation that doesn't take
      // explicit embedding into account, we can build up the order on
      // the fly, without following the level-based algorithm.
      var order = [], m;
      for (var i$7 = 0; i$7 < len;) {
        if (countsAsLeft.test(types[i$7])) {
          var start = i$7;
          for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7) {}
          order.push(new BidiSpan(0, start, i$7));
        } else {
          var pos = i$7, at = order.length, isRTL = direction == "rtl" ? 1 : 0;
          for (++i$7; i$7 < len && types[i$7] != "L"; ++i$7) {}
          for (var j$2 = pos; j$2 < i$7;) {
            if (countsAsNum.test(types[j$2])) {
              if (pos < j$2) { order.splice(at, 0, new BidiSpan(1, pos, j$2)); at += isRTL; }
              var nstart = j$2;
              for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2) {}
              order.splice(at, 0, new BidiSpan(2, nstart, j$2));
              at += isRTL;
              pos = j$2;
            } else { ++j$2; }
          }
          if (pos < i$7) { order.splice(at, 0, new BidiSpan(1, pos, i$7)); }
        }
      }
      if (direction == "ltr") {
        if (order[0].level == 1 && (m = str.match(/^\s+/))) {
          order[0].from = m[0].length;
          order.unshift(new BidiSpan(0, 0, m[0].length));
        }
        if (lst(order).level == 1 && (m = str.match(/\s+$/))) {
          lst(order).to -= m[0].length;
          order.push(new BidiSpan(0, len - m[0].length, len));
        }
      }

      return direction == "rtl" ? order.reverse() : order
    }
  })();

  // Get the bidi ordering for the given line (and cache it). Returns
  // false for lines that are fully left-to-right, and an array of
  // BidiSpan objects otherwise.
  function getOrder(line, direction) {
    var order = line.order;
    if (order == null) { order = line.order = bidiOrdering(line.text, direction); }
    return order
  }

  // EVENT HANDLING

  // Lightweight event framework. on/off also work on DOM nodes,
  // registering native DOM handlers.

  var noHandlers = [];

  var on = function(emitter, type, f) {
    if (emitter.addEventListener) {
      emitter.addEventListener(type, f, false);
    } else if (emitter.attachEvent) {
      emitter.attachEvent("on" + type, f);
    } else {
      var map = emitter._handlers || (emitter._handlers = {});
      map[type] = (map[type] || noHandlers).concat(f);
    }
  };

  function getHandlers(emitter, type) {
    return emitter._handlers && emitter._handlers[type] || noHandlers
  }

  function off(emitter, type, f) {
    if (emitter.removeEventListener) {
      emitter.removeEventListener(type, f, false);
    } else if (emitter.detachEvent) {
      emitter.detachEvent("on" + type, f);
    } else {
      var map = emitter._handlers, arr = map && map[type];
      if (arr) {
        var index = indexOf(arr, f);
        if (index > -1)
          { map[type] = arr.slice(0, index).concat(arr.slice(index + 1)); }
      }
    }
  }

  function signal(emitter, type /*, values...*/) {
    var handlers = getHandlers(emitter, type);
    if (!handlers.length) { return }
    var args = Array.prototype.slice.call(arguments, 2);
    for (var i = 0; i < handlers.length; ++i) { handlers[i].apply(null, args); }
  }

  // The DOM events that CodeMirror handles can be overridden by
  // registering a (non-DOM) handler on the editor for the event name,
  // and preventDefault-ing the event in that handler.
  function signalDOMEvent(cm, e, override) {
    if (typeof e == "string")
      { e = {type: e, preventDefault: function() { this.defaultPrevented = true; }}; }
    signal(cm, override || e.type, cm, e);
    return e_defaultPrevented(e) || e.codemirrorIgnore
  }

  function signalCursorActivity(cm) {
    var arr = cm._handlers && cm._handlers.cursorActivity;
    if (!arr) { return }
    var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []);
    for (var i = 0; i < arr.length; ++i) { if (indexOf(set, arr[i]) == -1)
      { set.push(arr[i]); } }
  }

  function hasHandler(emitter, type) {
    return getHandlers(emitter, type).length > 0
  }

  // Add on and off methods to a constructor's prototype, to make
  // registering events on such objects more convenient.
  function eventMixin(ctor) {
    ctor.prototype.on = function(type, f) {on(this, type, f);};
    ctor.prototype.off = function(type, f) {off(this, type, f);};
  }

  // Due to the fact that we still support jurassic IE versions, some
  // compatibility wrappers are needed.

  function e_preventDefault(e) {
    if (e.preventDefault) { e.preventDefault(); }
    else { e.returnValue = false; }
  }
  function e_stopPropagation(e) {
    if (e.stopPropagation) { e.stopPropagation(); }
    else { e.cancelBubble = true; }
  }
  function e_defaultPrevented(e) {
    return e.defaultPrevented != null ? e.defaultPrevented : e.returnValue == false
  }
  function e_stop(e) {e_preventDefault(e); e_stopPropagation(e);}

  function e_target(e) {return e.target || e.srcElement}
  function e_button(e) {
    var b = e.which;
    if (b == null) {
      if (e.button & 1) { b = 1; }
      else if (e.button & 2) { b = 3; }
      else if (e.button & 4) { b = 2; }
    }
    if (mac && e.ctrlKey && b == 1) { b = 3; }
    return b
  }

  // Detect drag-and-drop
  var dragAndDrop = function() {
    // There is *some* kind of drag-and-drop support in IE6-8, but I
    // couldn't get it to work yet.
    if (ie && ie_version < 9) { return false }
    var div = elt('div');
    return "draggable" in div || "dragDrop" in div
  }();

  var zwspSupported;
  function zeroWidthElement(measure) {
    if (zwspSupported == null) {
      var test = elt("span", "\u200b");
      removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")]));
      if (measure.firstChild.offsetHeight != 0)
        { zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8); }
    }
    var node = zwspSupported ? elt("span", "\u200b") :
      elt("span", "\u00a0", null, "display: inline-block; width: 1px; margin-right: -1px");
    node.setAttribute("cm-text", "");
    return node
  }

  // Feature-detect IE's crummy client rect reporting for bidi text
  var badBidiRects;
  function hasBadBidiRects(measure) {
    if (badBidiRects != null) { return badBidiRects }
    var txt = removeChildrenAndAdd(measure, document.createTextNode("A\u062eA"));
    var r0 = range(txt, 0, 1).getBoundingClientRect();
    var r1 = range(txt, 1, 2).getBoundingClientRect();
    removeChildren(measure);
    if (!r0 || r0.left == r0.right) { return false } // Safari returns null in some cases (#2780)
    return badBidiRects = (r1.right - r0.right < 3)
  }

  // See if "".split is the broken IE version, if so, provide an
  // alternative way to split lines.
  var splitLinesAuto = "\n\nb".split(/\n/).length != 3 ? function (string) {
    var pos = 0, result = [], l = string.length;
    while (pos <= l) {
      var nl = string.indexOf("\n", pos);
      if (nl == -1) { nl = string.length; }
      var line = string.slice(pos, string.charAt(nl - 1) == "\r" ? nl - 1 : nl);
      var rt = line.indexOf("\r");
      if (rt != -1) {
        result.push(line.slice(0, rt));
        pos += rt + 1;
      } else {
        result.push(line);
        pos = nl + 1;
      }
    }
    return result
  } : function (string) { return string.split(/\r\n?|\n/); };

  var hasSelection = window.getSelection ? function (te) {
    try { return te.selectionStart != te.selectionEnd }
    catch(e) { return false }
  } : function (te) {
    var range;
    try {range = te.ownerDocument.selection.createRange();}
    catch(e) {}
    if (!range || range.parentElement() != te) { return false }
    return range.compareEndPoints("StartToEnd", range) != 0
  };

  var hasCopyEvent = (function () {
    var e = elt("div");
    if ("oncopy" in e) { return true }
    e.setAttribute("oncopy", "return;");
    return typeof e.oncopy == "function"
  })();

  var badZoomedRects = null;
  function hasBadZoomedRects(measure) {
    if (badZoomedRects != null) { return badZoomedRects }
    var node = removeChildrenAndAdd(measure, elt("span", "x"));
    var normal = node.getBoundingClientRect();
    var fromRange = range(node, 0, 1).getBoundingClientRect();
    return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
  }

  // Known modes, by name and by MIME
  var modes = {}, mimeModes = {};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  function defineMode(name, mode) {
    if (arguments.length > 2)
      { mode.dependencies = Array.prototype.slice.call(arguments, 2); }
    modes[name] = mode;
  }

  function defineMIME(mime, spec) {
    mimeModes[mime] = spec;
  }

  // Given a MIME type, a {name, ...options} config object, or a name
  // string, return a mode config object.
  function resolveMode(spec) {
    if (typeof spec == "string" && mimeModes.hasOwnProperty(spec)) {
      spec = mimeModes[spec];
    } else if (spec && typeof spec.name == "string" && mimeModes.hasOwnProperty(spec.name)) {
      var found = mimeModes[spec.name];
      if (typeof found == "string") { found = {name: found}; }
      spec = createObj(found, spec);
      spec.name = found.name;
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) {
      return resolveMode("application/xml")
    } else if (typeof spec == "string" && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) {
      return resolveMode("application/json")
    }
    if (typeof spec == "string") { return {name: spec} }
    else { return spec || {name: "null"} }
  }

  // Given a mode spec (anything that resolveMode accepts), find and
  // initialize an actual mode object.
  function getMode(options, spec) {
    spec = resolveMode(spec);
    var mfactory = modes[spec.name];
    if (!mfactory) { return getMode(options, "text/plain") }
    var modeObj = mfactory(options, spec);
    if (modeExtensions.hasOwnProperty(spec.name)) {
      var exts = modeExtensions[spec.name];
      for (var prop in exts) {
        if (!exts.hasOwnProperty(prop)) { continue }
        if (modeObj.hasOwnProperty(prop)) { modeObj["_" + prop] = modeObj[prop]; }
        modeObj[prop] = exts[prop];
      }
    }
    modeObj.name = spec.name;
    if (spec.helperType) { modeObj.helperType = spec.helperType; }
    if (spec.modeProps) { for (var prop$1 in spec.modeProps)
      { modeObj[prop$1] = spec.modeProps[prop$1]; } }

    return modeObj
  }

  // This can be used to attach properties to mode objects from
  // outside the actual mode definition.
  var modeExtensions = {};
  function extendMode(mode, properties) {
    var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : (modeExtensions[mode] = {});
    copyObj(properties, exts);
  }

  function copyState(mode, state) {
    if (state === true) { return state }
    if (mode.copyState) { return mode.copyState(state) }
    var nstate = {};
    for (var n in state) {
      var val = state[n];
      if (val instanceof Array) { val = val.concat([]); }
      nstate[n] = val;
    }
    return nstate
  }

  // Given a mode and a state (for that mode), find the inner mode and
  // state at the position that the state refers to.
  function innerMode(mode, state) {
    var info;
    while (mode.innerMode) {
      info = mode.innerMode(state);
      if (!info || info.mode == mode) { break }
      state = info.state;
      mode = info.mode;
    }
    return info || {mode: mode, state: state}
  }

  function startState(mode, a1, a2) {
    return mode.startState ? mode.startState(a1, a2) : true
  }

  // STRING STREAM

  // Fed to the mode parsers, provides helper functions to make
  // parsers more succinct.

  var StringStream = function(string, tabSize, lineOracle) {
    this.pos = this.start = 0;
    this.string = string;
    this.tabSize = tabSize || 8;
    this.lastColumnPos = this.lastColumnValue = 0;
    this.lineStart = 0;
    this.lineOracle = lineOracle;
  };

  StringStream.prototype.eol = function () {return this.pos >= this.string.length};
  StringStream.prototype.sol = function () {return this.pos == this.lineStart};
  StringStream.prototype.peek = function () {return this.string.charAt(this.pos) || undefined};
  StringStream.prototype.next = function () {
    if (this.pos < this.string.length)
      { return this.string.charAt(this.pos++) }
  };
  StringStream.prototype.eat = function (match) {
    var ch = this.string.charAt(this.pos);
    var ok;
    if (typeof match == "string") { ok = ch == match; }
    else { ok = ch && (match.test ? match.test(ch) : match(ch)); }
    if (ok) {++this.pos; return ch}
  };
  StringStream.prototype.eatWhile = function (match) {
    var start = this.pos;
    while (this.eat(match)){}
    return this.pos > start
  };
  StringStream.prototype.eatSpace = function () {
    var start = this.pos;
    while (/[\s\u00a0]/.test(this.string.charAt(this.pos))) { ++this.pos; }
    return this.pos > start
  };
  StringStream.prototype.skipToEnd = function () {this.pos = this.string.length;};
  StringStream.prototype.skipTo = function (ch) {
    var found = this.string.indexOf(ch, this.pos);
    if (found > -1) {this.pos = found; return true}
  };
  StringStream.prototype.backUp = function (n) {this.pos -= n;};
  StringStream.prototype.column = function () {
    if (this.lastColumnPos < this.start) {
      this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue);
      this.lastColumnPos = this.start;
    }
    return this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.indentation = function () {
    return countColumn(this.string, null, this.tabSize) -
      (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
  };
  StringStream.prototype.match = function (pattern, consume, caseInsensitive) {
    if (typeof pattern == "string") {
      var cased = function (str) { return caseInsensitive ? str.toLowerCase() : str; };
      var substr = this.string.substr(this.pos, pattern.length);
      if (cased(substr) == cased(pattern)) {
        if (consume !== false) { this.pos += pattern.length; }
        return true
      }
    } else {
      var match = this.string.slice(this.pos).match(pattern);
      if (match && match.index > 0) { return null }
      if (match && consume !== false) { this.pos += match[0].length; }
      return match
    }
  };
  StringStream.prototype.current = function (){return this.string.slice(this.start, this.pos)};
  StringStream.prototype.hideFirstChars = function (n, inner) {
    this.lineStart += n;
    try { return inner() }
    finally { this.lineStart -= n; }
  };
  StringStream.prototype.lookAhead = function (n) {
    var oracle = this.lineOracle;
    return oracle && oracle.lookAhead(n)
  };
  StringStream.prototype.baseToken = function () {
    var oracle = this.lineOracle;
    return oracle && oracle.baseToken(this.pos)
  };

  // Find the line object corresponding to the given line number.
  function getLine(doc, n) {
    n -= doc.first;
    if (n < 0 || n >= doc.size) { throw new Error("There is no line " + (n + doc.first) + " in the document.") }
    var chunk = doc;
    while (!chunk.lines) {
      for (var i = 0;; ++i) {
        var child = chunk.children[i], sz = child.chunkSize();
        if (n < sz) { chunk = child; break }
        n -= sz;
      }
    }
    return chunk.lines[n]
  }

  // Get the part of a document between two positions, as an array of
  // strings.
  function getBetween(doc, start, end) {
    var out = [], n = start.line;
    doc.iter(start.line, end.line + 1, function (line) {
      var text = line.text;
      if (n == end.line) { text = text.slice(0, end.ch); }
      if (n == start.line) { text = text.slice(start.ch); }
      out.push(text);
      ++n;
    });
    return out
  }
  // Get the lines between from and to, as array of strings.
  function getLines(doc, from, to) {
    var out = [];
    doc.iter(from, to, function (line) { out.push(line.text); }); // iter aborts when callback returns truthy value
    return out
  }

  // Update the height of a line, propagating the height change
  // upwards to parent nodes.
  function updateLineHeight(line, height) {
    var diff = height - line.height;
    if (diff) { for (var n = line; n; n = n.parent) { n.height += diff; } }
  }

  // Given a line object, find its line number by walking up through
  // its parent links.
  function lineNo(line) {
    if (line.parent == null) { return null }
    var cur = line.parent, no = indexOf(cur.lines, line);
    for (var chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent) {
      for (var i = 0;; ++i) {
        if (chunk.children[i] == cur) { break }
        no += chunk.children[i].chunkSize();
      }
    }
    return no + cur.first
  }

  // Find the line at the given vertical position, using the height
  // information in the document tree.
  function lineAtHeight(chunk, h) {
    var n = chunk.first;
    outer: do {
      for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
        var child = chunk.children[i$1], ch = child.height;
        if (h < ch) { chunk = child; continue outer }
        h -= ch;
        n += child.chunkSize();
      }
      return n
    } while (!chunk.lines)
    var i = 0;
    for (; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i], lh = line.height;
      if (h < lh) { break }
      h -= lh;
    }
    return n + i
  }

  function isLine(doc, l) {return l >= doc.first && l < doc.first + doc.size}

  function lineNumberFor(options, i) {
    return String(options.lineNumberFormatter(i + options.firstLineNumber))
  }

  // A Pos instance represents a position within the text.
  function Pos(line, ch, sticky) {
    if ( sticky === void 0 ) sticky = null;

    if (!(this instanceof Pos)) { return new Pos(line, ch, sticky) }
    this.line = line;
    this.ch = ch;
    this.sticky = sticky;
  }

  // Compare two positions, return 0 if they are the same, a negative
  // number when a is less, and a positive number otherwise.
  function cmp(a, b) { return a.line - b.line || a.ch - b.ch }

  function equalCursorPos(a, b) { return a.sticky == b.sticky && cmp(a, b) == 0 }

  function copyPos(x) {return Pos(x.line, x.ch)}
  function maxPos(a, b) { return cmp(a, b) < 0 ? b : a }
  function minPos(a, b) { return cmp(a, b) < 0 ? a : b }

  // Most of the external API clips given positions to make sure they
  // actually exist within the document.
  function clipLine(doc, n) {return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))}
  function clipPos(doc, pos) {
    if (pos.line < doc.first) { return Pos(doc.first, 0) }
    var last = doc.first + doc.size - 1;
    if (pos.line > last) { return Pos(last, getLine(doc, last).text.length) }
    return clipToLen(pos, getLine(doc, pos.line).text.length)
  }
  function clipToLen(pos, linelen) {
    var ch = pos.ch;
    if (ch == null || ch > linelen) { return Pos(pos.line, linelen) }
    else if (ch < 0) { return Pos(pos.line, 0) }
    else { return pos }
  }
  function clipPosArray(doc, array) {
    var out = [];
    for (var i = 0; i < array.length; i++) { out[i] = clipPos(doc, array[i]); }
    return out
  }

  var SavedContext = function(state, lookAhead) {
    this.state = state;
    this.lookAhead = lookAhead;
  };

  var Context = function(doc, state, line, lookAhead) {
    this.state = state;
    this.doc = doc;
    this.line = line;
    this.maxLookAhead = lookAhead || 0;
    this.baseTokens = null;
    this.baseTokenPos = 1;
  };

  Context.prototype.lookAhead = function (n) {
    var line = this.doc.getLine(this.line + n);
    if (line != null && n > this.maxLookAhead) { this.maxLookAhead = n; }
    return line
  };

  Context.prototype.baseToken = function (n) {
    if (!this.baseTokens) { return null }
    while (this.baseTokens[this.baseTokenPos] <= n)
      { this.baseTokenPos += 2; }
    var type = this.baseTokens[this.baseTokenPos + 1];
    return {type: type && type.replace(/( |^)overlay .*/, ""),
            size: this.baseTokens[this.baseTokenPos] - n}
  };

  Context.prototype.nextLine = function () {
    this.line++;
    if (this.maxLookAhead > 0) { this.maxLookAhead--; }
  };

  Context.fromSaved = function (doc, saved, line) {
    if (saved instanceof SavedContext)
      { return new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) }
    else
      { return new Context(doc, copyState(doc.mode, saved), line) }
  };

  Context.prototype.save = function (copy) {
    var state = copy !== false ? copyState(this.doc.mode, this.state) : this.state;
    return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
  };


  // Compute a style array (an array starting with a mode generation
  // -- for invalidation -- followed by pairs of end positions and
  // style strings), which is used to highlight the tokens on the
  // line.
  function highlightLine(cm, line, context, forceToEnd) {
    // A styles array always starts with a number identifying the
    // mode/overlays that it is based on (for easy invalidation).
    var st = [cm.state.modeGen], lineClasses = {};
    // Compute the base array of styles
    runMode(cm, line.text, cm.doc.mode, context, function (end, style) { return st.push(end, style); },
            lineClasses, forceToEnd);
    var state = context.state;

    // Run overlays, adjust style array.
    var loop = function ( o ) {
      context.baseTokens = st;
      var overlay = cm.state.overlays[o], i = 1, at = 0;
      context.state = true;
      runMode(cm, line.text, overlay.mode, context, function (end, style) {
        var start = i;
        // Ensure there's a token end at the current position, and that i points at it
        while (at < end) {
          var i_end = st[i];
          if (i_end > end)
            { st.splice(i, 1, end, st[i+1], i_end); }
          i += 2;
          at = Math.min(end, i_end);
        }
        if (!style) { return }
        if (overlay.opaque) {
          st.splice(start, i - start, end, "overlay " + style);
          i = start + 2;
        } else {
          for (; start < i; start += 2) {
            var cur = st[start+1];
            st[start+1] = (cur ? cur + " " : "") + "overlay " + style;
          }
        }
      }, lineClasses);
      context.state = state;
      context.baseTokens = null;
      context.baseTokenPos = 1;
    };

    for (var o = 0; o < cm.state.overlays.length; ++o) loop( o );

    return {styles: st, classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null}
  }

  function getLineStyles(cm, line, updateFrontier) {
    if (!line.styles || line.styles[0] != cm.state.modeGen) {
      var context = getContextBefore(cm, lineNo(line));
      var resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state);
      var result = highlightLine(cm, line, context);
      if (resetState) { context.state = resetState; }
      line.stateAfter = context.save(!resetState);
      line.styles = result.styles;
      if (result.classes) { line.styleClasses = result.classes; }
      else if (line.styleClasses) { line.styleClasses = null; }
      if (updateFrontier === cm.doc.highlightFrontier)
        { cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier); }
    }
    return line.styles
  }

  function getContextBefore(cm, n, precise) {
    var doc = cm.doc, display = cm.display;
    if (!doc.mode.startState) { return new Context(doc, true, n) }
    var start = findStartLine(cm, n, precise);
    var saved = start > doc.first && getLine(doc, start - 1).stateAfter;
    var context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);

    doc.iter(start, n, function (line) {
      processLine(cm, line.text, context);
      var pos = context.line;
      line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null;
      context.nextLine();
    });
    if (precise) { doc.modeFrontier = context.line; }
    return context
  }

  // Lightweight form of highlight -- proceed over this line and
  // update state, but don't save a style array. Used for lines that
  // aren't currently visible.
  function processLine(cm, text, context, startAt) {
    var mode = cm.doc.mode;
    var stream = new StringStream(text, cm.options.tabSize, context);
    stream.start = stream.pos = startAt || 0;
    if (text == "") { callBlankLine(mode, context.state); }
    while (!stream.eol()) {
      readToken(mode, stream, context.state);
      stream.start = stream.pos;
    }
  }

  function callBlankLine(mode, state) {
    if (mode.blankLine) { return mode.blankLine(state) }
    if (!mode.innerMode) { return }
    var inner = innerMode(mode, state);
    if (inner.mode.blankLine) { return inner.mode.blankLine(inner.state) }
  }

  function readToken(mode, stream, state, inner) {
    for (var i = 0; i < 10; i++) {
      if (inner) { inner[0] = innerMode(mode, state).mode; }
      var style = mode.token(stream, state);
      if (stream.pos > stream.start) { return style }
    }
    throw new Error("Mode " + mode.name + " failed to advance stream.")
  }

  var Token = function(stream, type, state) {
    this.start = stream.start; this.end = stream.pos;
    this.string = stream.current();
    this.type = type || null;
    this.state = state;
  };

  // Utility for getTokenAt and getLineTokens
  function takeToken(cm, pos, precise, asArray) {
    var doc = cm.doc, mode = doc.mode, style;
    pos = clipPos(doc, pos);
    var line = getLine(doc, pos.line), context = getContextBefore(cm, pos.line, precise);
    var stream = new StringStream(line.text, cm.options.tabSize, context), tokens;
    if (asArray) { tokens = []; }
    while ((asArray || stream.pos < pos.ch) && !stream.eol()) {
      stream.start = stream.pos;
      style = readToken(mode, stream, context.state);
      if (asArray) { tokens.push(new Token(stream, style, copyState(doc.mode, context.state))); }
    }
    return asArray ? tokens : new Token(stream, style, context.state)
  }

  function extractLineClasses(type, output) {
    if (type) { for (;;) {
      var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
      if (!lineClass) { break }
      type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
      var prop = lineClass[1] ? "bgClass" : "textClass";
      if (output[prop] == null)
        { output[prop] = lineClass[2]; }
      else if (!(new RegExp("(?:^|\\s)" + lineClass[2] + "(?:$|\\s)")).test(output[prop]))
        { output[prop] += " " + lineClass[2]; }
    } }
    return type
  }

  // Run the given mode's parser over a line, calling f for each token.
  function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
    var flattenSpans = mode.flattenSpans;
    if (flattenSpans == null) { flattenSpans = cm.options.flattenSpans; }
    var curStart = 0, curStyle = null;
    var stream = new StringStream(text, cm.options.tabSize, context), style;
    var inner = cm.options.addModeClass && [null];
    if (text == "") { extractLineClasses(callBlankLine(mode, context.state), lineClasses); }
    while (!stream.eol()) {
      if (stream.pos > cm.options.maxHighlightLength) {
        flattenSpans = false;
        if (forceToEnd) { processLine(cm, text, context, stream.pos); }
        stream.pos = text.length;
        style = null;
      } else {
        style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses);
      }
      if (inner) {
        var mName = inner[0].name;
        if (mName) { style = "m-" + (style ? mName + " " + style : mName); }
      }
      if (!flattenSpans || curStyle != style) {
        while (curStart < stream.start) {
          curStart = Math.min(stream.start, curStart + 5000);
          f(curStart, curStyle);
        }
        curStyle = style;
      }
      stream.start = stream.pos;
    }
    while (curStart < stream.pos) {
      // Webkit seems to refuse to render text nodes longer than 57444
      // characters, and returns inaccurate measurements in nodes
      // starting around 5000 chars.
      var pos = Math.min(stream.pos, curStart + 5000);
      f(pos, curStyle);
      curStart = pos;
    }
  }

  // Finds the line to start with when starting a parse. Tries to
  // find a line with a stateAfter, so that it can start with a
  // valid state. If that fails, it returns the line with the
  // smallest indentation, which tends to need the least context to
  // parse correctly.
  function findStartLine(cm, n, precise) {
    var minindent, minline, doc = cm.doc;
    var lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1000 : 100);
    for (var search = n; search > lim; --search) {
      if (search <= doc.first) { return doc.first }
      var line = getLine(doc, search - 1), after = line.stateAfter;
      if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier))
        { return search }
      var indented = countColumn(line.text, null, cm.options.tabSize);
      if (minline == null || minindent > indented) {
        minline = search - 1;
        minindent = indented;
      }
    }
    return minline
  }

  function retreatFrontier(doc, n) {
    doc.modeFrontier = Math.min(doc.modeFrontier, n);
    if (doc.highlightFrontier < n - 10) { return }
    var start = doc.first;
    for (var line = n - 1; line > start; line--) {
      var saved = getLine(doc, line).stateAfter;
      // change is on 3
      // state on line 1 looked ahead 2 -- so saw 3
      // test 1 + 2 < 3 should cover this
      if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
        start = line + 1;
        break
      }
    }
    doc.highlightFrontier = Math.min(doc.highlightFrontier, start);
  }

  // Optimize some code when these features are not used.
  var sawReadOnlySpans = false, sawCollapsedSpans = false;

  function seeReadOnlySpans() {
    sawReadOnlySpans = true;
  }

  function seeCollapsedSpans() {
    sawCollapsedSpans = true;
  }

  // TEXTMARKER SPANS

  function MarkedSpan(marker, from, to) {
    this.marker = marker;
    this.from = from; this.to = to;
  }

  // Search an array of spans for a span matching the given marker.
  function getMarkedSpanFor(spans, marker) {
    if (spans) { for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.marker == marker) { return span }
    } }
  }
  // Remove a span from an array, returning undefined if no spans are
  // left (we don't store arrays for lines without spans).
  function removeMarkedSpan(spans, span) {
    var r;
    for (var i = 0; i < spans.length; ++i)
      { if (spans[i] != span) { (r || (r = [])).push(spans[i]); } }
    return r
  }
  // Add a span to a line.
  function addMarkedSpan(line, span) {
    line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span];
    span.marker.attachLine(line);
  }

  // Used for the algorithm that adjusts markers for a change in the
  // document. These functions cut an array of spans at a given
  // character position, returning an array of remaining chunks (or
  // undefined if nothing remains).
  function markedSpansBefore(old, startCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
      if (startsBefore || span.from == startCh && marker.type == "bookmark" && (!isInsert || !span.marker.insertLeft)) {
        var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to));
      }
    } }
    return nw
  }
  function markedSpansAfter(old, endCh, isInsert) {
    var nw;
    if (old) { for (var i = 0; i < old.length; ++i) {
      var span = old[i], marker = span.marker;
      var endsAfter = span.to == null || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
      if (endsAfter || span.from == endCh && marker.type == "bookmark" && (!isInsert || span.marker.insertLeft)) {
        var startsBefore = span.from == null || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh)
        ;(nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh,
                                              span.to == null ? null : span.to - endCh));
      }
    } }
    return nw
  }

  // Given a change object, compute the new set of marker spans that
  // cover the line in which the change took place. Removes spans
  // entirely within the change, reconnects spans belonging to the
  // same marker that appear on both sides of the change, and cuts off
  // spans partially within the change. Returns an array of span
  // arrays with one element for each line in (after) the change.
  function stretchSpansOverChange(doc, change) {
    if (change.full) { return null }
    var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans;
    var oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
    if (!oldFirst && !oldLast) { return null }

    var startCh = change.from.ch, endCh = change.to.ch, isInsert = cmp(change.from, change.to) == 0;
    // Get the spans that 'stick out' on both sides
    var first = markedSpansBefore(oldFirst, startCh, isInsert);
    var last = markedSpansAfter(oldLast, endCh, isInsert);

    // Next, merge those two ends
    var sameLine = change.text.length == 1, offset = lst(change.text).length + (sameLine ? startCh : 0);
    if (first) {
      // Fix up .to properties of first
      for (var i = 0; i < first.length; ++i) {
        var span = first[i];
        if (span.to == null) {
          var found = getMarkedSpanFor(last, span.marker);
          if (!found) { span.to = startCh; }
          else if (sameLine) { span.to = found.to == null ? null : found.to + offset; }
        }
      }
    }
    if (last) {
      // Fix up .from in last (or move them into first in case of sameLine)
      for (var i$1 = 0; i$1 < last.length; ++i$1) {
        var span$1 = last[i$1];
        if (span$1.to != null) { span$1.to += offset; }
        if (span$1.from == null) {
          var found$1 = getMarkedSpanFor(first, span$1.marker);
          if (!found$1) {
            span$1.from = offset;
            if (sameLine) { (first || (first = [])).push(span$1); }
          }
        } else {
          span$1.from += offset;
          if (sameLine) { (first || (first = [])).push(span$1); }
        }
      }
    }
    // Make sure we didn't create any zero-length spans
    if (first) { first = clearEmptySpans(first); }
    if (last && last != first) { last = clearEmptySpans(last); }

    var newMarkers = [first];
    if (!sameLine) {
      // Fill gap with whole-line-spans
      var gap = change.text.length - 2, gapMarkers;
      if (gap > 0 && first)
        { for (var i$2 = 0; i$2 < first.length; ++i$2)
          { if (first[i$2].to == null)
            { (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null)); } } }
      for (var i$3 = 0; i$3 < gap; ++i$3)
        { newMarkers.push(gapMarkers); }
      newMarkers.push(last);
    }
    return newMarkers
  }

  // Remove spans that are empty and don't have a clearWhenEmpty
  // option of false.
  function clearEmptySpans(spans) {
    for (var i = 0; i < spans.length; ++i) {
      var span = spans[i];
      if (span.from != null && span.from == span.to && span.marker.clearWhenEmpty !== false)
        { spans.splice(i--, 1); }
    }
    if (!spans.length) { return null }
    return spans
  }

  // Used to 'clip' out readOnly ranges when making a change.
  function removeReadOnlyRanges(doc, from, to) {
    var markers = null;
    doc.iter(from.line, to.line + 1, function (line) {
      if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
        var mark = line.markedSpans[i].marker;
        if (mark.readOnly && (!markers || indexOf(markers, mark) == -1))
          { (markers || (markers = [])).push(mark); }
      } }
    });
    if (!markers) { return null }
    var parts = [{from: from, to: to}];
    for (var i = 0; i < markers.length; ++i) {
      var mk = markers[i], m = mk.find(0);
      for (var j = 0; j < parts.length; ++j) {
        var p = parts[j];
        if (cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0) { continue }
        var newParts = [j, 1], dfrom = cmp(p.from, m.from), dto = cmp(p.to, m.to);
        if (dfrom < 0 || !mk.inclusiveLeft && !dfrom)
          { newParts.push({from: p.from, to: m.from}); }
        if (dto > 0 || !mk.inclusiveRight && !dto)
          { newParts.push({from: m.to, to: p.to}); }
        parts.splice.apply(parts, newParts);
        j += newParts.length - 3;
      }
    }
    return parts
  }

  // Connect or disconnect spans from a line.
  function detachMarkedSpans(line) {
    var spans = line.markedSpans;
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.detachLine(line); }
    line.markedSpans = null;
  }
  function attachMarkedSpans(line, spans) {
    if (!spans) { return }
    for (var i = 0; i < spans.length; ++i)
      { spans[i].marker.attachLine(line); }
    line.markedSpans = spans;
  }

  // Helpers used when computing which overlapping collapsed span
  // counts as the larger one.
  function extraLeft(marker) { return marker.inclusiveLeft ? -1 : 0 }
  function extraRight(marker) { return marker.inclusiveRight ? 1 : 0 }

  // Returns a number indicating which of two overlapping collapsed
  // spans is larger (and thus includes the other). Falls back to
  // comparing ids when the spans cover exactly the same range.
  function compareCollapsedMarkers(a, b) {
    var lenDiff = a.lines.length - b.lines.length;
    if (lenDiff != 0) { return lenDiff }
    var aPos = a.find(), bPos = b.find();
    var fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
    if (fromCmp) { return -fromCmp }
    var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
    if (toCmp) { return toCmp }
    return b.id - a.id
  }

  // Find out whether a line ends or starts in a collapsed span. If
  // so, return the marker for that span.
  function collapsedSpanAtSide(line, start) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (sp.marker.collapsed && (start ? sp.from : sp.to) == null &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0))
        { found = sp.marker; }
    } }
    return found
  }
  function collapsedSpanAtStart(line) { return collapsedSpanAtSide(line, true) }
  function collapsedSpanAtEnd(line) { return collapsedSpanAtSide(line, false) }

  function collapsedSpanAround(line, ch) {
    var sps = sawCollapsedSpans && line.markedSpans, found;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (sp.marker.collapsed && (sp.from == null || sp.from < ch) && (sp.to == null || sp.to > ch) &&
          (!found || compareCollapsedMarkers(found, sp.marker) < 0)) { found = sp.marker; }
    } }
    return found
  }

  // Test whether there exists a collapsed span that partially
  // overlaps (covers the start or end, but not both) of a new span.
  // Such overlap is not allowed.
  function conflictingCollapsedRange(doc, lineNo, from, to, marker) {
    var line = getLine(doc, lineNo);
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var i = 0; i < sps.length; ++i) {
      var sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      var found = sp.marker.find(0);
      var fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker);
      var toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
      if (fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) { continue }
      if (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) ||
          fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))
        { return true }
    } }
  }

  // A visual line is a line as drawn on the screen. Folding, for
  // example, can cause multiple logical lines to appear on the same
  // visual line. This finds the start of the visual line that the
  // given line is part of (usually that is the line itself).
  function visualLine(line) {
    var merged;
    while (merged = collapsedSpanAtStart(line))
      { line = merged.find(-1, true).line; }
    return line
  }

  function visualLineEnd(line) {
    var merged;
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return line
  }

  // Returns an array of logical lines that continue the visual line
  // started by the argument, or undefined if there are no such lines.
  function visualLineContinued(line) {
    var merged, lines;
    while (merged = collapsedSpanAtEnd(line)) {
      line = merged.find(1, true).line
      ;(lines || (lines = [])).push(line);
    }
    return lines
  }

  // Get the line number of the start of the visual line that the
  // given line number is part of.
  function visualLineNo(doc, lineN) {
    var line = getLine(doc, lineN), vis = visualLine(line);
    if (line == vis) { return lineN }
    return lineNo(vis)
  }

  // Get the line number of the start of the next visual line after
  // the given line.
  function visualLineEndNo(doc, lineN) {
    if (lineN > doc.lastLine()) { return lineN }
    var line = getLine(doc, lineN), merged;
    if (!lineIsHidden(doc, line)) { return lineN }
    while (merged = collapsedSpanAtEnd(line))
      { line = merged.find(1, true).line; }
    return lineNo(line) + 1
  }

  // Compute whether a line is hidden. Lines count as hidden when they
  // are part of a visual line that starts with another line, or when
  // they are entirely covered by collapsed, non-widget span.
  function lineIsHidden(doc, line) {
    var sps = sawCollapsedSpans && line.markedSpans;
    if (sps) { for (var sp = (void 0), i = 0; i < sps.length; ++i) {
      sp = sps[i];
      if (!sp.marker.collapsed) { continue }
      if (sp.from == null) { return true }
      if (sp.marker.widgetNode) { continue }
      if (sp.from == 0 && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp))
        { return true }
    } }
  }
  function lineIsHiddenInner(doc, line, span) {
    if (span.to == null) {
      var end = span.marker.find(1, true);
      return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
    }
    if (span.marker.inclusiveRight && span.to == line.text.length)
      { return true }
    for (var sp = (void 0), i = 0; i < line.markedSpans.length; ++i) {
      sp = line.markedSpans[i];
      if (sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to &&
          (sp.to == null || sp.to != span.from) &&
          (sp.marker.inclusiveLeft || span.marker.inclusiveRight) &&
          lineIsHiddenInner(doc, line, sp)) { return true }
    }
  }

  // Find the height above the given line.
  function heightAtLine(lineObj) {
    lineObj = visualLine(lineObj);

    var h = 0, chunk = lineObj.parent;
    for (var i = 0; i < chunk.lines.length; ++i) {
      var line = chunk.lines[i];
      if (line == lineObj) { break }
      else { h += line.height; }
    }
    for (var p = chunk.parent; p; chunk = p, p = chunk.parent) {
      for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
        var cur = p.children[i$1];
        if (cur == chunk) { break }
        else { h += cur.height; }
      }
    }
    return h
  }

  // Compute the character length of a line, taking into account
  // collapsed ranges (see markText) that might hide parts, and join
  // other lines onto it.
  function lineLength(line) {
    if (line.height == 0) { return 0 }
    var len = line.text.length, merged, cur = line;
    while (merged = collapsedSpanAtStart(cur)) {
      var found = merged.find(0, true);
      cur = found.from.line;
      len += found.from.ch - found.to.ch;
    }
    cur = line;
    while (merged = collapsedSpanAtEnd(cur)) {
      var found$1 = merged.find(0, true);
      len -= cur.text.length - found$1.from.ch;
      cur = found$1.to.line;
      len += cur.text.length - found$1.to.ch;
    }
    return len
  }

  // Find the longest line in the document.
  function findMaxLine(cm) {
    var d = cm.display, doc = cm.doc;
    d.maxLine = getLine(doc, doc.first);
    d.maxLineLength = lineLength(d.maxLine);
    d.maxLineChanged = true;
    doc.iter(function (line) {
      var len = lineLength(line);
      if (len > d.maxLineLength) {
        d.maxLineLength = len;
        d.maxLine = line;
      }
    });
  }

  // LINE DATA STRUCTURE

  // Line objects. These hold state related to a line, including
  // highlighting info (the styles array).
  var Line = function(text, markedSpans, estimateHeight) {
    this.text = text;
    attachMarkedSpans(this, markedSpans);
    this.height = estimateHeight ? estimateHeight(this) : 1;
  };

  Line.prototype.lineNo = function () { return lineNo(this) };
  eventMixin(Line);

  // Change the content (text, markers) of a line. Automatically
  // invalidates cached information and tries to re-estimate the
  // line's height.
  function updateLine(line, text, markedSpans, estimateHeight) {
    line.text = text;
    if (line.stateAfter) { line.stateAfter = null; }
    if (line.styles) { line.styles = null; }
    if (line.order != null) { line.order = null; }
    detachMarkedSpans(line);
    attachMarkedSpans(line, markedSpans);
    var estHeight = estimateHeight ? estimateHeight(line) : 1;
    if (estHeight != line.height) { updateLineHeight(line, estHeight); }
  }

  // Detach a line from the document tree and its markers.
  function cleanUpLine(line) {
    line.parent = null;
    detachMarkedSpans(line);
  }

  // Convert a style as returned by a mode (either null, or a string
  // containing one or more styles) to a CSS style. This is cached,
  // and also looks for line-wide styles.
  var styleToClassCache = {}, styleToClassCacheWithMode = {};
  function interpretTokenStyle(style, options) {
    if (!style || /^\s*$/.test(style)) { return null }
    var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
    return cache[style] ||
      (cache[style] = style.replace(/\S+/g, "cm-$&"))
  }

  // Render the DOM representation of the text of a line. Also builds
  // up a 'line map', which points at the DOM nodes that represent
  // specific stretches of text, and is used by the measuring code.
  // The returned object contains the DOM node, this map, and
  // information about line-wide styles that were set by the mode.
  function buildLineContent(cm, lineView) {
    // The padding-right forces the element to have a 'border', which
    // is needed on Webkit to be able to get line-level bounding
    // rectangles for it (in measureChar).
    var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null);
    var builder = {pre: eltP("pre", [content], "CodeMirror-line"), content: content,
                   col: 0, pos: 0, cm: cm,
                   trailingSpace: false,
                   splitSpaces: cm.getOption("lineWrapping")};
    lineView.measure = {};

    // Iterate over the logical lines that make up this visual line.
    for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
      var line = i ? lineView.rest[i - 1] : lineView.line, order = (void 0);
      builder.pos = 0;
      builder.addToken = buildToken;
      // Optionally wire in some hacks into the token-rendering
      // algorithm, to deal with browser quirks.
      if (hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)))
        { builder.addToken = buildTokenBadBidi(builder.addToken, order); }
      builder.map = [];
      var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
      insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate));
      if (line.styleClasses) {
        if (line.styleClasses.bgClass)
          { builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || ""); }
        if (line.styleClasses.textClass)
          { builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""); }
      }

      // Ensure at least a single node is present, for measuring.
      if (builder.map.length == 0)
        { builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))); }

      // Store the map and a cache object for the current logical line
      if (i == 0) {
        lineView.measure.map = builder.map;
        lineView.measure.cache = {};
      } else {
  (lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map)
        ;(lineView.measure.caches || (lineView.measure.caches = [])).push({});
      }
    }

    // See issue #2901
    if (webkit) {
      var last = builder.content.lastChild;
      if (/\bcm-tab\b/.test(last.className) || (last.querySelector && last.querySelector(".cm-tab")))
        { builder.content.className = "cm-tab-wrap-hack"; }
    }

    signal(cm, "renderLine", cm, lineView.line, builder.pre);
    if (builder.pre.className)
      { builder.textClass = joinClasses(builder.pre.className, builder.textClass || ""); }

    return builder
  }

  function defaultSpecialCharPlaceholder(ch) {
    var token = elt("span", "\u2022", "cm-invalidchar");
    token.title = "\\u" + ch.charCodeAt(0).toString(16);
    token.setAttribute("aria-label", token.title);
    return token
  }

  // Build up the DOM representation for a single token, and add it to
  // the line map. Takes care to render special characters separately.
  function buildToken(builder, text, style, startStyle, endStyle, css, attributes) {
    if (!text) { return }
    var displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text;
    var special = builder.cm.state.specialChars, mustWrap = false;
    var content;
    if (!special.test(text)) {
      builder.col += text.length;
      content = document.createTextNode(displayText);
      builder.map.push(builder.pos, builder.pos + text.length, content);
      if (ie && ie_version < 9) { mustWrap = true; }
      builder.pos += text.length;
    } else {
      content = document.createDocumentFragment();
      var pos = 0;
      while (true) {
        special.lastIndex = pos;
        var m = special.exec(text);
        var skipped = m ? m.index - pos : text.length - pos;
        if (skipped) {
          var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt])); }
          else { content.appendChild(txt); }
          builder.map.push(builder.pos, builder.pos + skipped, txt);
          builder.col += skipped;
          builder.pos += skipped;
        }
        if (!m) { break }
        pos += skipped + 1;
        var txt$1 = (void 0);
        if (m[0] == "\t") {
          var tabSize = builder.cm.options.tabSize, tabWidth = tabSize - builder.col % tabSize;
          txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab"));
          txt$1.setAttribute("role", "presentation");
          txt$1.setAttribute("cm-text", "\t");
          builder.col += tabWidth;
        } else if (m[0] == "\r" || m[0] == "\n") {
          txt$1 = content.appendChild(elt("span", m[0] == "\r" ? "\u240d" : "\u2424", "cm-invalidchar"));
          txt$1.setAttribute("cm-text", m[0]);
          builder.col += 1;
        } else {
          txt$1 = builder.cm.options.specialCharPlaceholder(m[0]);
          txt$1.setAttribute("cm-text", m[0]);
          if (ie && ie_version < 9) { content.appendChild(elt("span", [txt$1])); }
          else { content.appendChild(txt$1); }
          builder.col += 1;
        }
        builder.map.push(builder.pos, builder.pos + 1, txt$1);
        builder.pos++;
      }
    }
    builder.trailingSpace = displayText.charCodeAt(text.length - 1) == 32;
    if (style || startStyle || endStyle || mustWrap || css || attributes) {
      var fullStyle = style || "";
      if (startStyle) { fullStyle += startStyle; }
      if (endStyle) { fullStyle += endStyle; }
      var token = elt("span", [content], fullStyle, css);
      if (attributes) {
        for (var attr in attributes) { if (attributes.hasOwnProperty(attr) && attr != "style" && attr != "class")
          { token.setAttribute(attr, attributes[attr]); } }
      }
      return builder.content.appendChild(token)
    }
    builder.content.appendChild(content);
  }

  // Change some spaces to NBSP to prevent the browser from collapsing
  // trailing spaces at the end of a line when rendering text (issue #1362).
  function splitSpaces(text, trailingBefore) {
    if (text.length > 1 && !/  /.test(text)) { return text }
    var spaceBefore = trailingBefore, result = "";
    for (var i = 0; i < text.length; i++) {
      var ch = text.charAt(i);
      if (ch == " " && spaceBefore && (i == text.length - 1 || text.charCodeAt(i + 1) == 32))
        { ch = "\u00a0"; }
      result += ch;
      spaceBefore = ch == " ";
    }
    return result
  }

  // Work around nonsense dimensions being reported for stretches of
  // right-to-left text.
  function buildTokenBadBidi(inner, order) {
    return function (builder, text, style, startStyle, endStyle, css, attributes) {
      style = style ? style + " cm-force-border" : "cm-force-border";
      var start = builder.pos, end = start + text.length;
      for (;;) {
        // Find the part that overlaps with the start of this text
        var part = (void 0);
        for (var i = 0; i < order.length; i++) {
          part = order[i];
          if (part.to > start && part.from <= start) { break }
        }
        if (part.to >= end) { return inner(builder, text, style, startStyle, endStyle, css, attributes) }
        inner(builder, text.slice(0, part.to - start), style, startStyle, null, css, attributes);
        startStyle = null;
        text = text.slice(part.to - start);
        start = part.to;
      }
    }
  }

  function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
    var widget = !ignoreWidget && marker.widgetNode;
    if (widget) { builder.map.push(builder.pos, builder.pos + size, widget); }
    if (!ignoreWidget && builder.cm.display.input.needsContentAttribute) {
      if (!widget)
        { widget = builder.content.appendChild(document.createElement("span")); }
      widget.setAttribute("cm-marker", marker.id);
    }
    if (widget) {
      builder.cm.display.input.setUneditable(widget);
      builder.content.appendChild(widget);
    }
    builder.pos += size;
    builder.trailingSpace = false;
  }

  // Outputs a number of spans to make up a line, taking highlighting
  // and marked text into account.
  function insertLineContent(line, builder, styles) {
    var spans = line.markedSpans, allText = line.text, at = 0;
    if (!spans) {
      for (var i$1 = 1; i$1 < styles.length; i$1+=2)
        { builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1+1], builder.cm.options)); }
      return
    }

    var len = allText.length, pos = 0, i = 1, text = "", style, css;
    var nextChange = 0, spanStyle, spanEndStyle, spanStartStyle, collapsed, attributes;
    for (;;) {
      if (nextChange == pos) { // Update current marker set
        spanStyle = spanEndStyle = spanStartStyle = css = "";
        attributes = null;
        collapsed = null; nextChange = Infinity;
        var foundBookmarks = [], endStyles = (void 0);
        for (var j = 0; j < spans.length; ++j) {
          var sp = spans[j], m = sp.marker;
          if (m.type == "bookmark" && sp.from == pos && m.widgetNode) {
            foundBookmarks.push(m);
          } else if (sp.from <= pos && (sp.to == null || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos)) {
            if (sp.to != null && sp.to != pos && nextChange > sp.to) {
              nextChange = sp.to;
              spanEndStyle = "";
            }
            if (m.className) { spanStyle += " " + m.className; }
            if (m.css) { css = (css ? css + ";" : "") + m.css; }
            if (m.startStyle && sp.from == pos) { spanStartStyle += " " + m.startStyle; }
            if (m.endStyle && sp.to == nextChange) { (endStyles || (endStyles = [])).push(m.endStyle, sp.to); }
            // support for the old title property
            // https://github.com/codemirror/CodeMirror/pull/5673
            if (m.title) { (attributes || (attributes = {})).title = m.title; }
            if (m.attributes) {
              for (var attr in m.attributes)
                { (attributes || (attributes = {}))[attr] = m.attributes[attr]; }
            }
            if (m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0))
              { collapsed = sp; }
          } else if (sp.from > pos && nextChange > sp.from) {
            nextChange = sp.from;
          }
        }
        if (endStyles) { for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2)
          { if (endStyles[j$1 + 1] == nextChange) { spanEndStyle += " " + endStyles[j$1]; } } }

        if (!collapsed || collapsed.from == pos) { for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2)
          { buildCollapsedSpan(builder, 0, foundBookmarks[j$2]); } }
        if (collapsed && (collapsed.from || 0) == pos) {
          buildCollapsedSpan(builder, (collapsed.to == null ? len + 1 : collapsed.to) - pos,
                             collapsed.marker, collapsed.from == null);
          if (collapsed.to == null) { return }
          if (collapsed.to == pos) { collapsed = false; }
        }
      }
      if (pos >= len) { break }

      var upto = Math.min(len, nextChange);
      while (true) {
        if (text) {
          var end = pos + text.length;
          if (!collapsed) {
            var tokenText = end > upto ? text.slice(0, upto - pos) : text;
            builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle,
                             spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", css, attributes);
          }
          if (end >= upto) {text = text.slice(upto - pos); pos = upto; break}
          pos = end;
          spanStartStyle = "";
        }
        text = allText.slice(at, at = styles[i++]);
        style = interpretTokenStyle(styles[i++], builder.cm.options);
      }
    }
  }


  // These objects are used to represent the visible (currently drawn)
  // part of the document. A LineView may correspond to multiple
  // logical lines, if those are connected by collapsed ranges.
  function LineView(doc, line, lineN) {
    // The starting line
    this.line = line;
    // Continuing lines, if any
    this.rest = visualLineContinued(line);
    // Number of logical lines in this visual line
    this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1;
    this.node = this.text = null;
    this.hidden = lineIsHidden(doc, line);
  }

  // Create a range of LineView objects for the given lines.
  function buildViewArray(cm, from, to) {
    var array = [], nextPos;
    for (var pos = from; pos < to; pos = nextPos) {
      var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
      nextPos = pos + view.size;
      array.push(view);
    }
    return array
  }

  var operationGroup = null;

  function pushOperation(op) {
    if (operationGroup) {
      operationGroup.ops.push(op);
    } else {
      op.ownsGroup = operationGroup = {
        ops: [op],
        delayedCallbacks: []
      };
    }
  }

  function fireCallbacksForOps(group) {
    // Calls delayed callbacks and cursorActivity handlers until no
    // new ones appear
    var callbacks = group.delayedCallbacks, i = 0;
    do {
      for (; i < callbacks.length; i++)
        { callbacks[i].call(null); }
      for (var j = 0; j < group.ops.length; j++) {
        var op = group.ops[j];
        if (op.cursorActivityHandlers)
          { while (op.cursorActivityCalled < op.cursorActivityHandlers.length)
            { op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm); } }
      }
    } while (i < callbacks.length)
  }

  function finishOperation(op, endCb) {
    var group = op.ownsGroup;
    if (!group) { return }

    try { fireCallbacksForOps(group); }
    finally {
      operationGroup = null;
      endCb(group);
    }
  }

  var orphanDelayedCallbacks = null;

  // Often, we want to signal events at a point where we are in the
  // middle of some work, but don't want the handler to start calling
  // other methods on the editor, which might be in an inconsistent
  // state or simply not expect any other events to happen.
  // signalLater looks whether there are any handlers, and schedules
  // them to be executed when the last operation ends, or, if no
  // operation is active, when a timeout fires.
  function signalLater(emitter, type /*, values...*/) {
    var arr = getHandlers(emitter, type);
    if (!arr.length) { return }
    var args = Array.prototype.slice.call(arguments, 2), list;
    if (operationGroup) {
      list = operationGroup.delayedCallbacks;
    } else if (orphanDelayedCallbacks) {
      list = orphanDelayedCallbacks;
    } else {
      list = orphanDelayedCallbacks = [];
      setTimeout(fireOrphanDelayed, 0);
    }
    var loop = function ( i ) {
      list.push(function () { return arr[i].apply(null, args); });
    };

    for (var i = 0; i < arr.length; ++i)
      loop( i );
  }

  function fireOrphanDelayed() {
    var delayed = orphanDelayedCallbacks;
    orphanDelayedCallbacks = null;
    for (var i = 0; i < delayed.length; ++i) { delayed[i](); }
  }

  // When an aspect of a line changes, a string is added to
  // lineView.changes. This updates the relevant part of the line's
  // DOM structure.
  function updateLineForChanges(cm, lineView, lineN, dims) {
    for (var j = 0; j < lineView.changes.length; j++) {
      var type = lineView.changes[j];
      if (type == "text") { updateLineText(cm, lineView); }
      else if (type == "gutter") { updateLineGutter(cm, lineView, lineN, dims); }
      else if (type == "class") { updateLineClasses(cm, lineView); }
      else if (type == "widget") { updateLineWidgets(cm, lineView, dims); }
    }
    lineView.changes = null;
  }

  // Lines with gutter elements, widgets or a background class need to
  // be wrapped, and have the extra elements added to the wrapper div
  function ensureLineWrapped(lineView) {
    if (lineView.node == lineView.text) {
      lineView.node = elt("div", null, null, "position: relative");
      if (lineView.text.parentNode)
        { lineView.text.parentNode.replaceChild(lineView.node, lineView.text); }
      lineView.node.appendChild(lineView.text);
      if (ie && ie_version < 8) { lineView.node.style.zIndex = 2; }
    }
    return lineView.node
  }

  function updateLineBackground(cm, lineView) {
    var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
    if (cls) { cls += " CodeMirror-linebackground"; }
    if (lineView.background) {
      if (cls) { lineView.background.className = cls; }
      else { lineView.background.parentNode.removeChild(lineView.background); lineView.background = null; }
    } else if (cls) {
      var wrap = ensureLineWrapped(lineView);
      lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild);
      cm.display.input.setUneditable(lineView.background);
    }
  }

  // Wrapper around buildLineContent which will reuse the structure
  // in display.externalMeasured when possible.
  function getLineContent(cm, lineView) {
    var ext = cm.display.externalMeasured;
    if (ext && ext.line == lineView.line) {
      cm.display.externalMeasured = null;
      lineView.measure = ext.measure;
      return ext.built
    }
    return buildLineContent(cm, lineView)
  }

  // Redraw the line's text. Interacts with the background and text
  // classes because the mode may output tokens that influence these
  // classes.
  function updateLineText(cm, lineView) {
    var cls = lineView.text.className;
    var built = getLineContent(cm, lineView);
    if (lineView.text == lineView.node) { lineView.node = built.pre; }
    lineView.text.parentNode.replaceChild(built.pre, lineView.text);
    lineView.text = built.pre;
    if (built.bgClass != lineView.bgClass || built.textClass != lineView.textClass) {
      lineView.bgClass = built.bgClass;
      lineView.textClass = built.textClass;
      updateLineClasses(cm, lineView);
    } else if (cls) {
      lineView.text.className = cls;
    }
  }

  function updateLineClasses(cm, lineView) {
    updateLineBackground(cm, lineView);
    if (lineView.line.wrapClass)
      { ensureLineWrapped(lineView).className = lineView.line.wrapClass; }
    else if (lineView.node != lineView.text)
      { lineView.node.className = ""; }
    var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
    lineView.text.className = textClass || "";
  }

  function updateLineGutter(cm, lineView, lineN, dims) {
    if (lineView.gutter) {
      lineView.node.removeChild(lineView.gutter);
      lineView.gutter = null;
    }
    if (lineView.gutterBackground) {
      lineView.node.removeChild(lineView.gutterBackground);
      lineView.gutterBackground = null;
    }
    if (lineView.line.gutterClass) {
      var wrap = ensureLineWrapped(lineView);
      lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass,
                                      ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + (dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(lineView.gutterBackground);
      wrap.insertBefore(lineView.gutterBackground, lineView.text);
    }
    var markers = lineView.line.gutterMarkers;
    if (cm.options.lineNumbers || markers) {
      var wrap$1 = ensureLineWrapped(lineView);
      var gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", ("left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px"));
      cm.display.input.setUneditable(gutterWrap);
      wrap$1.insertBefore(gutterWrap, lineView.text);
      if (lineView.line.gutterClass)
        { gutterWrap.className += " " + lineView.line.gutterClass; }
      if (cm.options.lineNumbers && (!markers || !markers["CodeMirror-linenumbers"]))
        { lineView.lineNumber = gutterWrap.appendChild(
          elt("div", lineNumberFor(cm.options, lineN),
              "CodeMirror-linenumber CodeMirror-gutter-elt",
              ("left: " + (dims.gutterLeft["CodeMirror-linenumbers"]) + "px; width: " + (cm.display.lineNumInnerWidth) + "px"))); }
      if (markers) { for (var k = 0; k < cm.display.gutterSpecs.length; ++k) {
        var id = cm.display.gutterSpecs[k].className, found = markers.hasOwnProperty(id) && markers[id];
        if (found)
          { gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt",
                                     ("left: " + (dims.gutterLeft[id]) + "px; width: " + (dims.gutterWidth[id]) + "px"))); }
      } }
    }
  }

  function updateLineWidgets(cm, lineView, dims) {
    if (lineView.alignable) { lineView.alignable = null; }
    var isWidget = classTest("CodeMirror-linewidget");
    for (var node = lineView.node.firstChild, next = (void 0); node; node = next) {
      next = node.nextSibling;
      if (isWidget.test(node.className)) { lineView.node.removeChild(node); }
    }
    insertLineWidgets(cm, lineView, dims);
  }

  // Build a line's DOM representation from scratch
  function buildLineElement(cm, lineView, lineN, dims) {
    var built = getLineContent(cm, lineView);
    lineView.text = lineView.node = built.pre;
    if (built.bgClass) { lineView.bgClass = built.bgClass; }
    if (built.textClass) { lineView.textClass = built.textClass; }

    updateLineClasses(cm, lineView);
    updateLineGutter(cm, lineView, lineN, dims);
    insertLineWidgets(cm, lineView, dims);
    return lineView.node
  }

  // A lineView may contain multiple logical lines (when merged by
  // collapsed spans). The widgets for all of them need to be drawn.
  function insertLineWidgets(cm, lineView, dims) {
    insertLineWidgetsFor(cm, lineView.line, lineView, dims, true);
    if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
      { insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, false); } }
  }

  function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
    if (!line.widgets) { return }
    var wrap = ensureLineWrapped(lineView);
    for (var i = 0, ws = line.widgets; i < ws.length; ++i) {
      var widget = ws[i], node = elt("div", [widget.node], "CodeMirror-linewidget" + (widget.className ? " " + widget.className : ""));
      if (!widget.handleMouseEvents) { node.setAttribute("cm-ignore-events", "true"); }
      positionLineWidget(widget, node, lineView, dims);
      cm.display.input.setUneditable(node);
      if (allowAbove && widget.above)
        { wrap.insertBefore(node, lineView.gutter || lineView.text); }
      else
        { wrap.appendChild(node); }
      signalLater(widget, "redraw");
    }
  }

  function positionLineWidget(widget, node, lineView, dims) {
    if (widget.noHScroll) {
  (lineView.alignable || (lineView.alignable = [])).push(node);
      var width = dims.wrapperWidth;
      node.style.left = dims.fixedPos + "px";
      if (!widget.coverGutter) {
        width -= dims.gutterTotalWidth;
        node.style.paddingLeft = dims.gutterTotalWidth + "px";
      }
      node.style.width = width + "px";
    }
    if (widget.coverGutter) {
      node.style.zIndex = 5;
      node.style.position = "relative";
      if (!widget.noHScroll) { node.style.marginLeft = -dims.gutterTotalWidth + "px"; }
    }
  }

  function widgetHeight(widget) {
    if (widget.height != null) { return widget.height }
    var cm = widget.doc.cm;
    if (!cm) { return 0 }
    if (!contains(document.body, widget.node)) {
      var parentStyle = "position: relative;";
      if (widget.coverGutter)
        { parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"; }
      if (widget.noHScroll)
        { parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"; }
      removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle));
    }
    return widget.height = widget.node.parentNode.offsetHeight
  }

  // Return true when the given mouse event happened in a widget
  function eventInWidget(display, e) {
    for (var n = e_target(e); n != display.wrapper; n = n.parentNode) {
      if (!n || (n.nodeType == 1 && n.getAttribute("cm-ignore-events") == "true") ||
          (n.parentNode == display.sizer && n != display.mover))
        { return true }
    }
  }

  // POSITION MEASUREMENT

  function paddingTop(display) {return display.lineSpace.offsetTop}
  function paddingVert(display) {return display.mover.offsetHeight - display.lineSpace.offsetHeight}
  function paddingH(display) {
    if (display.cachedPaddingH) { return display.cachedPaddingH }
    var e = removeChildrenAndAdd(display.measure, elt("pre", "x", "CodeMirror-line-like"));
    var style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle;
    var data = {left: parseInt(style.paddingLeft), right: parseInt(style.paddingRight)};
    if (!isNaN(data.left) && !isNaN(data.right)) { display.cachedPaddingH = data; }
    return data
  }

  function scrollGap(cm) { return scrollerGap - cm.display.nativeBarWidth }
  function displayWidth(cm) {
    return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
  }
  function displayHeight(cm) {
    return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
  }

  // Ensure the lineView.wrapping.heights array is populated. This is
  // an array of bottom offsets for the lines that make up a drawn
  // line. When lineWrapping is on, there might be more than one
  // height.
  function ensureLineHeights(cm, lineView, rect) {
    var wrapping = cm.options.lineWrapping;
    var curWidth = wrapping && displayWidth(cm);
    if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
      var heights = lineView.measure.heights = [];
      if (wrapping) {
        lineView.measure.width = curWidth;
        var rects = lineView.text.firstChild.getClientRects();
        for (var i = 0; i < rects.length - 1; i++) {
          var cur = rects[i], next = rects[i + 1];
          if (Math.abs(cur.bottom - next.bottom) > 2)
            { heights.push((cur.bottom + next.top) / 2 - rect.top); }
        }
      }
      heights.push(rect.bottom - rect.top);
    }
  }

  // Find a line map (mapping character offsets to text nodes) and a
  // measurement cache for the given line number. (A line view might
  // contain multiple lines when collapsed ranges are present.)
  function mapFromLineView(lineView, line, lineN) {
    if (lineView.line == line)
      { return {map: lineView.measure.map, cache: lineView.measure.cache} }
    for (var i = 0; i < lineView.rest.length; i++)
      { if (lineView.rest[i] == line)
        { return {map: lineView.measure.maps[i], cache: lineView.measure.caches[i]} } }
    for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
      { if (lineNo(lineView.rest[i$1]) > lineN)
        { return {map: lineView.measure.maps[i$1], cache: lineView.measure.caches[i$1], before: true} } }
  }

  // Render a line into the hidden node display.externalMeasured. Used
  // when measurement is needed for a line that's not in the viewport.
  function updateExternalMeasurement(cm, line) {
    line = visualLine(line);
    var lineN = lineNo(line);
    var view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
    view.lineN = lineN;
    var built = view.built = buildLineContent(cm, view);
    view.text = built.pre;
    removeChildrenAndAdd(cm.display.lineMeasure, built.pre);
    return view
  }

  // Get a {top, bottom, left, right} box (in line-local coordinates)
  // for a given character.
  function measureChar(cm, line, ch, bias) {
    return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
  }

  // Find a line view that corresponds to the given line number.
  function findViewForLine(cm, lineN) {
    if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo)
      { return cm.display.view[findViewIndex(cm, lineN)] }
    var ext = cm.display.externalMeasured;
    if (ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size)
      { return ext }
  }

  // Measurement can be split in two steps, the set-up work that
  // applies to the whole line, and the measurement of the actual
  // character. Functions like coordsChar, that need to do a lot of
  // measurements in a row, can thus ensure that the set-up work is
  // only done once.
  function prepareMeasureForLine(cm, line) {
    var lineN = lineNo(line);
    var view = findViewForLine(cm, lineN);
    if (view && !view.text) {
      view = null;
    } else if (view && view.changes) {
      updateLineForChanges(cm, view, lineN, getDimensions(cm));
      cm.curOp.forceUpdate = true;
    }
    if (!view)
      { view = updateExternalMeasurement(cm, line); }

    var info = mapFromLineView(view, line, lineN);
    return {
      line: line, view: view, rect: null,
      map: info.map, cache: info.cache, before: info.before,
      hasHeights: false
    }
  }

  // Given a prepared measurement object, measures the position of an
  // actual character (or fetches it from the cache).
  function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
    if (prepared.before) { ch = -1; }
    var key = ch + (bias || ""), found;
    if (prepared.cache.hasOwnProperty(key)) {
      found = prepared.cache[key];
    } else {
      if (!prepared.rect)
        { prepared.rect = prepared.view.text.getBoundingClientRect(); }
      if (!prepared.hasHeights) {
        ensureLineHeights(cm, prepared.view, prepared.rect);
        prepared.hasHeights = true;
      }
      found = measureCharInner(cm, prepared, ch, bias);
      if (!found.bogus) { prepared.cache[key] = found; }
    }
    return {left: found.left, right: found.right,
            top: varHeight ? found.rtop : found.top,
            bottom: varHeight ? found.rbottom : found.bottom}
  }

  var nullRect = {left: 0, right: 0, top: 0, bottom: 0};

  function nodeAndOffsetInLineMap(map, ch, bias) {
    var node, start, end, collapse, mStart, mEnd;
    // First, search the line map for the text node corresponding to,
    // or closest to, the target character.
    for (var i = 0; i < map.length; i += 3) {
      mStart = map[i];
      mEnd = map[i + 1];
      if (ch < mStart) {
        start = 0; end = 1;
        collapse = "left";
      } else if (ch < mEnd) {
        start = ch - mStart;
        end = start + 1;
      } else if (i == map.length - 3 || ch == mEnd && map[i + 3] > ch) {
        end = mEnd - mStart;
        start = end - 1;
        if (ch >= mEnd) { collapse = "right"; }
      }
      if (start != null) {
        node = map[i + 2];
        if (mStart == mEnd && bias == (node.insertLeft ? "left" : "right"))
          { collapse = bias; }
        if (bias == "left" && start == 0)
          { while (i && map[i - 2] == map[i - 3] && map[i - 1].insertLeft) {
            node = map[(i -= 3) + 2];
            collapse = "left";
          } }
        if (bias == "right" && start == mEnd - mStart)
          { while (i < map.length - 3 && map[i + 3] == map[i + 4] && !map[i + 5].insertLeft) {
            node = map[(i += 3) + 2];
            collapse = "right";
          } }
        break
      }
    }
    return {node: node, start: start, end: end, collapse: collapse, coverStart: mStart, coverEnd: mEnd}
  }

  function getUsefulRect(rects, bias) {
    var rect = nullRect;
    if (bias == "left") { for (var i = 0; i < rects.length; i++) {
      if ((rect = rects[i]).left != rect.right) { break }
    } } else { for (var i$1 = rects.length - 1; i$1 >= 0; i$1--) {
      if ((rect = rects[i$1]).left != rect.right) { break }
    } }
    return rect
  }

  function measureCharInner(cm, prepared, ch, bias) {
    var place = nodeAndOffsetInLineMap(prepared.map, ch, bias);
    var node = place.node, start = place.start, end = place.end, collapse = place.collapse;

    var rect;
    if (node.nodeType == 3) { // If it is a text node, use a range to retrieve the coordinates.
      for (var i$1 = 0; i$1 < 4; i$1++) { // Retry a maximum of 4 times when nonsense rectangles are returned
        while (start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start))) { --start; }
        while (place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end))) { ++end; }
        if (ie && ie_version < 9 && start == 0 && end == place.coverEnd - place.coverStart)
          { rect = node.parentNode.getBoundingClientRect(); }
        else
          { rect = getUsefulRect(range(node, start, end).getClientRects(), bias); }
        if (rect.left || rect.right || start == 0) { break }
        end = start;
        start = start - 1;
        collapse = "right";
      }
      if (ie && ie_version < 11) { rect = maybeUpdateRectForZooming(cm.display.measure, rect); }
    } else { // If it is a widget, simply get the box for the whole widget.
      if (start > 0) { collapse = bias = "right"; }
      var rects;
      if (cm.options.lineWrapping && (rects = node.getClientRects()).length > 1)
        { rect = rects[bias == "right" ? rects.length - 1 : 0]; }
      else
        { rect = node.getBoundingClientRect(); }
    }
    if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
      var rSpan = node.parentNode.getClientRects()[0];
      if (rSpan)
        { rect = {left: rSpan.left, right: rSpan.left + charWidth(cm.display), top: rSpan.top, bottom: rSpan.bottom}; }
      else
        { rect = nullRect; }
    }

    var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top;
    var mid = (rtop + rbot) / 2;
    var heights = prepared.view.measure.heights;
    var i = 0;
    for (; i < heights.length - 1; i++)
      { if (mid < heights[i]) { break } }
    var top = i ? heights[i - 1] : 0, bot = heights[i];
    var result = {left: (collapse == "right" ? rect.right : rect.left) - prepared.rect.left,
                  right: (collapse == "left" ? rect.left : rect.right) - prepared.rect.left,
                  top: top, bottom: bot};
    if (!rect.left && !rect.right) { result.bogus = true; }
    if (!cm.options.singleCursorHeightPerLine) { result.rtop = rtop; result.rbottom = rbot; }

    return result
  }

  // Work around problem with bounding client rects on ranges being
  // returned incorrectly when zoomed on IE10 and below.
  function maybeUpdateRectForZooming(measure, rect) {
    if (!window.screen || screen.logicalXDPI == null ||
        screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure))
      { return rect }
    var scaleX = screen.logicalXDPI / screen.deviceXDPI;
    var scaleY = screen.logicalYDPI / screen.deviceYDPI;
    return {left: rect.left * scaleX, right: rect.right * scaleX,
            top: rect.top * scaleY, bottom: rect.bottom * scaleY}
  }

  function clearLineMeasurementCacheFor(lineView) {
    if (lineView.measure) {
      lineView.measure.cache = {};
      lineView.measure.heights = null;
      if (lineView.rest) { for (var i = 0; i < lineView.rest.length; i++)
        { lineView.measure.caches[i] = {}; } }
    }
  }

  function clearLineMeasurementCache(cm) {
    cm.display.externalMeasure = null;
    removeChildren(cm.display.lineMeasure);
    for (var i = 0; i < cm.display.view.length; i++)
      { clearLineMeasurementCacheFor(cm.display.view[i]); }
  }

  function clearCaches(cm) {
    clearLineMeasurementCache(cm);
    cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null;
    if (!cm.options.lineWrapping) { cm.display.maxLineChanged = true; }
    cm.display.lineNumChars = null;
  }

  function pageScrollX() {
    // Work around https://bugs.chromium.org/p/chromium/issues/detail?id=489206
    // which causes page_Offset and bounding client rects to use
    // different reference viewports and invalidate our calculations.
    if (chrome && android) { return -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) }
    return window.pageXOffset || (document.documentElement || document.body).scrollLeft
  }
  function pageScrollY() {
    if (chrome && android) { return -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) }
    return window.pageYOffset || (document.documentElement || document.body).scrollTop
  }

  function widgetTopHeight(lineObj) {
    var height = 0;
    if (lineObj.widgets) { for (var i = 0; i < lineObj.widgets.length; ++i) { if (lineObj.widgets[i].above)
      { height += widgetHeight(lineObj.widgets[i]); } } }
    return height
  }

  // Converts a {top, bottom, left, right} box from line-local
  // coordinates into another coordinate system. Context may be one of
  // "line", "div" (display.lineDiv), "local"./null (editor), "window",
  // or "page".
  function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
    if (!includeWidgets) {
      var height = widgetTopHeight(lineObj);
      rect.top += height; rect.bottom += height;
    }
    if (context == "line") { return rect }
    if (!context) { context = "local"; }
    var yOff = heightAtLine(lineObj);
    if (context == "local") { yOff += paddingTop(cm.display); }
    else { yOff -= cm.display.viewOffset; }
    if (context == "page" || context == "window") {
      var lOff = cm.display.lineSpace.getBoundingClientRect();
      yOff += lOff.top + (context == "window" ? 0 : pageScrollY());
      var xOff = lOff.left + (context == "window" ? 0 : pageScrollX());
      rect.left += xOff; rect.right += xOff;
    }
    rect.top += yOff; rect.bottom += yOff;
    return rect
  }

  // Coverts a box from "div" coords to another coordinate system.
  // Context may be "window", "page", "div", or "local"./null.
  function fromCoordSystem(cm, coords, context) {
    if (context == "div") { return coords }
    var left = coords.left, top = coords.top;
    // First move into "page" coordinate system
    if (context == "page") {
      left -= pageScrollX();
      top -= pageScrollY();
    } else if (context == "local" || !context) {
      var localBox = cm.display.sizer.getBoundingClientRect();
      left += localBox.left;
      top += localBox.top;
    }

    var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
    return {left: left - lineSpaceBox.left, top: top - lineSpaceBox.top}
  }

  function charCoords(cm, pos, context, lineObj, bias) {
    if (!lineObj) { lineObj = getLine(cm.doc, pos.line); }
    return intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
  }

  // Returns a box for a given cursor position, which may have an
  // 'other' property containing the position of the secondary cursor
  // on a bidi boundary.
  // A cursor Pos(line, char, "before") is on the same visual line as `char - 1`
  // and after `char - 1` in writing order of `char - 1`
  // A cursor Pos(line, char, "after") is on the same visual line as `char`
  // and before `char` in writing order of `char`
  // Examples (upper-case letters are RTL, lower-case are LTR):
  //     Pos(0, 1, ...)
  //     before   after
  // ab     a|b     a|b
  // aB     a|B     aB|
  // Ab     |Ab     A|b
  // AB     B|A     B|A
  // Every position after the last character on a line is considered to stick
  // to the last character on the line.
  function cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
    lineObj = lineObj || getLine(cm.doc, pos.line);
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    function get(ch, right) {
      var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
      if (right) { m.left = m.right; } else { m.right = m.left; }
      return intoCoordSystem(cm, lineObj, m, context)
    }
    var order = getOrder(lineObj, cm.doc.direction), ch = pos.ch, sticky = pos.sticky;
    if (ch >= lineObj.text.length) {
      ch = lineObj.text.length;
      sticky = "before";
    } else if (ch <= 0) {
      ch = 0;
      sticky = "after";
    }
    if (!order) { return get(sticky == "before" ? ch - 1 : ch, sticky == "before") }

    function getBidi(ch, partPos, invert) {
      var part = order[partPos], right = part.level == 1;
      return get(invert ? ch - 1 : ch, right != invert)
    }
    var partPos = getBidiPartAt(order, ch, sticky);
    var other = bidiOther;
    var val = getBidi(ch, partPos, sticky == "before");
    if (other != null) { val.other = getBidi(ch, other, sticky != "before"); }
    return val
  }

  // Used to cheaply estimate the coordinates for a position. Used for
  // intermediate scroll updates.
  function estimateCoords(cm, pos) {
    var left = 0;
    pos = clipPos(cm.doc, pos);
    if (!cm.options.lineWrapping) { left = charWidth(cm.display) * pos.ch; }
    var lineObj = getLine(cm.doc, pos.line);
    var top = heightAtLine(lineObj) + paddingTop(cm.display);
    return {left: left, right: left, top: top, bottom: top + lineObj.height}
  }

  // Positions returned by coordsChar contain some extra information.
  // xRel is the relative x position of the input coordinates compared
  // to the found position (so xRel > 0 means the coordinates are to
  // the right of the character position, for example). When outside
  // is true, that means the coordinates lie outside the line's
  // vertical range.
  function PosWithInfo(line, ch, sticky, outside, xRel) {
    var pos = Pos(line, ch, sticky);
    pos.xRel = xRel;
    if (outside) { pos.outside = outside; }
    return pos
  }

  // Compute the character position closest to the given coordinates.
  // Input must be lineSpace-local ("div" coordinate system).
  function coordsChar(cm, x, y) {
    var doc = cm.doc;
    y += cm.display.viewOffset;
    if (y < 0) { return PosWithInfo(doc.first, 0, null, -1, -1) }
    var lineN = lineAtHeight(doc, y), last = doc.first + doc.size - 1;
    if (lineN > last)
      { return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, 1, 1) }
    if (x < 0) { x = 0; }

    var lineObj = getLine(doc, lineN);
    for (;;) {
      var found = coordsCharInner(cm, lineObj, lineN, x, y);
      var collapsed = collapsedSpanAround(lineObj, found.ch + (found.xRel > 0 || found.outside > 0 ? 1 : 0));
      if (!collapsed) { return found }
      var rangeEnd = collapsed.find(1);
      if (rangeEnd.line == lineN) { return rangeEnd }
      lineObj = getLine(doc, lineN = rangeEnd.line);
    }
  }

  function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
    y -= widgetTopHeight(lineObj);
    var end = lineObj.text.length;
    var begin = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y; }, end, 0);
    end = findFirst(function (ch) { return measureCharPrepared(cm, preparedMeasure, ch).top > y; }, begin, end);
    return {begin: begin, end: end}
  }

  function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
    if (!preparedMeasure) { preparedMeasure = prepareMeasureForLine(cm, lineObj); }
    var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
    return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
  }

  // Returns true if the given side of a box is after the given
  // coordinates, in top-to-bottom, left-to-right order.
  function boxIsAfter(box, x, y, left) {
    return box.bottom <= y ? false : box.top > y ? true : (left ? box.left : box.right) > x
  }

  function coordsCharInner(cm, lineObj, lineNo, x, y) {
    // Move y into line-local coordinate space
    y -= heightAtLine(lineObj);
    var preparedMeasure = prepareMeasureForLine(cm, lineObj);
    // When directly calling `measureCharPrepared`, we have to adjust
    // for the widgets at this line.
    var widgetHeight = widgetTopHeight(lineObj);
    var begin = 0, end = lineObj.text.length, ltr = true;

    var order = getOrder(lineObj, cm.doc.direction);
    // If the line isn't plain left-to-right text, first figure out
    // which bidi section the coordinates fall into.
    if (order) {
      var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)
                   (cm, lineObj, lineNo, preparedMeasure, order, x, y);
      ltr = part.level != 1;
      // The awkward -1 offsets are needed because findFirst (called
      // on these below) will treat its first bound as inclusive,
      // second as exclusive, but we want to actually address the
      // characters in the part's range
      begin = ltr ? part.from : part.to - 1;
      end = ltr ? part.to : part.from - 1;
    }

    // A binary search to find the first character whose bounding box
    // starts after the coordinates. If we run across any whose box wrap
    // the coordinates, store that.
    var chAround = null, boxAround = null;
    var ch = findFirst(function (ch) {
      var box = measureCharPrepared(cm, preparedMeasure, ch);
      box.top += widgetHeight; box.bottom += widgetHeight;
      if (!boxIsAfter(box, x, y, false)) { return false }
      if (box.top <= y && box.left <= x) {
        chAround = ch;
        boxAround = box;
      }
      return true
    }, begin, end);

    var baseX, sticky, outside = false;
    // If a box around the coordinates was found, use that
    if (boxAround) {
      // Distinguish coordinates nearer to the left or right side of the box
      var atLeft = x - boxAround.left < boxAround.right - x, atStart = atLeft == ltr;
      ch = chAround + (atStart ? 0 : 1);
      sticky = atStart ? "after" : "before";
      baseX = atLeft ? boxAround.left : boxAround.right;
    } else {
      // (Adjust for extended bound, if necessary.)
      if (!ltr && (ch == end || ch == begin)) { ch++; }
      // To determine which side to associate with, get the box to the
      // left of the character and compare it's vertical position to the
      // coordinates
      sticky = ch == 0 ? "after" : ch == lineObj.text.length ? "before" :
        (measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight <= y) == ltr ?
        "after" : "before";
      // Now get accurate coordinates for this place, in order to get a
      // base X position
      var coords = cursorCoords(cm, Pos(lineNo, ch, sticky), "line", lineObj, preparedMeasure);
      baseX = coords.left;
      outside = y < coords.top ? -1 : y >= coords.bottom ? 1 : 0;
    }

    ch = skipExtendingChars(lineObj.text, ch, 1);
    return PosWithInfo(lineNo, ch, sticky, outside, x - baseX)
  }

  function coordsBidiPart(cm, lineObj, lineNo, preparedMeasure, order, x, y) {
    // Bidi parts are sorted left-to-right, and in a non-line-wrapping
    // situation, we can take this ordering to correspond to the visual
    // ordering. This finds the first part whose end is after the given
    // coordinates.
    var index = findFirst(function (i) {
      var part = order[i], ltr = part.level != 1;
      return boxIsAfter(cursorCoords(cm, Pos(lineNo, ltr ? part.to : part.from, ltr ? "before" : "after"),
                                     "line", lineObj, preparedMeasure), x, y, true)
    }, 0, order.length - 1);
    var part = order[index];
    // If this isn't the first part, the part's start is also after
    // the coordinates, and the coordinates aren't on the same line as
    // that start, move one part back.
    if (index > 0) {
      var ltr = part.level != 1;
      var start = cursorCoords(cm, Pos(lineNo, ltr ? part.from : part.to, ltr ? "after" : "before"),
                               "line", lineObj, preparedMeasure);
      if (boxIsAfter(start, x, y, true) && start.top > y)
        { part = order[index - 1]; }
    }
    return part
  }

  function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
    // In a wrapped line, rtl text on wrapping boundaries can do things
    // that don't correspond to the ordering in our `order` array at
    // all, so a binary search doesn't work, and we want to return a
    // part that only spans one line so that the binary search in
    // coordsCharInner is safe. As such, we first find the extent of the
    // wrapped line, and then do a flat search in which we discard any
    // spans that aren't on the line.
    var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y);
    var begin = ref.begin;
    var end = ref.end;
    if (/\s/.test(lineObj.text.charAt(end - 1))) { end--; }
    var part = null, closestDist = null;
    for (var i = 0; i < order.length; i++) {
      var p = order[i];
      if (p.from >= end || p.to <= begin) { continue }
      var ltr = p.level != 1;
      var endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right;
      // Weigh against spans ending before this, so that they are only
      // picked if nothing ends after
      var dist = endX < x ? x - endX + 1e9 : endX - x;
      if (!part || closestDist > dist) {
        part = p;
        closestDist = dist;
      }
    }
    if (!part) { part = order[order.length - 1]; }
    // Clip the part to the wrapped line.
    if (part.from < begin) { part = {from: begin, to: part.to, level: part.level}; }
    if (part.to > end) { part = {from: part.from, to: end, level: part.level}; }
    return part
  }

  var measureText;
  // Compute the default text height.
  function textHeight(display) {
    if (display.cachedTextHeight != null) { return display.cachedTextHeight }
    if (measureText == null) {
      measureText = elt("pre", null, "CodeMirror-line-like");
      // Measure a bunch of lines, for browsers that compute
      // fractional heights.
      for (var i = 0; i < 49; ++i) {
        measureText.appendChild(document.createTextNode("x"));
        measureText.appendChild(elt("br"));
      }
      measureText.appendChild(document.createTextNode("x"));
    }
    removeChildrenAndAdd(display.measure, measureText);
    var height = measureText.offsetHeight / 50;
    if (height > 3) { display.cachedTextHeight = height; }
    removeChildren(display.measure);
    return height || 1
  }

  // Compute the default character width.
  function charWidth(display) {
    if (display.cachedCharWidth != null) { return display.cachedCharWidth }
    var anchor = elt("span", "xxxxxxxxxx");
    var pre = elt("pre", [anchor], "CodeMirror-line-like");
    removeChildrenAndAdd(display.measure, pre);
    var rect = anchor.getBoundingClientRect(), width = (rect.right - rect.left) / 10;
    if (width > 2) { display.cachedCharWidth = width; }
    return width || 10
  }

  // Do a bulk-read of the DOM positions and sizes needed to draw the
  // view, so that we don't interleave reading and writing to the DOM.
  function getDimensions(cm) {
    var d = cm.display, left = {}, width = {};
    var gutterLeft = d.gutters.clientLeft;
    for (var n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) {
      var id = cm.display.gutterSpecs[i].className;
      left[id] = n.offsetLeft + n.clientLeft + gutterLeft;
      width[id] = n.clientWidth;
    }
    return {fixedPos: compensateForHScroll(d),
            gutterTotalWidth: d.gutters.offsetWidth,
            gutterLeft: left,
            gutterWidth: width,
            wrapperWidth: d.wrapper.clientWidth}
  }

  // Computes display.scroller.scrollLeft + display.gutters.offsetWidth,
  // but using getBoundingClientRect to get a sub-pixel-accurate
  // result.
  function compensateForHScroll(display) {
    return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
  }

  // Returns a function that estimates the height of a line, to use as
  // first approximation until the line becomes visible (and is thus
  // properly measurable).
  function estimateHeight(cm) {
    var th = textHeight(cm.display), wrapping = cm.options.lineWrapping;
    var perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
    return function (line) {
      if (lineIsHidden(cm.doc, line)) { return 0 }

      var widgetsHeight = 0;
      if (line.widgets) { for (var i = 0; i < line.widgets.length; i++) {
        if (line.widgets[i].height) { widgetsHeight += line.widgets[i].height; }
      } }

      if (wrapping)
        { return widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th }
      else
        { return widgetsHeight + th }
    }
  }

  function estimateLineHeights(cm) {
    var doc = cm.doc, est = estimateHeight(cm);
    doc.iter(function (line) {
      var estHeight = est(line);
      if (estHeight != line.height) { updateLineHeight(line, estHeight); }
    });
  }

  // Given a mouse event, find the corresponding position. If liberal
  // is false, it checks whether a gutter or scrollbar was clicked,
  // and returns null if it was. forRect is used by rectangular
  // selections, and tries to estimate a character position even for
  // coordinates beyond the right of the text.
  function posFromMouse(cm, e, liberal, forRect) {
    var display = cm.display;
    if (!liberal && e_target(e).getAttribute("cm-not-content") == "true") { return null }

    var x, y, space = display.lineSpace.getBoundingClientRect();
    // Fails unpredictably on IE[67] when mouse is dragged around quickly.
    try { x = e.clientX - space.left; y = e.clientY - space.top; }
    catch (e$1) { return null }
    var coords = coordsChar(cm, x, y), line;
    if (forRect && coords.xRel > 0 && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
      var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
      coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff));
    }
    return coords
  }

  // Find the view element corresponding to a given line. Return null
  // when the line isn't visible.
  function findViewIndex(cm, n) {
    if (n >= cm.display.viewTo) { return null }
    n -= cm.display.viewFrom;
    if (n < 0) { return null }
    var view = cm.display.view;
    for (var i = 0; i < view.length; i++) {
      n -= view[i].size;
      if (n < 0) { return i }
    }
  }

  // Updates the display.view data structure for a given change to the
  // document. From and to are in pre-change coordinates. Lendiff is
  // the amount of lines added or subtracted by the change. This is
  // used for changes that span multiple lines, or change the way
  // lines are divided into visual lines. regLineChange (below)
  // registers single-line changes.
  function regChange(cm, from, to, lendiff) {
    if (from == null) { from = cm.doc.first; }
    if (to == null) { to = cm.doc.first + cm.doc.size; }
    if (!lendiff) { lendiff = 0; }

    var display = cm.display;
    if (lendiff && to < display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers > from))
      { display.updateLineNumbers = from; }

    cm.curOp.viewChanged = true;

    if (from >= display.viewTo) { // Change after
      if (sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo)
        { resetView(cm); }
    } else if (to <= display.viewFrom) { // Change before
      if (sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom) {
        resetView(cm);
      } else {
        display.viewFrom += lendiff;
        display.viewTo += lendiff;
      }
    } else if (from <= display.viewFrom && to >= display.viewTo) { // Full overlap
      resetView(cm);
    } else if (from <= display.viewFrom) { // Top overlap
      var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cut) {
        display.view = display.view.slice(cut.index);
        display.viewFrom = cut.lineN;
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    } else if (to >= display.viewTo) { // Bottom overlap
      var cut$1 = viewCuttingPoint(cm, from, from, -1);
      if (cut$1) {
        display.view = display.view.slice(0, cut$1.index);
        display.viewTo = cut$1.lineN;
      } else {
        resetView(cm);
      }
    } else { // Gap in the middle
      var cutTop = viewCuttingPoint(cm, from, from, -1);
      var cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
      if (cutTop && cutBot) {
        display.view = display.view.slice(0, cutTop.index)
          .concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN))
          .concat(display.view.slice(cutBot.index));
        display.viewTo += lendiff;
      } else {
        resetView(cm);
      }
    }

    var ext = display.externalMeasured;
    if (ext) {
      if (to < ext.lineN)
        { ext.lineN += lendiff; }
      else if (from < ext.lineN + ext.size)
        { display.externalMeasured = null; }
    }
  }

  // Register a change to a single line. Type must be one of "text",
  // "gutter", "class", "widget"
  function regLineChange(cm, line, type) {
    cm.curOp.viewChanged = true;
    var display = cm.display, ext = cm.display.externalMeasured;
    if (ext && line >= ext.lineN && line < ext.lineN + ext.size)
      { display.externalMeasured = null; }

    if (line < display.viewFrom || line >= display.viewTo) { return }
    var lineView = display.view[findViewIndex(cm, line)];
    if (lineView.node == null) { return }
    var arr = lineView.changes || (lineView.changes = []);
    if (indexOf(arr, type) == -1) { arr.push(type); }
  }

  // Clear the view.
  function resetView(cm) {
    cm.display.viewFrom = cm.display.viewTo = cm.doc.first;
    cm.display.view = [];
    cm.display.viewOffset = 0;
  }

  function viewCuttingPoint(cm, oldN, newN, dir) {
    var index = findViewIndex(cm, oldN), diff, view = cm.display.view;
    if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size)
      { return {index: index, lineN: newN} }
    var n = cm.display.viewFrom;
    for (var i = 0; i < index; i++)
      { n += view[i].size; }
    if (n != oldN) {
      if (dir > 0) {
        if (index == view.length - 1) { return null }
        diff = (n + view[index].size) - oldN;
        index++;
      } else {
        diff = n - oldN;
      }
      oldN += diff; newN += diff;
    }
    while (visualLineNo(cm.doc, newN) != newN) {
      if (index == (dir < 0 ? 0 : view.length - 1)) { return null }
      newN += dir * view[index - (dir < 0 ? 1 : 0)].size;
      index += dir;
    }
    return {index: index, lineN: newN}
  }

  // Force the view to cover a given range, adding empty view element
  // or clipping off existing ones as needed.
  function adjustView(cm, from, to) {
    var display = cm.display, view = display.view;
    if (view.length == 0 || from >= display.viewTo || to <= display.viewFrom) {
      display.view = buildViewArray(cm, from, to);
      display.viewFrom = from;
    } else {
      if (display.viewFrom > from)
        { display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view); }
      else if (display.viewFrom < from)
        { display.view = display.view.slice(findViewIndex(cm, from)); }
      display.viewFrom = from;
      if (display.viewTo < to)
        { display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)); }
      else if (display.viewTo > to)
        { display.view = display.view.slice(0, findViewIndex(cm, to)); }
    }
    display.viewTo = to;
  }

  // Count the number of lines in the view whose DOM representation is
  // out of date (or nonexistent).
  function countDirtyView(cm) {
    var view = cm.display.view, dirty = 0;
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (!lineView.hidden && (!lineView.node || lineView.changes)) { ++dirty; }
    }
    return dirty
  }

  function updateSelection(cm) {
    cm.display.input.showSelection(cm.display.input.prepareSelection());
  }

  function prepareSelection(cm, primary) {
    if ( primary === void 0 ) primary = true;

    var doc = cm.doc, result = {};
    var curFragment = result.cursors = document.createDocumentFragment();
    var selFragment = result.selection = document.createDocumentFragment();

    for (var i = 0; i < doc.sel.ranges.length; i++) {
      if (!primary && i == doc.sel.primIndex) { continue }
      var range = doc.sel.ranges[i];
      if (range.from().line >= cm.display.viewTo || range.to().line < cm.display.viewFrom) { continue }
      var collapsed = range.empty();
      if (collapsed || cm.options.showCursorWhenSelecting)
        { drawSelectionCursor(cm, range.head, curFragment); }
      if (!collapsed)
        { drawSelectionRange(cm, range, selFragment); }
    }
    return result
  }

  // Draws a cursor for the given range
  function drawSelectionCursor(cm, head, output) {
    var pos = cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine);

    var cursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor"));
    cursor.style.left = pos.left + "px";
    cursor.style.top = pos.top + "px";
    cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px";

    if (pos.other) {
      // Secondary cursor, shown when on a 'jump' in bi-directional text
      var otherCursor = output.appendChild(elt("div", "\u00a0", "CodeMirror-cursor CodeMirror-secondarycursor"));
      otherCursor.style.display = "";
      otherCursor.style.left = pos.other.left + "px";
      otherCursor.style.top = pos.other.top + "px";
      otherCursor.style.height = (pos.other.bottom - pos.other.top) * .85 + "px";
    }
  }

  function cmpCoords(a, b) { return a.top - b.top || a.left - b.left }

  // Draws the given range as a highlighted selection
  function drawSelectionRange(cm, range, output) {
    var display = cm.display, doc = cm.doc;
    var fragment = document.createDocumentFragment();
    var padding = paddingH(cm.display), leftSide = padding.left;
    var rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right;
    var docLTR = doc.direction == "ltr";

    function add(left, top, width, bottom) {
      if (top < 0) { top = 0; }
      top = Math.round(top);
      bottom = Math.round(bottom);
      fragment.appendChild(elt("div", null, "CodeMirror-selected", ("position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (width == null ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px")));
    }

    function drawForLine(line, fromArg, toArg) {
      var lineObj = getLine(doc, line);
      var lineLen = lineObj.text.length;
      var start, end;
      function coords(ch, bias) {
        return charCoords(cm, Pos(line, ch), "div", lineObj, bias)
      }

      function wrapX(pos, dir, side) {
        var extent = wrappedLineExtentChar(cm, lineObj, null, pos);
        var prop = (dir == "ltr") == (side == "after") ? "left" : "right";
        var ch = side == "after" ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
        return coords(ch, prop)[prop]
      }

      var order = getOrder(lineObj, doc.direction);
      iterateBidiSections(order, fromArg || 0, toArg == null ? lineLen : toArg, function (from, to, dir, i) {
        var ltr = dir == "ltr";
        var fromPos = coords(from, ltr ? "left" : "right");
        var toPos = coords(to - 1, ltr ? "right" : "left");

        var openStart = fromArg == null && from == 0, openEnd = toArg == null && to == lineLen;
        var first = i == 0, last = !order || i == order.length - 1;
        if (toPos.top - fromPos.top <= 3) { // Single line
          var openLeft = (docLTR ? openStart : openEnd) && first;
          var openRight = (docLTR ? openEnd : openStart) && last;
          var left = openLeft ? leftSide : (ltr ? fromPos : toPos).left;
          var right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
          add(left, fromPos.top, right - left, fromPos.bottom);
        } else { // Multiple lines
          var topLeft, topRight, botLeft, botRight;
          if (ltr) {
            topLeft = docLTR && openStart && first ? leftSide : fromPos.left;
            topRight = docLTR ? rightSide : wrapX(from, dir, "before");
            botLeft = docLTR ? leftSide : wrapX(to, dir, "after");
            botRight = docLTR && openEnd && last ? rightSide : toPos.right;
          } else {
            topLeft = !docLTR ? leftSide : wrapX(from, dir, "before");
            topRight = !docLTR && openStart && first ? rightSide : fromPos.right;
            botLeft = !docLTR && openEnd && last ? leftSide : toPos.left;
            botRight = !docLTR ? rightSide : wrapX(to, dir, "after");
          }
          add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom);
          if (fromPos.bottom < toPos.top) { add(leftSide, fromPos.bottom, null, toPos.top); }
          add(botLeft, toPos.top, botRight - botLeft, toPos.bottom);
        }

        if (!start || cmpCoords(fromPos, start) < 0) { start = fromPos; }
        if (cmpCoords(toPos, start) < 0) { start = toPos; }
        if (!end || cmpCoords(fromPos, end) < 0) { end = fromPos; }
        if (cmpCoords(toPos, end) < 0) { end = toPos; }
      });
      return {start: start, end: end}
    }

    var sFrom = range.from(), sTo = range.to();
    if (sFrom.line == sTo.line) {
      drawForLine(sFrom.line, sFrom.ch, sTo.ch);
    } else {
      var fromLine = getLine(doc, sFrom.line), toLine = getLine(doc, sTo.line);
      var singleVLine = visualLine(fromLine) == visualLine(toLine);
      var leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end;
      var rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
      if (singleVLine) {
        if (leftEnd.top < rightStart.top - 2) {
          add(leftEnd.right, leftEnd.top, null, leftEnd.bottom);
          add(leftSide, rightStart.top, rightStart.left, rightStart.bottom);
        } else {
          add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom);
        }
      }
      if (leftEnd.bottom < rightStart.top)
        { add(leftSide, leftEnd.bottom, null, rightStart.top); }
    }

    output.appendChild(fragment);
  }

  // Cursor-blinking
  function restartBlink(cm) {
    if (!cm.state.focused) { return }
    var display = cm.display;
    clearInterval(display.blinker);
    var on = true;
    display.cursorDiv.style.visibility = "";
    if (cm.options.cursorBlinkRate > 0)
      { display.blinker = setInterval(function () {
        if (!cm.hasFocus()) { onBlur(cm); }
        display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden";
      }, cm.options.cursorBlinkRate); }
    else if (cm.options.cursorBlinkRate < 0)
      { display.cursorDiv.style.visibility = "hidden"; }
  }

  function ensureFocus(cm) {
    if (!cm.hasFocus()) {
      cm.display.input.focus();
      if (!cm.state.focused) { onFocus(cm); }
    }
  }

  function delayBlurEvent(cm) {
    cm.state.delayingBlurEvent = true;
    setTimeout(function () { if (cm.state.delayingBlurEvent) {
      cm.state.delayingBlurEvent = false;
      if (cm.state.focused) { onBlur(cm); }
    } }, 100);
  }

  function onFocus(cm, e) {
    if (cm.state.delayingBlurEvent && !cm.state.draggingText) { cm.state.delayingBlurEvent = false; }

    if (cm.options.readOnly == "nocursor") { return }
    if (!cm.state.focused) {
      signal(cm, "focus", cm, e);
      cm.state.focused = true;
      addClass(cm.display.wrapper, "CodeMirror-focused");
      // This test prevents this from firing when a context
      // menu is closed (since the input reset would kill the
      // select-all detection hack)
      if (!cm.curOp && cm.display.selForContextMenu != cm.doc.sel) {
        cm.display.input.reset();
        if (webkit) { setTimeout(function () { return cm.display.input.reset(true); }, 20); } // Issue #1730
      }
      cm.display.input.receivedFocus();
    }
    restartBlink(cm);
  }
  function onBlur(cm, e) {
    if (cm.state.delayingBlurEvent) { return }

    if (cm.state.focused) {
      signal(cm, "blur", cm, e);
      cm.state.focused = false;
      rmClass(cm.display.wrapper, "CodeMirror-focused");
    }
    clearInterval(cm.display.blinker);
    setTimeout(function () { if (!cm.state.focused) { cm.display.shift = false; } }, 150);
  }

  // Read the actual heights of the rendered lines, and update their
  // stored heights to match.
  function updateHeightsInViewport(cm) {
    var display = cm.display;
    var prevBottom = display.lineDiv.offsetTop;
    for (var i = 0; i < display.view.length; i++) {
      var cur = display.view[i], wrapping = cm.options.lineWrapping;
      var height = (void 0), width = 0;
      if (cur.hidden) { continue }
      if (ie && ie_version < 8) {
        var bot = cur.node.offsetTop + cur.node.offsetHeight;
        height = bot - prevBottom;
        prevBottom = bot;
      } else {
        var box = cur.node.getBoundingClientRect();
        height = box.bottom - box.top;
        // Check that lines don't extend past the right of the current
        // editor width
        if (!wrapping && cur.text.firstChild)
          { width = cur.text.firstChild.getBoundingClientRect().right - box.left - 1; }
      }
      var diff = cur.line.height - height;
      if (diff > .005 || diff < -.005) {
        updateLineHeight(cur.line, height);
        updateWidgetHeight(cur.line);
        if (cur.rest) { for (var j = 0; j < cur.rest.length; j++)
          { updateWidgetHeight(cur.rest[j]); } }
      }
      if (width > cm.display.sizerWidth) {
        var chWidth = Math.ceil(width / charWidth(cm.display));
        if (chWidth > cm.display.maxLineLength) {
          cm.display.maxLineLength = chWidth;
          cm.display.maxLine = cur.line;
          cm.display.maxLineChanged = true;
        }
      }
    }
  }

  // Read and store the height of line widgets associated with the
  // given line.
  function updateWidgetHeight(line) {
    if (line.widgets) { for (var i = 0; i < line.widgets.length; ++i) {
      var w = line.widgets[i], parent = w.node.parentNode;
      if (parent) { w.height = parent.offsetHeight; }
    } }
  }

  // Compute the lines that are visible in a given viewport (defaults
  // the the current scroll position). viewport may contain top,
  // height, and ensure (see op.scrollToPos) properties.
  function visibleLines(display, doc, viewport) {
    var top = viewport && viewport.top != null ? Math.max(0, viewport.top) : display.scroller.scrollTop;
    top = Math.floor(top - paddingTop(display));
    var bottom = viewport && viewport.bottom != null ? viewport.bottom : top + display.wrapper.clientHeight;

    var from = lineAtHeight(doc, top), to = lineAtHeight(doc, bottom);
    // Ensure is a {from: {line, ch}, to: {line, ch}} object, and
    // forces those lines into the viewport (if possible).
    if (viewport && viewport.ensure) {
      var ensureFrom = viewport.ensure.from.line, ensureTo = viewport.ensure.to.line;
      if (ensureFrom < from) {
        from = ensureFrom;
        to = lineAtHeight(doc, heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight);
      } else if (Math.min(ensureTo, doc.lastLine()) >= to) {
        from = lineAtHeight(doc, heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight);
        to = ensureTo;
      }
    }
    return {from: from, to: Math.max(to, from + 1)}
  }

  // SCROLLING THINGS INTO VIEW

  // If an editor sits on the top or bottom of the window, partially
  // scrolled out of view, this ensures that the cursor is visible.
  function maybeScrollWindow(cm, rect) {
    if (signalDOMEvent(cm, "scrollCursorIntoView")) { return }

    var display = cm.display, box = display.sizer.getBoundingClientRect(), doScroll = null;
    if (rect.top + box.top < 0) { doScroll = true; }
    else if (rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight)) { doScroll = false; }
    if (doScroll != null && !phantom) {
      var scrollNode = elt("div", "\u200b", null, ("position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + (rect.left) + "px; width: " + (Math.max(2, rect.right - rect.left)) + "px;"));
      cm.display.lineSpace.appendChild(scrollNode);
      scrollNode.scrollIntoView(doScroll);
      cm.display.lineSpace.removeChild(scrollNode);
    }
  }

  // Scroll a given position into view (immediately), verifying that
  // it actually became visible (as line heights are accurately
  // measured, the position of something may 'drift' during drawing).
  function scrollPosIntoView(cm, pos, end, margin) {
    if (margin == null) { margin = 0; }
    var rect;
    if (!cm.options.lineWrapping && pos == end) {
      // Set pos and end to the cursor positions around the character pos sticks to
      // If pos.sticky == "before", that is around pos.ch - 1, otherwise around pos.ch
      // If pos == Pos(_, 0, "before"), pos and end are unchanged
      pos = pos.ch ? Pos(pos.line, pos.sticky == "before" ? pos.ch - 1 : pos.ch, "after") : pos;
      end = pos.sticky == "before" ? Pos(pos.line, pos.ch + 1, "before") : pos;
    }
    for (var limit = 0; limit < 5; limit++) {
      var changed = false;
      var coords = cursorCoords(cm, pos);
      var endCoords = !end || end == pos ? coords : cursorCoords(cm, end);
      rect = {left: Math.min(coords.left, endCoords.left),
              top: Math.min(coords.top, endCoords.top) - margin,
              right: Math.max(coords.left, endCoords.left),
              bottom: Math.max(coords.bottom, endCoords.bottom) + margin};
      var scrollPos = calculateScrollPos(cm, rect);
      var startTop = cm.doc.scrollTop, startLeft = cm.doc.scrollLeft;
      if (scrollPos.scrollTop != null) {
        updateScrollTop(cm, scrollPos.scrollTop);
        if (Math.abs(cm.doc.scrollTop - startTop) > 1) { changed = true; }
      }
      if (scrollPos.scrollLeft != null) {
        setScrollLeft(cm, scrollPos.scrollLeft);
        if (Math.abs(cm.doc.scrollLeft - startLeft) > 1) { changed = true; }
      }
      if (!changed) { break }
    }
    return rect
  }

  // Scroll a given set of coordinates into view (immediately).
  function scrollIntoView(cm, rect) {
    var scrollPos = calculateScrollPos(cm, rect);
    if (scrollPos.scrollTop != null) { updateScrollTop(cm, scrollPos.scrollTop); }
    if (scrollPos.scrollLeft != null) { setScrollLeft(cm, scrollPos.scrollLeft); }
  }

  // Calculate a new scroll position needed to scroll the given
  // rectangle into view. Returns an object with scrollTop and
  // scrollLeft properties. When these are undefined, the
  // vertical/horizontal position does not need to be adjusted.
  function calculateScrollPos(cm, rect) {
    var display = cm.display, snapMargin = textHeight(cm.display);
    if (rect.top < 0) { rect.top = 0; }
    var screentop = cm.curOp && cm.curOp.scrollTop != null ? cm.curOp.scrollTop : display.scroller.scrollTop;
    var screen = displayHeight(cm), result = {};
    if (rect.bottom - rect.top > screen) { rect.bottom = rect.top + screen; }
    var docBottom = cm.doc.height + paddingVert(display);
    var atTop = rect.top < snapMargin, atBottom = rect.bottom > docBottom - snapMargin;
    if (rect.top < screentop) {
      result.scrollTop = atTop ? 0 : rect.top;
    } else if (rect.bottom > screentop + screen) {
      var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
      if (newTop != screentop) { result.scrollTop = newTop; }
    }

    var gutterSpace = cm.options.fixedGutter ? 0 : display.gutters.offsetWidth;
    var screenleft = cm.curOp && cm.curOp.scrollLeft != null ? cm.curOp.scrollLeft : display.scroller.scrollLeft - gutterSpace;
    var screenw = displayWidth(cm) - display.gutters.offsetWidth;
    var tooWide = rect.right - rect.left > screenw;
    if (tooWide) { rect.right = rect.left + screenw; }
    if (rect.left < 10)
      { result.scrollLeft = 0; }
    else if (rect.left < screenleft)
      { result.scrollLeft = Math.max(0, rect.left + gutterSpace - (tooWide ? 0 : 10)); }
    else if (rect.right > screenw + screenleft - 3)
      { result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw; }
    return result
  }

  // Store a relative adjustment to the scroll position in the current
  // operation (to be applied when the operation finishes).
  function addToScrollTop(cm, top) {
    if (top == null) { return }
    resolveScrollToPos(cm);
    cm.curOp.scrollTop = (cm.curOp.scrollTop == null ? cm.doc.scrollTop : cm.curOp.scrollTop) + top;
  }

  // Make sure that at the end of the operation the current cursor is
  // shown.
  function ensureCursorVisible(cm) {
    resolveScrollToPos(cm);
    var cur = cm.getCursor();
    cm.curOp.scrollToPos = {from: cur, to: cur, margin: cm.options.cursorScrollMargin};
  }

  function scrollToCoords(cm, x, y) {
    if (x != null || y != null) { resolveScrollToPos(cm); }
    if (x != null) { cm.curOp.scrollLeft = x; }
    if (y != null) { cm.curOp.scrollTop = y; }
  }

  function scrollToRange(cm, range) {
    resolveScrollToPos(cm);
    cm.curOp.scrollToPos = range;
  }

  // When an operation has its scrollToPos property set, and another
  // scroll action is applied before the end of the operation, this
  // 'simulates' scrolling that position into view in a cheap way, so
  // that the effect of intermediate scroll commands is not ignored.
  function resolveScrollToPos(cm) {
    var range = cm.curOp.scrollToPos;
    if (range) {
      cm.curOp.scrollToPos = null;
      var from = estimateCoords(cm, range.from), to = estimateCoords(cm, range.to);
      scrollToCoordsRange(cm, from, to, range.margin);
    }
  }

  function scrollToCoordsRange(cm, from, to, margin) {
    var sPos = calculateScrollPos(cm, {
      left: Math.min(from.left, to.left),
      top: Math.min(from.top, to.top) - margin,
      right: Math.max(from.right, to.right),
      bottom: Math.max(from.bottom, to.bottom) + margin
    });
    scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop);
  }

  // Sync the scrollable area and scrollbars, ensure the viewport
  // covers the visible area.
  function updateScrollTop(cm, val) {
    if (Math.abs(cm.doc.scrollTop - val) < 2) { return }
    if (!gecko) { updateDisplaySimple(cm, {top: val}); }
    setScrollTop(cm, val, true);
    if (gecko) { updateDisplaySimple(cm); }
    startWorker(cm, 100);
  }

  function setScrollTop(cm, val, forceScroll) {
    val = Math.max(0, Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val));
    if (cm.display.scroller.scrollTop == val && !forceScroll) { return }
    cm.doc.scrollTop = val;
    cm.display.scrollbars.setScrollTop(val);
    if (cm.display.scroller.scrollTop != val) { cm.display.scroller.scrollTop = val; }
  }

  // Sync scroller and scrollbar, ensure the gutter elements are
  // aligned.
  function setScrollLeft(cm, val, isScroller, forceScroll) {
    val = Math.max(0, Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth));
    if ((isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll) { return }
    cm.doc.scrollLeft = val;
    alignHorizontally(cm);
    if (cm.display.scroller.scrollLeft != val) { cm.display.scroller.scrollLeft = val; }
    cm.display.scrollbars.setScrollLeft(val);
  }

  // SCROLLBARS

  // Prepare DOM reads needed to update the scrollbars. Done in one
  // shot to minimize update/measure roundtrips.
  function measureForScrollbars(cm) {
    var d = cm.display, gutterW = d.gutters.offsetWidth;
    var docH = Math.round(cm.doc.height + paddingVert(cm.display));
    return {
      clientHeight: d.scroller.clientHeight,
      viewHeight: d.wrapper.clientHeight,
      scrollWidth: d.scroller.scrollWidth, clientWidth: d.scroller.clientWidth,
      viewWidth: d.wrapper.clientWidth,
      barLeft: cm.options.fixedGutter ? gutterW : 0,
      docHeight: docH,
      scrollHeight: docH + scrollGap(cm) + d.barHeight,
      nativeBarWidth: d.nativeBarWidth,
      gutterWidth: gutterW
    }
  }

  var NativeScrollbars = function(place, scroll, cm) {
    this.cm = cm;
    var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar");
    var horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
    vert.tabIndex = horiz.tabIndex = -1;
    place(vert); place(horiz);

    on(vert, "scroll", function () {
      if (vert.clientHeight) { scroll(vert.scrollTop, "vertical"); }
    });
    on(horiz, "scroll", function () {
      if (horiz.clientWidth) { scroll(horiz.scrollLeft, "horizontal"); }
    });

    this.checkedZeroWidth = false;
    // Need to set a minimum width to see the scrollbar on IE7 (but must not set it on IE8).
    if (ie && ie_version < 8) { this.horiz.style.minHeight = this.vert.style.minWidth = "18px"; }
  };

  NativeScrollbars.prototype.update = function (measure) {
    var needsH = measure.scrollWidth > measure.clientWidth + 1;
    var needsV = measure.scrollHeight > measure.clientHeight + 1;
    var sWidth = measure.nativeBarWidth;

    if (needsV) {
      this.vert.style.display = "block";
      this.vert.style.bottom = needsH ? sWidth + "px" : "0";
      var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
      // A bug in IE8 can cause this value to be negative, so guard it.
      this.vert.firstChild.style.height =
        Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px";
    } else {
      this.vert.style.display = "";
      this.vert.firstChild.style.height = "0";
    }

    if (needsH) {
      this.horiz.style.display = "block";
      this.horiz.style.right = needsV ? sWidth + "px" : "0";
      this.horiz.style.left = measure.barLeft + "px";
      var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
      this.horiz.firstChild.style.width =
        Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px";
    } else {
      this.horiz.style.display = "";
      this.horiz.firstChild.style.width = "0";
    }

    if (!this.checkedZeroWidth && measure.clientHeight > 0) {
      if (sWidth == 0) { this.zeroWidthHack(); }
      this.checkedZeroWidth = true;
    }

    return {right: needsV ? sWidth : 0, bottom: needsH ? sWidth : 0}
  };

  NativeScrollbars.prototype.setScrollLeft = function (pos) {
    if (this.horiz.scrollLeft != pos) { this.horiz.scrollLeft = pos; }
    if (this.disableHoriz) { this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz"); }
  };

  NativeScrollbars.prototype.setScrollTop = function (pos) {
    if (this.vert.scrollTop != pos) { this.vert.scrollTop = pos; }
    if (this.disableVert) { this.enableZeroWidthBar(this.vert, this.disableVert, "vert"); }
  };

  NativeScrollbars.prototype.zeroWidthHack = function () {
    var w = mac && !mac_geMountainLion ? "12px" : "18px";
    this.horiz.style.height = this.vert.style.width = w;
    this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none";
    this.disableHoriz = new Delayed;
    this.disableVert = new Delayed;
  };

  NativeScrollbars.prototype.enableZeroWidthBar = function (bar, delay, type) {
    bar.style.pointerEvents = "auto";
    function maybeDisable() {
      // To find out whether the scrollbar is still visible, we
      // check whether the element under the pixel in the bottom
      // right corner of the scrollbar box is the scrollbar box
      // itself (when the bar is still visible) or its filler child
      // (when the bar is hidden). If it is still visible, we keep
      // it enabled, if it's hidden, we disable pointer events.
      var box = bar.getBoundingClientRect();
      var elt = type == "vert" ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2)
          : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
      if (elt != bar) { bar.style.pointerEvents = "none"; }
      else { delay.set(1000, maybeDisable); }
    }
    delay.set(1000, maybeDisable);
  };

  NativeScrollbars.prototype.clear = function () {
    var parent = this.horiz.parentNode;
    parent.removeChild(this.horiz);
    parent.removeChild(this.vert);
  };

  var NullScrollbars = function () {};

  NullScrollbars.prototype.update = function () { return {bottom: 0, right: 0} };
  NullScrollbars.prototype.setScrollLeft = function () {};
  NullScrollbars.prototype.setScrollTop = function () {};
  NullScrollbars.prototype.clear = function () {};

  function updateScrollbars(cm, measure) {
    if (!measure) { measure = measureForScrollbars(cm); }
    var startWidth = cm.display.barWidth, startHeight = cm.display.barHeight;
    updateScrollbarsInner(cm, measure);
    for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) {
      if (startWidth != cm.display.barWidth && cm.options.lineWrapping)
        { updateHeightsInViewport(cm); }
      updateScrollbarsInner(cm, measureForScrollbars(cm));
      startWidth = cm.display.barWidth; startHeight = cm.display.barHeight;
    }
  }

  // Re-synchronize the fake scrollbars with the actual size of the
  // content.
  function updateScrollbarsInner(cm, measure) {
    var d = cm.display;
    var sizes = d.scrollbars.update(measure);

    d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px";
    d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px";
    d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent";

    if (sizes.right && sizes.bottom) {
      d.scrollbarFiller.style.display = "block";
      d.scrollbarFiller.style.height = sizes.bottom + "px";
      d.scrollbarFiller.style.width = sizes.right + "px";
    } else { d.scrollbarFiller.style.display = ""; }
    if (sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter) {
      d.gutterFiller.style.display = "block";
      d.gutterFiller.style.height = sizes.bottom + "px";
      d.gutterFiller.style.width = measure.gutterWidth + "px";
    } else { d.gutterFiller.style.display = ""; }
  }

  var scrollbarModel = {"native": NativeScrollbars, "null": NullScrollbars};

  function initScrollbars(cm) {
    if (cm.display.scrollbars) {
      cm.display.scrollbars.clear();
      if (cm.display.scrollbars.addClass)
        { rmClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
    }

    cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function (node) {
      cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller);
      // Prevent clicks in the scrollbars from killing focus
      on(node, "mousedown", function () {
        if (cm.state.focused) { setTimeout(function () { return cm.display.input.focus(); }, 0); }
      });
      node.setAttribute("cm-not-content", "true");
    }, function (pos, axis) {
      if (axis == "horizontal") { setScrollLeft(cm, pos); }
      else { updateScrollTop(cm, pos); }
    }, cm);
    if (cm.display.scrollbars.addClass)
      { addClass(cm.display.wrapper, cm.display.scrollbars.addClass); }
  }

  // Operations are used to wrap a series of changes to the editor
  // state in such a way that each change won't have to update the
  // cursor and display (which would be awkward, slow, and
  // error-prone). Instead, display updates are batched and then all
  // combined and executed at once.

  var nextOpId = 0;
  // Start a new operation.
  function startOperation(cm) {
    cm.curOp = {
      cm: cm,
      viewChanged: false,      // Flag that indicates that lines might need to be redrawn
      startHeight: cm.doc.height, // Used to detect need to update scrollbar
      forceUpdate: false,      // Used to force a redraw
      updateInput: 0,       // Whether to reset the input textarea
      typing: false,           // Whether this reset should be careful to leave existing text (for compositing)
      changeObjs: null,        // Accumulated changes, for firing change events
      cursorActivityHandlers: null, // Set of handlers to fire cursorActivity on
      cursorActivityCalled: 0, // Tracks which cursorActivity handlers have been called already
      selectionChanged: false, // Whether the selection needs to be redrawn
      updateMaxLine: false,    // Set when the widest line needs to be determined anew
      scrollLeft: null, scrollTop: null, // Intermediate scroll position, not pushed to DOM yet
      scrollToPos: null,       // Used to scroll to a specific position
      focus: false,
      id: ++nextOpId           // Unique ID
    };
    pushOperation(cm.curOp);
  }

  // Finish an operation, updating the display and signalling delayed events
  function endOperation(cm) {
    var op = cm.curOp;
    if (op) { finishOperation(op, function (group) {
      for (var i = 0; i < group.ops.length; i++)
        { group.ops[i].cm.curOp = null; }
      endOperations(group);
    }); }
  }

  // The DOM updates done when an operation finishes are batched so
  // that the minimum number of relayouts are required.
  function endOperations(group) {
    var ops = group.ops;
    for (var i = 0; i < ops.length; i++) // Read DOM
      { endOperation_R1(ops[i]); }
    for (var i$1 = 0; i$1 < ops.length; i$1++) // Write DOM (maybe)
      { endOperation_W1(ops[i$1]); }
    for (var i$2 = 0; i$2 < ops.length; i$2++) // Read DOM
      { endOperation_R2(ops[i$2]); }
    for (var i$3 = 0; i$3 < ops.length; i$3++) // Write DOM (maybe)
      { endOperation_W2(ops[i$3]); }
    for (var i$4 = 0; i$4 < ops.length; i$4++) // Read DOM
      { endOperation_finish(ops[i$4]); }
  }

  function endOperation_R1(op) {
    var cm = op.cm, display = cm.display;
    maybeClipScrollbars(cm);
    if (op.updateMaxLine) { findMaxLine(cm); }

    op.mustUpdate = op.viewChanged || op.forceUpdate || op.scrollTop != null ||
      op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom ||
                         op.scrollToPos.to.line >= display.viewTo) ||
      display.maxLineChanged && cm.options.lineWrapping;
    op.update = op.mustUpdate &&
      new DisplayUpdate(cm, op.mustUpdate && {top: op.scrollTop, ensure: op.scrollToPos}, op.forceUpdate);
  }

  function endOperation_W1(op) {
    op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update);
  }

  function endOperation_R2(op) {
    var cm = op.cm, display = cm.display;
    if (op.updatedDisplay) { updateHeightsInViewport(cm); }

    op.barMeasure = measureForScrollbars(cm);

    // If the max line changed since it was last measured, measure it,
    // and ensure the document's width matches it.
    // updateDisplay_W2 will use these properties to do the actual resizing
    if (display.maxLineChanged && !cm.options.lineWrapping) {
      op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3;
      cm.display.sizerWidth = op.adjustWidthTo;
      op.barMeasure.scrollWidth =
        Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth);
      op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm));
    }

    if (op.updatedDisplay || op.selectionChanged)
      { op.preparedSelection = display.input.prepareSelection(); }
  }

  function endOperation_W2(op) {
    var cm = op.cm;

    if (op.adjustWidthTo != null) {
      cm.display.sizer.style.minWidth = op.adjustWidthTo + "px";
      if (op.maxScrollLeft < cm.doc.scrollLeft)
        { setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), true); }
      cm.display.maxLineChanged = false;
    }

    var takeFocus = op.focus && op.focus == activeElt();
    if (op.preparedSelection)
      { cm.display.input.showSelection(op.preparedSelection, takeFocus); }
    if (op.updatedDisplay || op.startHeight != cm.doc.height)
      { updateScrollbars(cm, op.barMeasure); }
    if (op.updatedDisplay)
      { setDocumentHeight(cm, op.barMeasure); }

    if (op.selectionChanged) { restartBlink(cm); }

    if (cm.state.focused && op.updateInput)
      { cm.display.input.reset(op.typing); }
    if (takeFocus) { ensureFocus(op.cm); }
  }

  function endOperation_finish(op) {
    var cm = op.cm, display = cm.display, doc = cm.doc;

    if (op.updatedDisplay) { postUpdateDisplay(cm, op.update); }

    // Abort mouse wheel delta measurement, when scrolling explicitly
    if (display.wheelStartX != null && (op.scrollTop != null || op.scrollLeft != null || op.scrollToPos))
      { display.wheelStartX = display.wheelStartY = null; }

    // Propagate the scroll position to the actual DOM scroller
    if (op.scrollTop != null) { setScrollTop(cm, op.scrollTop, op.forceScroll); }

    if (op.scrollLeft != null) { setScrollLeft(cm, op.scrollLeft, true, true); }
    // If we need to scroll a specific position into view, do so.
    if (op.scrollToPos) {
      var rect = scrollPosIntoView(cm, clipPos(doc, op.scrollToPos.from),
                                   clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
      maybeScrollWindow(cm, rect);
    }

    // Fire events for markers that are hidden/unidden by editing or
    // undoing
    var hidden = op.maybeHiddenMarkers, unhidden = op.maybeUnhiddenMarkers;
    if (hidden) { for (var i = 0; i < hidden.length; ++i)
      { if (!hidden[i].lines.length) { signal(hidden[i], "hide"); } } }
    if (unhidden) { for (var i$1 = 0; i$1 < unhidden.length; ++i$1)
      { if (unhidden[i$1].lines.length) { signal(unhidden[i$1], "unhide"); } } }

    if (display.wrapper.offsetHeight)
      { doc.scrollTop = cm.display.scroller.scrollTop; }

    // Fire change events, and delayed event handlers
    if (op.changeObjs)
      { signal(cm, "changes", cm, op.changeObjs); }
    if (op.update)
      { op.update.finish(); }
  }

  // Run the given function in an operation
  function runInOp(cm, f) {
    if (cm.curOp) { return f() }
    startOperation(cm);
    try { return f() }
    finally { endOperation(cm); }
  }
  // Wraps a function in an operation. Returns the wrapped function.
  function operation(cm, f) {
    return function() {
      if (cm.curOp) { return f.apply(cm, arguments) }
      startOperation(cm);
      try { return f.apply(cm, arguments) }
      finally { endOperation(cm); }
    }
  }
  // Used to add methods to editor and doc instances, wrapping them in
  // operations.
  function methodOp(f) {
    return function() {
      if (this.curOp) { return f.apply(this, arguments) }
      startOperation(this);
      try { return f.apply(this, arguments) }
      finally { endOperation(this); }
    }
  }
  function docMethodOp(f) {
    return function() {
      var cm = this.cm;
      if (!cm || cm.curOp) { return f.apply(this, arguments) }
      startOperation(cm);
      try { return f.apply(this, arguments) }
      finally { endOperation(cm); }
    }
  }

  // HIGHLIGHT WORKER

  function startWorker(cm, time) {
    if (cm.doc.highlightFrontier < cm.display.viewTo)
      { cm.state.highlight.set(time, bind(highlightWorker, cm)); }
  }

  function highlightWorker(cm) {
    var doc = cm.doc;
    if (doc.highlightFrontier >= cm.display.viewTo) { return }
    var end = +new Date + cm.options.workTime;
    var context = getContextBefore(cm, doc.highlightFrontier);
    var changedLines = [];

    doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function (line) {
      if (context.line >= cm.display.viewFrom) { // Visible
        var oldStyles = line.styles;
        var resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null;
        var highlighted = highlightLine(cm, line, context, true);
        if (resetState) { context.state = resetState; }
        line.styles = highlighted.styles;
        var oldCls = line.styleClasses, newCls = highlighted.classes;
        if (newCls) { line.styleClasses = newCls; }
        else if (oldCls) { line.styleClasses = null; }
        var ischange = !oldStyles || oldStyles.length != line.styles.length ||
          oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass);
        for (var i = 0; !ischange && i < oldStyles.length; ++i) { ischange = oldStyles[i] != line.styles[i]; }
        if (ischange) { changedLines.push(context.line); }
        line.stateAfter = context.save();
        context.nextLine();
      } else {
        if (line.text.length <= cm.options.maxHighlightLength)
          { processLine(cm, line.text, context); }
        line.stateAfter = context.line % 5 == 0 ? context.save() : null;
        context.nextLine();
      }
      if (+new Date > end) {
        startWorker(cm, cm.options.workDelay);
        return true
      }
    });
    doc.highlightFrontier = context.line;
    doc.modeFrontier = Math.max(doc.modeFrontier, context.line);
    if (changedLines.length) { runInOp(cm, function () {
      for (var i = 0; i < changedLines.length; i++)
        { regLineChange(cm, changedLines[i], "text"); }
    }); }
  }

  // DISPLAY DRAWING

  var DisplayUpdate = function(cm, viewport, force) {
    var display = cm.display;

    this.viewport = viewport;
    // Store some values that we'll need later (but don't want to force a relayout for)
    this.visible = visibleLines(display, cm.doc, viewport);
    this.editorIsHidden = !display.wrapper.offsetWidth;
    this.wrapperHeight = display.wrapper.clientHeight;
    this.wrapperWidth = display.wrapper.clientWidth;
    this.oldDisplayWidth = displayWidth(cm);
    this.force = force;
    this.dims = getDimensions(cm);
    this.events = [];
  };

  DisplayUpdate.prototype.signal = function (emitter, type) {
    if (hasHandler(emitter, type))
      { this.events.push(arguments); }
  };
  DisplayUpdate.prototype.finish = function () {
    for (var i = 0; i < this.events.length; i++)
      { signal.apply(null, this.events[i]); }
  };

  function maybeClipScrollbars(cm) {
    var display = cm.display;
    if (!display.scrollbarsClipped && display.scroller.offsetWidth) {
      display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth;
      display.heightForcer.style.height = scrollGap(cm) + "px";
      display.sizer.style.marginBottom = -display.nativeBarWidth + "px";
      display.sizer.style.borderRightWidth = scrollGap(cm) + "px";
      display.scrollbarsClipped = true;
    }
  }

  function selectionSnapshot(cm) {
    if (cm.hasFocus()) { return null }
    var active = activeElt();
    if (!active || !contains(cm.display.lineDiv, active)) { return null }
    var result = {activeElt: active};
    if (window.getSelection) {
      var sel = window.getSelection();
      if (sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode)) {
        result.anchorNode = sel.anchorNode;
        result.anchorOffset = sel.anchorOffset;
        result.focusNode = sel.focusNode;
        result.focusOffset = sel.focusOffset;
      }
    }
    return result
  }

  function restoreSelection(snapshot) {
    if (!snapshot || !snapshot.activeElt || snapshot.activeElt == activeElt()) { return }
    snapshot.activeElt.focus();
    if (!/^(INPUT|TEXTAREA)$/.test(snapshot.activeElt.nodeName) &&
        snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode)) {
      var sel = window.getSelection(), range = document.createRange();
      range.setEnd(snapshot.anchorNode, snapshot.anchorOffset);
      range.collapse(false);
      sel.removeAllRanges();
      sel.addRange(range);
      sel.extend(snapshot.focusNode, snapshot.focusOffset);
    }
  }

  // Does the actual updating of the line display. Bails out
  // (returning false) when there is nothing to be done and forced is
  // false.
  function updateDisplayIfNeeded(cm, update) {
    var display = cm.display, doc = cm.doc;

    if (update.editorIsHidden) {
      resetView(cm);
      return false
    }

    // Bail out if the visible area is already rendered and nothing changed.
    if (!update.force &&
        update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo) &&
        display.renderedView == display.view && countDirtyView(cm) == 0)
      { return false }

    if (maybeUpdateLineNumberWidth(cm)) {
      resetView(cm);
      update.dims = getDimensions(cm);
    }

    // Compute a suitable new viewport (from & to)
    var end = doc.first + doc.size;
    var from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first);
    var to = Math.min(end, update.visible.to + cm.options.viewportMargin);
    if (display.viewFrom < from && from - display.viewFrom < 20) { from = Math.max(doc.first, display.viewFrom); }
    if (display.viewTo > to && display.viewTo - to < 20) { to = Math.min(end, display.viewTo); }
    if (sawCollapsedSpans) {
      from = visualLineNo(cm.doc, from);
      to = visualLineEndNo(cm.doc, to);
    }

    var different = from != display.viewFrom || to != display.viewTo ||
      display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
    adjustView(cm, from, to);

    display.viewOffset = heightAtLine(getLine(cm.doc, display.viewFrom));
    // Position the mover div to align with the current scroll position
    cm.display.mover.style.top = display.viewOffset + "px";

    var toUpdate = countDirtyView(cm);
    if (!different && toUpdate == 0 && !update.force && display.renderedView == display.view &&
        (display.updateLineNumbers == null || display.updateLineNumbers >= display.viewTo))
      { return false }

    // For big changes, we hide the enclosing element during the
    // update, since that speeds up the operations on most browsers.
    var selSnapshot = selectionSnapshot(cm);
    if (toUpdate > 4) { display.lineDiv.style.display = "none"; }
    patchDisplay(cm, display.updateLineNumbers, update.dims);
    if (toUpdate > 4) { display.lineDiv.style.display = ""; }
    display.renderedView = display.view;
    // There might have been a widget with a focused element that got
    // hidden or updated, if so re-focus it.
    restoreSelection(selSnapshot);

    // Prevent selection and cursors from interfering with the scroll
    // width and height.
    removeChildren(display.cursorDiv);
    removeChildren(display.selectionDiv);
    display.gutters.style.height = display.sizer.style.minHeight = 0;

    if (different) {
      display.lastWrapHeight = update.wrapperHeight;
      display.lastWrapWidth = update.wrapperWidth;
      startWorker(cm, 400);
    }

    display.updateLineNumbers = null;

    return true
  }

  function postUpdateDisplay(cm, update) {
    var viewport = update.viewport;

    for (var first = true;; first = false) {
      if (!first || !cm.options.lineWrapping || update.oldDisplayWidth == displayWidth(cm)) {
        // Clip forced viewport to actual scrollable area.
        if (viewport && viewport.top != null)
          { viewport = {top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)}; }
        // Updated line heights might result in the drawn area not
        // actually covering the viewport. Keep looping until it does.
        update.visible = visibleLines(cm.display, cm.doc, viewport);
        if (update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo)
          { break }
      } else if (first) {
        update.visible = visibleLines(cm.display, cm.doc, viewport);
      }
      if (!updateDisplayIfNeeded(cm, update)) { break }
      updateHeightsInViewport(cm);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.force = false;
    }

    update.signal(cm, "update", cm);
    if (cm.display.viewFrom != cm.display.reportedViewFrom || cm.display.viewTo != cm.display.reportedViewTo) {
      update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo);
      cm.display.reportedViewFrom = cm.display.viewFrom; cm.display.reportedViewTo = cm.display.viewTo;
    }
  }

  function updateDisplaySimple(cm, viewport) {
    var update = new DisplayUpdate(cm, viewport);
    if (updateDisplayIfNeeded(cm, update)) {
      updateHeightsInViewport(cm);
      postUpdateDisplay(cm, update);
      var barMeasure = measureForScrollbars(cm);
      updateSelection(cm);
      updateScrollbars(cm, barMeasure);
      setDocumentHeight(cm, barMeasure);
      update.finish();
    }
  }

  // Sync the actual display DOM structure with display.view, removing
  // nodes for lines that are no longer in view, and creating the ones
  // that are not there yet, and updating the ones that are out of
  // date.
  function patchDisplay(cm, updateNumbersFrom, dims) {
    var display = cm.display, lineNumbers = cm.options.lineNumbers;
    var container = display.lineDiv, cur = container.firstChild;

    function rm(node) {
      var next = node.nextSibling;
      // Works around a throw-scroll bug in OS X Webkit
      if (webkit && mac && cm.display.currentWheelTarget == node)
        { node.style.display = "none"; }
      else
        { node.parentNode.removeChild(node); }
      return next
    }

    var view = display.view, lineN = display.viewFrom;
    // Loop over the elements in the view, syncing cur (the DOM nodes
    // in display.lineDiv) with the view as we go.
    for (var i = 0; i < view.length; i++) {
      var lineView = view[i];
      if (lineView.hidden) ; else if (!lineView.node || lineView.node.parentNode != container) { // Not drawn yet
        var node = buildLineElement(cm, lineView, lineN, dims);
        container.insertBefore(node, cur);
      } else { // Already drawn
        while (cur != lineView.node) { cur = rm(cur); }
        var updateNumber = lineNumbers && updateNumbersFrom != null &&
          updateNumbersFrom <= lineN && lineView.lineNumber;
        if (lineView.changes) {
          if (indexOf(lineView.changes, "gutter") > -1) { updateNumber = false; }
          updateLineForChanges(cm, lineView, lineN, dims);
        }
        if (updateNumber) {
          removeChildren(lineView.lineNumber);
          lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)));
        }
        cur = lineView.node.nextSibling;
      }
      lineN += lineView.size;
    }
    while (cur) { cur = rm(cur); }
  }

  function updateGutterSpace(display) {
    var width = display.gutters.offsetWidth;
    display.sizer.style.marginLeft = width + "px";
  }

  function setDocumentHeight(cm, measure) {
    cm.display.sizer.style.minHeight = measure.docHeight + "px";
    cm.display.heightForcer.style.top = measure.docHeight + "px";
    cm.display.gutters.style.height = (measure.docHeight + cm.display.barHeight + scrollGap(cm)) + "px";
  }

  // Re-align line numbers and gutter marks to compensate for
  // horizontal scrolling.
  function alignHorizontally(cm) {
    var display = cm.display, view = display.view;
    if (!display.alignWidgets && (!display.gutters.firstChild || !cm.options.fixedGutter)) { return }
    var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft;
    var gutterW = display.gutters.offsetWidth, left = comp + "px";
    for (var i = 0; i < view.length; i++) { if (!view[i].hidden) {
      if (cm.options.fixedGutter) {
        if (view[i].gutter)
          { view[i].gutter.style.left = left; }
        if (view[i].gutterBackground)
          { view[i].gutterBackground.style.left = left; }
      }
      var align = view[i].alignable;
      if (align) { for (var j = 0; j < align.length; j++)
        { align[j].style.left = left; } }
    } }
    if (cm.options.fixedGutter)
      { display.gutters.style.left = (comp + gutterW) + "px"; }
  }

  // Used to ensure that the line number gutter is still the right
  // size for the current document size. Returns true when an update
  // is needed.
  function maybeUpdateLineNumberWidth(cm) {
    if (!cm.options.lineNumbers) { return false }
    var doc = cm.doc, last = lineNumberFor(cm.options, doc.first + doc.size - 1), display = cm.display;
    if (last.length != display.lineNumChars) {
      var test = display.measure.appendChild(elt("div", [elt("div", last)],
                                                 "CodeMirror-linenumber CodeMirror-gutter-elt"));
      var innerW = test.firstChild.offsetWidth, padding = test.offsetWidth - innerW;
      display.lineGutter.style.width = "";
      display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1;
      display.lineNumWidth = display.lineNumInnerWidth + padding;
      display.lineNumChars = display.lineNumInnerWidth ? last.length : -1;
      display.lineGutter.style.width = display.lineNumWidth + "px";
      updateGutterSpace(cm.display);
      return true
    }
    return false
  }

  function getGutters(gutters, lineNumbers) {
    var result = [], sawLineNumbers = false;
    for (var i = 0; i < gutters.length; i++) {
      var name = gutters[i], style = null;
      if (typeof name != "string") { style = name.style; name = name.className; }
      if (name == "CodeMirror-linenumbers") {
        if (!lineNumbers) { continue }
        else { sawLineNumbers = true; }
      }
      result.push({className: name, style: style});
    }
    if (lineNumbers && !sawLineNumbers) { result.push({className: "CodeMirror-linenumbers", style: null}); }
    return result
  }

  // Rebuild the gutter elements, ensure the margin to the left of the
  // code matches their width.
  function renderGutters(display) {
    var gutters = display.gutters, specs = display.gutterSpecs;
    removeChildren(gutters);
    display.lineGutter = null;
    for (var i = 0; i < specs.length; ++i) {
      var ref = specs[i];
      var className = ref.className;
      var style = ref.style;
      var gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + className));
      if (style) { gElt.style.cssText = style; }
      if (className == "CodeMirror-linenumbers") {
        display.lineGutter = gElt;
        gElt.style.width = (display.lineNumWidth || 1) + "px";
      }
    }
    gutters.style.display = specs.length ? "" : "none";
    updateGutterSpace(display);
  }

  function updateGutters(cm) {
    renderGutters(cm.display);
    regChange(cm);
    alignHorizontally(cm);
  }

  // The display handles the DOM integration, both for input reading
  // and content drawing. It holds references to DOM nodes and
  // display-related state.

  function Display(place, doc, input, options) {
    var d = this;
    this.input = input;

    // Covers bottom-right square when both scrollbars are present.
    d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler");
    d.scrollbarFiller.setAttribute("cm-not-content", "true");
    // Covers bottom of gutter when coverGutterNextToScrollbar is on
    // and h scrollbar is present.
    d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler");
    d.gutterFiller.setAttribute("cm-not-content", "true");
    // Will contain the actual code, positioned to cover the viewport.
    d.lineDiv = eltP("div", null, "CodeMirror-code");
    // Elements are added to these to represent selection and cursors.
    d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1");
    d.cursorDiv = elt("div", null, "CodeMirror-cursors");
    // A visibility: hidden element used to find the size of things.
    d.measure = elt("div", null, "CodeMirror-measure");
    // When lines outside of the viewport are measured, they are drawn in this.
    d.lineMeasure = elt("div", null, "CodeMirror-measure");
    // Wraps everything that needs to exist inside the vertically-padded coordinate system
    d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv],
                      null, "position: relative; outline: none");
    var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
    // Moved around its parent to cover visible view.
    d.mover = elt("div", [lines], null, "position: relative");
    // Set to the height of the document, allowing scrolling.
    d.sizer = elt("div", [d.mover], "CodeMirror-sizer");
    d.sizerWidth = null;
    // Behavior of elts with overflow: auto and padding is
    // inconsistent across browsers. This is used to ensure the
    // scrollable area is big enough.
    d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;");
    // Will contain the gutters, if any.
    d.gutters = elt("div", null, "CodeMirror-gutters");
    d.lineGutter = null;
    // Actual scrollable element.
    d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll");
    d.scroller.setAttribute("tabIndex", "-1");
    // The element in which the editor lives.
    d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror");

    // Work around IE7 z-index bug (not perfect, hence IE7 not really being supported)
    if (ie && ie_version < 8) { d.gutters.style.zIndex = -1; d.scroller.style.paddingRight = 0; }
    if (!webkit && !(gecko && mobile)) { d.scroller.draggable = true; }

    if (place) {
      if (place.appendChild) { place.appendChild(d.wrapper); }
      else { place(d.wrapper); }
    }

    // Current rendered range (may be bigger than the view window).
    d.viewFrom = d.viewTo = doc.first;
    d.reportedViewFrom = d.reportedViewTo = doc.first;
    // Information about the rendered lines.
    d.view = [];
    d.renderedView = null;
    // Holds info about a single rendered line when it was rendered
    // for measurement, while not in view.
    d.externalMeasured = null;
    // Empty space (in pixels) above the view
    d.viewOffset = 0;
    d.lastWrapHeight = d.lastWrapWidth = 0;
    d.updateLineNumbers = null;

    d.nativeBarWidth = d.barHeight = d.barWidth = 0;
    d.scrollbarsClipped = false;

    // Used to only resize the line number gutter when necessary (when
    // the amount of lines crosses a boundary that makes its width change)
    d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null;
    // Set to true when a non-horizontal-scrolling line widget is
    // added. As an optimization, line widget aligning is skipped when
    // this is false.
    d.alignWidgets = false;

    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;

    // Tracks the maximum line length so that the horizontal scrollbar
    // can be kept static when scrolling.
    d.maxLine = null;
    d.maxLineLength = 0;
    d.maxLineChanged = false;

    // Used for measuring wheel scrolling granularity
    d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null;

    // True when shift is held down.
    d.shift = false;

    // Used to track whether anything happened since the context menu
    // was opened.
    d.selForContextMenu = null;

    d.activeTouch = null;

    d.gutterSpecs = getGutters(options.gutters, options.lineNumbers);
    renderGutters(d);

    input.init(d);
  }

  // Since the delta values reported on mouse wheel events are
  // unstandardized between browsers and even browser versions, and
  // generally horribly unpredictable, this code starts by measuring
  // the scroll effect that the first few mouse wheel events have,
  // and, from that, detects the way it can convert deltas to pixel
  // offsets afterwards.
  //
  // The reason we want to know the amount a wheel event will scroll
  // is that it gives us a chance to update the display before the
  // actual scrolling happens, reducing flickering.

  var wheelSamples = 0, wheelPixelsPerUnit = null;
  // Fill in a browser-detected starting value on browsers where we
  // know one. These don't have to be accurate -- the result of them
  // being wrong would just be a slight flicker on the first wheel
  // scroll (if it is large enough).
  if (ie) { wheelPixelsPerUnit = -.53; }
  else if (gecko) { wheelPixelsPerUnit = 15; }
  else if (chrome) { wheelPixelsPerUnit = -.7; }
  else if (safari) { wheelPixelsPerUnit = -1/3; }

  function wheelEventDelta(e) {
    var dx = e.wheelDeltaX, dy = e.wheelDeltaY;
    if (dx == null && e.detail && e.axis == e.HORIZONTAL_AXIS) { dx = e.detail; }
    if (dy == null && e.detail && e.axis == e.VERTICAL_AXIS) { dy = e.detail; }
    else if (dy == null) { dy = e.wheelDelta; }
    return {x: dx, y: dy}
  }
  function wheelEventPixels(e) {
    var delta = wheelEventDelta(e);
    delta.x *= wheelPixelsPerUnit;
    delta.y *= wheelPixelsPerUnit;
    return delta
  }

  function onScrollWheel(cm, e) {
    var delta = wheelEventDelta(e), dx = delta.x, dy = delta.y;

    var display = cm.display, scroll = display.scroller;
    // Quit if there's nothing to scroll here
    var canScrollX = scroll.scrollWidth > scroll.clientWidth;
    var canScrollY = scroll.scrollHeight > scroll.clientHeight;
    if (!(dx && canScrollX || dy && canScrollY)) { return }

    // Webkit browsers on OS X abort momentum scrolls when the target
    // of the scroll event is removed from the scrollable element.
    // This hack (see related code in patchDisplay) makes sure the
    // element is kept around.
    if (dy && mac && webkit) {
      outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode) {
        for (var i = 0; i < view.length; i++) {
          if (view[i].node == cur) {
            cm.display.currentWheelTarget = cur;
            break outer
          }
        }
      }
    }

    // On some browsers, horizontal scrolling will cause redraws to
    // happen before the gutter has been realigned, causing it to
    // wriggle around in a most unseemly way. When we have an
    // estimated pixels/delta value, we just handle horizontal
    // scrolling entirely here. It'll be slightly off from native, but
    // better than glitching out.
    if (dx && !gecko && !presto && wheelPixelsPerUnit != null) {
      if (dy && canScrollY)
        { updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)); }
      setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit));
      // Only prevent default scrolling if vertical scrolling is
      // actually possible. Otherwise, it causes vertical scroll
      // jitter on OSX trackpads when deltaX is small and deltaY
      // is large (issue #3579)
      if (!dy || (dy && canScrollY))
        { e_preventDefault(e); }
      display.wheelStartX = null; // Abort measurement, if in progress
      return
    }

    // 'Project' the visible viewport to cover the area that is being
    // scrolled into view (if we know enough to estimate it).
    if (dy && wheelPixelsPerUnit != null) {
      var pixels = dy * wheelPixelsPerUnit;
      var top = cm.doc.scrollTop, bot = top + display.wrapper.clientHeight;
      if (pixels < 0) { top = Math.max(0, top + pixels - 50); }
      else { bot = Math.min(cm.doc.height, bot + pixels + 50); }
      updateDisplaySimple(cm, {top: top, bottom: bot});
    }

    if (wheelSamples < 20) {
      if (display.wheelStartX == null) {
        display.wheelStartX = scroll.scrollLeft; display.wheelStartY = scroll.scrollTop;
        display.wheelDX = dx; display.wheelDY = dy;
        setTimeout(function () {
          if (display.wheelStartX == null) { return }
          var movedX = scroll.scrollLeft - display.wheelStartX;
          var movedY = scroll.scrollTop - display.wheelStartY;
          var sample = (movedY && display.wheelDY && movedY / display.wheelDY) ||
            (movedX && display.wheelDX && movedX / display.wheelDX);
          display.wheelStartX = display.wheelStartY = null;
          if (!sample) { return }
          wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1);
          ++wheelSamples;
        }, 200);
      } else {
        display.wheelDX += dx; display.wheelDY += dy;
      }
    }
  }

  // Selection objects are immutable. A new one is created every time
  // the selection changes. A selection is one or more non-overlapping
  // (and non-touching) ranges, sorted, and an integer that indicates
  // which one is the primary selection (the one that's scrolled into
  // view, that getCursor returns, etc).
  var Selection = function(ranges, primIndex) {
    this.ranges = ranges;
    this.primIndex = primIndex;
  };

  Selection.prototype.primary = function () { return this.ranges[this.primIndex] };

  Selection.prototype.equals = function (other) {
    if (other == this) { return true }
    if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) { return false }
    for (var i = 0; i < this.ranges.length; i++) {
      var here = this.ranges[i], there = other.ranges[i];
      if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) { return false }
    }
    return true
  };

  Selection.prototype.deepCopy = function () {
    var out = [];
    for (var i = 0; i < this.ranges.length; i++)
      { out[i] = new Range(copyPos(this.ranges[i].anchor), copyPos(this.ranges[i].head)); }
    return new Selection(out, this.primIndex)
  };

  Selection.prototype.somethingSelected = function () {
    for (var i = 0; i < this.ranges.length; i++)
      { if (!this.ranges[i].empty()) { return true } }
    return false
  };

  Selection.prototype.contains = function (pos, end) {
    if (!end) { end = pos; }
    for (var i = 0; i < this.ranges.length; i++) {
      var range = this.ranges[i];
      if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0)
        { return i }
    }
    return -1
  };

  var Range = function(anchor, head) {
    this.anchor = anchor; this.head = head;
  };

  Range.prototype.from = function () { return minPos(this.anchor, this.head) };
  Range.prototype.to = function () { return maxPos(this.anchor, this.head) };
  Range.prototype.empty = function () { return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch };

  // Take an unsorted, potentially overlapping set of ranges, and
  // build a selection out of it. 'Consumes' ranges array (modifying
  // it).
  function normalizeSelection(cm, ranges, primIndex) {
    var mayTouch = cm && cm.options.selectionsMayTouch;
    var prim = ranges[primIndex];
    ranges.sort(function (a, b) { return cmp(a.from(), b.from()); });
    primIndex = indexOf(ranges, prim);
    for (var i = 1; i < ranges.length; i++) {
      var cur = ranges[i], prev = ranges[i - 1];
      var diff = cmp(prev.to(), cur.from());
      if (mayTouch && !cur.empty() ? diff > 0 : diff >= 0) {
        var from = minPos(prev.from(), cur.from()), to = maxPos(prev.to(), cur.to());
        var inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
        if (i <= primIndex) { --primIndex; }
        ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to));
      }
    }
    return new Selection(ranges, primIndex)
  }

  function simpleSelection(anchor, head) {
    return new Selection([new Range(anchor, head || anchor)], 0)
  }

  // Compute the position of the end of a change (its 'to' property
  // refers to the pre-change end).
  function changeEnd(change) {
    if (!change.text) { return change.to }
    return Pos(change.from.line + change.text.length - 1,
               lst(change.text).length + (change.text.length == 1 ? change.from.ch : 0))
  }

  // Adjust a position to refer to the post-change position of the
  // same text, or the end of the change if the change covers it.
  function adjustForChange(pos, change) {
    if (cmp(pos, change.from) < 0) { return pos }
    if (cmp(pos, change.to) <= 0) { return changeEnd(change) }

    var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1, ch = pos.ch;
    if (pos.line == change.to.line) { ch += changeEnd(change).ch - change.to.ch; }
    return Pos(line, ch)
  }

  function computeSelAfterChange(doc, change) {
    var out = [];
    for (var i = 0; i < doc.sel.ranges.length; i++) {
      var range = doc.sel.ranges[i];
      out.push(new Range(adjustForChange(range.anchor, change),
                         adjustForChange(range.head, change)));
    }
    return normalizeSelection(doc.cm, out, doc.sel.primIndex)
  }

  function offsetPos(pos, old, nw) {
    if (pos.line == old.line)
      { return Pos(nw.line, pos.ch - old.ch + nw.ch) }
    else
      { return Pos(nw.line + (pos.line - old.line), pos.ch) }
  }

  // Used by replaceSelections to allow moving the selection to the
  // start or around the replaced test. Hint may be "start" or "around".
  function computeReplacedSel(doc, changes, hint) {
    var out = [];
    var oldPrev = Pos(doc.first, 0), newPrev = oldPrev;
    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];
      var from = offsetPos(change.from, oldPrev, newPrev);
      var to = offsetPos(changeEnd(change), oldPrev, newPrev);
      oldPrev = change.to;
      newPrev = to;
      if (hint == "around") {
        var range = doc.sel.ranges[i], inv = cmp(range.head, range.anchor) < 0;
        out[i] = new Range(inv ? to : from, inv ? from : to);
      } else {
        out[i] = new Range(from, from);
      }
    }
    return new Selection(out, doc.sel.primIndex)
  }

  // Used to get the editor into a consistent state again when options change.

  function loadMode(cm) {
    cm.doc.mode = getMode(cm.options, cm.doc.modeOption);
    resetModeState(cm);
  }

  function resetModeState(cm) {
    cm.doc.iter(function (line) {
      if (line.stateAfter) { line.stateAfter = null; }
      if (line.styles) { line.styles = null; }
    });
    cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first;
    startWorker(cm, 100);
    cm.state.modeGen++;
    if (cm.curOp) { regChange(cm); }
  }

  // DOCUMENT DATA STRUCTURE

  // By default, updates that start and end at the beginning of a line
  // are treated specially, in order to make the association of line
  // widgets and marker elements with the text behave more intuitive.
  function isWholeLineUpdate(doc, change) {
    return change.from.ch == 0 && change.to.ch == 0 && lst(change.text) == "" &&
      (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
  }

  // Perform a change on the document data structure.
  function updateDoc(doc, change, markedSpans, estimateHeight) {
    function spansFor(n) {return markedSpans ? markedSpans[n] : null}
    function update(line, text, spans) {
      updateLine(line, text, spans, estimateHeight);
      signalLater(line, "change", line, change);
    }
    function linesFor(start, end) {
      var result = [];
      for (var i = start; i < end; ++i)
        { result.push(new Line(text[i], spansFor(i), estimateHeight)); }
      return result
    }

    var from = change.from, to = change.to, text = change.text;
    var firstLine = getLine(doc, from.line), lastLine = getLine(doc, to.line);
    var lastText = lst(text), lastSpans = spansFor(text.length - 1), nlines = to.line - from.line;

    // Adjust the line structure
    if (change.full) {
      doc.insert(0, linesFor(0, text.length));
      doc.remove(text.length, doc.size - text.length);
    } else if (isWholeLineUpdate(doc, change)) {
      // This is a whole-line replace. Treated specially to make
      // sure line objects move the way they are supposed to.
      var added = linesFor(0, text.length - 1);
      update(lastLine, lastLine.text, lastSpans);
      if (nlines) { doc.remove(from.line, nlines); }
      if (added.length) { doc.insert(from.line, added); }
    } else if (firstLine == lastLine) {
      if (text.length == 1) {
        update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
      } else {
        var added$1 = linesFor(1, text.length - 1);
        added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight));
        update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
        doc.insert(from.line + 1, added$1);
      }
    } else if (text.length == 1) {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0));
      doc.remove(from.line + 1, nlines);
    } else {
      update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0));
      update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
      var added$2 = linesFor(1, text.length - 1);
      if (nlines > 1) { doc.remove(from.line + 1, nlines - 1); }
      doc.insert(from.line + 1, added$2);
    }

    signalLater(doc, "change", doc, change);
  }

  // Call f for all linked documents.
  function linkedDocs(doc, f, sharedHistOnly) {
    function propagate(doc, skip, sharedHist) {
      if (doc.linked) { for (var i = 0; i < doc.linked.length; ++i) {
        var rel = doc.linked[i];
        if (rel.doc == skip) { continue }
        var shared = sharedHist && rel.sharedHist;
        if (sharedHistOnly && !shared) { continue }
        f(rel.doc, shared);
        propagate(rel.doc, doc, shared);
      } }
    }
    propagate(doc, null, true);
  }

  // Attach a document to an editor.
  function attachDoc(cm, doc) {
    if (doc.cm) { throw new Error("This document is already in use.") }
    cm.doc = doc;
    doc.cm = cm;
    estimateLineHeights(cm);
    loadMode(cm);
    setDirectionClass(cm);
    if (!cm.options.lineWrapping) { findMaxLine(cm); }
    cm.options.mode = doc.modeOption;
    regChange(cm);
  }

  function setDirectionClass(cm) {
  (cm.doc.direction == "rtl" ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl");
  }

  function directionChanged(cm) {
    runInOp(cm, function () {
      setDirectionClass(cm);
      regChange(cm);
    });
  }

  function History(startGen) {
    // Arrays of change events and selections. Doing something adds an
    // event to done and clears undo. Undoing moves events from done
    // to undone, redoing moves them in the other direction.
    this.done = []; this.undone = [];
    this.undoDepth = Infinity;
    // Used to track when changes can be merged into a single undo
    // event
    this.lastModTime = this.lastSelTime = 0;
    this.lastOp = this.lastSelOp = null;
    this.lastOrigin = this.lastSelOrigin = null;
    // Used by the isClean() method
    this.generation = this.maxGeneration = startGen || 1;
  }

  // Create a history change event from an updateDoc-style change
  // object.
  function historyChangeFromChange(doc, change) {
    var histChange = {from: copyPos(change.from), to: changeEnd(change), text: getBetween(doc, change.from, change.to)};
    attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1);
    linkedDocs(doc, function (doc) { return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1); }, true);
    return histChange
  }

  // Pop all selection events off the end of a history array. Stop at
  // a change event.
  function clearSelectionEvents(array) {
    while (array.length) {
      var last = lst(array);
      if (last.ranges) { array.pop(); }
      else { break }
    }
  }

  // Find the top change event in the history. Pop off selection
  // events that are in the way.
  function lastChangeEvent(hist, force) {
    if (force) {
      clearSelectionEvents(hist.done);
      return lst(hist.done)
    } else if (hist.done.length && !lst(hist.done).ranges) {
      return lst(hist.done)
    } else if (hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges) {
      hist.done.pop();
      return lst(hist.done)
    }
  }

  // Register a change in the history. Merges changes that are within
  // a single operation, or are close together with an origin that
  // allows merging (starting with "+") into a single event.
  function addChangeToHistory(doc, change, selAfter, opId) {
    var hist = doc.history;
    hist.undone.length = 0;
    var time = +new Date, cur;
    var last;

    if ((hist.lastOp == opId ||
         hist.lastOrigin == change.origin && change.origin &&
         ((change.origin.charAt(0) == "+" && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500)) ||
          change.origin.charAt(0) == "*")) &&
        (cur = lastChangeEvent(hist, hist.lastOp == opId))) {
      // Merge this change into the last event
      last = lst(cur.changes);
      if (cmp(change.from, change.to) == 0 && cmp(change.from, last.to) == 0) {
        // Optimized case for simple insertion -- don't want to add
        // new changesets for every character typed
        last.to = changeEnd(change);
      } else {
        // Add new sub-event
        cur.changes.push(historyChangeFromChange(doc, change));
      }
    } else {
      // Can not be merged, start a new event.
      var before = lst(hist.done);
      if (!before || !before.ranges)
        { pushSelectionToHistory(doc.sel, hist.done); }
      cur = {changes: [historyChangeFromChange(doc, change)],
             generation: hist.generation};
      hist.done.push(cur);
      while (hist.done.length > hist.undoDepth) {
        hist.done.shift();
        if (!hist.done[0].ranges) { hist.done.shift(); }
      }
    }
    hist.done.push(selAfter);
    hist.generation = ++hist.maxGeneration;
    hist.lastModTime = hist.lastSelTime = time;
    hist.lastOp = hist.lastSelOp = opId;
    hist.lastOrigin = hist.lastSelOrigin = change.origin;

    if (!last) { signal(doc, "historyAdded"); }
  }

  function selectionEventCanBeMerged(doc, origin, prev, sel) {
    var ch = origin.charAt(0);
    return ch == "*" ||
      ch == "+" &&
      prev.ranges.length == sel.ranges.length &&
      prev.somethingSelected() == sel.somethingSelected() &&
      new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
  }

  // Called whenever the selection changes, sets the new selection as
  // the pending selection in the history, and pushes the old pending
  // selection into the 'done' array when it was significantly
  // different (in number of selected ranges, emptiness, or time).
  function addSelectionToHistory(doc, sel, opId, options) {
    var hist = doc.history, origin = options && options.origin;

    // A new event is started when the previous origin does not match
    // the current, or the origins don't allow matching. Origins
    // starting with * are always merged, those starting with + are
    // merged when similar and close together in time.
    if (opId == hist.lastSelOp ||
        (origin && hist.lastSelOrigin == origin &&
         (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin ||
          selectionEventCanBeMerged(doc, origin, lst(hist.done), sel))))
      { hist.done[hist.done.length - 1] = sel; }
    else
      { pushSelectionToHistory(sel, hist.done); }

    hist.lastSelTime = +new Date;
    hist.lastSelOrigin = origin;
    hist.lastSelOp = opId;
    if (options && options.clearRedo !== false)
      { clearSelectionEvents(hist.undone); }
  }

  function pushSelectionToHistory(sel, dest) {
    var top = lst(dest);
    if (!(top && top.ranges && top.equals(sel)))
      { dest.push(sel); }
  }

  // Used to store marked span information in the history.
  function attachLocalSpans(doc, change, from, to) {
    var existing = change["spans_" + doc.id], n = 0;
    doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function (line) {
      if (line.markedSpans)
        { (existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans; }
      ++n;
    });
  }

  // When un/re-doing restores text containing marked spans, those
  // that have been explicitly cleared should not be restored.
  function removeClearedSpans(spans) {
    if (!spans) { return null }
    var out;
    for (var i = 0; i < spans.length; ++i) {
      if (spans[i].marker.explicitlyCleared) { if (!out) { out = spans.slice(0, i); } }
      else if (out) { out.push(spans[i]); }
    }
    return !out ? spans : out.length ? out : null
  }

  // Retrieve and filter the old marked spans stored in a change event.
  function getOldSpans(doc, change) {
    var found = change["spans_" + doc.id];
    if (!found) { return null }
    var nw = [];
    for (var i = 0; i < change.text.length; ++i)
      { nw.push(removeClearedSpans(found[i])); }
    return nw
  }

  // Used for un/re-doing changes from the history. Combines the
  // result of computing the existing spans with the set of spans that
  // existed in the history (so that deleting around a span and then
  // undoing brings back the span).
  function mergeOldSpans(doc, change) {
    var old = getOldSpans(doc, change);
    var stretched = stretchSpansOverChange(doc, change);
    if (!old) { return stretched }
    if (!stretched) { return old }

    for (var i = 0; i < old.length; ++i) {
      var oldCur = old[i], stretchCur = stretched[i];
      if (oldCur && stretchCur) {
        spans: for (var j = 0; j < stretchCur.length; ++j) {
          var span = stretchCur[j];
          for (var k = 0; k < oldCur.length; ++k)
            { if (oldCur[k].marker == span.marker) { continue spans } }
          oldCur.push(span);
        }
      } else if (stretchCur) {
        old[i] = stretchCur;
      }
    }
    return old
  }

  // Used both to provide a JSON-safe object in .getHistory, and, when
  // detaching a document, to split the history in two
  function copyHistoryArray(events, newGroup, instantiateSel) {
    var copy = [];
    for (var i = 0; i < events.length; ++i) {
      var event = events[i];
      if (event.ranges) {
        copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
        continue
      }
      var changes = event.changes, newChanges = [];
      copy.push({changes: newChanges});
      for (var j = 0; j < changes.length; ++j) {
        var change = changes[j], m = (void 0);
        newChanges.push({from: change.from, to: change.to, text: change.text});
        if (newGroup) { for (var prop in change) { if (m = prop.match(/^spans_(\d+)$/)) {
          if (indexOf(newGroup, Number(m[1])) > -1) {
            lst(newChanges)[prop] = change[prop];
            delete change[prop];
          }
        } } }
      }
    }
    return copy
  }

  // The 'scroll' parameter given to many of these indicated whether
  // the new cursor position should be scrolled into view after
  // modifying the selection.

  // If shift is held or the extend flag is set, extends a range to
  // include a given position (and optionally a second position).
  // Otherwise, simply returns the range between the given positions.
  // Used for cursor motion and such.
  function extendRange(range, head, other, extend) {
    if (extend) {
      var anchor = range.anchor;
      if (other) {
        var posBefore = cmp(head, anchor) < 0;
        if (posBefore != (cmp(other, anchor) < 0)) {
          anchor = head;
          head = other;
        } else if (posBefore != (cmp(head, other) < 0)) {
          head = other;
        }
      }
      return new Range(anchor, head)
    } else {
      return new Range(other || head, head)
    }
  }

  // Extend the primary selection range, discard the rest.
  function extendSelection(doc, head, other, options, extend) {
    if (extend == null) { extend = doc.cm && (doc.cm.display.shift || doc.extend); }
    setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options);
  }

  // Extend all selections (pos is an array of selections with length
  // equal the number of selections)
  function extendSelections(doc, heads, options) {
    var out = [];
    var extend = doc.cm && (doc.cm.display.shift || doc.extend);
    for (var i = 0; i < doc.sel.ranges.length; i++)
      { out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend); }
    var newSel = normalizeSelection(doc.cm, out, doc.sel.primIndex);
    setSelection(doc, newSel, options);
  }

  // Updates a single range in the selection.
  function replaceOneSelection(doc, i, range, options) {
    var ranges = doc.sel.ranges.slice(0);
    ranges[i] = range;
    setSelection(doc, normalizeSelection(doc.cm, ranges, doc.sel.primIndex), options);
  }

  // Reset the selection to a single range.
  function setSimpleSelection(doc, anchor, head, options) {
    setSelection(doc, simpleSelection(anchor, head), options);
  }

  // Give beforeSelectionChange handlers a change to influence a
  // selection update.
  function filterSelectionChange(doc, sel, options) {
    var obj = {
      ranges: sel.ranges,
      update: function(ranges) {
        this.ranges = [];
        for (var i = 0; i < ranges.length; i++)
          { this.ranges[i] = new Range(clipPos(doc, ranges[i].anchor),
                                     clipPos(doc, ranges[i].head)); }
      },
      origin: options && options.origin
    };
    signal(doc, "beforeSelectionChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeSelectionChange", doc.cm, obj); }
    if (obj.ranges != sel.ranges) { return normalizeSelection(doc.cm, obj.ranges, obj.ranges.length - 1) }
    else { return sel }
  }

  function setSelectionReplaceHistory(doc, sel, options) {
    var done = doc.history.done, last = lst(done);
    if (last && last.ranges) {
      done[done.length - 1] = sel;
      setSelectionNoUndo(doc, sel, options);
    } else {
      setSelection(doc, sel, options);
    }
  }

  // Set a new selection.
  function setSelection(doc, sel, options) {
    setSelectionNoUndo(doc, sel, options);
    addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options);
  }

  function setSelectionNoUndo(doc, sel, options) {
    if (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange"))
      { sel = filterSelectionChange(doc, sel, options); }

    var bias = options && options.bias ||
      (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
    setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, true));

    if (!(options && options.scroll === false) && doc.cm && doc.cm.getOption("readOnly") != "nocursor")
      { ensureCursorVisible(doc.cm); }
  }

  function setSelectionInner(doc, sel) {
    if (sel.equals(doc.sel)) { return }

    doc.sel = sel;

    if (doc.cm) {
      doc.cm.curOp.updateInput = 1;
      doc.cm.curOp.selectionChanged = true;
      signalCursorActivity(doc.cm);
    }
    signalLater(doc, "cursorActivity", doc);
  }

  // Verify that the selection does not partially select any atomic
  // marked ranges.
  function reCheckSelection(doc) {
    setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, false));
  }

  // Return a selection that does not partially select any atomic
  // ranges.
  function skipAtomicInSelection(doc, sel, bias, mayClear) {
    var out;
    for (var i = 0; i < sel.ranges.length; i++) {
      var range = sel.ranges[i];
      var old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i];
      var newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear);
      var newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
      if (out || newAnchor != range.anchor || newHead != range.head) {
        if (!out) { out = sel.ranges.slice(0, i); }
        out[i] = new Range(newAnchor, newHead);
      }
    }
    return out ? normalizeSelection(doc.cm, out, sel.primIndex) : sel
  }

  function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
    var line = getLine(doc, pos.line);
    if (line.markedSpans) { for (var i = 0; i < line.markedSpans.length; ++i) {
      var sp = line.markedSpans[i], m = sp.marker;

      // Determine if we should prevent the cursor being placed to the left/right of an atomic marker
      // Historically this was determined using the inclusiveLeft/Right option, but the new way to control it
      // is with selectLeft/Right
      var preventCursorLeft = ("selectLeft" in m) ? !m.selectLeft : m.inclusiveLeft;
      var preventCursorRight = ("selectRight" in m) ? !m.selectRight : m.inclusiveRight;

      if ((sp.from == null || (preventCursorLeft ? sp.from <= pos.ch : sp.from < pos.ch)) &&
          (sp.to == null || (preventCursorRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
        if (mayClear) {
          signal(m, "beforeCursorEnter");
          if (m.explicitlyCleared) {
            if (!line.markedSpans) { break }
            else {--i; continue}
          }
        }
        if (!m.atomic) { continue }

        if (oldPos) {
          var near = m.find(dir < 0 ? 1 : -1), diff = (void 0);
          if (dir < 0 ? preventCursorRight : preventCursorLeft)
            { near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null); }
          if (near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0))
            { return skipAtomicInner(doc, near, pos, dir, mayClear) }
        }

        var far = m.find(dir < 0 ? -1 : 1);
        if (dir < 0 ? preventCursorLeft : preventCursorRight)
          { far = movePos(doc, far, dir, far.line == pos.line ? line : null); }
        return far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
      }
    } }
    return pos
  }

  // Ensure a given position is not inside an atomic range.
  function skipAtomic(doc, pos, oldPos, bias, mayClear) {
    var dir = bias || 1;
    var found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, dir, true)) ||
        skipAtomicInner(doc, pos, oldPos, -dir, mayClear) ||
        (!mayClear && skipAtomicInner(doc, pos, oldPos, -dir, true));
    if (!found) {
      doc.cantEdit = true;
      return Pos(doc.first, 0)
    }
    return found
  }

  function movePos(doc, pos, dir, line) {
    if (dir < 0 && pos.ch == 0) {
      if (pos.line > doc.first) { return clipPos(doc, Pos(pos.line - 1)) }
      else { return null }
    } else if (dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length) {
      if (pos.line < doc.first + doc.size - 1) { return Pos(pos.line + 1, 0) }
      else { return null }
    } else {
      return new Pos(pos.line, pos.ch + dir)
    }
  }

  function selectAll(cm) {
    cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll);
  }

  // UPDATING

  // Allow "beforeChange" event handlers to influence a change
  function filterChange(doc, change, update) {
    var obj = {
      canceled: false,
      from: change.from,
      to: change.to,
      text: change.text,
      origin: change.origin,
      cancel: function () { return obj.canceled = true; }
    };
    if (update) { obj.update = function (from, to, text, origin) {
      if (from) { obj.from = clipPos(doc, from); }
      if (to) { obj.to = clipPos(doc, to); }
      if (text) { obj.text = text; }
      if (origin !== undefined) { obj.origin = origin; }
    }; }
    signal(doc, "beforeChange", doc, obj);
    if (doc.cm) { signal(doc.cm, "beforeChange", doc.cm, obj); }

    if (obj.canceled) {
      if (doc.cm) { doc.cm.curOp.updateInput = 2; }
      return null
    }
    return {from: obj.from, to: obj.to, text: obj.text, origin: obj.origin}
  }

  // Apply a change to a document, and add it to the document's
  // history, and propagating it to all linked documents.
  function makeChange(doc, change, ignoreReadOnly) {
    if (doc.cm) {
      if (!doc.cm.curOp) { return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly) }
      if (doc.cm.state.suppressEdits) { return }
    }

    if (hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) {
      change = filterChange(doc, change, true);
      if (!change) { return }
    }

    // Possibly split or suppress the update based on the presence
    // of read-only spans in its range.
    var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
    if (split) {
      for (var i = split.length - 1; i >= 0; --i)
        { makeChangeInner(doc, {from: split[i].from, to: split[i].to, text: i ? [""] : change.text, origin: change.origin}); }
    } else {
      makeChangeInner(doc, change);
    }
  }

  function makeChangeInner(doc, change) {
    if (change.text.length == 1 && change.text[0] == "" && cmp(change.from, change.to) == 0) { return }
    var selAfter = computeSelAfterChange(doc, change);
    addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN);

    makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
    var rebased = [];

    linkedDocs(doc, function (doc, sharedHist) {
      if (!sharedHist && indexOf(rebased, doc.history) == -1) {
        rebaseHist(doc.history, change);
        rebased.push(doc.history);
      }
      makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change));
    });
  }

  // Revert a change stored in a document's history.
  function makeChangeFromHistory(doc, type, allowSelectionOnly) {
    var suppress = doc.cm && doc.cm.state.suppressEdits;
    if (suppress && !allowSelectionOnly) { return }

    var hist = doc.history, event, selAfter = doc.sel;
    var source = type == "undo" ? hist.done : hist.undone, dest = type == "undo" ? hist.undone : hist.done;

    // Verify that there is a useable event (so that ctrl-z won't
    // needlessly clear selection events)
    var i = 0;
    for (; i < source.length; i++) {
      event = source[i];
      if (allowSelectionOnly ? event.ranges && !event.equals(doc.sel) : !event.ranges)
        { break }
    }
    if (i == source.length) { return }
    hist.lastOrigin = hist.lastSelOrigin = null;

    for (;;) {
      event = source.pop();
      if (event.ranges) {
        pushSelectionToHistory(event, dest);
        if (allowSelectionOnly && !event.equals(doc.sel)) {
          setSelection(doc, event, {clearRedo: false});
          return
        }
        selAfter = event;
      } else if (suppress) {
        source.push(event);
        return
      } else { break }
    }

    // Build up a reverse change object to add to the opposite history
    // stack (redo when undoing, and vice versa).
    var antiChanges = [];
    pushSelectionToHistory(selAfter, dest);
    dest.push({changes: antiChanges, generation: hist.generation});
    hist.generation = event.generation || ++hist.maxGeneration;

    var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange");

    var loop = function ( i ) {
      var change = event.changes[i];
      change.origin = type;
      if (filter && !filterChange(doc, change, false)) {
        source.length = 0;
        return {}
      }

      antiChanges.push(historyChangeFromChange(doc, change));

      var after = i ? computeSelAfterChange(doc, change) : lst(source);
      makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change));
      if (!i && doc.cm) { doc.cm.scrollIntoView({from: change.from, to: changeEnd(change)}); }
      var rebased = [];

      // Propagate to the linked documents
      linkedDocs(doc, function (doc, sharedHist) {
        if (!sharedHist && indexOf(rebased, doc.history) == -1) {
          rebaseHist(doc.history, change);
          rebased.push(doc.history);
        }
        makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change));
      });
    };

    for (var i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
      var returned = loop( i$1 );

      if ( returned ) return returned.v;
    }
  }

  // Sub-views need their line numbers shifted when text is added
  // above or below them in the parent document.
  function shiftDoc(doc, distance) {
    if (distance == 0) { return }
    doc.first += distance;
    doc.sel = new Selection(map(doc.sel.ranges, function (range) { return new Range(
      Pos(range.anchor.line + distance, range.anchor.ch),
      Pos(range.head.line + distance, range.head.ch)
    ); }), doc.sel.primIndex);
    if (doc.cm) {
      regChange(doc.cm, doc.first, doc.first - distance, distance);
      for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++)
        { regLineChange(doc.cm, l, "gutter"); }
    }
  }

  // More lower-level change function, handling only a single document
  // (not linked ones).
  function makeChangeSingleDoc(doc, change, selAfter, spans) {
    if (doc.cm && !doc.cm.curOp)
      { return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans) }

    if (change.to.line < doc.first) {
      shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
      return
    }
    if (change.from.line > doc.lastLine()) { return }

    // Clip the change to the size of this doc
    if (change.from.line < doc.first) {
      var shift = change.text.length - 1 - (doc.first - change.from.line);
      shiftDoc(doc, shift);
      change = {from: Pos(doc.first, 0), to: Pos(change.to.line + shift, change.to.ch),
                text: [lst(change.text)], origin: change.origin};
    }
    var last = doc.lastLine();
    if (change.to.line > last) {
      change = {from: change.from, to: Pos(last, getLine(doc, last).text.length),
                text: [change.text[0]], origin: change.origin};
    }

    change.removed = getBetween(doc, change.from, change.to);

    if (!selAfter) { selAfter = computeSelAfterChange(doc, change); }
    if (doc.cm) { makeChangeSingleDocInEditor(doc.cm, change, spans); }
    else { updateDoc(doc, change, spans); }
    setSelectionNoUndo(doc, selAfter, sel_dontScroll);

    if (doc.cantEdit && skipAtomic(doc, Pos(doc.firstLine(), 0)))
      { doc.cantEdit = false; }
  }

  // Handle the interaction of a change to a document with the editor
  // that this document is part of.
  function makeChangeSingleDocInEditor(cm, change, spans) {
    var doc = cm.doc, display = cm.display, from = change.from, to = change.to;

    var recomputeMaxLength = false, checkWidthStart = from.line;
    if (!cm.options.lineWrapping) {
      checkWidthStart = lineNo(visualLine(getLine(doc, from.line)));
      doc.iter(checkWidthStart, to.line + 1, function (line) {
        if (line == display.maxLine) {
          recomputeMaxLength = true;
          return true
        }
      });
    }

    if (doc.sel.contains(change.from, change.to) > -1)
      { signalCursorActivity(cm); }

    updateDoc(doc, change, spans, estimateHeight(cm));

    if (!cm.options.lineWrapping) {
      doc.iter(checkWidthStart, from.line + change.text.length, function (line) {
        var len = lineLength(line);
        if (len > display.maxLineLength) {
          display.maxLine = line;
          display.maxLineLength = len;
          display.maxLineChanged = true;
          recomputeMaxLength = false;
        }
      });
      if (recomputeMaxLength) { cm.curOp.updateMaxLine = true; }
    }

    retreatFrontier(doc, from.line);
    startWorker(cm, 400);

    var lendiff = change.text.length - (to.line - from.line) - 1;
    // Remember that these lines changed, for updating the display
    if (change.full)
      { regChange(cm); }
    else if (from.line == to.line && change.text.length == 1 && !isWholeLineUpdate(cm.doc, change))
      { regLineChange(cm, from.line, "text"); }
    else
      { regChange(cm, from.line, to.line + 1, lendiff); }

    var changesHandler = hasHandler(cm, "changes"), changeHandler = hasHandler(cm, "change");
    if (changeHandler || changesHandler) {
      var obj = {
        from: from, to: to,
        text: change.text,
        removed: change.removed,
        origin: change.origin
      };
      if (changeHandler) { signalLater(cm, "change", cm, obj); }
      if (changesHandler) { (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj); }
    }
    cm.display.selForContextMenu = null;
  }

  function replaceRange(doc, code, from, to, origin) {
    var assign;

    if (!to) { to = from; }
    if (cmp(to, from) < 0) { (assign = [to, from], from = assign[0], to = assign[1]); }
    if (typeof code == "string") { code = doc.splitLines(code); }
    makeChange(doc, {from: from, to: to, text: code, origin: origin});
  }

  // Rebasing/resetting history to deal with externally-sourced changes

  function rebaseHistSelSingle(pos, from, to, diff) {
    if (to < pos.line) {
      pos.line += diff;
    } else if (from < pos.line) {
      pos.line = from;
      pos.ch = 0;
    }
  }

  // Tries to rebase an array of history events given a change in the
  // document. If the change touches the same lines as the event, the
  // event, and everything 'behind' it, is discarded. If the change is
  // before the event, the event's positions are updated. Uses a
  // copy-on-write scheme for the positions, to avoid having to
  // reallocate them all on every rebase, but also avoid problems with
  // shared position objects being unsafely updated.
  function rebaseHistArray(array, from, to, diff) {
    for (var i = 0; i < array.length; ++i) {
      var sub = array[i], ok = true;
      if (sub.ranges) {
        if (!sub.copied) { sub = array[i] = sub.deepCopy(); sub.copied = true; }
        for (var j = 0; j < sub.ranges.length; j++) {
          rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff);
          rebaseHistSelSingle(sub.ranges[j].head, from, to, diff);
        }
        continue
      }
      for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
        var cur = sub.changes[j$1];
        if (to < cur.from.line) {
          cur.from = Pos(cur.from.line + diff, cur.from.ch);
          cur.to = Pos(cur.to.line + diff, cur.to.ch);
        } else if (from <= cur.to.line) {
          ok = false;
          break
        }
      }
      if (!ok) {
        array.splice(0, i + 1);
        i = 0;
      }
    }
  }

  function rebaseHist(hist, change) {
    var from = change.from.line, to = change.to.line, diff = change.text.length - (to - from) - 1;
    rebaseHistArray(hist.done, from, to, diff);
    rebaseHistArray(hist.undone, from, to, diff);
  }

  // Utility for applying a change to a line by handle or number,
  // returning the number and optionally registering the line as
  // changed.
  function changeLine(doc, handle, changeType, op) {
    var no = handle, line = handle;
    if (typeof handle == "number") { line = getLine(doc, clipLine(doc, handle)); }
    else { no = lineNo(handle); }
    if (no == null) { return null }
    if (op(line, no) && doc.cm) { regLineChange(doc.cm, no, changeType); }
    return line
  }

  // The document is represented as a BTree consisting of leaves, with
  // chunk of lines in them, and branches, with up to ten leaves or
  // other branch nodes below them. The top node is always a branch
  // node, and is the document object itself (meaning it has
  // additional methods and properties).
  //
  // All nodes have parent links. The tree is used both to go from
  // line numbers to line objects, and to go from objects to numbers.
  // It also indexes by height, and is used to convert between height
  // and line object, and to find the total height of the document.
  //
  // See also http://marijnhaverbeke.nl/blog/codemirror-line-tree.html

  function LeafChunk(lines) {
    this.lines = lines;
    this.parent = null;
    var height = 0;
    for (var i = 0; i < lines.length; ++i) {
      lines[i].parent = this;
      height += lines[i].height;
    }
    this.height = height;
  }

  LeafChunk.prototype = {
    chunkSize: function() { return this.lines.length },

    // Remove the n lines at offset 'at'.
    removeInner: function(at, n) {
      for (var i = at, e = at + n; i < e; ++i) {
        var line = this.lines[i];
        this.height -= line.height;
        cleanUpLine(line);
        signalLater(line, "delete");
      }
      this.lines.splice(at, n);
    },

    // Helper used to collapse a small branch into a single leaf.
    collapse: function(lines) {
      lines.push.apply(lines, this.lines);
    },

    // Insert the given array of lines at offset 'at', count them as
    // having the given height.
    insertInner: function(at, lines, height) {
      this.height += height;
      this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
      for (var i = 0; i < lines.length; ++i) { lines[i].parent = this; }
    },

    // Used to iterate over a part of the tree.
    iterN: function(at, n, op) {
      for (var e = at + n; at < e; ++at)
        { if (op(this.lines[at])) { return true } }
    }
  };

  function BranchChunk(children) {
    this.children = children;
    var size = 0, height = 0;
    for (var i = 0; i < children.length; ++i) {
      var ch = children[i];
      size += ch.chunkSize(); height += ch.height;
      ch.parent = this;
    }
    this.size = size;
    this.height = height;
    this.parent = null;
  }

  BranchChunk.prototype = {
    chunkSize: function() { return this.size },

    removeInner: function(at, n) {
      this.size -= n;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var rm = Math.min(n, sz - at), oldHeight = child.height;
          child.removeInner(at, rm);
          this.height -= oldHeight - child.height;
          if (sz == rm) { this.children.splice(i--, 1); child.parent = null; }
          if ((n -= rm) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
      // If the result is smaller than 25 lines, ensure that it is a
      // single leaf node.
      if (this.size - n < 25 &&
          (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
        var lines = [];
        this.collapse(lines);
        this.children = [new LeafChunk(lines)];
        this.children[0].parent = this;
      }
    },

    collapse: function(lines) {
      for (var i = 0; i < this.children.length; ++i) { this.children[i].collapse(lines); }
    },

    insertInner: function(at, lines, height) {
      this.size += lines.length;
      this.height += height;
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at <= sz) {
          child.insertInner(at, lines, height);
          if (child.lines && child.lines.length > 50) {
            // To avoid memory thrashing when child.lines is huge (e.g. first view of a large file), it's never spliced.
            // Instead, small slices are taken. They're taken in order because sequential memory accesses are fastest.
            var remaining = child.lines.length % 25 + 25;
            for (var pos = remaining; pos < child.lines.length;) {
              var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
              child.height -= leaf.height;
              this.children.splice(++i, 0, leaf);
              leaf.parent = this;
            }
            child.lines = child.lines.slice(0, remaining);
            this.maybeSpill();
          }
          break
        }
        at -= sz;
      }
    },

    // When a node has grown, check whether it should be split.
    maybeSpill: function() {
      if (this.children.length <= 10) { return }
      var me = this;
      do {
        var spilled = me.children.splice(me.children.length - 5, 5);
        var sibling = new BranchChunk(spilled);
        if (!me.parent) { // Become the parent node
          var copy = new BranchChunk(me.children);
          copy.parent = me;
          me.children = [copy, sibling];
          me = copy;
       } else {
          me.size -= sibling.size;
          me.height -= sibling.height;
          var myIndex = indexOf(me.parent.children, me);
          me.parent.children.splice(myIndex + 1, 0, sibling);
        }
        sibling.parent = me.parent;
      } while (me.children.length > 10)
      me.parent.maybeSpill();
    },

    iterN: function(at, n, op) {
      for (var i = 0; i < this.children.length; ++i) {
        var child = this.children[i], sz = child.chunkSize();
        if (at < sz) {
          var used = Math.min(n, sz - at);
          if (child.iterN(at, used, op)) { return true }
          if ((n -= used) == 0) { break }
          at = 0;
        } else { at -= sz; }
      }
    }
  };

  // Line widgets are block elements displayed above or below a line.

  var LineWidget = function(doc, node, options) {
    if (options) { for (var opt in options) { if (options.hasOwnProperty(opt))
      { this[opt] = options[opt]; } } }
    this.doc = doc;
    this.node = node;
  };

  LineWidget.prototype.clear = function () {
    var cm = this.doc.cm, ws = this.line.widgets, line = this.line, no = lineNo(line);
    if (no == null || !ws) { return }
    for (var i = 0; i < ws.length; ++i) { if (ws[i] == this) { ws.splice(i--, 1); } }
    if (!ws.length) { line.widgets = null; }
    var height = widgetHeight(this);
    updateLineHeight(line, Math.max(0, line.height - height));
    if (cm) {
      runInOp(cm, function () {
        adjustScrollWhenAboveVisible(cm, line, -height);
        regLineChange(cm, no, "widget");
      });
      signalLater(cm, "lineWidgetCleared", cm, this, no);
    }
  };

  LineWidget.prototype.changed = function () {
      var this$1 = this;

    var oldH = this.height, cm = this.doc.cm, line = this.line;
    this.height = null;
    var diff = widgetHeight(this) - oldH;
    if (!diff) { return }
    if (!lineIsHidden(this.doc, line)) { updateLineHeight(line, line.height + diff); }
    if (cm) {
      runInOp(cm, function () {
        cm.curOp.forceUpdate = true;
        adjustScrollWhenAboveVisible(cm, line, diff);
        signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line));
      });
    }
  };
  eventMixin(LineWidget);

  function adjustScrollWhenAboveVisible(cm, line, diff) {
    if (heightAtLine(line) < ((cm.curOp && cm.curOp.scrollTop) || cm.doc.scrollTop))
      { addToScrollTop(cm, diff); }
  }

  function addLineWidget(doc, handle, node, options) {
    var widget = new LineWidget(doc, node, options);
    var cm = doc.cm;
    if (cm && widget.noHScroll) { cm.display.alignWidgets = true; }
    changeLine(doc, handle, "widget", function (line) {
      var widgets = line.widgets || (line.widgets = []);
      if (widget.insertAt == null) { widgets.push(widget); }
      else { widgets.splice(Math.min(widgets.length, Math.max(0, widget.insertAt)), 0, widget); }
      widget.line = line;
      if (cm && !lineIsHidden(doc, line)) {
        var aboveVisible = heightAtLine(line) < doc.scrollTop;
        updateLineHeight(line, line.height + widgetHeight(widget));
        if (aboveVisible) { addToScrollTop(cm, widget.height); }
        cm.curOp.forceUpdate = true;
      }
      return true
    });
    if (cm) { signalLater(cm, "lineWidgetAdded", cm, widget, typeof handle == "number" ? handle : lineNo(handle)); }
    return widget
  }

  // TEXTMARKERS

  // Created with markText and setBookmark methods. A TextMarker is a
  // handle that can be used to clear or find a marked position in the
  // document. Line objects hold arrays (markedSpans) containing
  // {from, to, marker} object pointing to such marker objects, and
  // indicating that such a marker is present on that line. Multiple
  // lines may point to the same marker when it spans across lines.
  // The spans will have null for their from/to properties when the
  // marker continues beyond the start/end of the line. Markers have
  // links back to the lines they currently touch.

  // Collapsed markers have unique ids, in order to be able to order
  // them, which is needed for uniquely determining an outer marker
  // when they overlap (they may nest, but not partially overlap).
  var nextMarkerId = 0;

  var TextMarker = function(doc, type) {
    this.lines = [];
    this.type = type;
    this.doc = doc;
    this.id = ++nextMarkerId;
  };

  // Clear the marker.
  TextMarker.prototype.clear = function () {
    if (this.explicitlyCleared) { return }
    var cm = this.doc.cm, withOp = cm && !cm.curOp;
    if (withOp) { startOperation(cm); }
    if (hasHandler(this, "clear")) {
      var found = this.find();
      if (found) { signalLater(this, "clear", found.from, found.to); }
    }
    var min = null, max = null;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (cm && !this.collapsed) { regLineChange(cm, lineNo(line), "text"); }
      else if (cm) {
        if (span.to != null) { max = lineNo(line); }
        if (span.from != null) { min = lineNo(line); }
      }
      line.markedSpans = removeMarkedSpan(line.markedSpans, span);
      if (span.from == null && this.collapsed && !lineIsHidden(this.doc, line) && cm)
        { updateLineHeight(line, textHeight(cm.display)); }
    }
    if (cm && this.collapsed && !cm.options.lineWrapping) { for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
      var visual = visualLine(this.lines[i$1]), len = lineLength(visual);
      if (len > cm.display.maxLineLength) {
        cm.display.maxLine = visual;
        cm.display.maxLineLength = len;
        cm.display.maxLineChanged = true;
      }
    } }

    if (min != null && cm && this.collapsed) { regChange(cm, min, max + 1); }
    this.lines.length = 0;
    this.explicitlyCleared = true;
    if (this.atomic && this.doc.cantEdit) {
      this.doc.cantEdit = false;
      if (cm) { reCheckSelection(cm.doc); }
    }
    if (cm) { signalLater(cm, "markerCleared", cm, this, min, max); }
    if (withOp) { endOperation(cm); }
    if (this.parent) { this.parent.clear(); }
  };

  // Find the position of the marker in the document. Returns a {from,
  // to} object by default. Side can be passed to get a specific side
  // -- 0 (both), -1 (left), or 1 (right). When lineObj is true, the
  // Pos objects returned contain a line object, rather than a line
  // number (used to prevent looking up the same line twice).
  TextMarker.prototype.find = function (side, lineObj) {
    if (side == null && this.type == "bookmark") { side = 1; }
    var from, to;
    for (var i = 0; i < this.lines.length; ++i) {
      var line = this.lines[i];
      var span = getMarkedSpanFor(line.markedSpans, this);
      if (span.from != null) {
        from = Pos(lineObj ? line : lineNo(line), span.from);
        if (side == -1) { return from }
      }
      if (span.to != null) {
        to = Pos(lineObj ? line : lineNo(line), span.to);
        if (side == 1) { return to }
      }
    }
    return from && {from: from, to: to}
  };

  // Signals that the marker's widget changed, and surrounding layout
  // should be recomputed.
  TextMarker.prototype.changed = function () {
      var this$1 = this;

    var pos = this.find(-1, true), widget = this, cm = this.doc.cm;
    if (!pos || !cm) { return }
    runInOp(cm, function () {
      var line = pos.line, lineN = lineNo(pos.line);
      var view = findViewForLine(cm, lineN);
      if (view) {
        clearLineMeasurementCacheFor(view);
        cm.curOp.selectionChanged = cm.curOp.forceUpdate = true;
      }
      cm.curOp.updateMaxLine = true;
      if (!lineIsHidden(widget.doc, line) && widget.height != null) {
        var oldHeight = widget.height;
        widget.height = null;
        var dHeight = widgetHeight(widget) - oldHeight;
        if (dHeight)
          { updateLineHeight(line, line.height + dHeight); }
      }
      signalLater(cm, "markerChanged", cm, this$1);
    });
  };

  TextMarker.prototype.attachLine = function (line) {
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp;
      if (!op.maybeHiddenMarkers || indexOf(op.maybeHiddenMarkers, this) == -1)
        { (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this); }
    }
    this.lines.push(line);
  };

  TextMarker.prototype.detachLine = function (line) {
    this.lines.splice(indexOf(this.lines, line), 1);
    if (!this.lines.length && this.doc.cm) {
      var op = this.doc.cm.curOp
      ;(op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this);
    }
  };
  eventMixin(TextMarker);

  // Create a marker, wire it up to the right lines, and
  function markText(doc, from, to, options, type) {
    // Shared markers (across linked documents) are handled separately
    // (markTextShared will call out to this again, once per
    // document).
    if (options && options.shared) { return markTextShared(doc, from, to, options, type) }
    // Ensure we are in an operation.
    if (doc.cm && !doc.cm.curOp) { return operation(doc.cm, markText)(doc, from, to, options, type) }

    var marker = new TextMarker(doc, type), diff = cmp(from, to);
    if (options) { copyObj(options, marker, false); }
    // Don't connect empty markers unless clearWhenEmpty is false
    if (diff > 0 || diff == 0 && marker.clearWhenEmpty !== false)
      { return marker }
    if (marker.replacedWith) {
      // Showing up as a widget implies collapsed (widget replaces text)
      marker.collapsed = true;
      marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget");
      if (!options.handleMouseEvents) { marker.widgetNode.setAttribute("cm-ignore-events", "true"); }
      if (options.insertLeft) { marker.widgetNode.insertLeft = true; }
    }
    if (marker.collapsed) {
      if (conflictingCollapsedRange(doc, from.line, from, to, marker) ||
          from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker))
        { throw new Error("Inserting collapsed marker partially overlapping an existing one") }
      seeCollapsedSpans();
    }

    if (marker.addToHistory)
      { addChangeToHistory(doc, {from: from, to: to, origin: "markText"}, doc.sel, NaN); }

    var curLine = from.line, cm = doc.cm, updateMaxLine;
    doc.iter(curLine, to.line + 1, function (line) {
      if (cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine)
        { updateMaxLine = true; }
      if (marker.collapsed && curLine != from.line) { updateLineHeight(line, 0); }
      addMarkedSpan(line, new MarkedSpan(marker,
                                         curLine == from.line ? from.ch : null,
                                         curLine == to.line ? to.ch : null));
      ++curLine;
    });
    // lineIsHidden depends on the presence of the spans, so needs a second pass
    if (marker.collapsed) { doc.iter(from.line, to.line + 1, function (line) {
      if (lineIsHidden(doc, line)) { updateLineHeight(line, 0); }
    }); }

    if (marker.clearOnEnter) { on(marker, "beforeCursorEnter", function () { return marker.clear(); }); }

    if (marker.readOnly) {
      seeReadOnlySpans();
      if (doc.history.done.length || doc.history.undone.length)
        { doc.clearHistory(); }
    }
    if (marker.collapsed) {
      marker.id = ++nextMarkerId;
      marker.atomic = true;
    }
    if (cm) {
      // Sync editor state
      if (updateMaxLine) { cm.curOp.updateMaxLine = true; }
      if (marker.collapsed)
        { regChange(cm, from.line, to.line + 1); }
      else if (marker.className || marker.startStyle || marker.endStyle || marker.css ||
               marker.attributes || marker.title)
        { for (var i = from.line; i <= to.line; i++) { regLineChange(cm, i, "text"); } }
      if (marker.atomic) { reCheckSelection(cm.doc); }
      signalLater(cm, "markerAdded", cm, marker);
    }
    return marker
  }

  // SHARED TEXTMARKERS

  // A shared marker spans multiple linked documents. It is
  // implemented as a meta-marker-object controlling multiple normal
  // markers.
  var SharedTextMarker = function(markers, primary) {
    this.markers = markers;
    this.primary = primary;
    for (var i = 0; i < markers.length; ++i)
      { markers[i].parent = this; }
  };

  SharedTextMarker.prototype.clear = function () {
    if (this.explicitlyCleared) { return }
    this.explicitlyCleared = true;
    for (var i = 0; i < this.markers.length; ++i)
      { this.markers[i].clear(); }
    signalLater(this, "clear");
  };

  SharedTextMarker.prototype.find = function (side, lineObj) {
    return this.primary.find(side, lineObj)
  };
  eventMixin(SharedTextMarker);

  function markTextShared(doc, from, to, options, type) {
    options = copyObj(options);
    options.shared = false;
    var markers = [markText(doc, from, to, options, type)], primary = markers[0];
    var widget = options.widgetNode;
    linkedDocs(doc, function (doc) {
      if (widget) { options.widgetNode = widget.cloneNode(true); }
      markers.push(markText(doc, clipPos(doc, from), clipPos(doc, to), options, type));
      for (var i = 0; i < doc.linked.length; ++i)
        { if (doc.linked[i].isParent) { return } }
      primary = lst(markers);
    });
    return new SharedTextMarker(markers, primary)
  }

  function findSharedMarkers(doc) {
    return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function (m) { return m.parent; })
  }

  function copySharedMarkers(doc, markers) {
    for (var i = 0; i < markers.length; i++) {
      var marker = markers[i], pos = marker.find();
      var mFrom = doc.clipPos(pos.from), mTo = doc.clipPos(pos.to);
      if (cmp(mFrom, mTo)) {
        var subMark = markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
        marker.markers.push(subMark);
        subMark.parent = marker;
      }
    }
  }

  function detachSharedMarkers(markers) {
    var loop = function ( i ) {
      var marker = markers[i], linked = [marker.primary.doc];
      linkedDocs(marker.primary.doc, function (d) { return linked.push(d); });
      for (var j = 0; j < marker.markers.length; j++) {
        var subMarker = marker.markers[j];
        if (indexOf(linked, subMarker.doc) == -1) {
          subMarker.parent = null;
          marker.markers.splice(j--, 1);
        }
      }
    };

    for (var i = 0; i < markers.length; i++) loop( i );
  }

  var nextDocId = 0;
  var Doc = function(text, mode, firstLine, lineSep, direction) {
    if (!(this instanceof Doc)) { return new Doc(text, mode, firstLine, lineSep, direction) }
    if (firstLine == null) { firstLine = 0; }

    BranchChunk.call(this, [new LeafChunk([new Line("", null)])]);
    this.first = firstLine;
    this.scrollTop = this.scrollLeft = 0;
    this.cantEdit = false;
    this.cleanGeneration = 1;
    this.modeFrontier = this.highlightFrontier = firstLine;
    var start = Pos(firstLine, 0);
    this.sel = simpleSelection(start);
    this.history = new History(null);
    this.id = ++nextDocId;
    this.modeOption = mode;
    this.lineSep = lineSep;
    this.direction = (direction == "rtl") ? "rtl" : "ltr";
    this.extend = false;

    if (typeof text == "string") { text = this.splitLines(text); }
    updateDoc(this, {from: start, to: start, text: text});
    setSelection(this, simpleSelection(start), sel_dontScroll);
  };

  Doc.prototype = createObj(BranchChunk.prototype, {
    constructor: Doc,
    // Iterate over the document. Supports two forms -- with only one
    // argument, it calls that for each line in the document. With
    // three, it iterates over the range given by the first two (with
    // the second being non-inclusive).
    iter: function(from, to, op) {
      if (op) { this.iterN(from - this.first, to - from, op); }
      else { this.iterN(this.first, this.first + this.size, from); }
    },

    // Non-public interface for adding and removing lines.
    insert: function(at, lines) {
      var height = 0;
      for (var i = 0; i < lines.length; ++i) { height += lines[i].height; }
      this.insertInner(at - this.first, lines, height);
    },
    remove: function(at, n) { this.removeInner(at - this.first, n); },

    // From here, the methods are part of the public interface. Most
    // are also available from CodeMirror (editor) instances.

    getValue: function(lineSep) {
      var lines = getLines(this, this.first, this.first + this.size);
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },
    setValue: docMethodOp(function(code) {
      var top = Pos(this.first, 0), last = this.first + this.size - 1;
      makeChange(this, {from: top, to: Pos(last, getLine(this, last).text.length),
                        text: this.splitLines(code), origin: "setValue", full: true}, true);
      if (this.cm) { scrollToCoords(this.cm, 0, 0); }
      setSelection(this, simpleSelection(top), sel_dontScroll);
    }),
    replaceRange: function(code, from, to, origin) {
      from = clipPos(this, from);
      to = to ? clipPos(this, to) : from;
      replaceRange(this, code, from, to, origin);
    },
    getRange: function(from, to, lineSep) {
      var lines = getBetween(this, clipPos(this, from), clipPos(this, to));
      if (lineSep === false) { return lines }
      return lines.join(lineSep || this.lineSeparator())
    },

    getLine: function(line) {var l = this.getLineHandle(line); return l && l.text},

    getLineHandle: function(line) {if (isLine(this, line)) { return getLine(this, line) }},
    getLineNumber: function(line) {return lineNo(line)},

    getLineHandleVisualStart: function(line) {
      if (typeof line == "number") { line = getLine(this, line); }
      return visualLine(line)
    },

    lineCount: function() {return this.size},
    firstLine: function() {return this.first},
    lastLine: function() {return this.first + this.size - 1},

    clipPos: function(pos) {return clipPos(this, pos)},

    getCursor: function(start) {
      var range = this.sel.primary(), pos;
      if (start == null || start == "head") { pos = range.head; }
      else if (start == "anchor") { pos = range.anchor; }
      else if (start == "end" || start == "to" || start === false) { pos = range.to(); }
      else { pos = range.from(); }
      return pos
    },
    listSelections: function() { return this.sel.ranges },
    somethingSelected: function() {return this.sel.somethingSelected()},

    setCursor: docMethodOp(function(line, ch, options) {
      setSimpleSelection(this, clipPos(this, typeof line == "number" ? Pos(line, ch || 0) : line), null, options);
    }),
    setSelection: docMethodOp(function(anchor, head, options) {
      setSimpleSelection(this, clipPos(this, anchor), clipPos(this, head || anchor), options);
    }),
    extendSelection: docMethodOp(function(head, other, options) {
      extendSelection(this, clipPos(this, head), other && clipPos(this, other), options);
    }),
    extendSelections: docMethodOp(function(heads, options) {
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    extendSelectionsBy: docMethodOp(function(f, options) {
      var heads = map(this.sel.ranges, f);
      extendSelections(this, clipPosArray(this, heads), options);
    }),
    setSelections: docMethodOp(function(ranges, primary, options) {
      if (!ranges.length) { return }
      var out = [];
      for (var i = 0; i < ranges.length; i++)
        { out[i] = new Range(clipPos(this, ranges[i].anchor),
                           clipPos(this, ranges[i].head)); }
      if (primary == null) { primary = Math.min(ranges.length - 1, this.sel.primIndex); }
      setSelection(this, normalizeSelection(this.cm, out, primary), options);
    }),
    addSelection: docMethodOp(function(anchor, head, options) {
      var ranges = this.sel.ranges.slice(0);
      ranges.push(new Range(clipPos(this, anchor), clipPos(this, head || anchor)));
      setSelection(this, normalizeSelection(this.cm, ranges, ranges.length - 1), options);
    }),

    getSelection: function(lineSep) {
      var ranges = this.sel.ranges, lines;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        lines = lines ? lines.concat(sel) : sel;
      }
      if (lineSep === false) { return lines }
      else { return lines.join(lineSep || this.lineSeparator()) }
    },
    getSelections: function(lineSep) {
      var parts = [], ranges = this.sel.ranges;
      for (var i = 0; i < ranges.length; i++) {
        var sel = getBetween(this, ranges[i].from(), ranges[i].to());
        if (lineSep !== false) { sel = sel.join(lineSep || this.lineSeparator()); }
        parts[i] = sel;
      }
      return parts
    },
    replaceSelection: function(code, collapse, origin) {
      var dup = [];
      for (var i = 0; i < this.sel.ranges.length; i++)
        { dup[i] = code; }
      this.replaceSelections(dup, collapse, origin || "+input");
    },
    replaceSelections: docMethodOp(function(code, collapse, origin) {
      var changes = [], sel = this.sel;
      for (var i = 0; i < sel.ranges.length; i++) {
        var range = sel.ranges[i];
        changes[i] = {from: range.from(), to: range.to(), text: this.splitLines(code[i]), origin: origin};
      }
      var newSel = collapse && collapse != "end" && computeReplacedSel(this, changes, collapse);
      for (var i$1 = changes.length - 1; i$1 >= 0; i$1--)
        { makeChange(this, changes[i$1]); }
      if (newSel) { setSelectionReplaceHistory(this, newSel); }
      else if (this.cm) { ensureCursorVisible(this.cm); }
    }),
    undo: docMethodOp(function() {makeChangeFromHistory(this, "undo");}),
    redo: docMethodOp(function() {makeChangeFromHistory(this, "redo");}),
    undoSelection: docMethodOp(function() {makeChangeFromHistory(this, "undo", true);}),
    redoSelection: docMethodOp(function() {makeChangeFromHistory(this, "redo", true);}),

    setExtending: function(val) {this.extend = val;},
    getExtending: function() {return this.extend},

    historySize: function() {
      var hist = this.history, done = 0, undone = 0;
      for (var i = 0; i < hist.done.length; i++) { if (!hist.done[i].ranges) { ++done; } }
      for (var i$1 = 0; i$1 < hist.undone.length; i$1++) { if (!hist.undone[i$1].ranges) { ++undone; } }
      return {undo: done, redo: undone}
    },
    clearHistory: function() {
      var this$1 = this;

      this.history = new History(this.history.maxGeneration);
      linkedDocs(this, function (doc) { return doc.history = this$1.history; }, true);
    },

    markClean: function() {
      this.cleanGeneration = this.changeGeneration(true);
    },
    changeGeneration: function(forceSplit) {
      if (forceSplit)
        { this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null; }
      return this.history.generation
    },
    isClean: function (gen) {
      return this.history.generation == (gen || this.cleanGeneration)
    },

    getHistory: function() {
      return {done: copyHistoryArray(this.history.done),
              undone: copyHistoryArray(this.history.undone)}
    },
    setHistory: function(histData) {
      var hist = this.history = new History(this.history.maxGeneration);
      hist.done = copyHistoryArray(histData.done.slice(0), null, true);
      hist.undone = copyHistoryArray(histData.undone.slice(0), null, true);
    },

    setGutterMarker: docMethodOp(function(line, gutterID, value) {
      return changeLine(this, line, "gutter", function (line) {
        var markers = line.gutterMarkers || (line.gutterMarkers = {});
        markers[gutterID] = value;
        if (!value && isEmpty(markers)) { line.gutterMarkers = null; }
        return true
      })
    }),

    clearGutter: docMethodOp(function(gutterID) {
      var this$1 = this;

      this.iter(function (line) {
        if (line.gutterMarkers && line.gutterMarkers[gutterID]) {
          changeLine(this$1, line, "gutter", function () {
            line.gutterMarkers[gutterID] = null;
            if (isEmpty(line.gutterMarkers)) { line.gutterMarkers = null; }
            return true
          });
        }
      });
    }),

    lineInfo: function(line) {
      var n;
      if (typeof line == "number") {
        if (!isLine(this, line)) { return null }
        n = line;
        line = getLine(this, line);
        if (!line) { return null }
      } else {
        n = lineNo(line);
        if (n == null) { return null }
      }
      return {line: n, handle: line, text: line.text, gutterMarkers: line.gutterMarkers,
              textClass: line.textClass, bgClass: line.bgClass, wrapClass: line.wrapClass,
              widgets: line.widgets}
    },

    addLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        if (!line[prop]) { line[prop] = cls; }
        else if (classTest(cls).test(line[prop])) { return false }
        else { line[prop] += " " + cls; }
        return true
      })
    }),
    removeLineClass: docMethodOp(function(handle, where, cls) {
      return changeLine(this, handle, where == "gutter" ? "gutter" : "class", function (line) {
        var prop = where == "text" ? "textClass"
                 : where == "background" ? "bgClass"
                 : where == "gutter" ? "gutterClass" : "wrapClass";
        var cur = line[prop];
        if (!cur) { return false }
        else if (cls == null) { line[prop] = null; }
        else {
          var found = cur.match(classTest(cls));
          if (!found) { return false }
          var end = found.index + found[0].length;
          line[prop] = cur.slice(0, found.index) + (!found.index || end == cur.length ? "" : " ") + cur.slice(end) || null;
        }
        return true
      })
    }),

    addLineWidget: docMethodOp(function(handle, node, options) {
      return addLineWidget(this, handle, node, options)
    }),
    removeLineWidget: function(widget) { widget.clear(); },

    markText: function(from, to, options) {
      return markText(this, clipPos(this, from), clipPos(this, to), options, options && options.type || "range")
    },
    setBookmark: function(pos, options) {
      var realOpts = {replacedWith: options && (options.nodeType == null ? options.widget : options),
                      insertLeft: options && options.insertLeft,
                      clearWhenEmpty: false, shared: options && options.shared,
                      handleMouseEvents: options && options.handleMouseEvents};
      pos = clipPos(this, pos);
      return markText(this, pos, pos, realOpts, "bookmark")
    },
    findMarksAt: function(pos) {
      pos = clipPos(this, pos);
      var markers = [], spans = getLine(this, pos.line).markedSpans;
      if (spans) { for (var i = 0; i < spans.length; ++i) {
        var span = spans[i];
        if ((span.from == null || span.from <= pos.ch) &&
            (span.to == null || span.to >= pos.ch))
          { markers.push(span.marker.parent || span.marker); }
      } }
      return markers
    },
    findMarks: function(from, to, filter) {
      from = clipPos(this, from); to = clipPos(this, to);
      var found = [], lineNo = from.line;
      this.iter(from.line, to.line + 1, function (line) {
        var spans = line.markedSpans;
        if (spans) { for (var i = 0; i < spans.length; i++) {
          var span = spans[i];
          if (!(span.to != null && lineNo == from.line && from.ch >= span.to ||
                span.from == null && lineNo != from.line ||
                span.from != null && lineNo == to.line && span.from >= to.ch) &&
              (!filter || filter(span.marker)))
            { found.push(span.marker.parent || span.marker); }
        } }
        ++lineNo;
      });
      return found
    },
    getAllMarks: function() {
      var markers = [];
      this.iter(function (line) {
        var sps = line.markedSpans;
        if (sps) { for (var i = 0; i < sps.length; ++i)
          { if (sps[i].from != null) { markers.push(sps[i].marker); } } }
      });
      return markers
    },

    posFromIndex: function(off) {
      var ch, lineNo = this.first, sepSize = this.lineSeparator().length;
      this.iter(function (line) {
        var sz = line.text.length + sepSize;
        if (sz > off) { ch = off; return true }
        off -= sz;
        ++lineNo;
      });
      return clipPos(this, Pos(lineNo, ch))
    },
    indexFromPos: function (coords) {
      coords = clipPos(this, coords);
      var index = coords.ch;
      if (coords.line < this.first || coords.ch < 0) { return 0 }
      var sepSize = this.lineSeparator().length;
      this.iter(this.first, coords.line, function (line) { // iter aborts when callback returns a truthy value
        index += line.text.length + sepSize;
      });
      return index
    },

    copy: function(copyHistory) {
      var doc = new Doc(getLines(this, this.first, this.first + this.size),
                        this.modeOption, this.first, this.lineSep, this.direction);
      doc.scrollTop = this.scrollTop; doc.scrollLeft = this.scrollLeft;
      doc.sel = this.sel;
      doc.extend = false;
      if (copyHistory) {
        doc.history.undoDepth = this.history.undoDepth;
        doc.setHistory(this.getHistory());
      }
      return doc
    },

    linkedDoc: function(options) {
      if (!options) { options = {}; }
      var from = this.first, to = this.first + this.size;
      if (options.from != null && options.from > from) { from = options.from; }
      if (options.to != null && options.to < to) { to = options.to; }
      var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
      if (options.sharedHist) { copy.history = this.history
      ; }(this.linked || (this.linked = [])).push({doc: copy, sharedHist: options.sharedHist});
      copy.linked = [{doc: this, isParent: true, sharedHist: options.sharedHist}];
      copySharedMarkers(copy, findSharedMarkers(this));
      return copy
    },
    unlinkDoc: function(other) {
      if (other instanceof CodeMirror) { other = other.doc; }
      if (this.linked) { for (var i = 0; i < this.linked.length; ++i) {
        var link = this.linked[i];
        if (link.doc != other) { continue }
        this.linked.splice(i, 1);
        other.unlinkDoc(this);
        detachSharedMarkers(findSharedMarkers(this));
        break
      } }
      // If the histories were shared, split them again
      if (other.history == this.history) {
        var splitIds = [other.id];
        linkedDocs(other, function (doc) { return splitIds.push(doc.id); }, true);
        other.history = new History(null);
        other.history.done = copyHistoryArray(this.history.done, splitIds);
        other.history.undone = copyHistoryArray(this.history.undone, splitIds);
      }
    },
    iterLinkedDocs: function(f) {linkedDocs(this, f);},

    getMode: function() {return this.mode},
    getEditor: function() {return this.cm},

    splitLines: function(str) {
      if (this.lineSep) { return str.split(this.lineSep) }
      return splitLinesAuto(str)
    },
    lineSeparator: function() { return this.lineSep || "\n" },

    setDirection: docMethodOp(function (dir) {
      if (dir != "rtl") { dir = "ltr"; }
      if (dir == this.direction) { return }
      this.direction = dir;
      this.iter(function (line) { return line.order = null; });
      if (this.cm) { directionChanged(this.cm); }
    })
  });

  // Public alias.
  Doc.prototype.eachLine = Doc.prototype.iter;

  // Kludge to work around strange IE behavior where it'll sometimes
  // re-fire a series of drag-related events right after the drop (#1551)
  var lastDrop = 0;

  function onDrop(e) {
    var cm = this;
    clearDragCursor(cm);
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e))
      { return }
    e_preventDefault(e);
    if (ie) { lastDrop = +new Date; }
    var pos = posFromMouse(cm, e, true), files = e.dataTransfer.files;
    if (!pos || cm.isReadOnly()) { return }
    // Might be a file drop, in which case we simply extract the text
    // and insert it.
    if (files && files.length && window.FileReader && window.File) {
      var n = files.length, text = Array(n), read = 0;
      var markAsReadAndPasteIfAllFilesAreRead = function () {
        if (++read == n) {
          operation(cm, function () {
            pos = clipPos(cm.doc, pos);
            var change = {from: pos, to: pos,
                          text: cm.doc.splitLines(
                              text.filter(function (t) { return t != null; }).join(cm.doc.lineSeparator())),
                          origin: "paste"};
            makeChange(cm.doc, change);
            setSelectionReplaceHistory(cm.doc, simpleSelection(clipPos(cm.doc, pos), clipPos(cm.doc, changeEnd(change))));
          })();
        }
      };
      var readTextFromFile = function (file, i) {
        if (cm.options.allowDropFileTypes &&
            indexOf(cm.options.allowDropFileTypes, file.type) == -1) {
          markAsReadAndPasteIfAllFilesAreRead();
          return
        }
        var reader = new FileReader;
        reader.onerror = function () { return markAsReadAndPasteIfAllFilesAreRead(); };
        reader.onload = function () {
          var content = reader.result;
          if (/[\x00-\x08\x0e-\x1f]{2}/.test(content)) {
            markAsReadAndPasteIfAllFilesAreRead();
            return
          }
          text[i] = content;
          markAsReadAndPasteIfAllFilesAreRead();
        };
        reader.readAsText(file);
      };
      for (var i = 0; i < files.length; i++) { readTextFromFile(files[i], i); }
    } else { // Normal drop
      // Don't do a replace if the drop happened inside of the selected text.
      if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) {
        cm.state.draggingText(e);
        // Ensure the editor is re-focused
        setTimeout(function () { return cm.display.input.focus(); }, 20);
        return
      }
      try {
        var text$1 = e.dataTransfer.getData("Text");
        if (text$1) {
          var selected;
          if (cm.state.draggingText && !cm.state.draggingText.copy)
            { selected = cm.listSelections(); }
          setSelectionNoUndo(cm.doc, simpleSelection(pos, pos));
          if (selected) { for (var i$1 = 0; i$1 < selected.length; ++i$1)
            { replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag"); } }
          cm.replaceSelection(text$1, "around", "paste");
          cm.display.input.focus();
        }
      }
      catch(e$1){}
    }
  }

  function onDragStart(cm, e) {
    if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) { e_stop(e); return }
    if (signalDOMEvent(cm, e) || eventInWidget(cm.display, e)) { return }

    e.dataTransfer.setData("Text", cm.getSelection());
    e.dataTransfer.effectAllowed = "copyMove";

    // Use dummy image instead of default browsers image.
    // Recent Safari (~6.0.2) have a tendency to segfault when this happens, so we don't do it there.
    if (e.dataTransfer.setDragImage && !safari) {
      var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
      img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==";
      if (presto) {
        img.width = img.height = 1;
        cm.display.wrapper.appendChild(img);
        // Force a relayout, or Opera won't use our image for some obscure reason
        img._top = img.offsetTop;
      }
      e.dataTransfer.setDragImage(img, 0, 0);
      if (presto) { img.parentNode.removeChild(img); }
    }
  }

  function onDragOver(cm, e) {
    var pos = posFromMouse(cm, e);
    if (!pos) { return }
    var frag = document.createDocumentFragment();
    drawSelectionCursor(cm, pos, frag);
    if (!cm.display.dragCursor) {
      cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors");
      cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv);
    }
    removeChildrenAndAdd(cm.display.dragCursor, frag);
  }

  function clearDragCursor(cm) {
    if (cm.display.dragCursor) {
      cm.display.lineSpace.removeChild(cm.display.dragCursor);
      cm.display.dragCursor = null;
    }
  }

  // These must be handled carefully, because naively registering a
  // handler for each editor will cause the editors to never be
  // garbage collected.

  function forEachCodeMirror(f) {
    if (!document.getElementsByClassName) { return }
    var byClass = document.getElementsByClassName("CodeMirror"), editors = [];
    for (var i = 0; i < byClass.length; i++) {
      var cm = byClass[i].CodeMirror;
      if (cm) { editors.push(cm); }
    }
    if (editors.length) { editors[0].operation(function () {
      for (var i = 0; i < editors.length; i++) { f(editors[i]); }
    }); }
  }

  var globalsRegistered = false;
  function ensureGlobalHandlers() {
    if (globalsRegistered) { return }
    registerGlobalHandlers();
    globalsRegistered = true;
  }
  function registerGlobalHandlers() {
    // When the window resizes, we need to refresh active editors.
    var resizeTimer;
    on(window, "resize", function () {
      if (resizeTimer == null) { resizeTimer = setTimeout(function () {
        resizeTimer = null;
        forEachCodeMirror(onResize);
      }, 100); }
    });
    // When the window loses focus, we want to show the editor as blurred
    on(window, "blur", function () { return forEachCodeMirror(onBlur); });
  }
  // Called when the window resizes
  function onResize(cm) {
    var d = cm.display;
    // Might be a text scaling operation, clear size caches.
    d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null;
    d.scrollbarsClipped = false;
    cm.setSize();
  }

  var keyNames = {
    3: "Pause", 8: "Backspace", 9: "Tab", 13: "Enter", 16: "Shift", 17: "Ctrl", 18: "Alt",
    19: "Pause", 20: "CapsLock", 27: "Esc", 32: "Space", 33: "PageUp", 34: "PageDown", 35: "End",
    36: "Home", 37: "Left", 38: "Up", 39: "Right", 40: "Down", 44: "PrintScrn", 45: "Insert",
    46: "Delete", 59: ";", 61: "=", 91: "Mod", 92: "Mod", 93: "Mod",
    106: "*", 107: "=", 109: "-", 110: ".", 111: "/", 145: "ScrollLock",
    173: "-", 186: ";", 187: "=", 188: ",", 189: "-", 190: ".", 191: "/", 192: "`", 219: "[", 220: "\\",
    221: "]", 222: "'", 224: "Mod", 63232: "Up", 63233: "Down", 63234: "Left", 63235: "Right", 63272: "Delete",
    63273: "Home", 63275: "End", 63276: "PageUp", 63277: "PageDown", 63302: "Insert"
  };

  // Number keys
  for (var i = 0; i < 10; i++) { keyNames[i + 48] = keyNames[i + 96] = String(i); }
  // Alphabetic keys
  for (var i$1 = 65; i$1 <= 90; i$1++) { keyNames[i$1] = String.fromCharCode(i$1); }
  // Function keys
  for (var i$2 = 1; i$2 <= 12; i$2++) { keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2; }

  var keyMap = {};

  keyMap.basic = {
    "Left": "goCharLeft", "Right": "goCharRight", "Up": "goLineUp", "Down": "goLineDown",
    "End": "goLineEnd", "Home": "goLineStartSmart", "PageUp": "goPageUp", "PageDown": "goPageDown",
    "Delete": "delCharAfter", "Backspace": "delCharBefore", "Shift-Backspace": "delCharBefore",
    "Tab": "defaultTab", "Shift-Tab": "indentAuto",
    "Enter": "newlineAndIndent", "Insert": "toggleOverwrite",
    "Esc": "singleSelection"
  };
  // Note that the save and find-related commands aren't defined by
  // default. User code or addons can define them. Unknown commands
  // are simply ignored.
  keyMap.pcDefault = {
    "Ctrl-A": "selectAll", "Ctrl-D": "deleteLine", "Ctrl-Z": "undo", "Shift-Ctrl-Z": "redo", "Ctrl-Y": "redo",
    "Ctrl-Home": "goDocStart", "Ctrl-End": "goDocEnd", "Ctrl-Up": "goLineUp", "Ctrl-Down": "goLineDown",
    "Ctrl-Left": "goGroupLeft", "Ctrl-Right": "goGroupRight", "Alt-Left": "goLineStart", "Alt-Right": "goLineEnd",
    "Ctrl-Backspace": "delGroupBefore", "Ctrl-Delete": "delGroupAfter", "Ctrl-S": "save", "Ctrl-F": "find",
    "Ctrl-G": "findNext", "Shift-Ctrl-G": "findPrev", "Shift-Ctrl-F": "replace", "Shift-Ctrl-R": "replaceAll",
    "Ctrl-[": "indentLess", "Ctrl-]": "indentMore",
    "Ctrl-U": "undoSelection", "Shift-Ctrl-U": "redoSelection", "Alt-U": "redoSelection",
    "fallthrough": "basic"
  };
  // Very basic readline/emacs-style bindings, which are standard on Mac.
  keyMap.emacsy = {
    "Ctrl-F": "goCharRight", "Ctrl-B": "goCharLeft", "Ctrl-P": "goLineUp", "Ctrl-N": "goLineDown",
    "Alt-F": "goWordRight", "Alt-B": "goWordLeft", "Ctrl-A": "goLineStart", "Ctrl-E": "goLineEnd",
    "Ctrl-V": "goPageDown", "Shift-Ctrl-V": "goPageUp", "Ctrl-D": "delCharAfter", "Ctrl-H": "delCharBefore",
    "Alt-D": "delWordAfter", "Alt-Backspace": "delWordBefore", "Ctrl-K": "killLine", "Ctrl-T": "transposeChars",
    "Ctrl-O": "openLine"
  };
  keyMap.macDefault = {
    "Cmd-A": "selectAll", "Cmd-D": "deleteLine", "Cmd-Z": "undo", "Shift-Cmd-Z": "redo", "Cmd-Y": "redo",
    "Cmd-Home": "goDocStart", "Cmd-Up": "goDocStart", "Cmd-End": "goDocEnd", "Cmd-Down": "goDocEnd", "Alt-Left": "goGroupLeft",
    "Alt-Right": "goGroupRight", "Cmd-Left": "goLineLeft", "Cmd-Right": "goLineRight", "Alt-Backspace": "delGroupBefore",
    "Ctrl-Alt-Backspace": "delGroupAfter", "Alt-Delete": "delGroupAfter", "Cmd-S": "save", "Cmd-F": "find",
    "Cmd-G": "findNext", "Shift-Cmd-G": "findPrev", "Cmd-Alt-F": "replace", "Shift-Cmd-Alt-F": "replaceAll",
    "Cmd-[": "indentLess", "Cmd-]": "indentMore", "Cmd-Backspace": "delWrappedLineLeft", "Cmd-Delete": "delWrappedLineRight",
    "Cmd-U": "undoSelection", "Shift-Cmd-U": "redoSelection", "Ctrl-Up": "goDocStart", "Ctrl-Down": "goDocEnd",
    "fallthrough": ["basic", "emacsy"]
  };
  keyMap["default"] = mac ? keyMap.macDefault : keyMap.pcDefault;

  // KEYMAP DISPATCH

  function normalizeKeyName(name) {
    var parts = name.split(/-(?!$)/);
    name = parts[parts.length - 1];
    var alt, ctrl, shift, cmd;
    for (var i = 0; i < parts.length - 1; i++) {
      var mod = parts[i];
      if (/^(cmd|meta|m)$/i.test(mod)) { cmd = true; }
      else if (/^a(lt)?$/i.test(mod)) { alt = true; }
      else if (/^(c|ctrl|control)$/i.test(mod)) { ctrl = true; }
      else if (/^s(hift)?$/i.test(mod)) { shift = true; }
      else { throw new Error("Unrecognized modifier name: " + mod) }
    }
    if (alt) { name = "Alt-" + name; }
    if (ctrl) { name = "Ctrl-" + name; }
    if (cmd) { name = "Cmd-" + name; }
    if (shift) { name = "Shift-" + name; }
    return name
  }

  // This is a kludge to keep keymaps mostly working as raw objects
  // (backwards compatibility) while at the same time support features
  // like normalization and multi-stroke key bindings. It compiles a
  // new normalized keymap, and then updates the old object to reflect
  // this.
  function normalizeKeyMap(keymap) {
    var copy = {};
    for (var keyname in keymap) { if (keymap.hasOwnProperty(keyname)) {
      var value = keymap[keyname];
      if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) { continue }
      if (value == "...") { delete keymap[keyname]; continue }

      var keys = map(keyname.split(" "), normalizeKeyName);
      for (var i = 0; i < keys.length; i++) {
        var val = (void 0), name = (void 0);
        if (i == keys.length - 1) {
          name = keys.join(" ");
          val = value;
        } else {
          name = keys.slice(0, i + 1).join(" ");
          val = "...";
        }
        var prev = copy[name];
        if (!prev) { copy[name] = val; }
        else if (prev != val) { throw new Error("Inconsistent bindings for " + name) }
      }
      delete keymap[keyname];
    } }
    for (var prop in copy) { keymap[prop] = copy[prop]; }
    return keymap
  }

  function lookupKey(key, map, handle, context) {
    map = getKeyMap(map);
    var found = map.call ? map.call(key, context) : map[key];
    if (found === false) { return "nothing" }
    if (found === "...") { return "multi" }
    if (found != null && handle(found)) { return "handled" }

    if (map.fallthrough) {
      if (Object.prototype.toString.call(map.fallthrough) != "[object Array]")
        { return lookupKey(key, map.fallthrough, handle, context) }
      for (var i = 0; i < map.fallthrough.length; i++) {
        var result = lookupKey(key, map.fallthrough[i], handle, context);
        if (result) { return result }
      }
    }
  }

  // Modifier key presses don't count as 'real' key presses for the
  // purpose of keymap fallthrough.
  function isModifierKey(value) {
    var name = typeof value == "string" ? value : keyNames[value.keyCode];
    return name == "Ctrl" || name == "Alt" || name == "Shift" || name == "Mod"
  }

  function addModifierNames(name, event, noShift) {
    var base = name;
    if (event.altKey && base != "Alt") { name = "Alt-" + name; }
    if ((flipCtrlCmd ? event.metaKey : event.ctrlKey) && base != "Ctrl") { name = "Ctrl-" + name; }
    if ((flipCtrlCmd ? event.ctrlKey : event.metaKey) && base != "Mod") { name = "Cmd-" + name; }
    if (!noShift && event.shiftKey && base != "Shift") { name = "Shift-" + name; }
    return name
  }

  // Look up the name of a key as indicated by an event object.
  function keyName(event, noShift) {
    if (presto && event.keyCode == 34 && event["char"]) { return false }
    var name = keyNames[event.keyCode];
    if (name == null || event.altGraphKey) { return false }
    // Ctrl-ScrollLock has keyCode 3, same as Ctrl-Pause,
    // so we'll use event.code when available (Chrome 48+, FF 38+, Safari 10.1+)
    if (event.keyCode == 3 && event.code) { name = event.code; }
    return addModifierNames(name, event, noShift)
  }

  function getKeyMap(val) {
    return typeof val == "string" ? keyMap[val] : val
  }

  // Helper for deleting text near the selection(s), used to implement
  // backspace, delete, and similar functionality.
  function deleteNearSelection(cm, compute) {
    var ranges = cm.doc.sel.ranges, kill = [];
    // Build up a set of ranges to kill first, merging overlapping
    // ranges.
    for (var i = 0; i < ranges.length; i++) {
      var toKill = compute(ranges[i]);
      while (kill.length && cmp(toKill.from, lst(kill).to) <= 0) {
        var replaced = kill.pop();
        if (cmp(replaced.from, toKill.from) < 0) {
          toKill.from = replaced.from;
          break
        }
      }
      kill.push(toKill);
    }
    // Next, remove those actual ranges.
    runInOp(cm, function () {
      for (var i = kill.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete"); }
      ensureCursorVisible(cm);
    });
  }

  function moveCharLogically(line, ch, dir) {
    var target = skipExtendingChars(line.text, ch + dir, dir);
    return target < 0 || target > line.text.length ? null : target
  }

  function moveLogically(line, start, dir) {
    var ch = moveCharLogically(line, start.ch, dir);
    return ch == null ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
  }

  function endOfLine(visually, cm, lineObj, lineNo, dir) {
    if (visually) {
      if (cm.doc.direction == "rtl") { dir = -dir; }
      var order = getOrder(lineObj, cm.doc.direction);
      if (order) {
        var part = dir < 0 ? lst(order) : order[0];
        var moveInStorageOrder = (dir < 0) == (part.level == 1);
        var sticky = moveInStorageOrder ? "after" : "before";
        var ch;
        // With a wrapped rtl chunk (possibly spanning multiple bidi parts),
        // it could be that the last bidi part is not on the last visual line,
        // since visual lines contain content order-consecutive chunks.
        // Thus, in rtl, we are looking for the first (content-order) character
        // in the rtl chunk that is on the last line (that is, the same line
        // as the last (content-order) character).
        if (part.level > 0 || cm.doc.direction == "rtl") {
          var prep = prepareMeasureForLine(cm, lineObj);
          ch = dir < 0 ? lineObj.text.length - 1 : 0;
          var targetTop = measureCharPrepared(cm, prep, ch).top;
          ch = findFirst(function (ch) { return measureCharPrepared(cm, prep, ch).top == targetTop; }, (dir < 0) == (part.level == 1) ? part.from : part.to - 1, ch);
          if (sticky == "before") { ch = moveCharLogically(lineObj, ch, 1); }
        } else { ch = dir < 0 ? part.to : part.from; }
        return new Pos(lineNo, ch, sticky)
      }
    }
    return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
  }

  function moveVisually(cm, line, start, dir) {
    var bidi = getOrder(line, cm.doc.direction);
    if (!bidi) { return moveLogically(line, start, dir) }
    if (start.ch >= line.text.length) {
      start.ch = line.text.length;
      start.sticky = "before";
    } else if (start.ch <= 0) {
      start.ch = 0;
      start.sticky = "after";
    }
    var partPos = getBidiPartAt(bidi, start.ch, start.sticky), part = bidi[partPos];
    if (cm.doc.direction == "ltr" && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) {
      // Case 1: We move within an ltr part in an ltr editor. Even with wrapped lines,
      // nothing interesting happens.
      return moveLogically(line, start, dir)
    }

    var mv = function (pos, dir) { return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir); };
    var prep;
    var getWrappedLineExtent = function (ch) {
      if (!cm.options.lineWrapping) { return {begin: 0, end: line.text.length} }
      prep = prep || prepareMeasureForLine(cm, line);
      return wrappedLineExtentChar(cm, line, prep, ch)
    };
    var wrappedLineExtent = getWrappedLineExtent(start.sticky == "before" ? mv(start, -1) : start.ch);

    if (cm.doc.direction == "rtl" || part.level == 1) {
      var moveInStorageOrder = (part.level == 1) == (dir < 0);
      var ch = mv(start, moveInStorageOrder ? 1 : -1);
      if (ch != null && (!moveInStorageOrder ? ch >= part.from && ch >= wrappedLineExtent.begin : ch <= part.to && ch <= wrappedLineExtent.end)) {
        // Case 2: We move within an rtl part or in an rtl editor on the same visual line
        var sticky = moveInStorageOrder ? "before" : "after";
        return new Pos(start.line, ch, sticky)
      }
    }

    // Case 3: Could not move within this bidi part in this visual line, so leave
    // the current bidi part

    var searchInVisualLine = function (partPos, dir, wrappedLineExtent) {
      var getRes = function (ch, moveInStorageOrder) { return moveInStorageOrder
        ? new Pos(start.line, mv(ch, 1), "before")
        : new Pos(start.line, ch, "after"); };

      for (; partPos >= 0 && partPos < bidi.length; partPos += dir) {
        var part = bidi[partPos];
        var moveInStorageOrder = (dir > 0) == (part.level != 1);
        var ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
        if (part.from <= ch && ch < part.to) { return getRes(ch, moveInStorageOrder) }
        ch = moveInStorageOrder ? part.from : mv(part.to, -1);
        if (wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) { return getRes(ch, moveInStorageOrder) }
      }
    };

    // Case 3a: Look for other bidi parts on the same visual line
    var res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
    if (res) { return res }

    // Case 3b: Look for other bidi parts on the next visual line
    var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
    if (nextCh != null && !(dir > 0 && nextCh == line.text.length)) {
      res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh));
      if (res) { return res }
    }

    // Case 4: Nowhere to move
    return null
  }

  // Commands are parameter-less actions that can be performed on an
  // editor, mostly used for keybindings.
  var commands = {
    selectAll: selectAll,
    singleSelection: function (cm) { return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll); },
    killLine: function (cm) { return deleteNearSelection(cm, function (range) {
      if (range.empty()) {
        var len = getLine(cm.doc, range.head.line).text.length;
        if (range.head.ch == len && range.head.line < cm.lastLine())
          { return {from: range.head, to: Pos(range.head.line + 1, 0)} }
        else
          { return {from: range.head, to: Pos(range.head.line, len)} }
      } else {
        return {from: range.from(), to: range.to()}
      }
    }); },
    deleteLine: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0),
      to: clipPos(cm.doc, Pos(range.to().line + 1, 0))
    }); }); },
    delLineLeft: function (cm) { return deleteNearSelection(cm, function (range) { return ({
      from: Pos(range.from().line, 0), to: range.from()
    }); }); },
    delWrappedLineLeft: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var leftPos = cm.coordsChar({left: 0, top: top}, "div");
      return {from: leftPos, to: range.from()}
    }); },
    delWrappedLineRight: function (cm) { return deleteNearSelection(cm, function (range) {
      var top = cm.charCoords(range.head, "div").top + 5;
      var rightPos = cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div");
      return {from: range.from(), to: rightPos }
    }); },
    undo: function (cm) { return cm.undo(); },
    redo: function (cm) { return cm.redo(); },
    undoSelection: function (cm) { return cm.undoSelection(); },
    redoSelection: function (cm) { return cm.redoSelection(); },
    goDocStart: function (cm) { return cm.extendSelection(Pos(cm.firstLine(), 0)); },
    goDocEnd: function (cm) { return cm.extendSelection(Pos(cm.lastLine())); },
    goLineStart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStart(cm, range.head.line); },
      {origin: "+move", bias: 1}
    ); },
    goLineStartSmart: function (cm) { return cm.extendSelectionsBy(function (range) { return lineStartSmart(cm, range.head); },
      {origin: "+move", bias: 1}
    ); },
    goLineEnd: function (cm) { return cm.extendSelectionsBy(function (range) { return lineEnd(cm, range.head.line); },
      {origin: "+move", bias: -1}
    ); },
    goLineRight: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: cm.display.lineDiv.offsetWidth + 100, top: top}, "div")
    }, sel_move); },
    goLineLeft: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      return cm.coordsChar({left: 0, top: top}, "div")
    }, sel_move); },
    goLineLeftSmart: function (cm) { return cm.extendSelectionsBy(function (range) {
      var top = cm.cursorCoords(range.head, "div").top + 5;
      var pos = cm.coordsChar({left: 0, top: top}, "div");
      if (pos.ch < cm.getLine(pos.line).search(/\S/)) { return lineStartSmart(cm, range.head) }
      return pos
    }, sel_move); },
    goLineUp: function (cm) { return cm.moveV(-1, "line"); },
    goLineDown: function (cm) { return cm.moveV(1, "line"); },
    goPageUp: function (cm) { return cm.moveV(-1, "page"); },
    goPageDown: function (cm) { return cm.moveV(1, "page"); },
    goCharLeft: function (cm) { return cm.moveH(-1, "char"); },
    goCharRight: function (cm) { return cm.moveH(1, "char"); },
    goColumnLeft: function (cm) { return cm.moveH(-1, "column"); },
    goColumnRight: function (cm) { return cm.moveH(1, "column"); },
    goWordLeft: function (cm) { return cm.moveH(-1, "word"); },
    goGroupRight: function (cm) { return cm.moveH(1, "group"); },
    goGroupLeft: function (cm) { return cm.moveH(-1, "group"); },
    goWordRight: function (cm) { return cm.moveH(1, "word"); },
    delCharBefore: function (cm) { return cm.deleteH(-1, "codepoint"); },
    delCharAfter: function (cm) { return cm.deleteH(1, "char"); },
    delWordBefore: function (cm) { return cm.deleteH(-1, "word"); },
    delWordAfter: function (cm) { return cm.deleteH(1, "word"); },
    delGroupBefore: function (cm) { return cm.deleteH(-1, "group"); },
    delGroupAfter: function (cm) { return cm.deleteH(1, "group"); },
    indentAuto: function (cm) { return cm.indentSelection("smart"); },
    indentMore: function (cm) { return cm.indentSelection("add"); },
    indentLess: function (cm) { return cm.indentSelection("subtract"); },
    insertTab: function (cm) { return cm.replaceSelection("\t"); },
    insertSoftTab: function (cm) {
      var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize;
      for (var i = 0; i < ranges.length; i++) {
        var pos = ranges[i].from();
        var col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
        spaces.push(spaceStr(tabSize - col % tabSize));
      }
      cm.replaceSelections(spaces);
    },
    defaultTab: function (cm) {
      if (cm.somethingSelected()) { cm.indentSelection("add"); }
      else { cm.execCommand("insertTab"); }
    },
    // Swap the two chars left and right of each selection's head.
    // Move cursor behind the two swapped characters afterwards.
    //
    // Doesn't consider line feeds a character.
    // Doesn't scan more than one line above to find a character.
    // Doesn't do anything on an empty line.
    // Doesn't do anything with non-empty selections.
    transposeChars: function (cm) { return runInOp(cm, function () {
      var ranges = cm.listSelections(), newSel = [];
      for (var i = 0; i < ranges.length; i++) {
        if (!ranges[i].empty()) { continue }
        var cur = ranges[i].head, line = getLine(cm.doc, cur.line).text;
        if (line) {
          if (cur.ch == line.length) { cur = new Pos(cur.line, cur.ch - 1); }
          if (cur.ch > 0) {
            cur = new Pos(cur.line, cur.ch + 1);
            cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2),
                            Pos(cur.line, cur.ch - 2), cur, "+transpose");
          } else if (cur.line > cm.doc.first) {
            var prev = getLine(cm.doc, cur.line - 1).text;
            if (prev) {
              cur = new Pos(cur.line, 1);
              cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() +
                              prev.charAt(prev.length - 1),
                              Pos(cur.line - 1, prev.length - 1), cur, "+transpose");
            }
          }
        }
        newSel.push(new Range(cur, cur));
      }
      cm.setSelections(newSel);
    }); },
    newlineAndIndent: function (cm) { return runInOp(cm, function () {
      var sels = cm.listSelections();
      for (var i = sels.length - 1; i >= 0; i--)
        { cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input"); }
      sels = cm.listSelections();
      for (var i$1 = 0; i$1 < sels.length; i$1++)
        { cm.indentLine(sels[i$1].from().line, null, true); }
      ensureCursorVisible(cm);
    }); },
    openLine: function (cm) { return cm.replaceSelection("\n", "start"); },
    toggleOverwrite: function (cm) { return cm.toggleOverwrite(); }
  };


  function lineStart(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLine(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, visual, lineN, 1)
  }
  function lineEnd(cm, lineN) {
    var line = getLine(cm.doc, lineN);
    var visual = visualLineEnd(line);
    if (visual != line) { lineN = lineNo(visual); }
    return endOfLine(true, cm, line, lineN, -1)
  }
  function lineStartSmart(cm, pos) {
    var start = lineStart(cm, pos.line);
    var line = getLine(cm.doc, start.line);
    var order = getOrder(line, cm.doc.direction);
    if (!order || order[0].level == 0) {
      var firstNonWS = Math.max(start.ch, line.text.search(/\S/));
      var inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
      return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
    }
    return start
  }

  // Run a handler that was bound to a key.
  function doHandleBinding(cm, bound, dropShift) {
    if (typeof bound == "string") {
      bound = commands[bound];
      if (!bound) { return false }
    }
    // Ensure previous input has been read, so that the handler sees a
    // consistent view of the document
    cm.display.input.ensurePolled();
    var prevShift = cm.display.shift, done = false;
    try {
      if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
      if (dropShift) { cm.display.shift = false; }
      done = bound(cm) != Pass;
    } finally {
      cm.display.shift = prevShift;
      cm.state.suppressEdits = false;
    }
    return done
  }

  function lookupKeyForEditor(cm, name, handle) {
    for (var i = 0; i < cm.state.keyMaps.length; i++) {
      var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
      if (result) { return result }
    }
    return (cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm))
      || lookupKey(name, cm.options.keyMap, handle, cm)
  }

  // Note that, despite the name, this function is also used to check
  // for bound mouse clicks.

  var stopSeq = new Delayed;

  function dispatchKey(cm, name, e, handle) {
    var seq = cm.state.keySeq;
    if (seq) {
      if (isModifierKey(name)) { return "handled" }
      if (/\'$/.test(name))
        { cm.state.keySeq = null; }
      else
        { stopSeq.set(50, function () {
          if (cm.state.keySeq == seq) {
            cm.state.keySeq = null;
            cm.display.input.reset();
          }
        }); }
      if (dispatchKeyInner(cm, seq + " " + name, e, handle)) { return true }
    }
    return dispatchKeyInner(cm, name, e, handle)
  }

  function dispatchKeyInner(cm, name, e, handle) {
    var result = lookupKeyForEditor(cm, name, handle);

    if (result == "multi")
      { cm.state.keySeq = name; }
    if (result == "handled")
      { signalLater(cm, "keyHandled", cm, name, e); }

    if (result == "handled" || result == "multi") {
      e_preventDefault(e);
      restartBlink(cm);
    }

    return !!result
  }

  // Handle a key from the keydown event.
  function handleKeyBinding(cm, e) {
    var name = keyName(e, true);
    if (!name) { return false }

    if (e.shiftKey && !cm.state.keySeq) {
      // First try to resolve full name (including 'Shift-'). Failing
      // that, see if there is a cursor-motion command (starting with
      // 'go') bound to the keyname without 'Shift-'.
      return dispatchKey(cm, "Shift-" + name, e, function (b) { return doHandleBinding(cm, b, true); })
          || dispatchKey(cm, name, e, function (b) {
               if (typeof b == "string" ? /^go[A-Z]/.test(b) : b.motion)
                 { return doHandleBinding(cm, b) }
             })
    } else {
      return dispatchKey(cm, name, e, function (b) { return doHandleBinding(cm, b); })
    }
  }

  // Handle a key from the keypress event
  function handleCharBinding(cm, e, ch) {
    return dispatchKey(cm, "'" + ch + "'", e, function (b) { return doHandleBinding(cm, b, true); })
  }

  var lastStoppedKey = null;
  function onKeyDown(e) {
    var cm = this;
    if (e.target && e.target != cm.display.input.getField()) { return }
    cm.curOp.focus = activeElt();
    if (signalDOMEvent(cm, e)) { return }
    // IE does strange things with escape.
    if (ie && ie_version < 11 && e.keyCode == 27) { e.returnValue = false; }
    var code = e.keyCode;
    cm.display.shift = code == 16 || e.shiftKey;
    var handled = handleKeyBinding(cm, e);
    if (presto) {
      lastStoppedKey = handled ? code : null;
      // Opera has no cut event... we try to at least catch the key combo
      if (!handled && code == 88 && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey))
        { cm.replaceSelection("", null, "cut"); }
    }
    if (gecko && !mac && !handled && code == 46 && e.shiftKey && !e.ctrlKey && document.execCommand)
      { document.execCommand("cut"); }

    // Turn mouse into crosshair when Alt is held on Mac.
    if (code == 18 && !/\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className))
      { showCrossHair(cm); }
  }

  function showCrossHair(cm) {
    var lineDiv = cm.display.lineDiv;
    addClass(lineDiv, "CodeMirror-crosshair");

    function up(e) {
      if (e.keyCode == 18 || !e.altKey) {
        rmClass(lineDiv, "CodeMirror-crosshair");
        off(document, "keyup", up);
        off(document, "mouseover", up);
      }
    }
    on(document, "keyup", up);
    on(document, "mouseover", up);
  }

  function onKeyUp(e) {
    if (e.keyCode == 16) { this.doc.sel.shift = false; }
    signalDOMEvent(this, e);
  }

  function onKeyPress(e) {
    var cm = this;
    if (e.target && e.target != cm.display.input.getField()) { return }
    if (eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey) { return }
    var keyCode = e.keyCode, charCode = e.charCode;
    if (presto && keyCode == lastStoppedKey) {lastStoppedKey = null; e_preventDefault(e); return}
    if ((presto && (!e.which || e.which < 10)) && handleKeyBinding(cm, e)) { return }
    var ch = String.fromCharCode(charCode == null ? keyCode : charCode);
    // Some browsers fire keypress events for backspace
    if (ch == "\x08") { return }
    if (handleCharBinding(cm, e, ch)) { return }
    cm.display.input.onKeyPress(e);
  }

  var DOUBLECLICK_DELAY = 400;

  var PastClick = function(time, pos, button) {
    this.time = time;
    this.pos = pos;
    this.button = button;
  };

  PastClick.prototype.compare = function (time, pos, button) {
    return this.time + DOUBLECLICK_DELAY > time &&
      cmp(pos, this.pos) == 0 && button == this.button
  };

  var lastClick, lastDoubleClick;
  function clickRepeat(pos, button) {
    var now = +new Date;
    if (lastDoubleClick && lastDoubleClick.compare(now, pos, button)) {
      lastClick = lastDoubleClick = null;
      return "triple"
    } else if (lastClick && lastClick.compare(now, pos, button)) {
      lastDoubleClick = new PastClick(now, pos, button);
      lastClick = null;
      return "double"
    } else {
      lastClick = new PastClick(now, pos, button);
      lastDoubleClick = null;
      return "single"
    }
  }

  // A mouse down can be a single click, double click, triple click,
  // start of selection drag, start of text drag, new cursor
  // (ctrl-click), rectangle drag (alt-drag), or xwin
  // middle-click-paste. Or it might be a click on something we should
  // not interfere with, such as a scrollbar or widget.
  function onMouseDown(e) {
    var cm = this, display = cm.display;
    if (signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch()) { return }
    display.input.ensurePolled();
    display.shift = e.shiftKey;

    if (eventInWidget(display, e)) {
      if (!webkit) {
        // Briefly turn off draggability, to allow widgets to do
        // normal dragging things.
        display.scroller.draggable = false;
        setTimeout(function () { return display.scroller.draggable = true; }, 100);
      }
      return
    }
    if (clickInGutter(cm, e)) { return }
    var pos = posFromMouse(cm, e), button = e_button(e), repeat = pos ? clickRepeat(pos, button) : "single";
    window.focus();

    // #3261: make sure, that we're not starting a second selection
    if (button == 1 && cm.state.selectingText)
      { cm.state.selectingText(e); }

    if (pos && handleMappedButton(cm, button, pos, repeat, e)) { return }

    if (button == 1) {
      if (pos) { leftButtonDown(cm, pos, repeat, e); }
      else if (e_target(e) == display.scroller) { e_preventDefault(e); }
    } else if (button == 2) {
      if (pos) { extendSelection(cm.doc, pos); }
      setTimeout(function () { return display.input.focus(); }, 20);
    } else if (button == 3) {
      if (captureRightClick) { cm.display.input.onContextMenu(e); }
      else { delayBlurEvent(cm); }
    }
  }

  function handleMappedButton(cm, button, pos, repeat, event) {
    var name = "Click";
    if (repeat == "double") { name = "Double" + name; }
    else if (repeat == "triple") { name = "Triple" + name; }
    name = (button == 1 ? "Left" : button == 2 ? "Middle" : "Right") + name;

    return dispatchKey(cm,  addModifierNames(name, event), event, function (bound) {
      if (typeof bound == "string") { bound = commands[bound]; }
      if (!bound) { return false }
      var done = false;
      try {
        if (cm.isReadOnly()) { cm.state.suppressEdits = true; }
        done = bound(cm, pos) != Pass;
      } finally {
        cm.state.suppressEdits = false;
      }
      return done
    })
  }

  function configureMouse(cm, repeat, event) {
    var option = cm.getOption("configureMouse");
    var value = option ? option(cm, repeat, event) : {};
    if (value.unit == null) {
      var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
      value.unit = rect ? "rectangle" : repeat == "single" ? "char" : repeat == "double" ? "word" : "line";
    }
    if (value.extend == null || cm.doc.extend) { value.extend = cm.doc.extend || event.shiftKey; }
    if (value.addNew == null) { value.addNew = mac ? event.metaKey : event.ctrlKey; }
    if (value.moveOnDrag == null) { value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey); }
    return value
  }

  function leftButtonDown(cm, pos, repeat, event) {
    if (ie) { setTimeout(bind(ensureFocus, cm), 0); }
    else { cm.curOp.focus = activeElt(); }

    var behavior = configureMouse(cm, repeat, event);

    var sel = cm.doc.sel, contained;
    if (cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() &&
        repeat == "single" && (contained = sel.contains(pos)) > -1 &&
        (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) &&
        (cmp(contained.to(), pos) > 0 || pos.xRel < 0))
      { leftButtonStartDrag(cm, event, pos, behavior); }
    else
      { leftButtonSelect(cm, event, pos, behavior); }
  }

  // Start a text drag. When it ends, see if any dragging actually
  // happen, and treat as a click if it didn't.
  function leftButtonStartDrag(cm, event, pos, behavior) {
    var display = cm.display, moved = false;
    var dragEnd = operation(cm, function (e) {
      if (webkit) { display.scroller.draggable = false; }
      cm.state.draggingText = false;
      if (cm.state.delayingBlurEvent) {
        if (cm.hasFocus()) { cm.state.delayingBlurEvent = false; }
        else { delayBlurEvent(cm); }
      }
      off(display.wrapper.ownerDocument, "mouseup", dragEnd);
      off(display.wrapper.ownerDocument, "mousemove", mouseMove);
      off(display.scroller, "dragstart", dragStart);
      off(display.scroller, "drop", dragEnd);
      if (!moved) {
        e_preventDefault(e);
        if (!behavior.addNew)
          { extendSelection(cm.doc, pos, null, null, behavior.extend); }
        // Work around unexplainable focus problem in IE9 (#2127) and Chrome (#3081)
        if ((webkit && !safari) || ie && ie_version == 9)
          { setTimeout(function () {display.wrapper.ownerDocument.body.focus({preventScroll: true}); display.input.focus();}, 20); }
        else
          { display.input.focus(); }
      }
    });
    var mouseMove = function(e2) {
      moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10;
    };
    var dragStart = function () { return moved = true; };
    // Let the drag handler handle this.
    if (webkit) { display.scroller.draggable = true; }
    cm.state.draggingText = dragEnd;
    dragEnd.copy = !behavior.moveOnDrag;
    on(display.wrapper.ownerDocument, "mouseup", dragEnd);
    on(display.wrapper.ownerDocument, "mousemove", mouseMove);
    on(display.scroller, "dragstart", dragStart);
    on(display.scroller, "drop", dragEnd);

    cm.state.delayingBlurEvent = true;
    setTimeout(function () { return display.input.focus(); }, 20);
    // IE's approach to draggable
    if (display.scroller.dragDrop) { display.scroller.dragDrop(); }
  }

  function rangeForUnit(cm, pos, unit) {
    if (unit == "char") { return new Range(pos, pos) }
    if (unit == "word") { return cm.findWordAt(pos) }
    if (unit == "line") { return new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))) }
    var result = unit(cm, pos);
    return new Range(result.from, result.to)
  }

  // Normal selection, as opposed to text dragging.
  function leftButtonSelect(cm, event, start, behavior) {
    if (ie) { delayBlurEvent(cm); }
    var display = cm.display, doc = cm.doc;
    e_preventDefault(event);

    var ourRange, ourIndex, startSel = doc.sel, ranges = startSel.ranges;
    if (behavior.addNew && !behavior.extend) {
      ourIndex = doc.sel.contains(start);
      if (ourIndex > -1)
        { ourRange = ranges[ourIndex]; }
      else
        { ourRange = new Range(start, start); }
    } else {
      ourRange = doc.sel.primary();
      ourIndex = doc.sel.primIndex;
    }

    if (behavior.unit == "rectangle") {
      if (!behavior.addNew) { ourRange = new Range(start, start); }
      start = posFromMouse(cm, event, true, true);
      ourIndex = -1;
    } else {
      var range = rangeForUnit(cm, start, behavior.unit);
      if (behavior.extend)
        { ourRange = extendRange(ourRange, range.anchor, range.head, behavior.extend); }
      else
        { ourRange = range; }
    }

    if (!behavior.addNew) {
      ourIndex = 0;
      setSelection(doc, new Selection([ourRange], 0), sel_mouse);
      startSel = doc.sel;
    } else if (ourIndex == -1) {
      ourIndex = ranges.length;
      setSelection(doc, normalizeSelection(cm, ranges.concat([ourRange]), ourIndex),
                   {scroll: false, origin: "*mouse"});
    } else if (ranges.length > 1 && ranges[ourIndex].empty() && behavior.unit == "char" && !behavior.extend) {
      setSelection(doc, normalizeSelection(cm, ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0),
                   {scroll: false, origin: "*mouse"});
      startSel = doc.sel;
    } else {
      replaceOneSelection(doc, ourIndex, ourRange, sel_mouse);
    }

    var lastPos = start;
    function extendTo(pos) {
      if (cmp(lastPos, pos) == 0) { return }
      lastPos = pos;

      if (behavior.unit == "rectangle") {
        var ranges = [], tabSize = cm.options.tabSize;
        var startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize);
        var posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize);
        var left = Math.min(startCol, posCol), right = Math.max(startCol, posCol);
        for (var line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line));
             line <= end; line++) {
          var text = getLine(doc, line).text, leftPos = findColumn(text, left, tabSize);
          if (left == right)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))); }
          else if (text.length > leftPos)
            { ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize)))); }
        }
        if (!ranges.length) { ranges.push(new Range(start, start)); }
        setSelection(doc, normalizeSelection(cm, startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex),
                     {origin: "*mouse", scroll: false});
        cm.scrollIntoView(pos);
      } else {
        var oldRange = ourRange;
        var range = rangeForUnit(cm, pos, behavior.unit);
        var anchor = oldRange.anchor, head;
        if (cmp(range.anchor, anchor) > 0) {
          head = range.head;
          anchor = minPos(oldRange.from(), range.anchor);
        } else {
          head = range.anchor;
          anchor = maxPos(oldRange.to(), range.head);
        }
        var ranges$1 = startSel.ranges.slice(0);
        ranges$1[ourIndex] = bidiSimplify(cm, new Range(clipPos(doc, anchor), head));
        setSelection(doc, normalizeSelection(cm, ranges$1, ourIndex), sel_mouse);
      }
    }

    var editorSize = display.wrapper.getBoundingClientRect();
    // Used to ensure timeout re-tries don't fire when another extend
    // happened in the meantime (clearTimeout isn't reliable -- at
    // least on Chrome, the timeouts still happen even when cleared,
    // if the clear happens after their scheduled firing time).
    var counter = 0;

    function extend(e) {
      var curCount = ++counter;
      var cur = posFromMouse(cm, e, true, behavior.unit == "rectangle");
      if (!cur) { return }
      if (cmp(cur, lastPos) != 0) {
        cm.curOp.focus = activeElt();
        extendTo(cur);
        var visible = visibleLines(display, doc);
        if (cur.line >= visible.to || cur.line < visible.from)
          { setTimeout(operation(cm, function () {if (counter == curCount) { extend(e); }}), 150); }
      } else {
        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
        if (outside) { setTimeout(operation(cm, function () {
          if (counter != curCount) { return }
          display.scroller.scrollTop += outside;
          extend(e);
        }), 50); }
      }
    }

    function done(e) {
      cm.state.selectingText = false;
      counter = Infinity;
      // If e is null or undefined we interpret this as someone trying
      // to explicitly cancel the selection rather than the user
      // letting go of the mouse button.
      if (e) {
        e_preventDefault(e);
        display.input.focus();
      }
      off(display.wrapper.ownerDocument, "mousemove", move);
      off(display.wrapper.ownerDocument, "mouseup", up);
      doc.history.lastSelOrigin = null;
    }

    var move = operation(cm, function (e) {
      if (e.buttons === 0 || !e_button(e)) { done(e); }
      else { extend(e); }
    });
    var up = operation(cm, done);
    cm.state.selectingText = up;
    on(display.wrapper.ownerDocument, "mousemove", move);
    on(display.wrapper.ownerDocument, "mouseup", up);
  }

  // Used when mouse-selecting to adjust the anchor to the proper side
  // of a bidi jump depending on the visual position of the head.
  function bidiSimplify(cm, range) {
    var anchor = range.anchor;
    var head = range.head;
    var anchorLine = getLine(cm.doc, anchor.line);
    if (cmp(anchor, head) == 0 && anchor.sticky == head.sticky) { return range }
    var order = getOrder(anchorLine);
    if (!order) { return range }
    var index = getBidiPartAt(order, anchor.ch, anchor.sticky), part = order[index];
    if (part.from != anchor.ch && part.to != anchor.ch) { return range }
    var boundary = index + ((part.from == anchor.ch) == (part.level != 1) ? 0 : 1);
    if (boundary == 0 || boundary == order.length) { return range }

    // Compute the relative visual position of the head compared to the
    // anchor (<0 is to the left, >0 to the right)
    var leftSide;
    if (head.line != anchor.line) {
      leftSide = (head.line - anchor.line) * (cm.doc.direction == "ltr" ? 1 : -1) > 0;
    } else {
      var headIndex = getBidiPartAt(order, head.ch, head.sticky);
      var dir = headIndex - index || (head.ch - anchor.ch) * (part.level == 1 ? -1 : 1);
      if (headIndex == boundary - 1 || headIndex == boundary)
        { leftSide = dir < 0; }
      else
        { leftSide = dir > 0; }
    }

    var usePart = order[boundary + (leftSide ? -1 : 0)];
    var from = leftSide == (usePart.level == 1);
    var ch = from ? usePart.from : usePart.to, sticky = from ? "after" : "before";
    return anchor.ch == ch && anchor.sticky == sticky ? range : new Range(new Pos(anchor.line, ch, sticky), head)
  }


  // Determines whether an event happened in the gutter, and fires the
  // handlers for the corresponding event.
  function gutterEvent(cm, e, type, prevent) {
    var mX, mY;
    if (e.touches) {
      mX = e.touches[0].clientX;
      mY = e.touches[0].clientY;
    } else {
      try { mX = e.clientX; mY = e.clientY; }
      catch(e$1) { return false }
    }
    if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) { return false }
    if (prevent) { e_preventDefault(e); }

    var display = cm.display;
    var lineBox = display.lineDiv.getBoundingClientRect();

    if (mY > lineBox.bottom || !hasHandler(cm, type)) { return e_defaultPrevented(e) }
    mY -= lineBox.top - display.viewOffset;

    for (var i = 0; i < cm.display.gutterSpecs.length; ++i) {
      var g = display.gutters.childNodes[i];
      if (g && g.getBoundingClientRect().right >= mX) {
        var line = lineAtHeight(cm.doc, mY);
        var gutter = cm.display.gutterSpecs[i];
        signal(cm, type, cm, line, gutter.className, e);
        return e_defaultPrevented(e)
      }
    }
  }

  function clickInGutter(cm, e) {
    return gutterEvent(cm, e, "gutterClick", true)
  }

  // CONTEXT MENU HANDLING

  // To make the context menu work, we need to briefly unhide the
  // textarea (making it as unobtrusive as possible) to let the
  // right-click take effect on it.
  function onContextMenu(cm, e) {
    if (eventInWidget(cm.display, e) || contextMenuInGutter(cm, e)) { return }
    if (signalDOMEvent(cm, e, "contextmenu")) { return }
    if (!captureRightClick) { cm.display.input.onContextMenu(e); }
  }

  function contextMenuInGutter(cm, e) {
    if (!hasHandler(cm, "gutterContextMenu")) { return false }
    return gutterEvent(cm, e, "gutterContextMenu", false)
  }

  function themeChanged(cm) {
    cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") +
      cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-");
    clearCaches(cm);
  }

  var Init = {toString: function(){return "CodeMirror.Init"}};

  var defaults = {};
  var optionHandlers = {};

  function defineOptions(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    function option(name, deflt, handle, notOnInit) {
      CodeMirror.defaults[name] = deflt;
      if (handle) { optionHandlers[name] =
        notOnInit ? function (cm, val, old) {if (old != Init) { handle(cm, val, old); }} : handle; }
    }

    CodeMirror.defineOption = option;

    // Passed to option handlers when there is no old value.
    CodeMirror.Init = Init;

    // These two are, on init, called from the constructor because they
    // have to be initialized before the editor can start at all.
    option("value", "", function (cm, val) { return cm.setValue(val); }, true);
    option("mode", null, function (cm, val) {
      cm.doc.modeOption = val;
      loadMode(cm);
    }, true);

    option("indentUnit", 2, loadMode, true);
    option("indentWithTabs", false);
    option("smartIndent", true);
    option("tabSize", 4, function (cm) {
      resetModeState(cm);
      clearCaches(cm);
      regChange(cm);
    }, true);

    option("lineSeparator", null, function (cm, val) {
      cm.doc.lineSep = val;
      if (!val) { return }
      var newBreaks = [], lineNo = cm.doc.first;
      cm.doc.iter(function (line) {
        for (var pos = 0;;) {
          var found = line.text.indexOf(val, pos);
          if (found == -1) { break }
          pos = found + val.length;
          newBreaks.push(Pos(lineNo, found));
        }
        lineNo++;
      });
      for (var i = newBreaks.length - 1; i >= 0; i--)
        { replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length)); }
    });
    option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200c\u200e\u200f\u2028\u2029\ufeff\ufff9-\ufffc]/g, function (cm, val, old) {
      cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g");
      if (old != Init) { cm.refresh(); }
    });
    option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function (cm) { return cm.refresh(); }, true);
    option("electricChars", true);
    option("inputStyle", mobile ? "contenteditable" : "textarea", function () {
      throw new Error("inputStyle can not (yet) be changed in a running editor") // FIXME
    }, true);
    option("spellcheck", false, function (cm, val) { return cm.getInputField().spellcheck = val; }, true);
    option("autocorrect", false, function (cm, val) { return cm.getInputField().autocorrect = val; }, true);
    option("autocapitalize", false, function (cm, val) { return cm.getInputField().autocapitalize = val; }, true);
    option("rtlMoveVisually", !windows);
    option("wholeLineUpdateBefore", true);

    option("theme", "default", function (cm) {
      themeChanged(cm);
      updateGutters(cm);
    }, true);
    option("keyMap", "default", function (cm, val, old) {
      var next = getKeyMap(val);
      var prev = old != Init && getKeyMap(old);
      if (prev && prev.detach) { prev.detach(cm, next); }
      if (next.attach) { next.attach(cm, prev || null); }
    });
    option("extraKeys", null);
    option("configureMouse", null);

    option("lineWrapping", false, wrappingChanged, true);
    option("gutters", [], function (cm, val) {
      cm.display.gutterSpecs = getGutters(val, cm.options.lineNumbers);
      updateGutters(cm);
    }, true);
    option("fixedGutter", true, function (cm, val) {
      cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0";
      cm.refresh();
    }, true);
    option("coverGutterNextToScrollbar", false, function (cm) { return updateScrollbars(cm); }, true);
    option("scrollbarStyle", "native", function (cm) {
      initScrollbars(cm);
      updateScrollbars(cm);
      cm.display.scrollbars.setScrollTop(cm.doc.scrollTop);
      cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft);
    }, true);
    option("lineNumbers", false, function (cm, val) {
      cm.display.gutterSpecs = getGutters(cm.options.gutters, val);
      updateGutters(cm);
    }, true);
    option("firstLineNumber", 1, updateGutters, true);
    option("lineNumberFormatter", function (integer) { return integer; }, updateGutters, true);
    option("showCursorWhenSelecting", false, updateSelection, true);

    option("resetSelectionOnContextMenu", true);
    option("lineWiseCopyCut", true);
    option("pasteLinesPerSelection", true);
    option("selectionsMayTouch", false);

    option("readOnly", false, function (cm, val) {
      if (val == "nocursor") {
        onBlur(cm);
        cm.display.input.blur();
      }
      cm.display.input.readOnlyChanged(val);
    });

    option("screenReaderLabel", null, function (cm, val) {
      val = (val === '') ? null : val;
      cm.display.input.screenReaderLabelChanged(val);
    });

    option("disableInput", false, function (cm, val) {if (!val) { cm.display.input.reset(); }}, true);
    option("dragDrop", true, dragDropChanged);
    option("allowDropFileTypes", null);

    option("cursorBlinkRate", 530);
    option("cursorScrollMargin", 0);
    option("cursorHeight", 1, updateSelection, true);
    option("singleCursorHeightPerLine", true, updateSelection, true);
    option("workTime", 100);
    option("workDelay", 100);
    option("flattenSpans", true, resetModeState, true);
    option("addModeClass", false, resetModeState, true);
    option("pollInterval", 100);
    option("undoDepth", 200, function (cm, val) { return cm.doc.history.undoDepth = val; });
    option("historyEventDelay", 1250);
    option("viewportMargin", 10, function (cm) { return cm.refresh(); }, true);
    option("maxHighlightLength", 10000, resetModeState, true);
    option("moveInputWithCursor", true, function (cm, val) {
      if (!val) { cm.display.input.resetPosition(); }
    });

    option("tabindex", null, function (cm, val) { return cm.display.input.getField().tabIndex = val || ""; });
    option("autofocus", null);
    option("direction", "ltr", function (cm, val) { return cm.doc.setDirection(val); }, true);
    option("phrases", null);
  }

  function dragDropChanged(cm, value, old) {
    var wasOn = old && old != Init;
    if (!value != !wasOn) {
      var funcs = cm.display.dragFunctions;
      var toggle = value ? on : off;
      toggle(cm.display.scroller, "dragstart", funcs.start);
      toggle(cm.display.scroller, "dragenter", funcs.enter);
      toggle(cm.display.scroller, "dragover", funcs.over);
      toggle(cm.display.scroller, "dragleave", funcs.leave);
      toggle(cm.display.scroller, "drop", funcs.drop);
    }
  }

  function wrappingChanged(cm) {
    if (cm.options.lineWrapping) {
      addClass(cm.display.wrapper, "CodeMirror-wrap");
      cm.display.sizer.style.minWidth = "";
      cm.display.sizerWidth = null;
    } else {
      rmClass(cm.display.wrapper, "CodeMirror-wrap");
      findMaxLine(cm);
    }
    estimateLineHeights(cm);
    regChange(cm);
    clearCaches(cm);
    setTimeout(function () { return updateScrollbars(cm); }, 100);
  }

  // A CodeMirror instance represents an editor. This is the object
  // that user code is usually dealing with.

  function CodeMirror(place, options) {
    var this$1 = this;

    if (!(this instanceof CodeMirror)) { return new CodeMirror(place, options) }

    this.options = options = options ? copyObj(options) : {};
    // Determine effective options based on given values and defaults.
    copyObj(defaults, options, false);

    var doc = options.value;
    if (typeof doc == "string") { doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction); }
    else if (options.mode) { doc.modeOption = options.mode; }
    this.doc = doc;

    var input = new CodeMirror.inputStyles[options.inputStyle](this);
    var display = this.display = new Display(place, doc, input, options);
    display.wrapper.CodeMirror = this;
    themeChanged(this);
    if (options.lineWrapping)
      { this.display.wrapper.className += " CodeMirror-wrap"; }
    initScrollbars(this);

    this.state = {
      keyMaps: [],  // stores maps added by addKeyMap
      overlays: [], // highlighting overlays, as added by addOverlay
      modeGen: 0,   // bumped when mode/overlay changes, used to invalidate highlighting info
      overwrite: false,
      delayingBlurEvent: false,
      focused: false,
      suppressEdits: false, // used to disable editing during key handlers when in readOnly mode
      pasteIncoming: -1, cutIncoming: -1, // help recognize paste/cut edits in input.poll
      selectingText: false,
      draggingText: false,
      highlight: new Delayed(), // stores highlight worker timeout
      keySeq: null,  // Unfinished key sequence
      specialChars: null
    };

    if (options.autofocus && !mobile) { display.input.focus(); }

    // Override magic textarea content restore that IE sometimes does
    // on our hidden textarea on reload
    if (ie && ie_version < 11) { setTimeout(function () { return this$1.display.input.reset(true); }, 20); }

    registerEventHandlers(this);
    ensureGlobalHandlers();

    startOperation(this);
    this.curOp.forceUpdate = true;
    attachDoc(this, doc);

    if ((options.autofocus && !mobile) || this.hasFocus())
      { setTimeout(function () {
        if (this$1.hasFocus() && !this$1.state.focused) { onFocus(this$1); }
      }, 20); }
    else
      { onBlur(this); }

    for (var opt in optionHandlers) { if (optionHandlers.hasOwnProperty(opt))
      { optionHandlers[opt](this, options[opt], Init); } }
    maybeUpdateLineNumberWidth(this);
    if (options.finishInit) { options.finishInit(this); }
    for (var i = 0; i < initHooks.length; ++i) { initHooks[i](this); }
    endOperation(this);
    // Suppress optimizelegibility in Webkit, since it breaks text
    // measuring on line wrapping boundaries.
    if (webkit && options.lineWrapping &&
        getComputedStyle(display.lineDiv).textRendering == "optimizelegibility")
      { display.lineDiv.style.textRendering = "auto"; }
  }

  // The default configuration options.
  CodeMirror.defaults = defaults;
  // Functions to run when options are changed.
  CodeMirror.optionHandlers = optionHandlers;

  // Attach the necessary event handlers when initializing the editor
  function registerEventHandlers(cm) {
    var d = cm.display;
    on(d.scroller, "mousedown", operation(cm, onMouseDown));
    // Older IE's will not fire a second mousedown for a double click
    if (ie && ie_version < 11)
      { on(d.scroller, "dblclick", operation(cm, function (e) {
        if (signalDOMEvent(cm, e)) { return }
        var pos = posFromMouse(cm, e);
        if (!pos || clickInGutter(cm, e) || eventInWidget(cm.display, e)) { return }
        e_preventDefault(e);
        var word = cm.findWordAt(pos);
        extendSelection(cm.doc, word.anchor, word.head);
      })); }
    else
      { on(d.scroller, "dblclick", function (e) { return signalDOMEvent(cm, e) || e_preventDefault(e); }); }
    // Some browsers fire contextmenu *after* opening the menu, at
    // which point we can't mess with it anymore. Context menu is
    // handled in onMouseDown for these browsers.
    on(d.scroller, "contextmenu", function (e) { return onContextMenu(cm, e); });
    on(d.input.getField(), "contextmenu", function (e) {
      if (!d.scroller.contains(e.target)) { onContextMenu(cm, e); }
    });

    // Used to suppress mouse event handling when a touch happens
    var touchFinished, prevTouch = {end: 0};
    function finishTouch() {
      if (d.activeTouch) {
        touchFinished = setTimeout(function () { return d.activeTouch = null; }, 1000);
        prevTouch = d.activeTouch;
        prevTouch.end = +new Date;
      }
    }
    function isMouseLikeTouchEvent(e) {
      if (e.touches.length != 1) { return false }
      var touch = e.touches[0];
      return touch.radiusX <= 1 && touch.radiusY <= 1
    }
    function farAway(touch, other) {
      if (other.left == null) { return true }
      var dx = other.left - touch.left, dy = other.top - touch.top;
      return dx * dx + dy * dy > 20 * 20
    }
    on(d.scroller, "touchstart", function (e) {
      if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
        d.input.ensurePolled();
        clearTimeout(touchFinished);
        var now = +new Date;
        d.activeTouch = {start: now, moved: false,
                         prev: now - prevTouch.end <= 300 ? prevTouch : null};
        if (e.touches.length == 1) {
          d.activeTouch.left = e.touches[0].pageX;
          d.activeTouch.top = e.touches[0].pageY;
        }
      }
    });
    on(d.scroller, "touchmove", function () {
      if (d.activeTouch) { d.activeTouch.moved = true; }
    });
    on(d.scroller, "touchend", function (e) {
      var touch = d.activeTouch;
      if (touch && !eventInWidget(d, e) && touch.left != null &&
          !touch.moved && new Date - touch.start < 300) {
        var pos = cm.coordsChar(d.activeTouch, "page"), range;
        if (!touch.prev || farAway(touch, touch.prev)) // Single tap
          { range = new Range(pos, pos); }
        else if (!touch.prev.prev || farAway(touch, touch.prev.prev)) // Double tap
          { range = cm.findWordAt(pos); }
        else // Triple tap
          { range = new Range(Pos(pos.line, 0), clipPos(cm.doc, Pos(pos.line + 1, 0))); }
        cm.setSelection(range.anchor, range.head);
        cm.focus();
        e_preventDefault(e);
      }
      finishTouch();
    });
    on(d.scroller, "touchcancel", finishTouch);

    // Sync scrolling between fake scrollbars and real scrollable
    // area, ensure viewport is updated when scrolling.
    on(d.scroller, "scroll", function () {
      if (d.scroller.clientHeight) {
        updateScrollTop(cm, d.scroller.scrollTop);
        setScrollLeft(cm, d.scroller.scrollLeft, true);
        signal(cm, "scroll", cm);
      }
    });

    // Listen to wheel events in order to try and update the viewport on time.
    on(d.scroller, "mousewheel", function (e) { return onScrollWheel(cm, e); });
    on(d.scroller, "DOMMouseScroll", function (e) { return onScrollWheel(cm, e); });

    // Prevent wrapper from ever scrolling
    on(d.wrapper, "scroll", function () { return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0; });

    d.dragFunctions = {
      enter: function (e) {if (!signalDOMEvent(cm, e)) { e_stop(e); }},
      over: function (e) {if (!signalDOMEvent(cm, e)) { onDragOver(cm, e); e_stop(e); }},
      start: function (e) { return onDragStart(cm, e); },
      drop: operation(cm, onDrop),
      leave: function (e) {if (!signalDOMEvent(cm, e)) { clearDragCursor(cm); }}
    };

    var inp = d.input.getField();
    on(inp, "keyup", function (e) { return onKeyUp.call(cm, e); });
    on(inp, "keydown", operation(cm, onKeyDown));
    on(inp, "keypress", operation(cm, onKeyPress));
    on(inp, "focus", function (e) { return onFocus(cm, e); });
    on(inp, "blur", function (e) { return onBlur(cm, e); });
  }

  var initHooks = [];
  CodeMirror.defineInitHook = function (f) { return initHooks.push(f); };

  // Indent the given line. The how parameter can be "smart",
  // "add"/null, "subtract", or "prev". When aggressive is false
  // (typically set to true for forced single-line indents), empty
  // lines are not indented, and places where the mode returns Pass
  // are left alone.
  function indentLine(cm, n, how, aggressive) {
    var doc = cm.doc, state;
    if (how == null) { how = "add"; }
    if (how == "smart") {
      // Fall back to "prev" when the mode doesn't have an indentation
      // method.
      if (!doc.mode.indent) { how = "prev"; }
      else { state = getContextBefore(cm, n).state; }
    }

    var tabSize = cm.options.tabSize;
    var line = getLine(doc, n), curSpace = countColumn(line.text, null, tabSize);
    if (line.stateAfter) { line.stateAfter = null; }
    var curSpaceString = line.text.match(/^\s*/)[0], indentation;
    if (!aggressive && !/\S/.test(line.text)) {
      indentation = 0;
      how = "not";
    } else if (how == "smart") {
      indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text);
      if (indentation == Pass || indentation > 150) {
        if (!aggressive) { return }
        how = "prev";
      }
    }
    if (how == "prev") {
      if (n > doc.first) { indentation = countColumn(getLine(doc, n-1).text, null, tabSize); }
      else { indentation = 0; }
    } else if (how == "add") {
      indentation = curSpace + cm.options.indentUnit;
    } else if (how == "subtract") {
      indentation = curSpace - cm.options.indentUnit;
    } else if (typeof how == "number") {
      indentation = curSpace + how;
    }
    indentation = Math.max(0, indentation);

    var indentString = "", pos = 0;
    if (cm.options.indentWithTabs)
      { for (var i = Math.floor(indentation / tabSize); i; --i) {pos += tabSize; indentString += "\t";} }
    if (pos < indentation) { indentString += spaceStr(indentation - pos); }

    if (indentString != curSpaceString) {
      replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input");
      line.stateAfter = null;
      return true
    } else {
      // Ensure that, if the cursor was in the whitespace at the start
      // of the line, it is moved to the end of that space.
      for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
        var range = doc.sel.ranges[i$1];
        if (range.head.line == n && range.head.ch < curSpaceString.length) {
          var pos$1 = Pos(n, curSpaceString.length);
          replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
          break
        }
      }
    }
  }

  // This will be set to a {lineWise: bool, text: [string]} object, so
  // that, when pasting, we know what kind of selections the copied
  // text was made out of.
  var lastCopied = null;

  function setLastCopied(newLastCopied) {
    lastCopied = newLastCopied;
  }

  function applyTextInput(cm, inserted, deleted, sel, origin) {
    var doc = cm.doc;
    cm.display.shift = false;
    if (!sel) { sel = doc.sel; }

    var recent = +new Date - 200;
    var paste = origin == "paste" || cm.state.pasteIncoming > recent;
    var textLines = splitLinesAuto(inserted), multiPaste = null;
    // When pasting N lines into N selections, insert one line per selection
    if (paste && sel.ranges.length > 1) {
      if (lastCopied && lastCopied.text.join("\n") == inserted) {
        if (sel.ranges.length % lastCopied.text.length == 0) {
          multiPaste = [];
          for (var i = 0; i < lastCopied.text.length; i++)
            { multiPaste.push(doc.splitLines(lastCopied.text[i])); }
        }
      } else if (textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection) {
        multiPaste = map(textLines, function (l) { return [l]; });
      }
    }

    var updateInput = cm.curOp.updateInput;
    // Normal behavior is to insert the new text into every selection
    for (var i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
      var range = sel.ranges[i$1];
      var from = range.from(), to = range.to();
      if (range.empty()) {
        if (deleted && deleted > 0) // Handle deletion
          { from = Pos(from.line, from.ch - deleted); }
        else if (cm.state.overwrite && !paste) // Handle overwrite
          { to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)); }
        else if (paste && lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == textLines.join("\n"))
          { from = to = Pos(from.line, 0); }
      }
      var changeEvent = {from: from, to: to, text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                         origin: origin || (paste ? "paste" : cm.state.cutIncoming > recent ? "cut" : "+input")};
      makeChange(cm.doc, changeEvent);
      signalLater(cm, "inputRead", cm, changeEvent);
    }
    if (inserted && !paste)
      { triggerElectric(cm, inserted); }

    ensureCursorVisible(cm);
    if (cm.curOp.updateInput < 2) { cm.curOp.updateInput = updateInput; }
    cm.curOp.typing = true;
    cm.state.pasteIncoming = cm.state.cutIncoming = -1;
  }

  function handlePaste(e, cm) {
    var pasted = e.clipboardData && e.clipboardData.getData("Text");
    if (pasted) {
      e.preventDefault();
      if (!cm.isReadOnly() && !cm.options.disableInput)
        { runInOp(cm, function () { return applyTextInput(cm, pasted, 0, null, "paste"); }); }
      return true
    }
  }

  function triggerElectric(cm, inserted) {
    // When an 'electric' character is inserted, immediately trigger a reindent
    if (!cm.options.electricChars || !cm.options.smartIndent) { return }
    var sel = cm.doc.sel;

    for (var i = sel.ranges.length - 1; i >= 0; i--) {
      var range = sel.ranges[i];
      if (range.head.ch > 100 || (i && sel.ranges[i - 1].head.line == range.head.line)) { continue }
      var mode = cm.getModeAt(range.head);
      var indented = false;
      if (mode.electricChars) {
        for (var j = 0; j < mode.electricChars.length; j++)
          { if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
            indented = indentLine(cm, range.head.line, "smart");
            break
          } }
      } else if (mode.electricInput) {
        if (mode.electricInput.test(getLine(cm.doc, range.head.line).text.slice(0, range.head.ch)))
          { indented = indentLine(cm, range.head.line, "smart"); }
      }
      if (indented) { signalLater(cm, "electricInput", cm, range.head.line); }
    }
  }

  function copyableRanges(cm) {
    var text = [], ranges = [];
    for (var i = 0; i < cm.doc.sel.ranges.length; i++) {
      var line = cm.doc.sel.ranges[i].head.line;
      var lineRange = {anchor: Pos(line, 0), head: Pos(line + 1, 0)};
      ranges.push(lineRange);
      text.push(cm.getRange(lineRange.anchor, lineRange.head));
    }
    return {text: text, ranges: ranges}
  }

  function disableBrowserMagic(field, spellcheck, autocorrect, autocapitalize) {
    field.setAttribute("autocorrect", autocorrect ? "" : "off");
    field.setAttribute("autocapitalize", autocapitalize ? "" : "off");
    field.setAttribute("spellcheck", !!spellcheck);
  }

  function hiddenTextarea() {
    var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none");
    var div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
    // The textarea is kept positioned near the cursor to prevent the
    // fact that it'll be scrolled into view on input from scrolling
    // our fake cursor out of view. On webkit, when wrap=off, paste is
    // very slow. So make the area wide instead.
    if (webkit) { te.style.width = "1000px"; }
    else { te.setAttribute("wrap", "off"); }
    // If border: 0; -- iOS fails to open keyboard (issue #1287)
    if (ios) { te.style.border = "1px solid black"; }
    disableBrowserMagic(te);
    return div
  }

  // The publicly visible API. Note that methodOp(f) means
  // 'wrap f in an operation, performed on its `this` parameter'.

  // This is not the complete set of editor methods. Most of the
  // methods defined on the Doc type are also injected into
  // CodeMirror.prototype, for backwards compatibility and
  // convenience.

  function addEditorMethods(CodeMirror) {
    var optionHandlers = CodeMirror.optionHandlers;

    var helpers = CodeMirror.helpers = {};

    CodeMirror.prototype = {
      constructor: CodeMirror,
      focus: function(){window.focus(); this.display.input.focus();},

      setOption: function(option, value) {
        var options = this.options, old = options[option];
        if (options[option] == value && option != "mode") { return }
        options[option] = value;
        if (optionHandlers.hasOwnProperty(option))
          { operation(this, optionHandlers[option])(this, value, old); }
        signal(this, "optionChange", this, option);
      },

      getOption: function(option) {return this.options[option]},
      getDoc: function() {return this.doc},

      addKeyMap: function(map, bottom) {
        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map));
      },
      removeKeyMap: function(map) {
        var maps = this.state.keyMaps;
        for (var i = 0; i < maps.length; ++i)
          { if (maps[i] == map || maps[i].name == map) {
            maps.splice(i, 1);
            return true
          } }
      },

      addOverlay: methodOp(function(spec, options) {
        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
        if (mode.startState) { throw new Error("Overlays may not be stateful.") }
        insertSorted(this.state.overlays,
                     {mode: mode, modeSpec: spec, opaque: options && options.opaque,
                      priority: (options && options.priority) || 0},
                     function (overlay) { return overlay.priority; });
        this.state.modeGen++;
        regChange(this);
      }),
      removeOverlay: methodOp(function(spec) {
        var overlays = this.state.overlays;
        for (var i = 0; i < overlays.length; ++i) {
          var cur = overlays[i].modeSpec;
          if (cur == spec || typeof spec == "string" && cur.name == spec) {
            overlays.splice(i, 1);
            this.state.modeGen++;
            regChange(this);
            return
          }
        }
      }),

      indentLine: methodOp(function(n, dir, aggressive) {
        if (typeof dir != "string" && typeof dir != "number") {
          if (dir == null) { dir = this.options.smartIndent ? "smart" : "prev"; }
          else { dir = dir ? "add" : "subtract"; }
        }
        if (isLine(this.doc, n)) { indentLine(this, n, dir, aggressive); }
      }),
      indentSelection: methodOp(function(how) {
        var ranges = this.doc.sel.ranges, end = -1;
        for (var i = 0; i < ranges.length; i++) {
          var range = ranges[i];
          if (!range.empty()) {
            var from = range.from(), to = range.to();
            var start = Math.max(end, from.line);
            end = Math.min(this.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
            for (var j = start; j < end; ++j)
              { indentLine(this, j, how); }
            var newRanges = this.doc.sel.ranges;
            if (from.ch == 0 && ranges.length == newRanges.length && newRanges[i].from().ch > 0)
              { replaceOneSelection(this.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll); }
          } else if (range.head.line > end) {
            indentLine(this, range.head.line, how, true);
            end = range.head.line;
            if (i == this.doc.sel.primIndex) { ensureCursorVisible(this); }
          }
        }
      }),

      // Fetch the parser token for a given character. Useful for hacks
      // that want to inspect the mode state (say, for completion).
      getTokenAt: function(pos, precise) {
        return takeToken(this, pos, precise)
      },

      getLineTokens: function(line, precise) {
        return takeToken(this, Pos(line), precise, true)
      },

      getTokenTypeAt: function(pos) {
        pos = clipPos(this.doc, pos);
        var styles = getLineStyles(this, getLine(this.doc, pos.line));
        var before = 0, after = (styles.length - 1) / 2, ch = pos.ch;
        var type;
        if (ch == 0) { type = styles[2]; }
        else { for (;;) {
          var mid = (before + after) >> 1;
          if ((mid ? styles[mid * 2 - 1] : 0) >= ch) { after = mid; }
          else if (styles[mid * 2 + 1] < ch) { before = mid + 1; }
          else { type = styles[mid * 2 + 2]; break }
        } }
        var cut = type ? type.indexOf("overlay ") : -1;
        return cut < 0 ? type : cut == 0 ? null : type.slice(0, cut - 1)
      },

      getModeAt: function(pos) {
        var mode = this.doc.mode;
        if (!mode.innerMode) { return mode }
        return CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode
      },

      getHelper: function(pos, type) {
        return this.getHelpers(pos, type)[0]
      },

      getHelpers: function(pos, type) {
        var found = [];
        if (!helpers.hasOwnProperty(type)) { return found }
        var help = helpers[type], mode = this.getModeAt(pos);
        if (typeof mode[type] == "string") {
          if (help[mode[type]]) { found.push(help[mode[type]]); }
        } else if (mode[type]) {
          for (var i = 0; i < mode[type].length; i++) {
            var val = help[mode[type][i]];
            if (val) { found.push(val); }
          }
        } else if (mode.helperType && help[mode.helperType]) {
          found.push(help[mode.helperType]);
        } else if (help[mode.name]) {
          found.push(help[mode.name]);
        }
        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
          var cur = help._global[i$1];
          if (cur.pred(mode, this) && indexOf(found, cur.val) == -1)
            { found.push(cur.val); }
        }
        return found
      },

      getStateAfter: function(line, precise) {
        var doc = this.doc;
        line = clipLine(doc, line == null ? doc.first + doc.size - 1: line);
        return getContextBefore(this, line + 1, precise).state
      },

      cursorCoords: function(start, mode) {
        var pos, range = this.doc.sel.primary();
        if (start == null) { pos = range.head; }
        else if (typeof start == "object") { pos = clipPos(this.doc, start); }
        else { pos = start ? range.from() : range.to(); }
        return cursorCoords(this, pos, mode || "page")
      },

      charCoords: function(pos, mode) {
        return charCoords(this, clipPos(this.doc, pos), mode || "page")
      },

      coordsChar: function(coords, mode) {
        coords = fromCoordSystem(this, coords, mode || "page");
        return coordsChar(this, coords.left, coords.top)
      },

      lineAtHeight: function(height, mode) {
        height = fromCoordSystem(this, {top: height, left: 0}, mode || "page").top;
        return lineAtHeight(this.doc, height + this.display.viewOffset)
      },
      heightAtLine: function(line, mode, includeWidgets) {
        var end = false, lineObj;
        if (typeof line == "number") {
          var last = this.doc.first + this.doc.size - 1;
          if (line < this.doc.first) { line = this.doc.first; }
          else if (line > last) { line = last; end = true; }
          lineObj = getLine(this.doc, line);
        } else {
          lineObj = line;
        }
        return intoCoordSystem(this, lineObj, {top: 0, left: 0}, mode || "page", includeWidgets || end).top +
          (end ? this.doc.height - heightAtLine(lineObj) : 0)
      },

      defaultTextHeight: function() { return textHeight(this.display) },
      defaultCharWidth: function() { return charWidth(this.display) },

      getViewport: function() { return {from: this.display.viewFrom, to: this.display.viewTo}},

      addWidget: function(pos, node, scroll, vert, horiz) {
        var display = this.display;
        pos = cursorCoords(this, clipPos(this.doc, pos));
        var top = pos.bottom, left = pos.left;
        node.style.position = "absolute";
        node.setAttribute("cm-ignore-events", "true");
        this.display.input.setUneditable(node);
        display.sizer.appendChild(node);
        if (vert == "over") {
          top = pos.top;
        } else if (vert == "above" || vert == "near") {
          var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
          hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
          // Default to positioning above (if specified and possible); otherwise default to positioning below
          if ((vert == 'above' || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight)
            { top = pos.top - node.offsetHeight; }
          else if (pos.bottom + node.offsetHeight <= vspace)
            { top = pos.bottom; }
          if (left + node.offsetWidth > hspace)
            { left = hspace - node.offsetWidth; }
        }
        node.style.top = top + "px";
        node.style.left = node.style.right = "";
        if (horiz == "right") {
          left = display.sizer.clientWidth - node.offsetWidth;
          node.style.right = "0px";
        } else {
          if (horiz == "left") { left = 0; }
          else if (horiz == "middle") { left = (display.sizer.clientWidth - node.offsetWidth) / 2; }
          node.style.left = left + "px";
        }
        if (scroll)
          { scrollIntoView(this, {left: left, top: top, right: left + node.offsetWidth, bottom: top + node.offsetHeight}); }
      },

      triggerOnKeyDown: methodOp(onKeyDown),
      triggerOnKeyPress: methodOp(onKeyPress),
      triggerOnKeyUp: onKeyUp,
      triggerOnMouseDown: methodOp(onMouseDown),

      execCommand: function(cmd) {
        if (commands.hasOwnProperty(cmd))
          { return commands[cmd].call(null, this) }
      },

      triggerElectric: methodOp(function(text) { triggerElectric(this, text); }),

      findPosH: function(from, amount, unit, visually) {
        var dir = 1;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          cur = findPosH(this.doc, cur, dir, unit, visually);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveH: methodOp(function(dir, unit) {
        var this$1 = this;

        this.extendSelectionsBy(function (range) {
          if (this$1.display.shift || this$1.doc.extend || range.empty())
            { return findPosH(this$1.doc, range.head, dir, unit, this$1.options.rtlMoveVisually) }
          else
            { return dir < 0 ? range.from() : range.to() }
        }, sel_move);
      }),

      deleteH: methodOp(function(dir, unit) {
        var sel = this.doc.sel, doc = this.doc;
        if (sel.somethingSelected())
          { doc.replaceSelection("", null, "+delete"); }
        else
          { deleteNearSelection(this, function (range) {
            var other = findPosH(doc, range.head, dir, unit, false);
            return dir < 0 ? {from: other, to: range.head} : {from: range.head, to: other}
          }); }
      }),

      findPosV: function(from, amount, unit, goalColumn) {
        var dir = 1, x = goalColumn;
        if (amount < 0) { dir = -1; amount = -amount; }
        var cur = clipPos(this.doc, from);
        for (var i = 0; i < amount; ++i) {
          var coords = cursorCoords(this, cur, "div");
          if (x == null) { x = coords.left; }
          else { coords.left = x; }
          cur = findPosV(this, coords, dir, unit);
          if (cur.hitSide) { break }
        }
        return cur
      },

      moveV: methodOp(function(dir, unit) {
        var this$1 = this;

        var doc = this.doc, goals = [];
        var collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
        doc.extendSelectionsBy(function (range) {
          if (collapse)
            { return dir < 0 ? range.from() : range.to() }
          var headPos = cursorCoords(this$1, range.head, "div");
          if (range.goalColumn != null) { headPos.left = range.goalColumn; }
          goals.push(headPos.left);
          var pos = findPosV(this$1, headPos, dir, unit);
          if (unit == "page" && range == doc.sel.primary())
            { addToScrollTop(this$1, charCoords(this$1, pos, "div").top - headPos.top); }
          return pos
        }, sel_move);
        if (goals.length) { for (var i = 0; i < doc.sel.ranges.length; i++)
          { doc.sel.ranges[i].goalColumn = goals[i]; } }
      }),

      // Find the word at the given position (as returned by coordsChar).
      findWordAt: function(pos) {
        var doc = this.doc, line = getLine(doc, pos.line).text;
        var start = pos.ch, end = pos.ch;
        if (line) {
          var helper = this.getHelper(pos, "wordChars");
          if ((pos.sticky == "before" || end == line.length) && start) { --start; } else { ++end; }
          var startChar = line.charAt(start);
          var check = isWordChar(startChar, helper)
            ? function (ch) { return isWordChar(ch, helper); }
            : /\s/.test(startChar) ? function (ch) { return /\s/.test(ch); }
            : function (ch) { return (!/\s/.test(ch) && !isWordChar(ch)); };
          while (start > 0 && check(line.charAt(start - 1))) { --start; }
          while (end < line.length && check(line.charAt(end))) { ++end; }
        }
        return new Range(Pos(pos.line, start), Pos(pos.line, end))
      },

      toggleOverwrite: function(value) {
        if (value != null && value == this.state.overwrite) { return }
        if (this.state.overwrite = !this.state.overwrite)
          { addClass(this.display.cursorDiv, "CodeMirror-overwrite"); }
        else
          { rmClass(this.display.cursorDiv, "CodeMirror-overwrite"); }

        signal(this, "overwriteToggle", this, this.state.overwrite);
      },
      hasFocus: function() { return this.display.input.getField() == activeElt() },
      isReadOnly: function() { return !!(this.options.readOnly || this.doc.cantEdit) },

      scrollTo: methodOp(function (x, y) { scrollToCoords(this, x, y); }),
      getScrollInfo: function() {
        var scroller = this.display.scroller;
        return {left: scroller.scrollLeft, top: scroller.scrollTop,
                height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                clientHeight: displayHeight(this), clientWidth: displayWidth(this)}
      },

      scrollIntoView: methodOp(function(range, margin) {
        if (range == null) {
          range = {from: this.doc.sel.primary().head, to: null};
          if (margin == null) { margin = this.options.cursorScrollMargin; }
        } else if (typeof range == "number") {
          range = {from: Pos(range, 0), to: null};
        } else if (range.from == null) {
          range = {from: range, to: null};
        }
        if (!range.to) { range.to = range.from; }
        range.margin = margin || 0;

        if (range.from.line != null) {
          scrollToRange(this, range);
        } else {
          scrollToCoordsRange(this, range.from, range.to, range.margin);
        }
      }),

      setSize: methodOp(function(width, height) {
        var this$1 = this;

        var interpret = function (val) { return typeof val == "number" || /^\d+$/.test(String(val)) ? val + "px" : val; };
        if (width != null) { this.display.wrapper.style.width = interpret(width); }
        if (height != null) { this.display.wrapper.style.height = interpret(height); }
        if (this.options.lineWrapping) { clearLineMeasurementCache(this); }
        var lineNo = this.display.viewFrom;
        this.doc.iter(lineNo, this.display.viewTo, function (line) {
          if (line.widgets) { for (var i = 0; i < line.widgets.length; i++)
            { if (line.widgets[i].noHScroll) { regLineChange(this$1, lineNo, "widget"); break } } }
          ++lineNo;
        });
        this.curOp.forceUpdate = true;
        signal(this, "refresh", this);
      }),

      operation: function(f){return runInOp(this, f)},
      startOperation: function(){return startOperation(this)},
      endOperation: function(){return endOperation(this)},

      refresh: methodOp(function() {
        var oldHeight = this.display.cachedTextHeight;
        regChange(this);
        this.curOp.forceUpdate = true;
        clearCaches(this);
        scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop);
        updateGutterSpace(this.display);
        if (oldHeight == null || Math.abs(oldHeight - textHeight(this.display)) > .5 || this.options.lineWrapping)
          { estimateLineHeights(this); }
        signal(this, "refresh", this);
      }),

      swapDoc: methodOp(function(doc) {
        var old = this.doc;
        old.cm = null;
        // Cancel the current text selection if any (#5821)
        if (this.state.selectingText) { this.state.selectingText(); }
        attachDoc(this, doc);
        clearCaches(this);
        this.display.input.reset();
        scrollToCoords(this, doc.scrollLeft, doc.scrollTop);
        this.curOp.forceScroll = true;
        signalLater(this, "swapDoc", this, old);
        return old
      }),

      phrase: function(phraseText) {
        var phrases = this.options.phrases;
        return phrases && Object.prototype.hasOwnProperty.call(phrases, phraseText) ? phrases[phraseText] : phraseText
      },

      getInputField: function(){return this.display.input.getField()},
      getWrapperElement: function(){return this.display.wrapper},
      getScrollerElement: function(){return this.display.scroller},
      getGutterElement: function(){return this.display.gutters}
    };
    eventMixin(CodeMirror);

    CodeMirror.registerHelper = function(type, name, value) {
      if (!helpers.hasOwnProperty(type)) { helpers[type] = CodeMirror[type] = {_global: []}; }
      helpers[type][name] = value;
    };
    CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
      CodeMirror.registerHelper(type, name, value);
      helpers[type]._global.push({pred: predicate, val: value});
    };
  }

  // Used for horizontal relative motion. Dir is -1 or 1 (left or
  // right), unit can be "codepoint", "char", "column" (like char, but
  // doesn't cross line boundaries), "word" (across next word), or
  // "group" (to the start of next group of word or
  // non-word-non-whitespace chars). The visually param controls
  // whether, in right-to-left text, direction 1 means to move towards
  // the next index in the string, or towards the character to the right
  // of the current position. The resulting position will have a
  // hitSide=true property if it reached the end of the document.
  function findPosH(doc, pos, dir, unit, visually) {
    var oldPos = pos;
    var origDir = dir;
    var lineObj = getLine(doc, pos.line);
    var lineDir = visually && doc.direction == "rtl" ? -dir : dir;
    function findNextLine() {
      var l = pos.line + lineDir;
      if (l < doc.first || l >= doc.first + doc.size) { return false }
      pos = new Pos(l, pos.ch, pos.sticky);
      return lineObj = getLine(doc, l)
    }
    function moveOnce(boundToLine) {
      var next;
      if (unit == "codepoint") {
        var ch = lineObj.text.charCodeAt(pos.ch + (dir > 0 ? 0 : -1));
        if (isNaN(ch)) {
          next = null;
        } else {
          var astral = dir > 0 ? ch >= 0xD800 && ch < 0xDC00 : ch >= 0xDC00 && ch < 0xDFFF;
          next = new Pos(pos.line, Math.max(0, Math.min(lineObj.text.length, pos.ch + dir * (astral ? 2 : 1))), -dir);
        }
      } else if (visually) {
        next = moveVisually(doc.cm, lineObj, pos, dir);
      } else {
        next = moveLogically(lineObj, pos, dir);
      }
      if (next == null) {
        if (!boundToLine && findNextLine())
          { pos = endOfLine(visually, doc.cm, lineObj, pos.line, lineDir); }
        else
          { return false }
      } else {
        pos = next;
      }
      return true
    }

    if (unit == "char" || unit == "codepoint") {
      moveOnce();
    } else if (unit == "column") {
      moveOnce(true);
    } else if (unit == "word" || unit == "group") {
      var sawType = null, group = unit == "group";
      var helper = doc.cm && doc.cm.getHelper(pos, "wordChars");
      for (var first = true;; first = false) {
        if (dir < 0 && !moveOnce(!first)) { break }
        var cur = lineObj.text.charAt(pos.ch) || "\n";
        var type = isWordChar(cur, helper) ? "w"
          : group && cur == "\n" ? "n"
          : !group || /\s/.test(cur) ? null
          : "p";
        if (group && !first && !type) { type = "s"; }
        if (sawType && sawType != type) {
          if (dir < 0) {dir = 1; moveOnce(); pos.sticky = "after";}
          break
        }

        if (type) { sawType = type; }
        if (dir > 0 && !moveOnce(!first)) { break }
      }
    }
    var result = skipAtomic(doc, pos, oldPos, origDir, true);
    if (equalCursorPos(oldPos, result)) { result.hitSide = true; }
    return result
  }

  // For relative vertical movement. Dir may be -1 or 1. Unit can be
  // "page" or "line". The resulting position will have a hitSide=true
  // property if it reached the end of the document.
  function findPosV(cm, pos, dir, unit) {
    var doc = cm.doc, x = pos.left, y;
    if (unit == "page") {
      var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight);
      var moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
      y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount;

    } else if (unit == "line") {
      y = dir > 0 ? pos.bottom + 3 : pos.top - 3;
    }
    var target;
    for (;;) {
      target = coordsChar(cm, x, y);
      if (!target.outside) { break }
      if (dir < 0 ? y <= 0 : y >= doc.height) { target.hitSide = true; break }
      y += dir * 5;
    }
    return target
  }

  // CONTENTEDITABLE INPUT STYLE

  var ContentEditableInput = function(cm) {
    this.cm = cm;
    this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null;
    this.polling = new Delayed();
    this.composing = null;
    this.gracePeriod = false;
    this.readDOMTimeout = null;
  };

  ContentEditableInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = input.cm;
    var div = input.div = display.lineDiv;
    disableBrowserMagic(div, cm.options.spellcheck, cm.options.autocorrect, cm.options.autocapitalize);

    function belongsToInput(e) {
      for (var t = e.target; t; t = t.parentNode) {
        if (t == div) { return true }
        if (/\bCodeMirror-(?:line)?widget\b/.test(t.className)) { break }
      }
      return false
    }

    on(div, "paste", function (e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }
      // IE doesn't fire input events, so we schedule a read for the pasted content in this way
      if (ie_version <= 11) { setTimeout(operation(cm, function () { return this$1.updateFromDOM(); }), 20); }
    });

    on(div, "compositionstart", function (e) {
      this$1.composing = {data: e.data, done: false};
    });
    on(div, "compositionupdate", function (e) {
      if (!this$1.composing) { this$1.composing = {data: e.data, done: false}; }
    });
    on(div, "compositionend", function (e) {
      if (this$1.composing) {
        if (e.data != this$1.composing.data) { this$1.readFromDOMSoon(); }
        this$1.composing.done = true;
      }
    });

    on(div, "touchstart", function () { return input.forceCompositionEnd(); });

    on(div, "input", function () {
      if (!this$1.composing) { this$1.readFromDOMSoon(); }
    });

    function onCopyCut(e) {
      if (!belongsToInput(e) || signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
        if (e.type == "cut") { cm.replaceSelection("", null, "cut"); }
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.operation(function () {
            cm.setSelections(ranges.ranges, 0, sel_dontScroll);
            cm.replaceSelection("", null, "cut");
          });
        }
      }
      if (e.clipboardData) {
        e.clipboardData.clearData();
        var content = lastCopied.text.join("\n");
        // iOS exposes the clipboard API, but seems to discard content inserted into it
        e.clipboardData.setData("Text", content);
        if (e.clipboardData.getData("Text") == content) {
          e.preventDefault();
          return
        }
      }
      // Old-fashioned briefly-focus-a-textarea hack
      var kludge = hiddenTextarea(), te = kludge.firstChild;
      cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild);
      te.value = lastCopied.text.join("\n");
      var hadFocus = document.activeElement;
      selectInput(te);
      setTimeout(function () {
        cm.display.lineSpace.removeChild(kludge);
        hadFocus.focus();
        if (hadFocus == div) { input.showPrimarySelection(); }
      }, 50);
    }
    on(div, "copy", onCopyCut);
    on(div, "cut", onCopyCut);
  };

  ContentEditableInput.prototype.screenReaderLabelChanged = function (label) {
    // Label for screenreaders, accessibility
    if(label) {
      this.div.setAttribute('aria-label', label);
    } else {
      this.div.removeAttribute('aria-label');
    }
  };

  ContentEditableInput.prototype.prepareSelection = function () {
    var result = prepareSelection(this.cm, false);
    result.focus = document.activeElement == this.div;
    return result
  };

  ContentEditableInput.prototype.showSelection = function (info, takeFocus) {
    if (!info || !this.cm.display.view.length) { return }
    if (info.focus || takeFocus) { this.showPrimarySelection(); }
    this.showMultipleSelections(info);
  };

  ContentEditableInput.prototype.getSelection = function () {
    return this.cm.display.wrapper.ownerDocument.getSelection()
  };

  ContentEditableInput.prototype.showPrimarySelection = function () {
    var sel = this.getSelection(), cm = this.cm, prim = cm.doc.sel.primary();
    var from = prim.from(), to = prim.to();

    if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) {
      sel.removeAllRanges();
      return
    }

    var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (curAnchor && !curAnchor.bad && curFocus && !curFocus.bad &&
        cmp(minPos(curAnchor, curFocus), from) == 0 &&
        cmp(maxPos(curAnchor, curFocus), to) == 0)
      { return }

    var view = cm.display.view;
    var start = (from.line >= cm.display.viewFrom && posToDOM(cm, from)) ||
        {node: view[0].measure.map[2], offset: 0};
    var end = to.line < cm.display.viewTo && posToDOM(cm, to);
    if (!end) {
      var measure = view[view.length - 1].measure;
      var map = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
      end = {node: map[map.length - 1], offset: map[map.length - 2] - map[map.length - 3]};
    }

    if (!start || !end) {
      sel.removeAllRanges();
      return
    }

    var old = sel.rangeCount && sel.getRangeAt(0), rng;
    try { rng = range(start.node, start.offset, end.offset, end.node); }
    catch(e) {} // Our model of the DOM might be outdated, in which case the range we try to set can be impossible
    if (rng) {
      if (!gecko && cm.state.focused) {
        sel.collapse(start.node, start.offset);
        if (!rng.collapsed) {
          sel.removeAllRanges();
          sel.addRange(rng);
        }
      } else {
        sel.removeAllRanges();
        sel.addRange(rng);
      }
      if (old && sel.anchorNode == null) { sel.addRange(old); }
      else if (gecko) { this.startGracePeriod(); }
    }
    this.rememberSelection();
  };

  ContentEditableInput.prototype.startGracePeriod = function () {
      var this$1 = this;

    clearTimeout(this.gracePeriod);
    this.gracePeriod = setTimeout(function () {
      this$1.gracePeriod = false;
      if (this$1.selectionChanged())
        { this$1.cm.operation(function () { return this$1.cm.curOp.selectionChanged = true; }); }
    }, 20);
  };

  ContentEditableInput.prototype.showMultipleSelections = function (info) {
    removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors);
    removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection);
  };

  ContentEditableInput.prototype.rememberSelection = function () {
    var sel = this.getSelection();
    this.lastAnchorNode = sel.anchorNode; this.lastAnchorOffset = sel.anchorOffset;
    this.lastFocusNode = sel.focusNode; this.lastFocusOffset = sel.focusOffset;
  };

  ContentEditableInput.prototype.selectionInEditor = function () {
    var sel = this.getSelection();
    if (!sel.rangeCount) { return false }
    var node = sel.getRangeAt(0).commonAncestorContainer;
    return contains(this.div, node)
  };

  ContentEditableInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor") {
      if (!this.selectionInEditor() || document.activeElement != this.div)
        { this.showSelection(this.prepareSelection(), true); }
      this.div.focus();
    }
  };
  ContentEditableInput.prototype.blur = function () { this.div.blur(); };
  ContentEditableInput.prototype.getField = function () { return this.div };

  ContentEditableInput.prototype.supportsTouch = function () { return true };

  ContentEditableInput.prototype.receivedFocus = function () {
    var input = this;
    if (this.selectionInEditor())
      { this.pollSelection(); }
    else
      { runInOp(this.cm, function () { return input.cm.curOp.selectionChanged = true; }); }

    function poll() {
      if (input.cm.state.focused) {
        input.pollSelection();
        input.polling.set(input.cm.options.pollInterval, poll);
      }
    }
    this.polling.set(this.cm.options.pollInterval, poll);
  };

  ContentEditableInput.prototype.selectionChanged = function () {
    var sel = this.getSelection();
    return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset ||
      sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
  };

  ContentEditableInput.prototype.pollSelection = function () {
    if (this.readDOMTimeout != null || this.gracePeriod || !this.selectionChanged()) { return }
    var sel = this.getSelection(), cm = this.cm;
    // On Android Chrome (version 56, at least), backspacing into an
    // uneditable block element will put the cursor in that element,
    // and then, because it's not editable, hide the virtual keyboard.
    // Because Android doesn't allow us to actually detect backspace
    // presses in a sane way, this code checks for when that happens
    // and simulates a backspace press in this case.
    if (android && chrome && this.cm.display.gutterSpecs.length && isInGutter(sel.anchorNode)) {
      this.cm.triggerOnKeyDown({type: "keydown", keyCode: 8, preventDefault: Math.abs});
      this.blur();
      this.focus();
      return
    }
    if (this.composing) { return }
    this.rememberSelection();
    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset);
    var head = domToPos(cm, sel.focusNode, sel.focusOffset);
    if (anchor && head) { runInOp(cm, function () {
      setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll);
      if (anchor.bad || head.bad) { cm.curOp.selectionChanged = true; }
    }); }
  };

  ContentEditableInput.prototype.pollContent = function () {
    if (this.readDOMTimeout != null) {
      clearTimeout(this.readDOMTimeout);
      this.readDOMTimeout = null;
    }

    var cm = this.cm, display = cm.display, sel = cm.doc.sel.primary();
    var from = sel.from(), to = sel.to();
    if (from.ch == 0 && from.line > cm.firstLine())
      { from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length); }
    if (to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine())
      { to = Pos(to.line + 1, 0); }
    if (from.line < display.viewFrom || to.line > display.viewTo - 1) { return false }

    var fromIndex, fromLine, fromNode;
    if (from.line == display.viewFrom || (fromIndex = findViewIndex(cm, from.line)) == 0) {
      fromLine = lineNo(display.view[0].line);
      fromNode = display.view[0].node;
    } else {
      fromLine = lineNo(display.view[fromIndex].line);
      fromNode = display.view[fromIndex - 1].node.nextSibling;
    }
    var toIndex = findViewIndex(cm, to.line);
    var toLine, toNode;
    if (toIndex == display.view.length - 1) {
      toLine = display.viewTo - 1;
      toNode = display.lineDiv.lastChild;
    } else {
      toLine = lineNo(display.view[toIndex + 1].line) - 1;
      toNode = display.view[toIndex + 1].node.previousSibling;
    }

    if (!fromNode) { return false }
    var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine));
    var oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length));
    while (newText.length > 1 && oldText.length > 1) {
      if (lst(newText) == lst(oldText)) { newText.pop(); oldText.pop(); toLine--; }
      else if (newText[0] == oldText[0]) { newText.shift(); oldText.shift(); fromLine++; }
      else { break }
    }

    var cutFront = 0, cutEnd = 0;
    var newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length);
    while (cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront))
      { ++cutFront; }
    var newBot = lst(newText), oldBot = lst(oldText);
    var maxCutEnd = Math.min(newBot.length - (newText.length == 1 ? cutFront : 0),
                             oldBot.length - (oldText.length == 1 ? cutFront : 0));
    while (cutEnd < maxCutEnd &&
           newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1))
      { ++cutEnd; }
    // Try to move start of change to start of selection if ambiguous
    if (newText.length == 1 && oldText.length == 1 && fromLine == from.line) {
      while (cutFront && cutFront > from.ch &&
             newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1)) {
        cutFront--;
        cutEnd++;
      }
    }

    newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, "");
    newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");

    var chFrom = Pos(fromLine, cutFront);
    var chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
    if (newText.length > 1 || newText[0] || cmp(chFrom, chTo)) {
      replaceRange(cm.doc, newText, chFrom, chTo, "+input");
      return true
    }
  };

  ContentEditableInput.prototype.ensurePolled = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.reset = function () {
    this.forceCompositionEnd();
  };
  ContentEditableInput.prototype.forceCompositionEnd = function () {
    if (!this.composing) { return }
    clearTimeout(this.readDOMTimeout);
    this.composing = null;
    this.updateFromDOM();
    this.div.blur();
    this.div.focus();
  };
  ContentEditableInput.prototype.readFromDOMSoon = function () {
      var this$1 = this;

    if (this.readDOMTimeout != null) { return }
    this.readDOMTimeout = setTimeout(function () {
      this$1.readDOMTimeout = null;
      if (this$1.composing) {
        if (this$1.composing.done) { this$1.composing = null; }
        else { return }
      }
      this$1.updateFromDOM();
    }, 80);
  };

  ContentEditableInput.prototype.updateFromDOM = function () {
      var this$1 = this;

    if (this.cm.isReadOnly() || !this.pollContent())
      { runInOp(this.cm, function () { return regChange(this$1.cm); }); }
  };

  ContentEditableInput.prototype.setUneditable = function (node) {
    node.contentEditable = "false";
  };

  ContentEditableInput.prototype.onKeyPress = function (e) {
    if (e.charCode == 0 || this.composing) { return }
    e.preventDefault();
    if (!this.cm.isReadOnly())
      { operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(e.charCode == null ? e.keyCode : e.charCode), 0); }
  };

  ContentEditableInput.prototype.readOnlyChanged = function (val) {
    this.div.contentEditable = String(val != "nocursor");
  };

  ContentEditableInput.prototype.onContextMenu = function () {};
  ContentEditableInput.prototype.resetPosition = function () {};

  ContentEditableInput.prototype.needsContentAttribute = true;

  function posToDOM(cm, pos) {
    var view = findViewForLine(cm, pos.line);
    if (!view || view.hidden) { return null }
    var line = getLine(cm.doc, pos.line);
    var info = mapFromLineView(view, line, pos.line);

    var order = getOrder(line, cm.doc.direction), side = "left";
    if (order) {
      var partPos = getBidiPartAt(order, pos.ch);
      side = partPos % 2 ? "right" : "left";
    }
    var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
    result.offset = result.collapse == "right" ? result.end : result.start;
    return result
  }

  function isInGutter(node) {
    for (var scan = node; scan; scan = scan.parentNode)
      { if (/CodeMirror-gutter-wrapper/.test(scan.className)) { return true } }
    return false
  }

  function badPos(pos, bad) { if (bad) { pos.bad = true; } return pos }

  function domTextBetween(cm, from, to, fromLine, toLine) {
    var text = "", closing = false, lineSep = cm.doc.lineSeparator(), extraLinebreak = false;
    function recognizeMarker(id) { return function (marker) { return marker.id == id; } }
    function close() {
      if (closing) {
        text += lineSep;
        if (extraLinebreak) { text += lineSep; }
        closing = extraLinebreak = false;
      }
    }
    function addText(str) {
      if (str) {
        close();
        text += str;
      }
    }
    function walk(node) {
      if (node.nodeType == 1) {
        var cmText = node.getAttribute("cm-text");
        if (cmText) {
          addText(cmText);
          return
        }
        var markerID = node.getAttribute("cm-marker"), range;
        if (markerID) {
          var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
          if (found.length && (range = found[0].find(0)))
            { addText(getBetween(cm.doc, range.from, range.to).join(lineSep)); }
          return
        }
        if (node.getAttribute("contenteditable") == "false") { return }
        var isBlock = /^(pre|div|p|li|table|br)$/i.test(node.nodeName);
        if (!/^br$/i.test(node.nodeName) && node.textContent.length == 0) { return }

        if (isBlock) { close(); }
        for (var i = 0; i < node.childNodes.length; i++)
          { walk(node.childNodes[i]); }

        if (/^(pre|p)$/i.test(node.nodeName)) { extraLinebreak = true; }
        if (isBlock) { closing = true; }
      } else if (node.nodeType == 3) {
        addText(node.nodeValue.replace(/\u200b/g, "").replace(/\u00a0/g, " "));
      }
    }
    for (;;) {
      walk(from);
      if (from == to) { break }
      from = from.nextSibling;
      extraLinebreak = false;
    }
    return text
  }

  function domToPos(cm, node, offset) {
    var lineNode;
    if (node == cm.display.lineDiv) {
      lineNode = cm.display.lineDiv.childNodes[offset];
      if (!lineNode) { return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), true) }
      node = null; offset = 0;
    } else {
      for (lineNode = node;; lineNode = lineNode.parentNode) {
        if (!lineNode || lineNode == cm.display.lineDiv) { return null }
        if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) { break }
      }
    }
    for (var i = 0; i < cm.display.view.length; i++) {
      var lineView = cm.display.view[i];
      if (lineView.node == lineNode)
        { return locateNodeInLineView(lineView, node, offset) }
    }
  }

  function locateNodeInLineView(lineView, node, offset) {
    var wrapper = lineView.text.firstChild, bad = false;
    if (!node || !contains(wrapper, node)) { return badPos(Pos(lineNo(lineView.line), 0), true) }
    if (node == wrapper) {
      bad = true;
      node = wrapper.childNodes[offset];
      offset = 0;
      if (!node) {
        var line = lineView.rest ? lst(lineView.rest) : lineView.line;
        return badPos(Pos(lineNo(line), line.text.length), bad)
      }
    }

    var textNode = node.nodeType == 3 ? node : null, topNode = node;
    if (!textNode && node.childNodes.length == 1 && node.firstChild.nodeType == 3) {
      textNode = node.firstChild;
      if (offset) { offset = textNode.nodeValue.length; }
    }
    while (topNode.parentNode != wrapper) { topNode = topNode.parentNode; }
    var measure = lineView.measure, maps = measure.maps;

    function find(textNode, topNode, offset) {
      for (var i = -1; i < (maps ? maps.length : 0); i++) {
        var map = i < 0 ? measure.map : maps[i];
        for (var j = 0; j < map.length; j += 3) {
          var curNode = map[j + 2];
          if (curNode == textNode || curNode == topNode) {
            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]);
            var ch = map[j] + offset;
            if (offset < 0 || curNode != textNode) { ch = map[j + (offset ? 1 : 0)]; }
            return Pos(line, ch)
          }
        }
      }
    }
    var found = find(textNode, topNode, offset);
    if (found) { return badPos(found, bad) }

    // FIXME this is all really shaky. might handle the few cases it needs to handle, but likely to cause problems
    for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
      found = find(after, after.firstChild, 0);
      if (found)
        { return badPos(Pos(found.line, found.ch - dist), bad) }
      else
        { dist += after.textContent.length; }
    }
    for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
      found = find(before, before.firstChild, -1);
      if (found)
        { return badPos(Pos(found.line, found.ch + dist$1), bad) }
      else
        { dist$1 += before.textContent.length; }
    }
  }

  // TEXTAREA INPUT STYLE

  var TextareaInput = function(cm) {
    this.cm = cm;
    // See input.poll and input.reset
    this.prevInput = "";

    // Flag that indicates whether we expect input to appear real soon
    // now (after some event like 'keypress' or 'input') and are
    // polling intensively.
    this.pollingFast = false;
    // Self-resetting timeout for the poller
    this.polling = new Delayed();
    // Used to work around IE issue with selection being forgotten when focus moves away from textarea
    this.hasSelection = false;
    this.composing = null;
  };

  TextareaInput.prototype.init = function (display) {
      var this$1 = this;

    var input = this, cm = this.cm;
    this.createField(display);
    var te = this.textarea;

    display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild);

    // Needed to hide big blue blinking cursor on Mobile Safari (doesn't seem to work in iOS 8 anymore)
    if (ios) { te.style.width = "0px"; }

    on(te, "input", function () {
      if (ie && ie_version >= 9 && this$1.hasSelection) { this$1.hasSelection = null; }
      input.poll();
    });

    on(te, "paste", function (e) {
      if (signalDOMEvent(cm, e) || handlePaste(e, cm)) { return }

      cm.state.pasteIncoming = +new Date;
      input.fastPoll();
    });

    function prepareCopyCut(e) {
      if (signalDOMEvent(cm, e)) { return }
      if (cm.somethingSelected()) {
        setLastCopied({lineWise: false, text: cm.getSelections()});
      } else if (!cm.options.lineWiseCopyCut) {
        return
      } else {
        var ranges = copyableRanges(cm);
        setLastCopied({lineWise: true, text: ranges.text});
        if (e.type == "cut") {
          cm.setSelections(ranges.ranges, null, sel_dontScroll);
        } else {
          input.prevInput = "";
          te.value = ranges.text.join("\n");
          selectInput(te);
        }
      }
      if (e.type == "cut") { cm.state.cutIncoming = +new Date; }
    }
    on(te, "cut", prepareCopyCut);
    on(te, "copy", prepareCopyCut);

    on(display.scroller, "paste", function (e) {
      if (eventInWidget(display, e) || signalDOMEvent(cm, e)) { return }
      if (!te.dispatchEvent) {
        cm.state.pasteIncoming = +new Date;
        input.focus();
        return
      }

      // Pass the `paste` event to the textarea so it's handled by its event listener.
      var event = new Event("paste");
      event.clipboardData = e.clipboardData;
      te.dispatchEvent(event);
    });

    // Prevent normal selection in the editor (we handle our own)
    on(display.lineSpace, "selectstart", function (e) {
      if (!eventInWidget(display, e)) { e_preventDefault(e); }
    });

    on(te, "compositionstart", function () {
      var start = cm.getCursor("from");
      if (input.composing) { input.composing.range.clear(); }
      input.composing = {
        start: start,
        range: cm.markText(start, cm.getCursor("to"), {className: "CodeMirror-composing"})
      };
    });
    on(te, "compositionend", function () {
      if (input.composing) {
        input.poll();
        input.composing.range.clear();
        input.composing = null;
      }
    });
  };

  TextareaInput.prototype.createField = function (_display) {
    // Wraps and hides input textarea
    this.wrapper = hiddenTextarea();
    // The semihidden textarea that is focused when the editor is
    // focused, and receives input.
    this.textarea = this.wrapper.firstChild;
  };

  TextareaInput.prototype.screenReaderLabelChanged = function (label) {
    // Label for screenreaders, accessibility
    if(label) {
      this.textarea.setAttribute('aria-label', label);
    } else {
      this.textarea.removeAttribute('aria-label');
    }
  };

  TextareaInput.prototype.prepareSelection = function () {
    // Redraw the selection and/or cursor
    var cm = this.cm, display = cm.display, doc = cm.doc;
    var result = prepareSelection(cm);

    // Move the hidden textarea near the cursor to prevent scrolling artifacts
    if (cm.options.moveInputWithCursor) {
      var headPos = cursorCoords(cm, doc.sel.primary().head, "div");
      var wrapOff = display.wrapper.getBoundingClientRect(), lineOff = display.lineDiv.getBoundingClientRect();
      result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10,
                                          headPos.top + lineOff.top - wrapOff.top));
      result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10,
                                           headPos.left + lineOff.left - wrapOff.left));
    }

    return result
  };

  TextareaInput.prototype.showSelection = function (drawn) {
    var cm = this.cm, display = cm.display;
    removeChildrenAndAdd(display.cursorDiv, drawn.cursors);
    removeChildrenAndAdd(display.selectionDiv, drawn.selection);
    if (drawn.teTop != null) {
      this.wrapper.style.top = drawn.teTop + "px";
      this.wrapper.style.left = drawn.teLeft + "px";
    }
  };

  // Reset the input to correspond to the selection (or to be empty,
  // when not typing and nothing is selected)
  TextareaInput.prototype.reset = function (typing) {
    if (this.contextMenuPending || this.composing) { return }
    var cm = this.cm;
    if (cm.somethingSelected()) {
      this.prevInput = "";
      var content = cm.getSelection();
      this.textarea.value = content;
      if (cm.state.focused) { selectInput(this.textarea); }
      if (ie && ie_version >= 9) { this.hasSelection = content; }
    } else if (!typing) {
      this.prevInput = this.textarea.value = "";
      if (ie && ie_version >= 9) { this.hasSelection = null; }
    }
  };

  TextareaInput.prototype.getField = function () { return this.textarea };

  TextareaInput.prototype.supportsTouch = function () { return false };

  TextareaInput.prototype.focus = function () {
    if (this.cm.options.readOnly != "nocursor" && (!mobile || activeElt() != this.textarea)) {
      try { this.textarea.focus(); }
      catch (e) {} // IE8 will throw if the textarea is display: none or not in DOM
    }
  };

  TextareaInput.prototype.blur = function () { this.textarea.blur(); };

  TextareaInput.prototype.resetPosition = function () {
    this.wrapper.style.top = this.wrapper.style.left = 0;
  };

  TextareaInput.prototype.receivedFocus = function () { this.slowPoll(); };

  // Poll for input changes, using the normal rate of polling. This
  // runs as long as the editor is focused.
  TextareaInput.prototype.slowPoll = function () {
      var this$1 = this;

    if (this.pollingFast) { return }
    this.polling.set(this.cm.options.pollInterval, function () {
      this$1.poll();
      if (this$1.cm.state.focused) { this$1.slowPoll(); }
    });
  };

  // When an event has just come in that is likely to add or change
  // something in the input textarea, we poll faster, to ensure that
  // the change appears on the screen quickly.
  TextareaInput.prototype.fastPoll = function () {
    var missed = false, input = this;
    input.pollingFast = true;
    function p() {
      var changed = input.poll();
      if (!changed && !missed) {missed = true; input.polling.set(60, p);}
      else {input.pollingFast = false; input.slowPoll();}
    }
    input.polling.set(20, p);
  };

  // Read input from the textarea, and update the document to match.
  // When something is selected, it is present in the textarea, and
  // selected (unless it is huge, in which case a placeholder is
  // used). When nothing is selected, the cursor sits after previously
  // seen text (can be empty), which is stored in prevInput (we must
  // not reset the textarea when typing, because that breaks IME).
  TextareaInput.prototype.poll = function () {
      var this$1 = this;

    var cm = this.cm, input = this.textarea, prevInput = this.prevInput;
    // Since this is called a *lot*, try to bail out as cheaply as
    // possible when it is clear that nothing happened. hasSelection
    // will be the case when there is a lot of text in the textarea,
    // in which case reading its value would be expensive.
    if (this.contextMenuPending || !cm.state.focused ||
        (hasSelection(input) && !prevInput && !this.composing) ||
        cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq)
      { return false }

    var text = input.value;
    // If nothing changed, bail.
    if (text == prevInput && !cm.somethingSelected()) { return false }
    // Work around nonsensical selection resetting in IE9/10, and
    // inexplicable appearance of private area unicode characters on
    // some key combos in Mac (#2689).
    if (ie && ie_version >= 9 && this.hasSelection === text ||
        mac && /[\uf700-\uf7ff]/.test(text)) {
      cm.display.input.reset();
      return false
    }

    if (cm.doc.sel == cm.display.selForContextMenu) {
      var first = text.charCodeAt(0);
      if (first == 0x200b && !prevInput) { prevInput = "\u200b"; }
      if (first == 0x21da) { this.reset(); return this.cm.execCommand("undo") }
    }
    // Find the part of the input that is actually new
    var same = 0, l = Math.min(prevInput.length, text.length);
    while (same < l && prevInput.charCodeAt(same) == text.charCodeAt(same)) { ++same; }

    runInOp(cm, function () {
      applyTextInput(cm, text.slice(same), prevInput.length - same,
                     null, this$1.composing ? "*compose" : null);

      // Don't leave long text in the textarea, since it makes further polling slow
      if (text.length > 1000 || text.indexOf("\n") > -1) { input.value = this$1.prevInput = ""; }
      else { this$1.prevInput = text; }

      if (this$1.composing) {
        this$1.composing.range.clear();
        this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"),
                                           {className: "CodeMirror-composing"});
      }
    });
    return true
  };

  TextareaInput.prototype.ensurePolled = function () {
    if (this.pollingFast && this.poll()) { this.pollingFast = false; }
  };

  TextareaInput.prototype.onKeyPress = function () {
    if (ie && ie_version >= 9) { this.hasSelection = null; }
    this.fastPoll();
  };

  TextareaInput.prototype.onContextMenu = function (e) {
    var input = this, cm = input.cm, display = cm.display, te = input.textarea;
    if (input.contextMenuPending) { input.contextMenuPending(); }
    var pos = posFromMouse(cm, e), scrollPos = display.scroller.scrollTop;
    if (!pos || presto) { return } // Opera is difficult.

    // Reset the current text selection only if the click is done outside of the selection
    // and 'resetSelectionOnContextMenu' option is true.
    var reset = cm.options.resetSelectionOnContextMenu;
    if (reset && cm.doc.sel.contains(pos) == -1)
      { operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll); }

    var oldCSS = te.style.cssText, oldWrapperCSS = input.wrapper.style.cssText;
    var wrapperBox = input.wrapper.offsetParent.getBoundingClientRect();
    input.wrapper.style.cssText = "position: static";
    te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
    var oldScrollY;
    if (webkit) { oldScrollY = window.scrollY; } // Work around Chrome issue (#2712)
    display.input.focus();
    if (webkit) { window.scrollTo(null, oldScrollY); }
    display.input.reset();
    // Adds "Select all" to context menu in FF
    if (!cm.somethingSelected()) { te.value = input.prevInput = " "; }
    input.contextMenuPending = rehide;
    display.selForContextMenu = cm.doc.sel;
    clearTimeout(display.detectingSelectAll);

    // Select-all will be greyed out if there's nothing to select, so
    // this adds a zero-width space so that we can later check whether
    // it got selected.
    function prepareSelectAllHack() {
      if (te.selectionStart != null) {
        var selected = cm.somethingSelected();
        var extval = "\u200b" + (selected ? te.value : "");
        te.value = "\u21da"; // Used to catch context-menu undo
        te.value = extval;
        input.prevInput = selected ? "" : "\u200b";
        te.selectionStart = 1; te.selectionEnd = extval.length;
        // Re-set this, in case some other handler touched the
        // selection in the meantime.
        display.selForContextMenu = cm.doc.sel;
      }
    }
    function rehide() {
      if (input.contextMenuPending != rehide) { return }
      input.contextMenuPending = false;
      input.wrapper.style.cssText = oldWrapperCSS;
      te.style.cssText = oldCSS;
      if (ie && ie_version < 9) { display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos); }

      // Try to detect the user choosing select-all
      if (te.selectionStart != null) {
        if (!ie || (ie && ie_version < 9)) { prepareSelectAllHack(); }
        var i = 0, poll = function () {
          if (display.selForContextMenu == cm.doc.sel && te.selectionStart == 0 &&
              te.selectionEnd > 0 && input.prevInput == "\u200b") {
            operation(cm, selectAll)(cm);
          } else if (i++ < 10) {
            display.detectingSelectAll = setTimeout(poll, 500);
          } else {
            display.selForContextMenu = null;
            display.input.reset();
          }
        };
        display.detectingSelectAll = setTimeout(poll, 200);
      }
    }

    if (ie && ie_version >= 9) { prepareSelectAllHack(); }
    if (captureRightClick) {
      e_stop(e);
      var mouseup = function () {
        off(window, "mouseup", mouseup);
        setTimeout(rehide, 20);
      };
      on(window, "mouseup", mouseup);
    } else {
      setTimeout(rehide, 50);
    }
  };

  TextareaInput.prototype.readOnlyChanged = function (val) {
    if (!val) { this.reset(); }
    this.textarea.disabled = val == "nocursor";
    this.textarea.readOnly = !!val;
  };

  TextareaInput.prototype.setUneditable = function () {};

  TextareaInput.prototype.needsContentAttribute = false;

  function fromTextArea(textarea, options) {
    options = options ? copyObj(options) : {};
    options.value = textarea.value;
    if (!options.tabindex && textarea.tabIndex)
      { options.tabindex = textarea.tabIndex; }
    if (!options.placeholder && textarea.placeholder)
      { options.placeholder = textarea.placeholder; }
    // Set autofocus to true if this textarea is focused, or if it has
    // autofocus and no other element is focused.
    if (options.autofocus == null) {
      var hasFocus = activeElt();
      options.autofocus = hasFocus == textarea ||
        textarea.getAttribute("autofocus") != null && hasFocus == document.body;
    }

    function save() {textarea.value = cm.getValue();}

    var realSubmit;
    if (textarea.form) {
      on(textarea.form, "submit", save);
      // Deplorable hack to make the submit method do the right thing.
      if (!options.leaveSubmitMethodAlone) {
        var form = textarea.form;
        realSubmit = form.submit;
        try {
          var wrappedSubmit = form.submit = function () {
            save();
            form.submit = realSubmit;
            form.submit();
            form.submit = wrappedSubmit;
          };
        } catch(e) {}
      }
    }

    options.finishInit = function (cm) {
      cm.save = save;
      cm.getTextArea = function () { return textarea; };
      cm.toTextArea = function () {
        cm.toTextArea = isNaN; // Prevent this from being ran twice
        save();
        textarea.parentNode.removeChild(cm.getWrapperElement());
        textarea.style.display = "";
        if (textarea.form) {
          off(textarea.form, "submit", save);
          if (!options.leaveSubmitMethodAlone && typeof textarea.form.submit == "function")
            { textarea.form.submit = realSubmit; }
        }
      };
    };

    textarea.style.display = "none";
    var cm = CodeMirror(function (node) { return textarea.parentNode.insertBefore(node, textarea.nextSibling); },
      options);
    return cm
  }

  function addLegacyProps(CodeMirror) {
    CodeMirror.off = off;
    CodeMirror.on = on;
    CodeMirror.wheelEventPixels = wheelEventPixels;
    CodeMirror.Doc = Doc;
    CodeMirror.splitLines = splitLinesAuto;
    CodeMirror.countColumn = countColumn;
    CodeMirror.findColumn = findColumn;
    CodeMirror.isWordChar = isWordCharBasic;
    CodeMirror.Pass = Pass;
    CodeMirror.signal = signal;
    CodeMirror.Line = Line;
    CodeMirror.changeEnd = changeEnd;
    CodeMirror.scrollbarModel = scrollbarModel;
    CodeMirror.Pos = Pos;
    CodeMirror.cmpPos = cmp;
    CodeMirror.modes = modes;
    CodeMirror.mimeModes = mimeModes;
    CodeMirror.resolveMode = resolveMode;
    CodeMirror.getMode = getMode;
    CodeMirror.modeExtensions = modeExtensions;
    CodeMirror.extendMode = extendMode;
    CodeMirror.copyState = copyState;
    CodeMirror.startState = startState;
    CodeMirror.innerMode = innerMode;
    CodeMirror.commands = commands;
    CodeMirror.keyMap = keyMap;
    CodeMirror.keyName = keyName;
    CodeMirror.isModifierKey = isModifierKey;
    CodeMirror.lookupKey = lookupKey;
    CodeMirror.normalizeKeyMap = normalizeKeyMap;
    CodeMirror.StringStream = StringStream;
    CodeMirror.SharedTextMarker = SharedTextMarker;
    CodeMirror.TextMarker = TextMarker;
    CodeMirror.LineWidget = LineWidget;
    CodeMirror.e_preventDefault = e_preventDefault;
    CodeMirror.e_stopPropagation = e_stopPropagation;
    CodeMirror.e_stop = e_stop;
    CodeMirror.addClass = addClass;
    CodeMirror.contains = contains;
    CodeMirror.rmClass = rmClass;
    CodeMirror.keyNames = keyNames;
  }

  // EDITOR CONSTRUCTOR

  defineOptions(CodeMirror);

  addEditorMethods(CodeMirror);

  // Set up methods on CodeMirror's prototype to redirect to the editor's document.
  var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
  for (var prop in Doc.prototype) { if (Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0)
    { CodeMirror.prototype[prop] = (function(method) {
      return function() {return method.apply(this.doc, arguments)}
    })(Doc.prototype[prop]); } }

  eventMixin(Doc);
  CodeMirror.inputStyles = {"textarea": TextareaInput, "contenteditable": ContentEditableInput};

  // Extra arguments are stored as the mode's dependencies, which is
  // used by (legacy) mechanisms like loadmode.js to automatically
  // load a mode. (Preferred mechanism is the require/define calls.)
  CodeMirror.defineMode = function(name/*, mode, …*/) {
    if (!CodeMirror.defaults.mode && name != "null") { CodeMirror.defaults.mode = name; }
    defineMode.apply(this, arguments);
  };

  CodeMirror.defineMIME = defineMIME;

  // Minimal default mode.
  CodeMirror.defineMode("null", function () { return ({token: function (stream) { return stream.skipToEnd(); }}); });
  CodeMirror.defineMIME("text/plain", "null");

  // EXTENSIONS

  CodeMirror.defineExtension = function (name, func) {
    CodeMirror.prototype[name] = func;
  };
  CodeMirror.defineDocExtension = function (name, func) {
    Doc.prototype[name] = func;
  };

  CodeMirror.fromTextArea = fromTextArea;

  addLegacyProps(CodeMirror);

  CodeMirror.version = "5.59.2";

  return CodeMirror;

})));
});

var xml = createCommonjsModule(function (module, exports) {
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  mod(codemirror);
})(function(CodeMirror) {

var htmlConfig = {
  autoSelfClosers: {'area': true, 'base': true, 'br': true, 'col': true, 'command': true,
                    'embed': true, 'frame': true, 'hr': true, 'img': true, 'input': true,
                    'keygen': true, 'link': true, 'meta': true, 'param': true, 'source': true,
                    'track': true, 'wbr': true, 'menuitem': true},
  implicitlyClosed: {'dd': true, 'li': true, 'optgroup': true, 'option': true, 'p': true,
                     'rp': true, 'rt': true, 'tbody': true, 'td': true, 'tfoot': true,
                     'th': true, 'tr': true},
  contextGrabbers: {
    'dd': {'dd': true, 'dt': true},
    'dt': {'dd': true, 'dt': true},
    'li': {'li': true},
    'option': {'option': true, 'optgroup': true},
    'optgroup': {'optgroup': true},
    'p': {'address': true, 'article': true, 'aside': true, 'blockquote': true, 'dir': true,
          'div': true, 'dl': true, 'fieldset': true, 'footer': true, 'form': true,
          'h1': true, 'h2': true, 'h3': true, 'h4': true, 'h5': true, 'h6': true,
          'header': true, 'hgroup': true, 'hr': true, 'menu': true, 'nav': true, 'ol': true,
          'p': true, 'pre': true, 'section': true, 'table': true, 'ul': true},
    'rp': {'rp': true, 'rt': true},
    'rt': {'rp': true, 'rt': true},
    'tbody': {'tbody': true, 'tfoot': true},
    'td': {'td': true, 'th': true},
    'tfoot': {'tbody': true},
    'th': {'td': true, 'th': true},
    'thead': {'tbody': true, 'tfoot': true},
    'tr': {'tr': true}
  },
  doNotIndent: {"pre": true},
  allowUnquoted: true,
  allowMissing: true,
  caseFold: true
};

var xmlConfig = {
  autoSelfClosers: {},
  implicitlyClosed: {},
  contextGrabbers: {},
  doNotIndent: {},
  allowUnquoted: false,
  allowMissing: false,
  allowMissingTagName: false,
  caseFold: false
};

CodeMirror.defineMode("xml", function(editorConf, config_) {
  var indentUnit = editorConf.indentUnit;
  var config = {};
  var defaults = config_.htmlMode ? htmlConfig : xmlConfig;
  for (var prop in defaults) config[prop] = defaults[prop];
  for (var prop in config_) config[prop] = config_[prop];

  // Return variables for tokenizers
  var type, setStyle;

  function inText(stream, state) {
    function chain(parser) {
      state.tokenize = parser;
      return parser(stream, state);
    }

    var ch = stream.next();
    if (ch == "<") {
      if (stream.eat("!")) {
        if (stream.eat("[")) {
          if (stream.match("CDATA[")) return chain(inBlock("atom", "]]>"));
          else return null;
        } else if (stream.match("--")) {
          return chain(inBlock("comment", "-->"));
        } else if (stream.match("DOCTYPE", true, true)) {
          stream.eatWhile(/[\w\._\-]/);
          return chain(doctype(1));
        } else {
          return null;
        }
      } else if (stream.eat("?")) {
        stream.eatWhile(/[\w\._\-]/);
        state.tokenize = inBlock("meta", "?>");
        return "meta";
      } else {
        type = stream.eat("/") ? "closeTag" : "openTag";
        state.tokenize = inTag;
        return "tag bracket";
      }
    } else if (ch == "&") {
      var ok;
      if (stream.eat("#")) {
        if (stream.eat("x")) {
          ok = stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";");
        } else {
          ok = stream.eatWhile(/[\d]/) && stream.eat(";");
        }
      } else {
        ok = stream.eatWhile(/[\w\.\-:]/) && stream.eat(";");
      }
      return ok ? "atom" : "error";
    } else {
      stream.eatWhile(/[^&<]/);
      return null;
    }
  }
  inText.isInText = true;

  function inTag(stream, state) {
    var ch = stream.next();
    if (ch == ">" || (ch == "/" && stream.eat(">"))) {
      state.tokenize = inText;
      type = ch == ">" ? "endTag" : "selfcloseTag";
      return "tag bracket";
    } else if (ch == "=") {
      type = "equals";
      return null;
    } else if (ch == "<") {
      state.tokenize = inText;
      state.state = baseState;
      state.tagName = state.tagStart = null;
      var next = state.tokenize(stream, state);
      return next ? next + " tag error" : "tag error";
    } else if (/[\'\"]/.test(ch)) {
      state.tokenize = inAttribute(ch);
      state.stringStartCol = stream.column();
      return state.tokenize(stream, state);
    } else {
      stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/);
      return "word";
    }
  }

  function inAttribute(quote) {
    var closure = function(stream, state) {
      while (!stream.eol()) {
        if (stream.next() == quote) {
          state.tokenize = inTag;
          break;
        }
      }
      return "string";
    };
    closure.isInAttribute = true;
    return closure;
  }

  function inBlock(style, terminator) {
    return function(stream, state) {
      while (!stream.eol()) {
        if (stream.match(terminator)) {
          state.tokenize = inText;
          break;
        }
        stream.next();
      }
      return style;
    }
  }

  function doctype(depth) {
    return function(stream, state) {
      var ch;
      while ((ch = stream.next()) != null) {
        if (ch == "<") {
          state.tokenize = doctype(depth + 1);
          return state.tokenize(stream, state);
        } else if (ch == ">") {
          if (depth == 1) {
            state.tokenize = inText;
            break;
          } else {
            state.tokenize = doctype(depth - 1);
            return state.tokenize(stream, state);
          }
        }
      }
      return "meta";
    };
  }

  function Context(state, tagName, startOfLine) {
    this.prev = state.context;
    this.tagName = tagName || "";
    this.indent = state.indented;
    this.startOfLine = startOfLine;
    if (config.doNotIndent.hasOwnProperty(tagName) || (state.context && state.context.noIndent))
      this.noIndent = true;
  }
  function popContext(state) {
    if (state.context) state.context = state.context.prev;
  }
  function maybePopContext(state, nextTagName) {
    var parentTagName;
    while (true) {
      if (!state.context) {
        return;
      }
      parentTagName = state.context.tagName;
      if (!config.contextGrabbers.hasOwnProperty(parentTagName) ||
          !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) {
        return;
      }
      popContext(state);
    }
  }

  function baseState(type, stream, state) {
    if (type == "openTag") {
      state.tagStart = stream.column();
      return tagNameState;
    } else if (type == "closeTag") {
      return closeTagNameState;
    } else {
      return baseState;
    }
  }
  function tagNameState(type, stream, state) {
    if (type == "word") {
      state.tagName = stream.current();
      setStyle = "tag";
      return attrState;
    } else if (config.allowMissingTagName && type == "endTag") {
      setStyle = "tag bracket";
      return attrState(type, stream, state);
    } else {
      setStyle = "error";
      return tagNameState;
    }
  }
  function closeTagNameState(type, stream, state) {
    if (type == "word") {
      var tagName = stream.current();
      if (state.context && state.context.tagName != tagName &&
          config.implicitlyClosed.hasOwnProperty(state.context.tagName))
        popContext(state);
      if ((state.context && state.context.tagName == tagName) || config.matchClosing === false) {
        setStyle = "tag";
        return closeState;
      } else {
        setStyle = "tag error";
        return closeStateErr;
      }
    } else if (config.allowMissingTagName && type == "endTag") {
      setStyle = "tag bracket";
      return closeState(type, stream, state);
    } else {
      setStyle = "error";
      return closeStateErr;
    }
  }

  function closeState(type, _stream, state) {
    if (type != "endTag") {
      setStyle = "error";
      return closeState;
    }
    popContext(state);
    return baseState;
  }
  function closeStateErr(type, stream, state) {
    setStyle = "error";
    return closeState(type, stream, state);
  }

  function attrState(type, _stream, state) {
    if (type == "word") {
      setStyle = "attribute";
      return attrEqState;
    } else if (type == "endTag" || type == "selfcloseTag") {
      var tagName = state.tagName, tagStart = state.tagStart;
      state.tagName = state.tagStart = null;
      if (type == "selfcloseTag" ||
          config.autoSelfClosers.hasOwnProperty(tagName)) {
        maybePopContext(state, tagName);
      } else {
        maybePopContext(state, tagName);
        state.context = new Context(state, tagName, tagStart == state.indented);
      }
      return baseState;
    }
    setStyle = "error";
    return attrState;
  }
  function attrEqState(type, stream, state) {
    if (type == "equals") return attrValueState;
    if (!config.allowMissing) setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrValueState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    if (type == "word" && config.allowUnquoted) {setStyle = "string"; return attrState;}
    setStyle = "error";
    return attrState(type, stream, state);
  }
  function attrContinuedState(type, stream, state) {
    if (type == "string") return attrContinuedState;
    return attrState(type, stream, state);
  }

  return {
    startState: function(baseIndent) {
      var state = {tokenize: inText,
                   state: baseState,
                   indented: baseIndent || 0,
                   tagName: null, tagStart: null,
                   context: null};
      if (baseIndent != null) state.baseIndent = baseIndent;
      return state
    },

    token: function(stream, state) {
      if (!state.tagName && stream.sol())
        state.indented = stream.indentation();

      if (stream.eatSpace()) return null;
      type = null;
      var style = state.tokenize(stream, state);
      if ((style || type) && style != "comment") {
        setStyle = null;
        state.state = state.state(type || style, stream, state);
        if (setStyle)
          style = setStyle == "error" ? style + " error" : setStyle;
      }
      return style;
    },

    indent: function(state, textAfter, fullLine) {
      var context = state.context;
      // Indent multi-line strings (e.g. css).
      if (state.tokenize.isInAttribute) {
        if (state.tagStart == state.indented)
          return state.stringStartCol + 1;
        else
          return state.indented + indentUnit;
      }
      if (context && context.noIndent) return CodeMirror.Pass;
      if (state.tokenize != inTag && state.tokenize != inText)
        return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
      // Indent the starts of attribute names.
      if (state.tagName) {
        if (config.multilineTagIndentPastTag !== false)
          return state.tagStart + state.tagName.length + 2;
        else
          return state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
      }
      if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
      var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
      if (tagAfter && tagAfter[1]) { // Closing tag spotted
        while (context) {
          if (context.tagName == tagAfter[2]) {
            context = context.prev;
            break;
          } else if (config.implicitlyClosed.hasOwnProperty(context.tagName)) {
            context = context.prev;
          } else {
            break;
          }
        }
      } else if (tagAfter) { // Opening tag spotted
        while (context) {
          var grabbers = config.contextGrabbers[context.tagName];
          if (grabbers && grabbers.hasOwnProperty(tagAfter[2]))
            context = context.prev;
          else
            break;
        }
      }
      while (context && context.prev && !context.startOfLine)
        context = context.prev;
      if (context) return context.indent + indentUnit;
      else return state.baseIndent || 0;
    },

    electricInput: /<\/[\s\w:]+>$/,
    blockCommentStart: "<!--",
    blockCommentEnd: "-->",

    configuration: config.htmlMode ? "html" : "xml",
    helperType: config.htmlMode ? "html" : "xml",

    skipAttribute: function(state) {
      if (state.state == attrValueState)
        state.state = attrState;
    },

    xmlCurrentTag: function(state) {
      return state.tagName ? {name: state.tagName, close: state.type == "closeTag"} : null
    },

    xmlCurrentContext: function(state) {
      var context = [];
      for (var cx = state.context; cx; cx = cx.prev)
        context.push(cx.tagName);
      return context.reverse()
    }
  };
});

CodeMirror.defineMIME("text/xml", "xml");
CodeMirror.defineMIME("application/xml", "xml");
if (!CodeMirror.mimeModes.hasOwnProperty("text/html"))
  CodeMirror.defineMIME("text/html", {name: "xml", htmlMode: true});

});
});

var javascript = createCommonjsModule(function (module, exports) {
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  mod(codemirror);
})(function(CodeMirror) {

CodeMirror.defineMode("javascript", function(config, parserConfig) {
  var indentUnit = config.indentUnit;
  var statementIndent = parserConfig.statementIndent;
  var jsonldMode = parserConfig.jsonld;
  var jsonMode = parserConfig.json || jsonldMode;
  var isTS = parserConfig.typescript;
  var wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/;

  // Tokenizer

  var keywords = function(){
    function kw(type) {return {type: type, style: "keyword"};}
    var A = kw("keyword a"), B = kw("keyword b"), C = kw("keyword c"), D = kw("keyword d");
    var operator = kw("operator"), atom = {type: "atom", style: "atom"};

    return {
      "if": kw("if"), "while": A, "with": A, "else": B, "do": B, "try": B, "finally": B,
      "return": D, "break": D, "continue": D, "new": kw("new"), "delete": C, "void": C, "throw": C,
      "debugger": kw("debugger"), "var": kw("var"), "const": kw("var"), "let": kw("var"),
      "function": kw("function"), "catch": kw("catch"),
      "for": kw("for"), "switch": kw("switch"), "case": kw("case"), "default": kw("default"),
      "in": operator, "typeof": operator, "instanceof": operator,
      "true": atom, "false": atom, "null": atom, "undefined": atom, "NaN": atom, "Infinity": atom,
      "this": kw("this"), "class": kw("class"), "super": kw("atom"),
      "yield": C, "export": kw("export"), "import": kw("import"), "extends": C,
      "await": C
    };
  }();

  var isOperatorChar = /[+\-*&%=<>!?|~^@]/;
  var isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/;

  function readRegexp(stream) {
    var escaped = false, next, inSet = false;
    while ((next = stream.next()) != null) {
      if (!escaped) {
        if (next == "/" && !inSet) return;
        if (next == "[") inSet = true;
        else if (inSet && next == "]") inSet = false;
      }
      escaped = !escaped && next == "\\";
    }
  }

  // Used as scratch variables to communicate multiple values without
  // consing up tons of objects.
  var type, content;
  function ret(tp, style, cont) {
    type = tp; content = cont;
    return style;
  }
  function tokenBase(stream, state) {
    var ch = stream.next();
    if (ch == '"' || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "." && stream.match(/^\d[\d_]*(?:[eE][+\-]?[\d_]+)?/)) {
      return ret("number", "number");
    } else if (ch == "." && stream.match("..")) {
      return ret("spread", "meta");
    } else if (/[\[\]{}\(\),;\:\.]/.test(ch)) {
      return ret(ch);
    } else if (ch == "=" && stream.eat(">")) {
      return ret("=>", "operator");
    } else if (ch == "0" && stream.match(/^(?:x[\dA-Fa-f_]+|o[0-7_]+|b[01_]+)n?/)) {
      return ret("number", "number");
    } else if (/\d/.test(ch)) {
      stream.match(/^[\d_]*(?:n|(?:\.[\d_]*)?(?:[eE][+\-]?[\d_]+)?)?/);
      return ret("number", "number");
    } else if (ch == "/") {
      if (stream.eat("*")) {
        state.tokenize = tokenComment;
        return tokenComment(stream, state);
      } else if (stream.eat("/")) {
        stream.skipToEnd();
        return ret("comment", "comment");
      } else if (expressionAllowed(stream, state, 1)) {
        readRegexp(stream);
        stream.match(/^\b(([gimyus])(?![gimyus]*\2))+\b/);
        return ret("regexp", "string-2");
      } else {
        stream.eat("=");
        return ret("operator", "operator", stream.current());
      }
    } else if (ch == "`") {
      state.tokenize = tokenQuasi;
      return tokenQuasi(stream, state);
    } else if (ch == "#" && stream.peek() == "!") {
      stream.skipToEnd();
      return ret("meta", "meta");
    } else if (ch == "#" && stream.eatWhile(wordRE)) {
      return ret("variable", "property")
    } else if (ch == "<" && stream.match("!--") ||
               (ch == "-" && stream.match("->") && !/\S/.test(stream.string.slice(0, stream.start)))) {
      stream.skipToEnd();
      return ret("comment", "comment")
    } else if (isOperatorChar.test(ch)) {
      if (ch != ">" || !state.lexical || state.lexical.type != ">") {
        if (stream.eat("=")) {
          if (ch == "!" || ch == "=") stream.eat("=");
        } else if (/[<>*+\-|&?]/.test(ch)) {
          stream.eat(ch);
          if (ch == ">") stream.eat(ch);
        }
      }
      if (ch == "?" && stream.eat(".")) return ret(".")
      return ret("operator", "operator", stream.current());
    } else if (wordRE.test(ch)) {
      stream.eatWhile(wordRE);
      var word = stream.current();
      if (state.lastType != ".") {
        if (keywords.propertyIsEnumerable(word)) {
          var kw = keywords[word];
          return ret(kw.type, kw.style, word)
        }
        if (word == "async" && stream.match(/^(\s|\/\*([^*]|\*(?!\/))*?\*\/)*[\[\(\w]/, false))
          return ret("async", "keyword", word)
      }
      return ret("variable", "variable", word)
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, next;
      if (jsonldMode && stream.peek() == "@" && stream.match(isJsonldKeyword)){
        state.tokenize = tokenBase;
        return ret("jsonld-keyword", "meta");
      }
      while ((next = stream.next()) != null) {
        if (next == quote && !escaped) break;
        escaped = !escaped && next == "\\";
      }
      if (!escaped) state.tokenize = tokenBase;
      return ret("string", "string");
    };
  }

  function tokenComment(stream, state) {
    var maybeEnd = false, ch;
    while (ch = stream.next()) {
      if (ch == "/" && maybeEnd) {
        state.tokenize = tokenBase;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ret("comment", "comment");
  }

  function tokenQuasi(stream, state) {
    var escaped = false, next;
    while ((next = stream.next()) != null) {
      if (!escaped && (next == "`" || next == "$" && stream.eat("{"))) {
        state.tokenize = tokenBase;
        break;
      }
      escaped = !escaped && next == "\\";
    }
    return ret("quasi", "string-2", stream.current());
  }

  var brackets = "([{}])";
  // This is a crude lookahead trick to try and notice that we're
  // parsing the argument patterns for a fat-arrow function before we
  // actually hit the arrow token. It only works if the arrow is on
  // the same line as the arguments and there's no strange noise
  // (comments) in between. Fallback is to only notice when we hit the
  // arrow, and not declare the arguments as locals for the arrow
  // body.
  function findFatArrow(stream, state) {
    if (state.fatArrowAt) state.fatArrowAt = null;
    var arrow = stream.string.indexOf("=>", stream.start);
    if (arrow < 0) return;

    if (isTS) { // Try to skip TypeScript return type declarations after the arguments
      var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
      if (m) arrow = m.index;
    }

    var depth = 0, sawSomething = false;
    for (var pos = arrow - 1; pos >= 0; --pos) {
      var ch = stream.string.charAt(pos);
      var bracket = brackets.indexOf(ch);
      if (bracket >= 0 && bracket < 3) {
        if (!depth) { ++pos; break; }
        if (--depth == 0) { if (ch == "(") sawSomething = true; break; }
      } else if (bracket >= 3 && bracket < 6) {
        ++depth;
      } else if (wordRE.test(ch)) {
        sawSomething = true;
      } else if (/["'\/`]/.test(ch)) {
        for (;; --pos) {
          if (pos == 0) return
          var next = stream.string.charAt(pos - 1);
          if (next == ch && stream.string.charAt(pos - 2) != "\\") { pos--; break }
        }
      } else if (sawSomething && !depth) {
        ++pos;
        break;
      }
    }
    if (sawSomething && !depth) state.fatArrowAt = pos;
  }

  // Parser

  var atomicTypes = {"atom": true, "number": true, "variable": true, "string": true, "regexp": true, "this": true, "jsonld-keyword": true};

  function JSLexical(indented, column, type, align, prev, info) {
    this.indented = indented;
    this.column = column;
    this.type = type;
    this.prev = prev;
    this.info = info;
    if (align != null) this.align = align;
  }

  function inScope(state, varname) {
    for (var v = state.localVars; v; v = v.next)
      if (v.name == varname) return true;
    for (var cx = state.context; cx; cx = cx.prev) {
      for (var v = cx.vars; v; v = v.next)
        if (v.name == varname) return true;
    }
  }

  function parseJS(state, style, type, content, stream) {
    var cc = state.cc;
    // Communicate our context to the combinators.
    // (Less wasteful than consing up a hundred closures on every call.)
    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc; cx.style = style;

    if (!state.lexical.hasOwnProperty("align"))
      state.lexical.align = true;

    while(true) {
      var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
      if (combinator(type, content)) {
        while(cc.length && cc[cc.length - 1].lex)
          cc.pop()();
        if (cx.marked) return cx.marked;
        if (type == "variable" && inScope(state, content)) return "variable-2";
        return style;
      }
    }
  }

  // Combinator utils

  var cx = {state: null, column: null, marked: null, cc: null};
  function pass() {
    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);
  }
  function cont() {
    pass.apply(null, arguments);
    return true;
  }
  function inList(name, list) {
    for (var v = list; v; v = v.next) if (v.name == name) return true
    return false;
  }
  function register(varname) {
    var state = cx.state;
    cx.marked = "def";
    if (state.context) {
      if (state.lexical.info == "var" && state.context && state.context.block) {
        // FIXME function decls are also not block scoped
        var newContext = registerVarScoped(varname, state.context);
        if (newContext != null) {
          state.context = newContext;
          return
        }
      } else if (!inList(varname, state.localVars)) {
        state.localVars = new Var(varname, state.localVars);
        return
      }
    }
    // Fall through means this is global
    if (parserConfig.globalVars && !inList(varname, state.globalVars))
      state.globalVars = new Var(varname, state.globalVars);
  }
  function registerVarScoped(varname, context) {
    if (!context) {
      return null
    } else if (context.block) {
      var inner = registerVarScoped(varname, context.prev);
      if (!inner) return null
      if (inner == context.prev) return context
      return new Context(inner, context.vars, true)
    } else if (inList(varname, context.vars)) {
      return context
    } else {
      return new Context(context.prev, new Var(varname, context.vars), false)
    }
  }

  function isModifier(name) {
    return name == "public" || name == "private" || name == "protected" || name == "abstract" || name == "readonly"
  }

  // Combinators

  function Context(prev, vars, block) { this.prev = prev; this.vars = vars; this.block = block; }
  function Var(name, next) { this.name = name; this.next = next; }

  var defaultVars = new Var("this", new Var("arguments", null));
  function pushcontext() {
    cx.state.context = new Context(cx.state.context, cx.state.localVars, false);
    cx.state.localVars = defaultVars;
  }
  function pushblockcontext() {
    cx.state.context = new Context(cx.state.context, cx.state.localVars, true);
    cx.state.localVars = null;
  }
  function popcontext() {
    cx.state.localVars = cx.state.context.vars;
    cx.state.context = cx.state.context.prev;
  }
  popcontext.lex = true;
  function pushlex(type, info) {
    var result = function() {
      var state = cx.state, indent = state.indented;
      if (state.lexical.type == "stat") indent = state.lexical.indented;
      else for (var outer = state.lexical; outer && outer.type == ")" && outer.align; outer = outer.prev)
        indent = outer.indented;
      state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info);
    };
    result.lex = true;
    return result;
  }
  function poplex() {
    var state = cx.state;
    if (state.lexical.prev) {
      if (state.lexical.type == ")")
        state.indented = state.lexical.indented;
      state.lexical = state.lexical.prev;
    }
  }
  poplex.lex = true;

  function expect(wanted) {
    function exp(type) {
      if (type == wanted) return cont();
      else if (wanted == ";" || type == "}" || type == ")" || type == "]") return pass();
      else return cont(exp);
    }    return exp;
  }

  function statement(type, value) {
    if (type == "var") return cont(pushlex("vardef", value), vardef, expect(";"), poplex);
    if (type == "keyword a") return cont(pushlex("form"), parenExpr, statement, poplex);
    if (type == "keyword b") return cont(pushlex("form"), statement, poplex);
    if (type == "keyword d") return cx.stream.match(/^\s*$/, false) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex);
    if (type == "debugger") return cont(expect(";"));
    if (type == "{") return cont(pushlex("}"), pushblockcontext, block, poplex, popcontext);
    if (type == ";") return cont();
    if (type == "if") {
      if (cx.state.lexical.info == "else" && cx.state.cc[cx.state.cc.length - 1] == poplex)
        cx.state.cc.pop()();
      return cont(pushlex("form"), parenExpr, statement, poplex, maybeelse);
    }
    if (type == "function") return cont(functiondef);
    if (type == "for") return cont(pushlex("form"), forspec, statement, poplex);
    if (type == "class" || (isTS && value == "interface")) {
      cx.marked = "keyword";
      return cont(pushlex("form", type == "class" ? type : value), className, poplex)
    }
    if (type == "variable") {
      if (isTS && value == "declare") {
        cx.marked = "keyword";
        return cont(statement)
      } else if (isTS && (value == "module" || value == "enum" || value == "type") && cx.stream.match(/^\s*\w/, false)) {
        cx.marked = "keyword";
        if (value == "enum") return cont(enumdef);
        else if (value == "type") return cont(typename, expect("operator"), typeexpr, expect(";"));
        else return cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)
      } else if (isTS && value == "namespace") {
        cx.marked = "keyword";
        return cont(pushlex("form"), expression, statement, poplex)
      } else if (isTS && value == "abstract") {
        cx.marked = "keyword";
        return cont(statement)
      } else {
        return cont(pushlex("stat"), maybelabel);
      }
    }
    if (type == "switch") return cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), pushblockcontext,
                                      block, poplex, poplex, popcontext);
    if (type == "case") return cont(expression, expect(":"));
    if (type == "default") return cont(expect(":"));
    if (type == "catch") return cont(pushlex("form"), pushcontext, maybeCatchBinding, statement, poplex, popcontext);
    if (type == "export") return cont(pushlex("stat"), afterExport, poplex);
    if (type == "import") return cont(pushlex("stat"), afterImport, poplex);
    if (type == "async") return cont(statement)
    if (value == "@") return cont(expression, statement)
    return pass(pushlex("stat"), expression, expect(";"), poplex);
  }
  function maybeCatchBinding(type) {
    if (type == "(") return cont(funarg, expect(")"))
  }
  function expression(type, value) {
    return expressionInner(type, value, false);
  }
  function expressionNoComma(type, value) {
    return expressionInner(type, value, true);
  }
  function parenExpr(type) {
    if (type != "(") return pass()
    return cont(pushlex(")"), maybeexpression, expect(")"), poplex)
  }
  function expressionInner(type, value, noComma) {
    if (cx.state.fatArrowAt == cx.stream.start) {
      var body = noComma ? arrowBodyNoComma : arrowBody;
      if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
      else if (type == "variable") return pass(pushcontext, pattern, expect("=>"), body, popcontext);
    }

    var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
    if (atomicTypes.hasOwnProperty(type)) return cont(maybeop);
    if (type == "function") return cont(functiondef, maybeop);
    if (type == "class" || (isTS && value == "interface")) { cx.marked = "keyword"; return cont(pushlex("form"), classExpression, poplex); }
    if (type == "keyword c" || type == "async") return cont(noComma ? expressionNoComma : expression);
    if (type == "(") return cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop);
    if (type == "operator" || type == "spread") return cont(noComma ? expressionNoComma : expression);
    if (type == "[") return cont(pushlex("]"), arrayLiteral, poplex, maybeop);
    if (type == "{") return contCommasep(objprop, "}", null, maybeop);
    if (type == "quasi") return pass(quasi, maybeop);
    if (type == "new") return cont(maybeTarget(noComma));
    if (type == "import") return cont(expression);
    return cont();
  }
  function maybeexpression(type) {
    if (type.match(/[;\}\)\],]/)) return pass();
    return pass(expression);
  }

  function maybeoperatorComma(type, value) {
    if (type == ",") return cont(maybeexpression);
    return maybeoperatorNoComma(type, value, false);
  }
  function maybeoperatorNoComma(type, value, noComma) {
    var me = noComma == false ? maybeoperatorComma : maybeoperatorNoComma;
    var expr = noComma == false ? expression : expressionNoComma;
    if (type == "=>") return cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext);
    if (type == "operator") {
      if (/\+\+|--/.test(value) || isTS && value == "!") return cont(me);
      if (isTS && value == "<" && cx.stream.match(/^([^<>]|<[^<>]*>)*>\s*\(/, false))
        return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me);
      if (value == "?") return cont(expression, expect(":"), expr);
      return cont(expr);
    }
    if (type == "quasi") { return pass(quasi, me); }
    if (type == ";") return;
    if (type == "(") return contCommasep(expressionNoComma, ")", "call", me);
    if (type == ".") return cont(property, me);
    if (type == "[") return cont(pushlex("]"), maybeexpression, expect("]"), poplex, me);
    if (isTS && value == "as") { cx.marked = "keyword"; return cont(typeexpr, me) }
    if (type == "regexp") {
      cx.state.lastType = cx.marked = "operator";
      cx.stream.backUp(cx.stream.pos - cx.stream.start - 1);
      return cont(expr)
    }
  }
  function quasi(type, value) {
    if (type != "quasi") return pass();
    if (value.slice(value.length - 2) != "${") return cont(quasi);
    return cont(expression, continueQuasi);
  }
  function continueQuasi(type) {
    if (type == "}") {
      cx.marked = "string-2";
      cx.state.tokenize = tokenQuasi;
      return cont(quasi);
    }
  }
  function arrowBody(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expression);
  }
  function arrowBodyNoComma(type) {
    findFatArrow(cx.stream, cx.state);
    return pass(type == "{" ? statement : expressionNoComma);
  }
  function maybeTarget(noComma) {
    return function(type) {
      if (type == ".") return cont(noComma ? targetNoComma : target);
      else if (type == "variable" && isTS) return cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma)
      else return pass(noComma ? expressionNoComma : expression);
    };
  }
  function target(_, value) {
    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorComma); }
  }
  function targetNoComma(_, value) {
    if (value == "target") { cx.marked = "keyword"; return cont(maybeoperatorNoComma); }
  }
  function maybelabel(type) {
    if (type == ":") return cont(poplex, statement);
    return pass(maybeoperatorComma, expect(";"), poplex);
  }
  function property(type) {
    if (type == "variable") {cx.marked = "property"; return cont();}
  }
  function objprop(type, value) {
    if (type == "async") {
      cx.marked = "property";
      return cont(objprop);
    } else if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      if (value == "get" || value == "set") return cont(getterSetter);
      var m; // Work around fat-arrow-detection complication for detecting typescript typed arrow params
      if (isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, false)))
        cx.state.fatArrowAt = cx.stream.pos + m[0].length;
      return cont(afterprop);
    } else if (type == "number" || type == "string") {
      cx.marked = jsonldMode ? "property" : (cx.style + " property");
      return cont(afterprop);
    } else if (type == "jsonld-keyword") {
      return cont(afterprop);
    } else if (isTS && isModifier(value)) {
      cx.marked = "keyword";
      return cont(objprop)
    } else if (type == "[") {
      return cont(expression, maybetype, expect("]"), afterprop);
    } else if (type == "spread") {
      return cont(expressionNoComma, afterprop);
    } else if (value == "*") {
      cx.marked = "keyword";
      return cont(objprop);
    } else if (type == ":") {
      return pass(afterprop)
    }
  }
  function getterSetter(type) {
    if (type != "variable") return pass(afterprop);
    cx.marked = "property";
    return cont(functiondef);
  }
  function afterprop(type) {
    if (type == ":") return cont(expressionNoComma);
    if (type == "(") return pass(functiondef);
  }
  function commasep(what, end, sep) {
    function proceed(type, value) {
      if (sep ? sep.indexOf(type) > -1 : type == ",") {
        var lex = cx.state.lexical;
        if (lex.info == "call") lex.pos = (lex.pos || 0) + 1;
        return cont(function(type, value) {
          if (type == end || value == end) return pass()
          return pass(what)
        }, proceed);
      }
      if (type == end || value == end) return cont();
      if (sep && sep.indexOf(";") > -1) return pass(what)
      return cont(expect(end));
    }
    return function(type, value) {
      if (type == end || value == end) return cont();
      return pass(what, proceed);
    };
  }
  function contCommasep(what, end, info) {
    for (var i = 3; i < arguments.length; i++)
      cx.cc.push(arguments[i]);
    return cont(pushlex(end, info), commasep(what, end), poplex);
  }
  function block(type) {
    if (type == "}") return cont();
    return pass(statement, block);
  }
  function maybetype(type, value) {
    if (isTS) {
      if (type == ":") return cont(typeexpr);
      if (value == "?") return cont(maybetype);
    }
  }
  function maybetypeOrIn(type, value) {
    if (isTS && (type == ":" || value == "in")) return cont(typeexpr)
  }
  function mayberettype(type) {
    if (isTS && type == ":") {
      if (cx.stream.match(/^\s*\w+\s+is\b/, false)) return cont(expression, isKW, typeexpr)
      else return cont(typeexpr)
    }
  }
  function isKW(_, value) {
    if (value == "is") {
      cx.marked = "keyword";
      return cont()
    }
  }
  function typeexpr(type, value) {
    if (value == "keyof" || value == "typeof" || value == "infer") {
      cx.marked = "keyword";
      return cont(value == "typeof" ? expressionNoComma : typeexpr)
    }
    if (type == "variable" || value == "void") {
      cx.marked = "type";
      return cont(afterType)
    }
    if (value == "|" || value == "&") return cont(typeexpr)
    if (type == "string" || type == "number" || type == "atom") return cont(afterType);
    if (type == "[") return cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType)
    if (type == "{") return cont(pushlex("}"), typeprops, poplex, afterType)
    if (type == "(") return cont(commasep(typearg, ")"), maybeReturnType, afterType)
    if (type == "<") return cont(commasep(typeexpr, ">"), typeexpr)
  }
  function maybeReturnType(type) {
    if (type == "=>") return cont(typeexpr)
  }
  function typeprops(type) {
    if (type.match(/[\}\)\]]/)) return cont()
    if (type == "," || type == ";") return cont(typeprops)
    return pass(typeprop, typeprops)
  }
  function typeprop(type, value) {
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      return cont(typeprop)
    } else if (value == "?" || type == "number" || type == "string") {
      return cont(typeprop)
    } else if (type == ":") {
      return cont(typeexpr)
    } else if (type == "[") {
      return cont(expect("variable"), maybetypeOrIn, expect("]"), typeprop)
    } else if (type == "(") {
      return pass(functiondecl, typeprop)
    } else if (!type.match(/[;\}\)\],]/)) {
      return cont()
    }
  }
  function typearg(type, value) {
    if (type == "variable" && cx.stream.match(/^\s*[?:]/, false) || value == "?") return cont(typearg)
    if (type == ":") return cont(typeexpr)
    if (type == "spread") return cont(typearg)
    return pass(typeexpr)
  }
  function afterType(type, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
    if (value == "|" || type == "." || value == "&") return cont(typeexpr)
    if (type == "[") return cont(typeexpr, expect("]"), afterType)
    if (value == "extends" || value == "implements") { cx.marked = "keyword"; return cont(typeexpr) }
    if (value == "?") return cont(typeexpr, expect(":"), typeexpr)
  }
  function maybeTypeArgs(_, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
  }
  function typeparam() {
    return pass(typeexpr, maybeTypeDefault)
  }
  function maybeTypeDefault(_, value) {
    if (value == "=") return cont(typeexpr)
  }
  function vardef(_, value) {
    if (value == "enum") {cx.marked = "keyword"; return cont(enumdef)}
    return pass(pattern, maybetype, maybeAssign, vardefCont);
  }
  function pattern(type, value) {
    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(pattern) }
    if (type == "variable") { register(value); return cont(); }
    if (type == "spread") return cont(pattern);
    if (type == "[") return contCommasep(eltpattern, "]");
    if (type == "{") return contCommasep(proppattern, "}");
  }
  function proppattern(type, value) {
    if (type == "variable" && !cx.stream.match(/^\s*:/, false)) {
      register(value);
      return cont(maybeAssign);
    }
    if (type == "variable") cx.marked = "property";
    if (type == "spread") return cont(pattern);
    if (type == "}") return pass();
    if (type == "[") return cont(expression, expect(']'), expect(':'), proppattern);
    return cont(expect(":"), pattern, maybeAssign);
  }
  function eltpattern() {
    return pass(pattern, maybeAssign)
  }
  function maybeAssign(_type, value) {
    if (value == "=") return cont(expressionNoComma);
  }
  function vardefCont(type) {
    if (type == ",") return cont(vardef);
  }
  function maybeelse(type, value) {
    if (type == "keyword b" && value == "else") return cont(pushlex("form", "else"), statement, poplex);
  }
  function forspec(type, value) {
    if (value == "await") return cont(forspec);
    if (type == "(") return cont(pushlex(")"), forspec1, poplex);
  }
  function forspec1(type) {
    if (type == "var") return cont(vardef, forspec2);
    if (type == "variable") return cont(forspec2);
    return pass(forspec2)
  }
  function forspec2(type, value) {
    if (type == ")") return cont()
    if (type == ";") return cont(forspec2)
    if (value == "in" || value == "of") { cx.marked = "keyword"; return cont(expression, forspec2) }
    return pass(expression, forspec2)
  }
  function functiondef(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondef);}
    if (type == "variable") {register(value); return cont(functiondef);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext);
    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef)
  }
  function functiondecl(type, value) {
    if (value == "*") {cx.marked = "keyword"; return cont(functiondecl);}
    if (type == "variable") {register(value); return cont(functiondecl);}
    if (type == "(") return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, popcontext);
    if (isTS && value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondecl)
  }
  function typename(type, value) {
    if (type == "keyword" || type == "variable") {
      cx.marked = "type";
      return cont(typename)
    } else if (value == "<") {
      return cont(pushlex(">"), commasep(typeparam, ">"), poplex)
    }
  }
  function funarg(type, value) {
    if (value == "@") cont(expression, funarg);
    if (type == "spread") return cont(funarg);
    if (isTS && isModifier(value)) { cx.marked = "keyword"; return cont(funarg); }
    if (isTS && type == "this") return cont(maybetype, maybeAssign)
    return pass(pattern, maybetype, maybeAssign);
  }
  function classExpression(type, value) {
    // Class expressions may have an optional name.
    if (type == "variable") return className(type, value);
    return classNameAfter(type, value);
  }
  function className(type, value) {
    if (type == "variable") {register(value); return cont(classNameAfter);}
  }
  function classNameAfter(type, value) {
    if (value == "<") return cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter)
    if (value == "extends" || value == "implements" || (isTS && type == ",")) {
      if (value == "implements") cx.marked = "keyword";
      return cont(isTS ? typeexpr : expression, classNameAfter);
    }
    if (type == "{") return cont(pushlex("}"), classBody, poplex);
  }
  function classBody(type, value) {
    if (type == "async" ||
        (type == "variable" &&
         (value == "static" || value == "get" || value == "set" || (isTS && isModifier(value))) &&
         cx.stream.match(/^\s+[\w$\xa1-\uffff]/, false))) {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (type == "variable" || cx.style == "keyword") {
      cx.marked = "property";
      return cont(classfield, classBody);
    }
    if (type == "number" || type == "string") return cont(classfield, classBody);
    if (type == "[")
      return cont(expression, maybetype, expect("]"), classfield, classBody)
    if (value == "*") {
      cx.marked = "keyword";
      return cont(classBody);
    }
    if (isTS && type == "(") return pass(functiondecl, classBody)
    if (type == ";" || type == ",") return cont(classBody);
    if (type == "}") return cont();
    if (value == "@") return cont(expression, classBody)
  }
  function classfield(type, value) {
    if (value == "?") return cont(classfield)
    if (type == ":") return cont(typeexpr, maybeAssign)
    if (value == "=") return cont(expressionNoComma)
    var context = cx.state.lexical.prev, isInterface = context && context.info == "interface";
    return pass(isInterface ? functiondecl : functiondef)
  }
  function afterExport(type, value) {
    if (value == "*") { cx.marked = "keyword"; return cont(maybeFrom, expect(";")); }
    if (value == "default") { cx.marked = "keyword"; return cont(expression, expect(";")); }
    if (type == "{") return cont(commasep(exportField, "}"), maybeFrom, expect(";"));
    return pass(statement);
  }
  function exportField(type, value) {
    if (value == "as") { cx.marked = "keyword"; return cont(expect("variable")); }
    if (type == "variable") return pass(expressionNoComma, exportField);
  }
  function afterImport(type) {
    if (type == "string") return cont();
    if (type == "(") return pass(expression);
    return pass(importSpec, maybeMoreImports, maybeFrom);
  }
  function importSpec(type, value) {
    if (type == "{") return contCommasep(importSpec, "}");
    if (type == "variable") register(value);
    if (value == "*") cx.marked = "keyword";
    return cont(maybeAs);
  }
  function maybeMoreImports(type) {
    if (type == ",") return cont(importSpec, maybeMoreImports)
  }
  function maybeAs(_type, value) {
    if (value == "as") { cx.marked = "keyword"; return cont(importSpec); }
  }
  function maybeFrom(_type, value) {
    if (value == "from") { cx.marked = "keyword"; return cont(expression); }
  }
  function arrayLiteral(type) {
    if (type == "]") return cont();
    return pass(commasep(expressionNoComma, "]"));
  }
  function enumdef() {
    return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex)
  }
  function enummember() {
    return pass(pattern, maybeAssign);
  }

  function isContinuedStatement(state, textAfter) {
    return state.lastType == "operator" || state.lastType == "," ||
      isOperatorChar.test(textAfter.charAt(0)) ||
      /[,.]/.test(textAfter.charAt(0));
  }

  function expressionAllowed(stream, state, backUp) {
    return state.tokenize == tokenBase &&
      /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) ||
      (state.lastType == "quasi" && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0))))
  }

  // Interface

  return {
    startState: function(basecolumn) {
      var state = {
        tokenize: tokenBase,
        lastType: "sof",
        cc: [],
        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", false),
        localVars: parserConfig.localVars,
        context: parserConfig.localVars && new Context(null, null, false),
        indented: basecolumn || 0
      };
      if (parserConfig.globalVars && typeof parserConfig.globalVars == "object")
        state.globalVars = parserConfig.globalVars;
      return state;
    },

    token: function(stream, state) {
      if (stream.sol()) {
        if (!state.lexical.hasOwnProperty("align"))
          state.lexical.align = false;
        state.indented = stream.indentation();
        findFatArrow(stream, state);
      }
      if (state.tokenize != tokenComment && stream.eatSpace()) return null;
      var style = state.tokenize(stream, state);
      if (type == "comment") return style;
      state.lastType = type == "operator" && (content == "++" || content == "--") ? "incdec" : type;
      return parseJS(state, style, type, content, stream);
    },

    indent: function(state, textAfter) {
      if (state.tokenize == tokenComment || state.tokenize == tokenQuasi) return CodeMirror.Pass;
      if (state.tokenize != tokenBase) return 0;
      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical, top;
      // Kludge to prevent 'maybelse' from blocking lexical scope pops
      if (!/^\s*else\b/.test(textAfter)) for (var i = state.cc.length - 1; i >= 0; --i) {
        var c = state.cc[i];
        if (c == poplex) lexical = lexical.prev;
        else if (c != maybeelse) break;
      }
      while ((lexical.type == "stat" || lexical.type == "form") &&
             (firstChar == "}" || ((top = state.cc[state.cc.length - 1]) &&
                                   (top == maybeoperatorComma || top == maybeoperatorNoComma) &&
                                   !/^[,\.=+\-*:?[\(]/.test(textAfter))))
        lexical = lexical.prev;
      if (statementIndent && lexical.type == ")" && lexical.prev.type == "stat")
        lexical = lexical.prev;
      var type = lexical.type, closing = firstChar == type;

      if (type == "vardef") return lexical.indented + (state.lastType == "operator" || state.lastType == "," ? lexical.info.length + 1 : 0);
      else if (type == "form" && firstChar == "{") return lexical.indented;
      else if (type == "form") return lexical.indented + indentUnit;
      else if (type == "stat")
        return lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0);
      else if (lexical.info == "switch" && !closing && parserConfig.doubleIndentSwitch != false)
        return lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit);
      else if (lexical.align) return lexical.column + (closing ? 0 : 1);
      else return lexical.indented + (closing ? 0 : indentUnit);
    },

    electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
    blockCommentStart: jsonMode ? null : "/*",
    blockCommentEnd: jsonMode ? null : "*/",
    blockCommentContinue: jsonMode ? null : " * ",
    lineComment: jsonMode ? null : "//",
    fold: "brace",
    closeBrackets: "()[]{}''\"\"``",

    helperType: jsonMode ? "json" : "javascript",
    jsonldMode: jsonldMode,
    jsonMode: jsonMode,

    expressionAllowed: expressionAllowed,

    skipExpression: function(state) {
      var top = state.cc[state.cc.length - 1];
      if (top == expression || top == expressionNoComma) state.cc.pop();
    }
  };
});

CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/);

CodeMirror.defineMIME("text/javascript", "javascript");
CodeMirror.defineMIME("text/ecmascript", "javascript");
CodeMirror.defineMIME("application/javascript", "javascript");
CodeMirror.defineMIME("application/x-javascript", "javascript");
CodeMirror.defineMIME("application/ecmascript", "javascript");
CodeMirror.defineMIME("application/json", { name: "javascript", json: true });
CodeMirror.defineMIME("application/x-json", { name: "javascript", json: true });
CodeMirror.defineMIME("application/manifest+json", { name: "javascript", json: true });
CodeMirror.defineMIME("application/ld+json", { name: "javascript", jsonld: true });
CodeMirror.defineMIME("text/typescript", { name: "javascript", typescript: true });
CodeMirror.defineMIME("application/typescript", { name: "javascript", typescript: true });

});
});

var css = createCommonjsModule(function (module, exports) {
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  mod(codemirror);
})(function(CodeMirror) {

CodeMirror.defineMode("css", function(config, parserConfig) {
  var inline = parserConfig.inline;
  if (!parserConfig.propertyKeywords) parserConfig = CodeMirror.resolveMode("text/css");

  var indentUnit = config.indentUnit,
      tokenHooks = parserConfig.tokenHooks,
      documentTypes = parserConfig.documentTypes || {},
      mediaTypes = parserConfig.mediaTypes || {},
      mediaFeatures = parserConfig.mediaFeatures || {},
      mediaValueKeywords = parserConfig.mediaValueKeywords || {},
      propertyKeywords = parserConfig.propertyKeywords || {},
      nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
      fontProperties = parserConfig.fontProperties || {},
      counterDescriptors = parserConfig.counterDescriptors || {},
      colorKeywords = parserConfig.colorKeywords || {},
      valueKeywords = parserConfig.valueKeywords || {},
      allowNested = parserConfig.allowNested,
      lineComment = parserConfig.lineComment,
      supportsAtComponent = parserConfig.supportsAtComponent === true,
      highlightNonStandardPropertyKeywords = config.highlightNonStandardPropertyKeywords !== false;

  var type, override;
  function ret(style, tp) { type = tp; return style; }

  // Tokenizers

  function tokenBase(stream, state) {
    var ch = stream.next();
    if (tokenHooks[ch]) {
      var result = tokenHooks[ch](stream, state);
      if (result !== false) return result;
    }
    if (ch == "@") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("def", stream.current());
    } else if (ch == "=" || (ch == "~" || ch == "|") && stream.eat("=")) {
      return ret(null, "compare");
    } else if (ch == "\"" || ch == "'") {
      state.tokenize = tokenString(ch);
      return state.tokenize(stream, state);
    } else if (ch == "#") {
      stream.eatWhile(/[\w\\\-]/);
      return ret("atom", "hash");
    } else if (ch == "!") {
      stream.match(/^\s*\w*/);
      return ret("keyword", "important");
    } else if (/\d/.test(ch) || ch == "." && stream.eat(/\d/)) {
      stream.eatWhile(/[\w.%]/);
      return ret("number", "unit");
    } else if (ch === "-") {
      if (/[\d.]/.test(stream.peek())) {
        stream.eatWhile(/[\w.%]/);
        return ret("number", "unit");
      } else if (stream.match(/^-[\w\\\-]*/)) {
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false))
          return ret("variable-2", "variable-definition");
        return ret("variable-2", "variable");
      } else if (stream.match(/^\w+-/)) {
        return ret("meta", "meta");
      }
    } else if (/[,+>*\/]/.test(ch)) {
      return ret(null, "select-op");
    } else if (ch == "." && stream.match(/^-?[_a-z][_a-z0-9-]*/i)) {
      return ret("qualifier", "qualifier");
    } else if (/[:;{}\[\]\(\)]/.test(ch)) {
      return ret(null, ch);
    } else if (stream.match(/^[\w-.]+(?=\()/)) {
      if (/^(url(-prefix)?|domain|regexp)$/i.test(stream.current())) {
        state.tokenize = tokenParenthesized;
      }
      return ret("variable callee", "variable");
    } else if (/[\w\\\-]/.test(ch)) {
      stream.eatWhile(/[\w\\\-]/);
      return ret("property", "word");
    } else {
      return ret(null, null);
    }
  }

  function tokenString(quote) {
    return function(stream, state) {
      var escaped = false, ch;
      while ((ch = stream.next()) != null) {
        if (ch == quote && !escaped) {
          if (quote == ")") stream.backUp(1);
          break;
        }
        escaped = !escaped && ch == "\\";
      }
      if (ch == quote || !escaped && quote != ")") state.tokenize = null;
      return ret("string", "string");
    };
  }

  function tokenParenthesized(stream, state) {
    stream.next(); // Must be '('
    if (!stream.match(/^\s*[\"\')]/, false))
      state.tokenize = tokenString(")");
    else
      state.tokenize = null;
    return ret(null, "(");
  }

  // Context management

  function Context(type, indent, prev) {
    this.type = type;
    this.indent = indent;
    this.prev = prev;
  }

  function pushContext(state, stream, type, indent) {
    state.context = new Context(type, stream.indentation() + (indent === false ? 0 : indentUnit), state.context);
    return type;
  }

  function popContext(state) {
    if (state.context.prev)
      state.context = state.context.prev;
    return state.context.type;
  }

  function pass(type, stream, state) {
    return states[state.context.type](type, stream, state);
  }
  function popAndPass(type, stream, state, n) {
    for (var i = n || 1; i > 0; i--)
      state.context = state.context.prev;
    return pass(type, stream, state);
  }

  // Parser

  function wordAsValue(stream) {
    var word = stream.current().toLowerCase();
    if (valueKeywords.hasOwnProperty(word))
      override = "atom";
    else if (colorKeywords.hasOwnProperty(word))
      override = "keyword";
    else
      override = "variable";
  }

  var states = {};

  states.top = function(type, stream, state) {
    if (type == "{") {
      return pushContext(state, stream, "block");
    } else if (type == "}" && state.context.prev) {
      return popContext(state);
    } else if (supportsAtComponent && /@component/i.test(type)) {
      return pushContext(state, stream, "atComponentBlock");
    } else if (/^@(-moz-)?document$/i.test(type)) {
      return pushContext(state, stream, "documentTypes");
    } else if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) {
      return pushContext(state, stream, "atBlock");
    } else if (/^@(font-face|counter-style)/i.test(type)) {
      state.stateArg = type;
      return "restricted_atBlock_before";
    } else if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) {
      return "keyframes";
    } else if (type && type.charAt(0) == "@") {
      return pushContext(state, stream, "at");
    } else if (type == "hash") {
      override = "builtin";
    } else if (type == "word") {
      override = "tag";
    } else if (type == "variable-definition") {
      return "maybeprop";
    } else if (type == "interpolation") {
      return pushContext(state, stream, "interpolation");
    } else if (type == ":") {
      return "pseudo";
    } else if (allowNested && type == "(") {
      return pushContext(state, stream, "parens");
    }
    return state.context.type;
  };

  states.block = function(type, stream, state) {
    if (type == "word") {
      var word = stream.current().toLowerCase();
      if (propertyKeywords.hasOwnProperty(word)) {
        override = "property";
        return "maybeprop";
      } else if (nonStandardPropertyKeywords.hasOwnProperty(word)) {
        override = highlightNonStandardPropertyKeywords ? "string-2" : "property";
        return "maybeprop";
      } else if (allowNested) {
        override = stream.match(/^\s*:(?:\s|$)/, false) ? "property" : "tag";
        return "block";
      } else {
        override += " error";
        return "maybeprop";
      }
    } else if (type == "meta") {
      return "block";
    } else if (!allowNested && (type == "hash" || type == "qualifier")) {
      override = "error";
      return "block";
    } else {
      return states.top(type, stream, state);
    }
  };

  states.maybeprop = function(type, stream, state) {
    if (type == ":") return pushContext(state, stream, "prop");
    return pass(type, stream, state);
  };

  states.prop = function(type, stream, state) {
    if (type == ";") return popContext(state);
    if (type == "{" && allowNested) return pushContext(state, stream, "propBlock");
    if (type == "}" || type == "{") return popAndPass(type, stream, state);
    if (type == "(") return pushContext(state, stream, "parens");

    if (type == "hash" && !/^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
      override += " error";
    } else if (type == "word") {
      wordAsValue(stream);
    } else if (type == "interpolation") {
      return pushContext(state, stream, "interpolation");
    }
    return "prop";
  };

  states.propBlock = function(type, _stream, state) {
    if (type == "}") return popContext(state);
    if (type == "word") { override = "property"; return "maybeprop"; }
    return state.context.type;
  };

  states.parens = function(type, stream, state) {
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == ")") return popContext(state);
    if (type == "(") return pushContext(state, stream, "parens");
    if (type == "interpolation") return pushContext(state, stream, "interpolation");
    if (type == "word") wordAsValue(stream);
    return "parens";
  };

  states.pseudo = function(type, stream, state) {
    if (type == "meta") return "pseudo";

    if (type == "word") {
      override = "variable-3";
      return state.context.type;
    }
    return pass(type, stream, state);
  };

  states.documentTypes = function(type, stream, state) {
    if (type == "word" && documentTypes.hasOwnProperty(stream.current())) {
      override = "tag";
      return state.context.type;
    } else {
      return states.atBlock(type, stream, state);
    }
  };

  states.atBlock = function(type, stream, state) {
    if (type == "(") return pushContext(state, stream, "atBlock_parens");
    if (type == "}" || type == ";") return popAndPass(type, stream, state);
    if (type == "{") return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");

    if (type == "interpolation") return pushContext(state, stream, "interpolation");

    if (type == "word") {
      var word = stream.current().toLowerCase();
      if (word == "only" || word == "not" || word == "and" || word == "or")
        override = "keyword";
      else if (mediaTypes.hasOwnProperty(word))
        override = "attribute";
      else if (mediaFeatures.hasOwnProperty(word))
        override = "property";
      else if (mediaValueKeywords.hasOwnProperty(word))
        override = "keyword";
      else if (propertyKeywords.hasOwnProperty(word))
        override = "property";
      else if (nonStandardPropertyKeywords.hasOwnProperty(word))
        override = highlightNonStandardPropertyKeywords ? "string-2" : "property";
      else if (valueKeywords.hasOwnProperty(word))
        override = "atom";
      else if (colorKeywords.hasOwnProperty(word))
        override = "keyword";
      else
        override = "error";
    }
    return state.context.type;
  };

  states.atComponentBlock = function(type, stream, state) {
    if (type == "}")
      return popAndPass(type, stream, state);
    if (type == "{")
      return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", false);
    if (type == "word")
      override = "error";
    return state.context.type;
  };

  states.atBlock_parens = function(type, stream, state) {
    if (type == ")") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state, 2);
    return states.atBlock(type, stream, state);
  };

  states.restricted_atBlock_before = function(type, stream, state) {
    if (type == "{")
      return pushContext(state, stream, "restricted_atBlock");
    if (type == "word" && state.stateArg == "@counter-style") {
      override = "variable";
      return "restricted_atBlock_before";
    }
    return pass(type, stream, state);
  };

  states.restricted_atBlock = function(type, stream, state) {
    if (type == "}") {
      state.stateArg = null;
      return popContext(state);
    }
    if (type == "word") {
      if ((state.stateArg == "@font-face" && !fontProperties.hasOwnProperty(stream.current().toLowerCase())) ||
          (state.stateArg == "@counter-style" && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase())))
        override = "error";
      else
        override = "property";
      return "maybeprop";
    }
    return "restricted_atBlock";
  };

  states.keyframes = function(type, stream, state) {
    if (type == "word") { override = "variable"; return "keyframes"; }
    if (type == "{") return pushContext(state, stream, "top");
    return pass(type, stream, state);
  };

  states.at = function(type, stream, state) {
    if (type == ";") return popContext(state);
    if (type == "{" || type == "}") return popAndPass(type, stream, state);
    if (type == "word") override = "tag";
    else if (type == "hash") override = "builtin";
    return "at";
  };

  states.interpolation = function(type, stream, state) {
    if (type == "}") return popContext(state);
    if (type == "{" || type == ";") return popAndPass(type, stream, state);
    if (type == "word") override = "variable";
    else if (type != "variable" && type != "(" && type != ")") override = "error";
    return "interpolation";
  };

  return {
    startState: function(base) {
      return {tokenize: null,
              state: inline ? "block" : "top",
              stateArg: null,
              context: new Context(inline ? "block" : "top", base || 0, null)};
    },

    token: function(stream, state) {
      if (!state.tokenize && stream.eatSpace()) return null;
      var style = (state.tokenize || tokenBase)(stream, state);
      if (style && typeof style == "object") {
        type = style[1];
        style = style[0];
      }
      override = style;
      if (type != "comment")
        state.state = states[state.state](type, stream, state);
      return override;
    },

    indent: function(state, textAfter) {
      var cx = state.context, ch = textAfter && textAfter.charAt(0);
      var indent = cx.indent;
      if (cx.type == "prop" && (ch == "}" || ch == ")")) cx = cx.prev;
      if (cx.prev) {
        if (ch == "}" && (cx.type == "block" || cx.type == "top" ||
                          cx.type == "interpolation" || cx.type == "restricted_atBlock")) {
          // Resume indentation from parent context.
          cx = cx.prev;
          indent = cx.indent;
        } else if (ch == ")" && (cx.type == "parens" || cx.type == "atBlock_parens") ||
            ch == "{" && (cx.type == "at" || cx.type == "atBlock")) {
          // Dedent relative to current context.
          indent = Math.max(0, cx.indent - indentUnit);
        }
      }
      return indent;
    },

    electricChars: "}",
    blockCommentStart: "/*",
    blockCommentEnd: "*/",
    blockCommentContinue: " * ",
    lineComment: lineComment,
    fold: "brace"
  };
});

  function keySet(array) {
    var keys = {};
    for (var i = 0; i < array.length; ++i) {
      keys[array[i].toLowerCase()] = true;
    }
    return keys;
  }

  var documentTypes_ = [
    "domain", "regexp", "url", "url-prefix"
  ], documentTypes = keySet(documentTypes_);

  var mediaTypes_ = [
    "all", "aural", "braille", "handheld", "print", "projection", "screen",
    "tty", "tv", "embossed"
  ], mediaTypes = keySet(mediaTypes_);

  var mediaFeatures_ = [
    "width", "min-width", "max-width", "height", "min-height", "max-height",
    "device-width", "min-device-width", "max-device-width", "device-height",
    "min-device-height", "max-device-height", "aspect-ratio",
    "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio",
    "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color",
    "max-color", "color-index", "min-color-index", "max-color-index",
    "monochrome", "min-monochrome", "max-monochrome", "resolution",
    "min-resolution", "max-resolution", "scan", "grid", "orientation",
    "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio",
    "pointer", "any-pointer", "hover", "any-hover", "prefers-color-scheme"
  ], mediaFeatures = keySet(mediaFeatures_);

  var mediaValueKeywords_ = [
    "landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover",
    "interlace", "progressive",
    "dark", "light"
  ], mediaValueKeywords = keySet(mediaValueKeywords_);

  var propertyKeywords_ = [
    "align-content", "align-items", "align-self", "alignment-adjust",
    "alignment-baseline", "all", "anchor-point", "animation", "animation-delay",
    "animation-direction", "animation-duration", "animation-fill-mode",
    "animation-iteration-count", "animation-name", "animation-play-state",
    "animation-timing-function", "appearance", "azimuth", "backdrop-filter",
    "backface-visibility", "background", "background-attachment",
    "background-blend-mode", "background-clip", "background-color",
    "background-image", "background-origin", "background-position",
    "background-position-x", "background-position-y", "background-repeat",
    "background-size", "baseline-shift", "binding", "bleed", "block-size",
    "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target",
    "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius",
    "border-bottom-right-radius", "border-bottom-style", "border-bottom-width",
    "border-collapse", "border-color", "border-image", "border-image-outset",
    "border-image-repeat", "border-image-slice", "border-image-source",
    "border-image-width", "border-left", "border-left-color", "border-left-style",
    "border-left-width", "border-radius", "border-right", "border-right-color",
    "border-right-style", "border-right-width", "border-spacing", "border-style",
    "border-top", "border-top-color", "border-top-left-radius",
    "border-top-right-radius", "border-top-style", "border-top-width",
    "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing",
    "break-after", "break-before", "break-inside", "caption-side", "caret-color",
    "clear", "clip", "color", "color-profile", "column-count", "column-fill",
    "column-gap", "column-rule", "column-rule-color", "column-rule-style",
    "column-rule-width", "column-span", "column-width", "columns", "contain",
    "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after",
    "cue-before", "cursor", "direction", "display", "dominant-baseline",
    "drop-initial-after-adjust", "drop-initial-after-align",
    "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size",
    "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position",
    "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow",
    "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into",
    "font", "font-family", "font-feature-settings", "font-kerning",
    "font-language-override", "font-optical-sizing", "font-size",
    "font-size-adjust", "font-stretch", "font-style", "font-synthesis",
    "font-variant", "font-variant-alternates", "font-variant-caps",
    "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric",
    "font-variant-position", "font-variation-settings", "font-weight", "gap",
    "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows",
    "grid-column", "grid-column-end", "grid-column-gap", "grid-column-start",
    "grid-gap", "grid-row", "grid-row-end", "grid-row-gap", "grid-row-start",
    "grid-template", "grid-template-areas", "grid-template-columns",
    "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon",
    "image-orientation", "image-rendering", "image-resolution", "inline-box-align",
    "inset", "inset-block", "inset-block-end", "inset-block-start", "inset-inline",
    "inset-inline-end", "inset-inline-start", "isolation", "justify-content",
    "justify-items", "justify-self", "left", "letter-spacing", "line-break",
    "line-height", "line-height-step", "line-stacking", "line-stacking-ruby",
    "line-stacking-shift", "line-stacking-strategy", "list-style",
    "list-style-image", "list-style-position", "list-style-type", "margin",
    "margin-bottom", "margin-left", "margin-right", "margin-top", "marks",
    "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed",
    "marquee-style", "mask-clip", "mask-composite", "mask-image", "mask-mode",
    "mask-origin", "mask-position", "mask-repeat", "mask-size","mask-type",
    "max-block-size", "max-height", "max-inline-size",
    "max-width", "min-block-size", "min-height", "min-inline-size", "min-width",
    "mix-blend-mode", "move-to", "nav-down", "nav-index", "nav-left", "nav-right",
    "nav-up", "object-fit", "object-position", "offset", "offset-anchor",
    "offset-distance", "offset-path", "offset-position", "offset-rotate",
    "opacity", "order", "orphans", "outline", "outline-color", "outline-offset",
    "outline-style", "outline-width", "overflow", "overflow-style",
    "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom",
    "padding-left", "padding-right", "padding-top", "page", "page-break-after",
    "page-break-before", "page-break-inside", "page-policy", "pause",
    "pause-after", "pause-before", "perspective", "perspective-origin", "pitch",
    "pitch-range", "place-content", "place-items", "place-self", "play-during",
    "position", "presentation-level", "punctuation-trim", "quotes",
    "region-break-after", "region-break-before", "region-break-inside",
    "region-fragment", "rendering-intent", "resize", "rest", "rest-after",
    "rest-before", "richness", "right", "rotate", "rotation", "rotation-point",
    "row-gap", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span",
    "scale", "scroll-behavior", "scroll-margin", "scroll-margin-block",
    "scroll-margin-block-end", "scroll-margin-block-start", "scroll-margin-bottom",
    "scroll-margin-inline", "scroll-margin-inline-end",
    "scroll-margin-inline-start", "scroll-margin-left", "scroll-margin-right",
    "scroll-margin-top", "scroll-padding", "scroll-padding-block",
    "scroll-padding-block-end", "scroll-padding-block-start",
    "scroll-padding-bottom", "scroll-padding-inline", "scroll-padding-inline-end",
    "scroll-padding-inline-start", "scroll-padding-left", "scroll-padding-right",
    "scroll-padding-top", "scroll-snap-align", "scroll-snap-type",
    "shape-image-threshold", "shape-inside", "shape-margin", "shape-outside",
    "size", "speak", "speak-as", "speak-header", "speak-numeral",
    "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size",
    "table-layout", "target", "target-name", "target-new", "target-position",
    "text-align", "text-align-last", "text-combine-upright", "text-decoration",
    "text-decoration-color", "text-decoration-line", "text-decoration-skip",
    "text-decoration-skip-ink", "text-decoration-style", "text-emphasis",
    "text-emphasis-color", "text-emphasis-position", "text-emphasis-style",
    "text-height", "text-indent", "text-justify", "text-orientation",
    "text-outline", "text-overflow", "text-rendering", "text-shadow",
    "text-size-adjust", "text-space-collapse", "text-transform",
    "text-underline-position", "text-wrap", "top", "touch-action", "transform", "transform-origin",
    "transform-style", "transition", "transition-delay", "transition-duration",
    "transition-property", "transition-timing-function", "translate",
    "unicode-bidi", "user-select", "vertical-align", "visibility", "voice-balance",
    "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate",
    "voice-stress", "voice-volume", "volume", "white-space", "widows", "width",
    "will-change", "word-break", "word-spacing", "word-wrap", "writing-mode", "z-index",
    // SVG-specific
    "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color",
    "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events",
    "color-interpolation", "color-interpolation-filters",
    "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering",
    "marker", "marker-end", "marker-mid", "marker-start", "paint-order", "shape-rendering", "stroke",
    "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin",
    "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering",
    "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal",
    "glyph-orientation-vertical", "text-anchor", "writing-mode",
  ], propertyKeywords = keySet(propertyKeywords_);

  var nonStandardPropertyKeywords_ = [
    "border-block", "border-block-color", "border-block-end",
    "border-block-end-color", "border-block-end-style", "border-block-end-width",
    "border-block-start", "border-block-start-color", "border-block-start-style",
    "border-block-start-width", "border-block-style", "border-block-width",
    "border-inline", "border-inline-color", "border-inline-end",
    "border-inline-end-color", "border-inline-end-style",
    "border-inline-end-width", "border-inline-start", "border-inline-start-color",
    "border-inline-start-style", "border-inline-start-width",
    "border-inline-style", "border-inline-width", "margin-block",
    "margin-block-end", "margin-block-start", "margin-inline", "margin-inline-end",
    "margin-inline-start", "padding-block", "padding-block-end",
    "padding-block-start", "padding-inline", "padding-inline-end",
    "padding-inline-start", "scroll-snap-stop", "scrollbar-3d-light-color",
    "scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color",
    "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color",
    "scrollbar-track-color", "searchfield-cancel-button", "searchfield-decoration",
    "searchfield-results-button", "searchfield-results-decoration", "shape-inside", "zoom"
  ], nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_);

  var fontProperties_ = [
    "font-display", "font-family", "src", "unicode-range", "font-variant",
     "font-feature-settings", "font-stretch", "font-weight", "font-style"
  ], fontProperties = keySet(fontProperties_);

  var counterDescriptors_ = [
    "additive-symbols", "fallback", "negative", "pad", "prefix", "range",
    "speak-as", "suffix", "symbols", "system"
  ], counterDescriptors = keySet(counterDescriptors_);

  var colorKeywords_ = [
    "aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige",
    "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown",
    "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue",
    "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod",
    "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen",
    "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen",
    "darkslateblue", "darkslategray", "darkturquoise", "darkviolet",
    "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick",
    "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite",
    "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew",
    "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender",
    "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral",
    "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink",
    "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray",
    "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta",
    "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple",
    "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise",
    "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin",
    "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered",
    "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred",
    "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue",
    "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown",
    "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue",
    "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan",
    "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white",
    "whitesmoke", "yellow", "yellowgreen"
  ], colorKeywords = keySet(colorKeywords_);

  var valueKeywords_ = [
    "above", "absolute", "activeborder", "additive", "activecaption", "afar",
    "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate",
    "always", "amharic", "amharic-abegede", "antialiased", "appworkspace",
    "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page",
    "avoid-region", "axis-pan", "background", "backwards", "baseline", "below", "bidi-override", "binary",
    "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box",
    "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel",
    "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian",
    "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret",
    "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch",
    "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote",
    "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse",
    "compact", "condensed", "contain", "content", "contents",
    "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop",
    "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal",
    "decimal-leading-zero", "default", "default-button", "dense", "destination-atop",
    "destination-in", "destination-out", "destination-over", "devanagari", "difference",
    "disc", "discard", "disclosure-closed", "disclosure-open", "document",
    "dot-dash", "dot-dot-dash",
    "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out",
    "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede",
    "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er",
    "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er",
    "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et",
    "ethiopic-halehame-gez", "ethiopic-halehame-om-et",
    "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et",
    "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig",
    "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed",
    "extra-expanded", "fantasy", "fast", "fill", "fill-box", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes",
    "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove",
    "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew",
    "help", "hidden", "hide", "higher", "highlight", "highlighttext",
    "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore",
    "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite",
    "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis",
    "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert",
    "italic", "japanese-formal", "japanese-informal", "justify", "kannada",
    "katakana", "katakana-iroha", "keep-all", "khmer",
    "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal",
    "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten",
    "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem",
    "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian",
    "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian",
    "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "manipulation", "match", "matrix", "matrix3d",
    "media-controls-background", "media-current-time-display",
    "media-fullscreen-button", "media-mute-button", "media-play-button",
    "media-return-to-realtime-button", "media-rewind-button",
    "media-seek-back-button", "media-seek-forward-button", "media-slider",
    "media-sliderthumb", "media-time-remaining-display", "media-volume-slider",
    "media-volume-slider-container", "media-volume-sliderthumb", "medium",
    "menu", "menulist", "menulist-button", "menulist-text",
    "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic",
    "mix", "mongolian", "monospace", "move", "multiple", "multiple_mask_images", "multiply", "myanmar", "n-resize",
    "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop",
    "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap",
    "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote",
    "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset",
    "outside", "outside-shape", "overlay", "overline", "padding", "padding-box",
    "painted", "page", "paused", "persian", "perspective", "pinch-zoom", "plus-darker", "plus-lighter",
    "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d",
    "progress", "push-button", "radial-gradient", "radio", "read-only",
    "read-write", "read-write-plaintext-only", "rectangle", "region",
    "relative", "repeat", "repeating-linear-gradient",
    "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse",
    "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY",
    "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running",
    "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen",
    "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield",
    "searchfield-cancel-button", "searchfield-decoration",
    "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end",
    "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama",
    "simp-chinese-formal", "simp-chinese-informal", "single",
    "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal",
    "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow",
    "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali",
    "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square",
    "square-button", "start", "static", "status-bar", "stretch", "stroke", "stroke-box", "sub",
    "subpixel-antialiased", "svg_masks", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table",
    "table-caption", "table-cell", "table-column", "table-column-group",
    "table-footer-group", "table-header-group", "table-row", "table-row-group",
    "tamil",
    "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai",
    "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight",
    "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er",
    "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top",
    "trad-chinese-formal", "trad-chinese-informal", "transform",
    "translate", "translate3d", "translateX", "translateY", "translateZ",
    "transparent", "ultra-condensed", "ultra-expanded", "underline", "unidirectional-pan", "unset", "up",
    "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal",
    "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url",
    "var", "vertical", "vertical-text", "view-box", "visible", "visibleFill", "visiblePainted",
    "visibleStroke", "visual", "w-resize", "wait", "wave", "wider",
    "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor",
    "xx-large", "xx-small"
  ], valueKeywords = keySet(valueKeywords_);

  var allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_)
    .concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_)
    .concat(valueKeywords_);
  CodeMirror.registerHelper("hintWords", "css", allWords);

  function tokenCComment(stream, state) {
    var maybeEnd = false, ch;
    while ((ch = stream.next()) != null) {
      if (maybeEnd && ch == "/") {
        state.tokenize = null;
        break;
      }
      maybeEnd = (ch == "*");
    }
    return ["comment", "comment"];
  }

  CodeMirror.defineMIME("text/css", {
    documentTypes: documentTypes,
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    fontProperties: fontProperties,
    counterDescriptors: counterDescriptors,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    tokenHooks: {
      "/": function(stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css"
  });

  CodeMirror.defineMIME("text/x-scss", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      ":": function(stream) {
        if (stream.match(/^\s*\{/, false))
          return [null, null]
        return false;
      },
      "$": function(stream) {
        stream.match(/^[\w-]+/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "#": function(stream) {
        if (!stream.eat("{")) return false;
        return [null, "interpolation"];
      }
    },
    name: "css",
    helperType: "scss"
  });

  CodeMirror.defineMIME("text/x-less", {
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    mediaValueKeywords: mediaValueKeywords,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    fontProperties: fontProperties,
    allowNested: true,
    lineComment: "//",
    tokenHooks: {
      "/": function(stream, state) {
        if (stream.eat("/")) {
          stream.skipToEnd();
          return ["comment", "comment"];
        } else if (stream.eat("*")) {
          state.tokenize = tokenCComment;
          return tokenCComment(stream, state);
        } else {
          return ["operator", "operator"];
        }
      },
      "@": function(stream) {
        if (stream.eat("{")) return [null, "interpolation"];
        if (stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, false)) return false;
        stream.eatWhile(/[\w\\\-]/);
        if (stream.match(/^\s*:/, false))
          return ["variable-2", "variable-definition"];
        return ["variable-2", "variable"];
      },
      "&": function() {
        return ["atom", "atom"];
      }
    },
    name: "css",
    helperType: "less"
  });

  CodeMirror.defineMIME("text/x-gss", {
    documentTypes: documentTypes,
    mediaTypes: mediaTypes,
    mediaFeatures: mediaFeatures,
    propertyKeywords: propertyKeywords,
    nonStandardPropertyKeywords: nonStandardPropertyKeywords,
    fontProperties: fontProperties,
    counterDescriptors: counterDescriptors,
    colorKeywords: colorKeywords,
    valueKeywords: valueKeywords,
    supportsAtComponent: true,
    tokenHooks: {
      "/": function(stream, state) {
        if (!stream.eat("*")) return false;
        state.tokenize = tokenCComment;
        return tokenCComment(stream, state);
      }
    },
    name: "css",
    helperType: "gss"
  });

});
});

createCommonjsModule(function (module, exports) {
// CodeMirror, copyright (c) by Marijn Haverbeke and others
// Distributed under an MIT license: https://codemirror.net/LICENSE

(function(mod) {
  mod(codemirror, xml, javascript, css);
})(function(CodeMirror) {

  var defaultTags = {
    script: [
      ["lang", /(javascript|babel)/i, "javascript"],
      ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"],
      ["type", /./, "text/plain"],
      [null, null, "javascript"]
    ],
    style:  [
      ["lang", /^css$/i, "css"],
      ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"],
      ["type", /./, "text/plain"],
      [null, null, "css"]
    ]
  };

  function maybeBackup(stream, pat, style) {
    var cur = stream.current(), close = cur.search(pat);
    if (close > -1) {
      stream.backUp(cur.length - close);
    } else if (cur.match(/<\/?$/)) {
      stream.backUp(cur.length);
      if (!stream.match(pat, false)) stream.match(cur);
    }
    return style;
  }

  var attrRegexpCache = {};
  function getAttrRegexp(attr) {
    var regexp = attrRegexpCache[attr];
    if (regexp) return regexp;
    return attrRegexpCache[attr] = new RegExp("\\s+" + attr + "\\s*=\\s*('|\")?([^'\"]+)('|\")?\\s*");
  }

  function getAttrValue(text, attr) {
    var match = text.match(getAttrRegexp(attr));
    return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : ""
  }

  function getTagRegexp(tagName, anchored) {
    return new RegExp((anchored ? "^" : "") + "<\/\s*" + tagName + "\s*>", "i");
  }

  function addTags(from, to) {
    for (var tag in from) {
      var dest = to[tag] || (to[tag] = []);
      var source = from[tag];
      for (var i = source.length - 1; i >= 0; i--)
        dest.unshift(source[i]);
    }
  }

  function findMatchingMode(tagInfo, tagText) {
    for (var i = 0; i < tagInfo.length; i++) {
      var spec = tagInfo[i];
      if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2];
    }
  }

  CodeMirror.defineMode("htmlmixed", function (config, parserConfig) {
    var htmlMode = CodeMirror.getMode(config, {
      name: "xml",
      htmlMode: true,
      multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
      multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag,
      allowMissingTagName: parserConfig.allowMissingTagName,
    });

    var tags = {};
    var configTags = parserConfig && parserConfig.tags, configScript = parserConfig && parserConfig.scriptTypes;
    addTags(defaultTags, tags);
    if (configTags) addTags(configTags, tags);
    if (configScript) for (var i = configScript.length - 1; i >= 0; i--)
      tags.script.unshift(["type", configScript[i].matches, configScript[i].mode]);

    function html(stream, state) {
      var style = htmlMode.token(stream, state.htmlState), tag = /\btag\b/.test(style), tagName;
      if (tag && !/[<>\s\/]/.test(stream.current()) &&
          (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) &&
          tags.hasOwnProperty(tagName)) {
        state.inTag = tagName + " ";
      } else if (state.inTag && tag && />$/.test(stream.current())) {
        var inTag = /^([\S]+) (.*)/.exec(state.inTag);
        state.inTag = null;
        var modeSpec = stream.current() == ">" && findMatchingMode(tags[inTag[1]], inTag[2]);
        var mode = CodeMirror.getMode(config, modeSpec);
        var endTagA = getTagRegexp(inTag[1], true), endTag = getTagRegexp(inTag[1], false);
        state.token = function (stream, state) {
          if (stream.match(endTagA, false)) {
            state.token = html;
            state.localState = state.localMode = null;
            return null;
          }
          return maybeBackup(stream, endTag, state.localMode.token(stream, state.localState));
        };
        state.localMode = mode;
        state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, "", ""));
      } else if (state.inTag) {
        state.inTag += stream.current();
        if (stream.eol()) state.inTag += " ";
      }
      return style;
    }
    return {
      startState: function () {
        var state = CodeMirror.startState(htmlMode);
        return {token: html, inTag: null, localMode: null, localState: null, htmlState: state};
      },

      copyState: function (state) {
        var local;
        if (state.localState) {
          local = CodeMirror.copyState(state.localMode, state.localState);
        }
        return {token: state.token, inTag: state.inTag,
                localMode: state.localMode, localState: local,
                htmlState: CodeMirror.copyState(htmlMode, state.htmlState)};
      },

      token: function (stream, state) {
        return state.token(stream, state);
      },

      indent: function (state, textAfter, line) {
        if (!state.localMode || /^\s*<\//.test(textAfter))
          return htmlMode.indent(state.htmlState, textAfter, line);
        else if (state.localMode.indent)
          return state.localMode.indent(state.localState, textAfter, line);
        else
          return CodeMirror.Pass;
      },

      innerMode: function (state) {
        return {state: state.localState || state.htmlState, mode: state.localMode || htmlMode};
      }
    };
  }, "xml", "javascript", "css");

  CodeMirror.defineMIME("text/html", "htmlmixed");
});
});

const codeEditorCss = ":root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}:host,*,*:before,*:after{box-sizing:border-box}.CodeMirror{font-family:monospace;height:300px;color:black;direction:ltr}.CodeMirror-lines{padding:4px 0;}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like{padding:0 4px;}.CodeMirror-scrollbar-filler,.CodeMirror-gutter-filler{background-color:transparent;}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:black}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid black;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0 !important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-fat-cursor-mark{background-color:rgba(20, 255, 20, 0.5);-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite}.cm-animate-fat-cursor{width:auto;border:0;-webkit-animation:blink 1.06s steps(1) infinite;-moz-animation:blink 1.06s steps(1) infinite;animation:blink 1.06s steps(1) infinite;background-color:#7e7}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:0;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:blue}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:bold}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-variable-3,.cm-s-default .cm-type{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta{color:#555}.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error{color:#f00}.cm-invalidchar{color:#f00}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0b0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#a22}.CodeMirror-matchingtag{background:rgba(255, 150, 0, 0.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:white}.CodeMirror-scroll{overflow:scroll !important;margin-bottom:-50px;margin-right:-50px;padding-bottom:50px;height:100%;outline:none;position:relative}.CodeMirror-sizer{position:relative;border-right:50px solid transparent}.CodeMirror-vscrollbar,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-gutter-filler{position:absolute;z-index:6;display:none;outline:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-50px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:none !important;border:none !important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px;}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:transparent;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre.CodeMirror-line,.CodeMirror-wrap pre.CodeMirror-line-like{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;padding:0.1px;}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:none}.CodeMirror-scroll,.CodeMirror-sizer,.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors{visibility:visible}.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:rgba(255, 255, 0, 0.4)}.cm-force-border{padding-right:0.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:\"\"}span.CodeMirror-selectedtext{background:none}.cm-s-monokai.CodeMirror{background:#272822;color:#f8f8f2}.cm-s-monokai div.CodeMirror-selected{background:#49483E}.cm-s-monokai .CodeMirror-line::selection,.cm-s-monokai .CodeMirror-line>span::selection,.cm-s-monokai .CodeMirror-line>span>span::selection{background:rgba(73, 72, 62, 0.99)}.cm-s-monokai .CodeMirror-line::-moz-selection,.cm-s-monokai .CodeMirror-line>span::-moz-selection,.cm-s-monokai .CodeMirror-line>span>span::-moz-selection{background:rgba(73, 72, 62, 0.99)}.cm-s-monokai .CodeMirror-gutters{background:#272822;border-right:0px}.cm-s-monokai .CodeMirror-guttermarker{color:white}.cm-s-monokai .CodeMirror-guttermarker-subtle{color:#d0d0d0}.cm-s-monokai .CodeMirror-linenumber{color:#d0d0d0}.cm-s-monokai .CodeMirror-cursor{border-left:1px solid #f8f8f0}.cm-s-monokai span.cm-comment{color:#75715e}.cm-s-monokai span.cm-atom{color:#ae81ff}.cm-s-monokai span.cm-number{color:#ae81ff}.cm-s-monokai span.cm-comment.cm-attribute{color:#97b757}.cm-s-monokai span.cm-comment.cm-def{color:#bc9262}.cm-s-monokai span.cm-comment.cm-tag{color:#bc6283}.cm-s-monokai span.cm-comment.cm-type{color:#5998a6}.cm-s-monokai span.cm-property,.cm-s-monokai span.cm-attribute{color:#a6e22e}.cm-s-monokai span.cm-keyword{color:#f92672}.cm-s-monokai span.cm-builtin{color:#66d9ef}.cm-s-monokai span.cm-string{color:#e6db74}.cm-s-monokai span.cm-variable{color:#f8f8f2}.cm-s-monokai span.cm-variable-2{color:#9effff}.cm-s-monokai span.cm-variable-3,.cm-s-monokai span.cm-type{color:#66d9ef}.cm-s-monokai span.cm-def{color:#fd971f}.cm-s-monokai span.cm-bracket{color:#f8f8f2}.cm-s-monokai span.cm-tag{color:#f92672}.cm-s-monokai span.cm-header{color:#ae81ff}.cm-s-monokai span.cm-link{color:#ae81ff}.cm-s-monokai span.cm-error{background:#f92672;color:#f8f8f0}.cm-s-monokai .CodeMirror-activeline-background{background:#373831}.cm-s-monokai .CodeMirror-matchingbracket{text-decoration:underline;color:white !important}sdx-code-editor{display:block}sdx-code-editor .preview{border:1px solid #d6d6d6;border-radius:12px 12px 0 0;padding:24px}sdx-code-editor .preview~.CodeMirror{border-radius:0 0 12px 12px}sdx-code-editor.readonly .CodeMirror:after{content:\"Code\"}.CodeMirror{height:auto;font-family:Monaco, monospace;font-size:14px;padding:48px 24px 24px;border-radius:12px}.CodeMirror:after{content:\"Playground\";position:absolute;top:0;left:0;color:#666;border-right:1px solid #666;border-bottom:1px solid #666;border-bottom-right-radius:4px;padding:4px 8px}.CodeMirror-line span.cm-tag{color:#ea779c}.sdx--dark-theme .preview{border-color:#242424}.sdx--dark-theme .CodeMirror-line .cm-comment{color:#adadad}";

class CodeEditor {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.language = "htmlmixed";
    this.preview = true;
    this.readonly = false;
  }
  async refresh() {
    this.editor.refresh();
    this.renderPreview();
  }
  componentWillLoad() {
    var _a;
    this.textAreaEl = (_a = this.el.querySelector("textarea")) !== null && _a !== void 0 ? _a : undefined;
    if (!this.textAreaEl) {
      return;
    }
    // innerHTML security: entities of a textarea are being decoded by default, so no script tag will be executed here
    this.textAreaEl.innerHTML = this.indent(this.textAreaEl.innerHTML);
  }
  componentDidLoad() {
    if (!this.textAreaEl) {
      return;
    }
    const readOnly = this.readonly || !this.preview;
    this.editor = codemirror.fromTextArea(this.textAreaEl, {
      mode: this.language,
      theme: "monokai",
      readOnly,
      ...(readOnly ? { cursorBlinkRate: -1 } : {}),
    });
    this.editor.on("change", () => this.onChange());
    this.renderPreview();
  }
  onChange() {
    this.editor.save();
    this.renderPreview();
  }
  renderPreview() {
    if (this.previewEl) {
      // innerHTML security: the value is not sanitized
      this.previewEl.innerHTML = this.editor.getValue();
      dispatchEvent(this.el, "sdxrenderpreview");
    }
  }
  // Indent and trim blank lines
  indent(text) {
    const textLines = text.split("\n");
    // Remove blank lines at the beginning
    while (textLines[0].trim() === "") {
      textLines.splice(0, 1);
    }
    // Remove blank lines at the end
    while (textLines[textLines.length - 1].trim() === "") {
      textLines.splice(textLines.length - 1, 1);
    }
    // Detect indentation (count leading whitespaces on first line)
    const indentation = textLines[0].search(/\S/);
    // Indent code
    for (let i = 0; i < textLines.length; i++) {
      textLines[i] = textLines[i].substring(indentation);
    }
    return textLines.join("\n");
  }
  getHostClassNames() {
    return {
      paragraph: true,
      readonly: this.readonly || !this.preview,
    };
  }
  render() {
    return (hAsync(Host, { class: this.getHostClassNames() }, this.preview && (hAsync("div", { class: "preview", ref: (el) => (this.previewEl = el) })), hAsync("slot", null)));
  }
  get el() { return getElement(this); }
  static get style() { return codeEditorCss; }
  static get cmpMeta() { return {
    "$flags$": 4,
    "$tagName$": "sdx-code-editor",
    "$members$": {
      "language": [1],
      "preview": [4],
      "readonly": [4],
      "refresh": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const colorPickerCss = ":root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}:host,*,*:before,*:after{box-sizing:border-box}";

class ColorPicker {
  colorsChanged() {
    this.colorsParsed = parseJson(this.colors) || [];
  }
  valueChanged() {
    this.invokeChangeCallback(this.value);
  }
  changeCallbackChanged() {
    this.setInvokeChangeCallback();
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.invokeChangeCallback = () => null;
    this.colors = [];
    this.changeCallback = undefined;
    this.multiple = false;
    this.name = undefined;
    this.value = [];
    this.setInvokeChangeCallback();
    this.colorsParsed = parseJson(this.colors) || [];
  }
  setInvokeChangeCallback() {
    this.invokeChangeCallback = parseFunction(this.changeCallback);
  }
  getColorStyle(color) {
    return {
      height: "40px",
      width: "40px",
      borderRadius: "2px",
      background: color.code,
    };
  }
  render() {
    return (hAsync("sdx-input-group", { inline: true, theme: "container", name: this.name, type: this.multiple ? "checkbox" : "radio", value: this.value, changeCallback: (value) => (this.value = value) }, this.colorsParsed.map((color) => (hAsync("sdx-input-item", { value: color.name, hideCheckedIcon: true, labelStyle: { padding: "3px" }, checked: color.checked, srHint: color.name }, hAsync("div", { style: this.getColorStyle(color) }))))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "colors": ["colorsChanged"],
    "value": ["valueChanged"],
    "changeCallback": ["changeCallbackChanged"]
  }; }
  static get style() { return colorPickerCss; }
  static get cmpMeta() { return {
    "$flags$": 0,
    "$tagName$": "sdx-color-picker",
    "$members$": {
      "colors": [1],
      "changeCallback": [1, "change-callback"],
      "multiple": [4],
      "name": [1],
      "value": [1040]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}
/**
 * Emitted whenever user is checking/unchecking an item.
 * @event
 */
// @ts-ignore just for documentation purposes
ColorPicker.eventInput = "input";

const dialogReducer = (state = {}, action) => {
  switch (action.type) {
    default:
      return state;
  }
};
function getInitialState$5() {
  return {
    label: "",
    type: "modal",
    iconColorClass: "",
    display: "closed",
    toggle: () => Promise.resolve(),
    contentEl: undefined,
    toggleEl: undefined,
    notificationType: undefined,
    userInteractionInProgress: false,
  };
}

const breakpoints = {
  xs: 0,
  sm: 480,
  md: 768,
  lg: 1024,
  xl: 1280,
  ul: 1440,
};
function bp(breakpoint) {
  return window.innerWidth >= breakpoints[breakpoint];
}

const dialogCss = "/*!@:root*/.sc-sdx-dialog:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-dialog-h,*.sc-sdx-dialog,*.sc-sdx-dialog:before,*.sc-sdx-dialog:after{box-sizing:border-box}/*!@:host*/.sc-sdx-dialog-h{display:inline-block}/*!@:host(.no-toggle)*/.no-toggle.sc-sdx-dialog-h{display:none}";

class Dialog {
  stateChanged({}, prev) {
    const state = this.state.get();
    const prevState = prev.get();
    if (state.display !== prevState.display) {
      this.displayChanged(state);
    }
  }
  notificationTypeChanged() {
    this.store.set("notificationType", this.getNotificationType());
  }
  labelChanged() {
    this.store.set("label", this.label);
  }
  typeChanged() {
    this.store.set("type", this.type);
  }
  displayChangeCallbackChanged() {
    this.setInvokeDisplayChangeCallback();
  }
  iconNameChanged() {
    this.store.set("iconName", this.iconName);
  }
  iconColorClassChanged() {
    this.store.set("iconColorClass", this.iconColorClass);
  }
  /**
   * Toggles the modal.
   */
  toggle() {
    const { display } = this.state.get();
    if (display === "open") {
      return this.close();
    }
    else if (display === "closed") {
      return this.open();
    }
    else ;
    return Promise.resolve();
  }
  /**
   * Opens the modal.
   */
  open() {
    return new Promise((resolve) => {
      const { display, contentEl, userInteractionInProgress } = this.state.get();
      // Only a closed modal can be opened
      if (!(display === "closed" || display === "closing")) {
        resolve();
        return;
      }
      this.setDisplay("opening", userInteractionInProgress);
      // Move modal to the top of all other elements,
      // note that the modal is appended to the backdrop for positioning
      appendToOverlayOutlet(this.sdxBackdropEl, getOverlayOutletEl(), this.el);
      this.sdxBackdropEl.append(contentEl);
      anime.set(this.sdxBackdropEl, { display: "block" });
      anime.set(contentEl, {
        display: "block",
        opacity: bp("sm") ? 0 : 1,
        scale: bp("sm") ? 0.92 : "none",
        maxHeight: bp("sm") ? "none" : 0, // "auto" cannot be animated
      });
      anime
        .timeline({
        duration: this.getAnimationDuration(),
        easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
        complete: () => {
          this.setDisplay("open", userInteractionInProgress);
          resolve();
        },
      })
        .add({
        targets: this.sdxBackdropEl,
        backdropFilter: [
          "blur(0px) brightness(100%)",
          "blur(4px) brightness(50%)",
        ],
      })
        .add({
        targets: contentEl,
        ...(bp("sm")
          ? {
            opacity: 1,
            scale: 1,
          }
          : {
            maxHeight: `${window.innerHeight}px`,
            easing: "cubicBezier(0, 0, 0.58, 1.0)", // ease-out
          }),
      }, 0);
    });
  }
  /**
   * Closes the modal.
   */
  close() {
    return new Promise((resolve) => {
      const { display, contentEl, userInteractionInProgress } = this.state.get();
      if (display !== "open") {
        resolve();
        return;
      }
      this.setDisplay("closing", userInteractionInProgress);
      anime
        .timeline({
        duration: this.getAnimationDuration(),
        easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
        complete: () => {
          anime.set([this.sdxBackdropEl, contentEl], { display: "none" });
          // Move modal back
          appendToOverlayOutlet(contentEl, this.el, this.el);
          this.componentEl.append(this.sdxBackdropEl);
          this.setDisplay("closed", userInteractionInProgress);
          resolve();
        },
      })
        .add({
        targets: this.sdxBackdropEl,
        backdropFilter: "blur(0px) brightness(100%)",
      })
        .add({
        targets: contentEl,
        ...(bp("sm")
          ? {
            opacity: 0,
            scale: 0.92,
          }
          : {
            maxHeight: "0px",
            easing: "cubicBezier(0, 0, 0.58, 1.0)", // ease-out
          }),
      }, 0);
    });
  }
  /**
   * Calls close(), but only when the component is allowed to be closed.
   * @private
   */
  async requestToClose(e) {
    const { contentEl } = this.state.get();
    if (!contentEl) {
      return;
    }
    if (this.type !== "closable-modal") {
      return;
    }
    if (e instanceof KeyboardEvent) {
      if (e.key === "Escape") {
        this.store.set("userInteractionInProgress", true);
        this.close();
        this.store.set("userInteractionInProgress", false);
      }
      return;
    }
    const didClickOnContentEl = e.composedPath().includes(contentEl);
    if (didClickOnContentEl) {
      return;
    }
    // Clicked somewhere else on window
    this.store.set("userInteractionInProgress", true);
    this.close();
    this.store.set("userInteractionInProgress", false);
  }
  /**
   * Get the current display state.
   * @private
   */
  async getDisplay() {
    return this.state.get().display;
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.sdxdisplaychange = createEvent(this, "sdxdisplaychange", 7);
    this.animationDuration = 300;
    this.animationDurationMobile = 300;
    this.invokeDisplayChangeCallback = () => null;
    this.state = undefined;
    this.label = "";
    this.type = "modal";
    this.displayChangeCallback = undefined;
    this.iconName = undefined;
    this.iconColorClass = "";
    this.notificationType = undefined;
    this.gradient = undefined;
    this.animated = true;
    this.setInvokeDisplayChangeCallback();
    this.store = new StoreConnection(this, dialogReducer, getInitialState$5(), [
      "display",
      "contentEl",
      "toggleEl",
    ]);
    this.store.set("label", this.label);
    this.store.set("type", this.type);
    this.store.set("iconName", this.iconName);
    this.store.set("iconColorClass", this.iconColorClass);
    this.store.set("toggle", this.toggle.bind(this));
    this.store.set("notificationType", this.getNotificationType());
    this.store.flush();
  }
  disconnectedCallback() {
    // Make sure the dialog is closed when removed from the DOM
    this.close();
  }
  componentDidLoad() {
    this.store.subscribe();
  }
  displayChanged(state) {
    this.invokeDisplayChangeCallback(state.display);
  }
  setDisplay(display, userInteractionInProgress) {
    this.store.set("display", display);
    // Only fire events on end user interaction
    if (!userInteractionInProgress) {
      return;
    }
    this.sdxdisplaychange.emit({ display });
  }
  setInvokeDisplayChangeCallback() {
    this.invokeDisplayChangeCallback = parseFunction(this.displayChangeCallback);
  }
  getAnimationDuration() {
    if (!this.animated) {
      return 0;
    }
    return bp("sm") ? this.animationDuration : this.animationDurationMobile;
  }
  getNotificationType() {
    return this.gradient ? "gradient" : this.notificationType;
  }
  render() {
    const { toggleEl } = this.state.get();
    return (hAsync(Host, { class: { "no-toggle": !toggleEl } }, hAsync("div", { class: "component", ref: (el) => (this.componentEl = el) }, hAsync("slot", null), hAsync("sdx-backdrop", { ref: (el) => (this.sdxBackdropEl = el) }))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "state": ["stateChanged"],
    "gradient": ["notificationTypeChanged"],
    "notificationType": ["notificationTypeChanged"],
    "label": ["labelChanged"],
    "type": ["typeChanged"],
    "displayChangeCallback": ["displayChangeCallbackChanged"],
    "iconName": ["iconNameChanged"],
    "iconColorClass": ["iconColorClassChanged"]
  }; }
  static get style() { return dialogCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-dialog",
    "$members$": {
      "label": [1],
      "type": [1],
      "displayChangeCallback": [1, "display-change-callback"],
      "iconName": [1, "icon-name"],
      "iconColorClass": [1, "icon-color-class"],
      "notificationType": [1, "notification-type"],
      "gradient": [4],
      "animated": [4],
      "state": [32],
      "toggle": [64],
      "open": [64],
      "close": [64],
      "requestToClose": [64],
      "getDisplay": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const dialogContentCss = "/*!@:root*/.sc-sdx-dialog-content:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-dialog-content-h,*.sc-sdx-dialog-content,*.sc-sdx-dialog-content:before,*.sc-sdx-dialog-content:after{box-sizing:border-box}/*!@.text-body-1,\n.text-standard*/.text-body-1.sc-sdx-dialog-content,.text-standard.sc-sdx-dialog-content{line-height:24px;letter-spacing:-0.1px;font-size:18px}/*!@.text-body-2,\n.text-small*/.text-body-2.sc-sdx-dialog-content,.text-small.sc-sdx-dialog-content{line-height:21px;letter-spacing:0;font-size:16px}/*!@h1,\nh2,\nh3,\nh4,\nh5,\nh6,\np*/h1.sc-sdx-dialog-content,h2.sc-sdx-dialog-content,h3.sc-sdx-dialog-content,h4.sc-sdx-dialog-content,h5.sc-sdx-dialog-content,h6.sc-sdx-dialog-content,p.sc-sdx-dialog-content{margin:0;text-align:left;word-wrap:break-word}/*!@.h1,\n.h2,\n.h3,\n.h4,\n.h5,\n.h6,\n.hero,\n.d1,\n.d2,\n.d3*/.h1.sc-sdx-dialog-content,.h2.sc-sdx-dialog-content,.h3.sc-sdx-dialog-content,.h4.sc-sdx-dialog-content,.h5.sc-sdx-dialog-content,.h6.sc-sdx-dialog-content,.hero.sc-sdx-dialog-content,.d1.sc-sdx-dialog-content,.d2.sc-sdx-dialog-content,.d3.sc-sdx-dialog-content{color:#015}/*!@.h1,\n.h2,\n.text-h1,\n.text-h2,\nh1,\nh2*/.h1.sc-sdx-dialog-content,.h2.sc-sdx-dialog-content,.text-h1.sc-sdx-dialog-content,.text-h2.sc-sdx-dialog-content,h1.sc-sdx-dialog-content,h2.sc-sdx-dialog-content{margin-bottom:32px}/*!@.h1,\n.text-h1,\nh1*/.h1.sc-sdx-dialog-content,.text-h1.sc-sdx-dialog-content,h1.sc-sdx-dialog-content{line-height:40px;letter-spacing:-1px;font-size:32px;font-weight:700}@media (min-width: 1024px){/*!@.h1,\n  .text-h1,\n  h1*/.h1.sc-sdx-dialog-content,.text-h1.sc-sdx-dialog-content,h1.sc-sdx-dialog-content{line-height:48px;letter-spacing:-1.2px;font-size:40px}}/*!@.h2,\n.text-h2,\nh2*/.h2.sc-sdx-dialog-content,.text-h2.sc-sdx-dialog-content,h2.sc-sdx-dialog-content{line-height:32px;letter-spacing:-0.75px;font-size:28px;font-weight:700}@media (min-width: 1024px){/*!@.h2,\n  .text-h2,\n  h2*/.h2.sc-sdx-dialog-content,.text-h2.sc-sdx-dialog-content,h2.sc-sdx-dialog-content{line-height:40px;letter-spacing:-1px;font-size:32px}}/*!@.h3,\n.h4,\n.text-h3,\n.text-h4,\nh3,\nh4*/.h3.sc-sdx-dialog-content,.h4.sc-sdx-dialog-content,.text-h3.sc-sdx-dialog-content,.text-h4.sc-sdx-dialog-content,h3.sc-sdx-dialog-content,h4.sc-sdx-dialog-content{margin-bottom:24px}/*!@.h3,\n.text-h3,\nh3*/.h3.sc-sdx-dialog-content,.text-h3.sc-sdx-dialog-content,h3.sc-sdx-dialog-content{line-height:32px;letter-spacing:-0.35px;font-size:24px;font-weight:600}@media (min-width: 1024px){/*!@.h3,\n  .text-h3,\n  h3*/.h3.sc-sdx-dialog-content,.text-h3.sc-sdx-dialog-content,h3.sc-sdx-dialog-content{line-height:32px;letter-spacing:-0.75px;font-size:28px}}/*!@.h4,\n.text-h4,\nh4*/.h4.sc-sdx-dialog-content,.text-h4.sc-sdx-dialog-content,h4.sc-sdx-dialog-content{line-height:24px;letter-spacing:-0.1px;font-size:20px;font-weight:600}@media (min-width: 1024px){/*!@.h4,\n  .text-h4,\n  h4*/.h4.sc-sdx-dialog-content,.text-h4.sc-sdx-dialog-content,h4.sc-sdx-dialog-content{line-height:32px;letter-spacing:-0.35px;font-size:24px}}/*!@.text-h3.text-compact*/.text-h3.text-compact.sc-sdx-dialog-content{line-height:31px}/*!@.text-h4.text-compact*/.text-h4.text-compact.sc-sdx-dialog-content{line-height:27px}/*!@.h5,\n.h6,\n.text-h5,\n.text-h6,\nh5,\nh6*/.h5.sc-sdx-dialog-content,.h6.sc-sdx-dialog-content,.text-h5.sc-sdx-dialog-content,.text-h6.sc-sdx-dialog-content,h5.sc-sdx-dialog-content,h6.sc-sdx-dialog-content{margin-bottom:8px}/*!@.h5,\n.text-h5,\nh5*/.h5.sc-sdx-dialog-content,.text-h5.sc-sdx-dialog-content,h5.sc-sdx-dialog-content{line-height:24px;letter-spacing:-0.1px;font-size:18px;font-weight:600}/*!@.h6,\n.text-h6,\nh6*/.h6.sc-sdx-dialog-content,.text-h6.sc-sdx-dialog-content,h6.sc-sdx-dialog-content{line-height:24px;letter-spacing:-0.1px;font-size:16px;font-weight:600}/*!@.paragraph,\np*/.paragraph.sc-sdx-dialog-content,p.sc-sdx-dialog-content{line-height:24px;letter-spacing:-0.1px;font-size:18px;margin-bottom:32px}/*!@.paragraph:last-child,\np:last-child*/.paragraph.sc-sdx-dialog-content:last-child,p.sc-sdx-dialog-content:last-child{margin-bottom:0}/*!@.hero,\n.text-hero,\n.d1,\n.text-d1,\n.d2,\n.text-d2,\n.d3,\n.text-d3*/.hero.sc-sdx-dialog-content,.text-hero.sc-sdx-dialog-content,.d1.sc-sdx-dialog-content,.text-d1.sc-sdx-dialog-content,.d2.sc-sdx-dialog-content,.text-d2.sc-sdx-dialog-content,.d3.sc-sdx-dialog-content,.text-d3.sc-sdx-dialog-content{font-weight:700}/*!@.hero,\n.text-hero*/.hero.sc-sdx-dialog-content,.text-hero.sc-sdx-dialog-content{line-height:80px;letter-spacing:-1.75px;font-size:70px}@media (min-width: 1024px){/*!@.hero,\n  .text-hero*/.hero.sc-sdx-dialog-content,.text-hero.sc-sdx-dialog-content{line-height:104px;letter-spacing:-2px;font-size:96px}}/*!@.d1,\n.text-d1*/.d1.sc-sdx-dialog-content,.text-d1.sc-sdx-dialog-content{line-height:64px;letter-spacing:-1.35px;font-size:54px}@media (min-width: 1024px){/*!@.d1,\n  .text-d1*/.d1.sc-sdx-dialog-content,.text-d1.sc-sdx-dialog-content{line-height:80px;letter-spacing:-1.75px;font-size:70px}}/*!@.d2,\n.text-d2*/.d2.sc-sdx-dialog-content,.text-d2.sc-sdx-dialog-content{line-height:56px;letter-spacing:-1.2px;font-size:48px}@media (min-width: 1024px){/*!@.d2,\n  .text-d2*/.d2.sc-sdx-dialog-content,.text-d2.sc-sdx-dialog-content{line-height:64px;letter-spacing:-1.35px;font-size:54px}}/*!@.d3,\n.text-d3*/.d3.sc-sdx-dialog-content,.text-d3.sc-sdx-dialog-content{line-height:48px;letter-spacing:-1.2px;font-size:40px}@media (min-width: 1024px){/*!@.d3,\n  .text-d3*/.d3.sc-sdx-dialog-content,.text-d3.sc-sdx-dialog-content{line-height:56px;letter-spacing:-1.2px;font-size:48px}}/*!@.text-b1*/.text-b1.sc-sdx-dialog-content{line-height:24px;letter-spacing:-0.1px;font-size:18px;font-weight:400}/*!@.text-b2*/.text-b2.sc-sdx-dialog-content{line-height:21px;letter-spacing:0;font-size:16px;font-weight:400}/*!@.text-sm,\n.text-smaller*/.text-sm.sc-sdx-dialog-content,.text-smaller.sc-sdx-dialog-content{line-height:18px;letter-spacing:0.1px;font-size:14px;font-weight:400}/*!@.text-compact*/.text-compact.sc-sdx-dialog-content{line-height:21px}/*!@.figcaption*/.figcaption.sc-sdx-dialog-content{line-height:18px;letter-spacing:0.1px;font-size:14px}/*!@.code*/.code.sc-sdx-dialog-content{font-family:monospace;background-color:#f8fafb;border-radius:4px;border:1px solid #d6d6d6;color:#474747;font-size:16px;padding:0 6px}/*!@address*/address.sc-sdx-dialog-content{font-style:normal}/*!@strong*/strong.sc-sdx-dialog-content{font-weight:600}/*!@em*/em.sc-sdx-dialog-content{font-style:italic}/*!@.sdx--dark-theme .code*/.sdx--dark-theme.sc-sdx-dialog-content .code.sc-sdx-dialog-content{background-color:#242424;color:#d6d6d6}/*!@.font*/.font.sc-sdx-dialog-content{font-family:TheSans, sans-serif}/*!@.font--sans*/.font--sans.sc-sdx-dialog-content{font-family:TheSans, sans-serif}/*!@.font--serif*/.font--serif.sc-sdx-dialog-content{font-family:TheSerif, serif}/*!@.font--light*/.font--light.sc-sdx-dialog-content{font-weight:300}/*!@.font--semi-light*/.font--semi-light.sc-sdx-dialog-content{font-weight:400}/*!@.font--semi-bold*/.font--semi-bold.sc-sdx-dialog-content{font-weight:600}/*!@.sdx--dark-theme .h1,\n.sdx--dark-theme .h2,\n.sdx--dark-theme .h3,\n.sdx--dark-theme .h4,\n.sdx--dark-theme .h5,\n.sdx--dark-theme .h6,\n.sdx--dark-theme .hero,\n.sdx--dark-theme .d1,\n.sdx--dark-theme .d2,\n.sdx--dark-theme .d3*/.sdx--dark-theme.sc-sdx-dialog-content .h1.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .h2.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .h3.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .h4.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .h5.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .h6.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .hero.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .d1.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .d2.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .d3.sc-sdx-dialog-content{color:unset}/*!@.sdx--dark-theme .h1,\n.sdx--dark-theme .text-h1,\n.sdx--dark-theme h1,\n.sdx--dark-theme .h2,\n.sdx--dark-theme .text-h2,\n.sdx--dark-theme h2,\n.sdx--dark-theme .h3,\n.sdx--dark-theme .text-h3,\n.sdx--dark-theme h3,\n.sdx--dark-theme .h4,\n.sdx--dark-theme .text-h4,\n.sdx--dark-theme h4,\n.sdx--dark-theme .d1,\n.sdx--dark-theme .text-d1,\n.sdx--dark-theme .d2,\n.sdx--dark-theme .text-d2,\n.sdx--dark-theme .d3,\n.sdx--dark-theme .text-d3*/.sdx--dark-theme.sc-sdx-dialog-content .h1.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .text-h1.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content h1.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .h2.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .text-h2.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content h2.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .h3.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .text-h3.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content h3.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .h4.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .text-h4.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content h4.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .d1.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .text-d1.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .d2.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .text-d2.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .d3.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .text-d3.sc-sdx-dialog-content{font-weight:600}/*!@.sdx--dark-theme .p,\n.sdx--dark-theme .paragraph,\n.sdx--dark-theme p*/.sdx--dark-theme.sc-sdx-dialog-content .p.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .paragraph.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content p.sc-sdx-dialog-content{font-weight:500}/*!@.sdx--dark-theme .h1,\n.sdx--dark-theme .text-h1,\n.sdx--dark-theme h1*/.sdx--dark-theme.sc-sdx-dialog-content .h1.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .text-h1.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content h1.sc-sdx-dialog-content{letter-spacing:-0.8px}/*!@.sdx--dark-theme .h2,\n.sdx--dark-theme .text-h2,\n.sdx--dark-theme h2*/.sdx--dark-theme.sc-sdx-dialog-content .h2.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .text-h2.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content h2.sc-sdx-dialog-content{letter-spacing:-0.6px}/*!@.sdx--dark-theme .h3,\n.sdx--dark-theme .text-h3,\n.sdx--dark-theme h3*/.sdx--dark-theme.sc-sdx-dialog-content .h3.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .text-h3.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content h3.sc-sdx-dialog-content{letter-spacing:-0.5px}/*!@.sdx--dark-theme .h4,\n.sdx--dark-theme .text-h4,\n.sdx--dark-theme h4*/.sdx--dark-theme.sc-sdx-dialog-content .h4.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .text-h4.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content h4.sc-sdx-dialog-content{letter-spacing:-0.2px}/*!@.sdx--dark-theme .h5,\n.sdx--dark-theme .text-h5,\n.sdx--dark-theme h5*/.sdx--dark-theme.sc-sdx-dialog-content .h5.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .text-h5.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content h5.sc-sdx-dialog-content{letter-spacing:-0.1px}/*!@.sdx--dark-theme .h6,\n.sdx--dark-theme .text-h6,\n.sdx--dark-theme h6*/.sdx--dark-theme.sc-sdx-dialog-content .h6.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .text-h6.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content h6.sc-sdx-dialog-content{letter-spacing:0px}/*!@.sdx--dark-theme .d1,\n.sdx--dark-theme .text-d1*/.sdx--dark-theme.sc-sdx-dialog-content .d1.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .text-d1.sc-sdx-dialog-content{letter-spacing:-1.4px}/*!@.sdx--dark-theme .d2,\n.sdx--dark-theme .text-d2*/.sdx--dark-theme.sc-sdx-dialog-content .d2.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .text-d2.sc-sdx-dialog-content{letter-spacing:-1px}/*!@.sdx--dark-theme .d3,\n.sdx--dark-theme .text-d3*/.sdx--dark-theme.sc-sdx-dialog-content .d3.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content .text-d3.sc-sdx-dialog-content{letter-spacing:-0.9px}/*!@.sdx--dark-theme strong,\n.sdx--dark-theme b*/.sdx--dark-theme.sc-sdx-dialog-content strong.sc-sdx-dialog-content,.sdx--dark-theme.sc-sdx-dialog-content b.sc-sdx-dialog-content{color:#fff}/*!@.sdx--dark-theme code*/.sdx--dark-theme.sc-sdx-dialog-content code.sc-sdx-dialog-content{background-color:#242424;border:1px solid #b1b9be;border-radius:4px;color:#cfd5d9;font-size:16px}/*!@.bg-white*/.bg-white.sc-sdx-dialog-content{background-color:#fff}/*!@.bg-navy*/.bg-navy.sc-sdx-dialog-content{background-color:#015}/*!@.bg-blue*/.bg-blue.sc-sdx-dialog-content{background-color:#086adb}/*!@.bg-blue-tint-2, .bg-blue-40*/.bg-blue-tint-2.sc-sdx-dialog-content,.bg-blue-40.sc-sdx-dialog-content{background-color:#a2cdf4}/*!@.bg-blue-tint-3, .bg-blue-20*/.bg-blue-tint-3.sc-sdx-dialog-content,.bg-blue-20.sc-sdx-dialog-content{background-color:#d1e6f9}/*!@.bg-aluminium,\n.bg-aluminum*/.bg-aluminium.sc-sdx-dialog-content,.bg-aluminum.sc-sdx-dialog-content{background-color:#dde3e7}/*!@.bg-aluminium-80, .bg-aluminium-tint-2,\n.bg-aluminum-80,\n.bg-aluminum-tint-2*/.bg-aluminium-80.sc-sdx-dialog-content,.bg-aluminium-tint-2.sc-sdx-dialog-content,.bg-aluminum-80.sc-sdx-dialog-content,.bg-aluminum-tint-2.sc-sdx-dialog-content{background-color:#e4e9ec}/*!@.bg-horizon*/.bg-horizon.sc-sdx-dialog-content{background-color:#eef3f6}/*!@.bg-horizon-40, .bg-horizon-tint-2*/.bg-horizon-40.sc-sdx-dialog-content,.bg-horizon-tint-2.sc-sdx-dialog-content{background-color:#f8fafb}/*!@.bg-gray*/.bg-gray.sc-sdx-dialog-content{background-color:#333}/*!@.bg-gray-90, .bg-gray-tint-2*/.bg-gray-90.sc-sdx-dialog-content,.bg-gray-tint-2.sc-sdx-dialog-content{background-color:#474747}/*!@.bg-gray-80, .bg-gray-tint-3*/.bg-gray-80.sc-sdx-dialog-content,.bg-gray-tint-3.sc-sdx-dialog-content{background-color:#5c5c5c}/*!@.bg-gray-mid, .bg-gray-tint-4*/.bg-gray-mid.sc-sdx-dialog-content,.bg-gray-tint-4.sc-sdx-dialog-content{background-color:#666}/*!@.bg-gray-60, .bg-gray-tint-5*/.bg-gray-60.sc-sdx-dialog-content,.bg-gray-tint-5.sc-sdx-dialog-content{background-color:#858585}/*!@.bg-gray-40, .bg-gray-tint-6*/.bg-gray-40.sc-sdx-dialog-content,.bg-gray-tint-6.sc-sdx-dialog-content{background-color:#adadad}/*!@.bg-gray-light, .bg-gray-tint-7*/.bg-gray-light.sc-sdx-dialog-content,.bg-gray-tint-7.sc-sdx-dialog-content{background-color:#bbb}/*!@.bg-gray-20, .bg-gray-tint-8*/.bg-gray-20.sc-sdx-dialog-content,.bg-gray-tint-8.sc-sdx-dialog-content{background-color:#d6d6d6}/*!@.bg-sc-blue*/.bg-sc-blue.sc-sdx-dialog-content{background-color:#1af}/*!@.bg-sc-red*/.bg-sc-red.sc-sdx-dialog-content{background-color:#d12}/*!@.bg-sc-navy*/.bg-sc-navy.sc-sdx-dialog-content{background-color:#015}/*!@.bg-sc-white*/.bg-sc-white.sc-sdx-dialog-content{background-color:#fff}/*!@.bg-gradient-1*/.bg-gradient-1.sc-sdx-dialog-content{background:radial-gradient(110% 240% at 0% 130%, rgba(19, 163, 244, 0.9) 0%, rgba(22, 158, 255, 0.5) 55%, rgba(16, 136, 222, 0) 130%), #001155}/*!@.bg-gradient-2, .component.notification .notification-header.gradient*/.bg-gradient-2.sc-sdx-dialog-content,.component.notification.sc-sdx-dialog-content .notification-header.gradient.sc-sdx-dialog-content{background:radial-gradient(110% 220% at 0% 140%, #13a3f4 0%, rgba(22, 158, 255, 0.5) 40%, rgba(16, 136, 222, 0) 100%), radial-gradient(290% 800% at 220% -440%, #dd1122 30%, #001155 100%)}/*!@.bg-cloud*/.bg-cloud.sc-sdx-dialog-content{background:#f9f9f9}/*!@.bg-int-blue*/.bg-int-blue.sc-sdx-dialog-content{background-color:#086adb}/*!@.bg-int-blue--active*/.bg-int-blue--active.sc-sdx-dialog-content{background-color:#0048cf}/*!@.bg-int-gray*/.bg-int-gray.sc-sdx-dialog-content{background-color:#cfd5d9}/*!@.bg-int-gray--active*/.bg-int-gray--active.sc-sdx-dialog-content{background-color:#b1b9be}/*!@.bg-int-green*/.bg-int-green.sc-sdx-dialog-content{background-color:#1b8712}/*!@.bg-int-green--active*/.bg-int-green--active.sc-sdx-dialog-content{background-color:#0d6f2c}/*!@.bg-int-red*/.bg-int-red.sc-sdx-dialog-content{background-color:#d12}/*!@.bg-int-red--active*/.bg-int-red--active.sc-sdx-dialog-content{background-color:#be0000}/*!@.bg-int-orange*/.bg-int-orange.sc-sdx-dialog-content{background-color:#cf4a0c}/*!@.bg-int-orange--active*/.bg-int-orange--active.sc-sdx-dialog-content{background-color:#ba3e06}/*!@.bg-azure*/.bg-azure.sc-sdx-dialog-content{background-color:#1781e3}/*!@.bg-azure--active*/.bg-azure--active.sc-sdx-dialog-content{background-color:#0851da}/*!@.bg-orchid*/.bg-orchid.sc-sdx-dialog-content{background-color:#a63297}/*!@.bg-orchid--active*/.bg-orchid--active.sc-sdx-dialog-content{background-color:#7f2879}/*!@.bg-iris*/.bg-iris.sc-sdx-dialog-content{background-color:#5944c6}/*!@.bg-iris--active*/.bg-iris--active.sc-sdx-dialog-content{background-color:#42389e}/*!@.bg-pink*/.bg-pink.sc-sdx-dialog-content{background-color:#e61e64}/*!@.bg-pink--active*/.bg-pink--active.sc-sdx-dialog-content{background-color:#bf1b5a}/*!@.bg-apple,\n.bg-petrol,\n.bg-turquoise*/.bg-apple.sc-sdx-dialog-content,.bg-petrol.sc-sdx-dialog-content,.bg-turquoise.sc-sdx-dialog-content{background-color:#0eaba9}/*!@.bg-apple--active,\n.bg-petrol--active,\n.bg-turquoise--active*/.bg-apple--active.sc-sdx-dialog-content,.bg-petrol--active.sc-sdx-dialog-content,.bg-turquoise--active.sc-sdx-dialog-content{background-color:#0c847e}/*!@.sdx--dark-theme .bg-dusk*/.sdx--dark-theme.sc-sdx-dialog-content .bg-dusk.sc-sdx-dialog-content{background-color:#141414}/*!@.sdx--dark-theme .bg-dusk-tint-2*/.sdx--dark-theme.sc-sdx-dialog-content .bg-dusk-tint-2.sc-sdx-dialog-content{background-color:#1d1d1d}/*!@.sdx--dark-theme .bg-dusk-tint-3*/.sdx--dark-theme.sc-sdx-dialog-content .bg-dusk-tint-3.sc-sdx-dialog-content{background-color:#222}/*!@.sdx--dark-theme .bg-dusk-tint-4*/.sdx--dark-theme.sc-sdx-dialog-content .bg-dusk-tint-4.sc-sdx-dialog-content{background-color:#242424}/*!@.sdx--dark-theme .bg-gray*/.sdx--dark-theme.sc-sdx-dialog-content .bg-gray.sc-sdx-dialog-content{background-color:#e6e6e6}/*!@.sdx--dark-theme .bg-gray-tint-3*/.sdx--dark-theme.sc-sdx-dialog-content .bg-gray-tint-3.sc-sdx-dialog-content{background-color:#cfd5d9}/*!@.sdx--dark-theme .bg-gray-tint-4*/.sdx--dark-theme.sc-sdx-dialog-content .bg-gray-tint-4.sc-sdx-dialog-content{background-color:#b1b9be}/*!@.sdx--dark-theme .bg-gray-tint-6*/.sdx--dark-theme.sc-sdx-dialog-content .bg-gray-tint-6.sc-sdx-dialog-content{background-color:#8c8c8c}/*!@.sdx--dark-theme .bg-gray-tint-7*/.sdx--dark-theme.sc-sdx-dialog-content .bg-gray-tint-7.sc-sdx-dialog-content{background-color:#707070}/*!@.sdx--dark-theme .bg-gray-tint-8*/.sdx--dark-theme.sc-sdx-dialog-content .bg-gray-tint-8.sc-sdx-dialog-content{background-color:#5c5c5c}/*!@.sdx--dark-theme .bg-azure*/.sdx--dark-theme.sc-sdx-dialog-content .bg-azure.sc-sdx-dialog-content{background-color:#136fc3}/*!@.sdx--dark-theme .bg-azure--active*/.sdx--dark-theme.sc-sdx-dialog-content .bg-azure--active.sc-sdx-dialog-content{background-color:#1578d3}/*!@.sdx--dark-theme .bg-turquoise*/.sdx--dark-theme.sc-sdx-dialog-content .bg-turquoise.sc-sdx-dialog-content{background-color:#0a7b7a}/*!@.sdx--dark-theme .bg-turquoise--active*/.sdx--dark-theme.sc-sdx-dialog-content .bg-turquoise--active.sc-sdx-dialog-content{background-color:#0b8483}/*!@.sdx--dark-theme .bg-iris*/.sdx--dark-theme.sc-sdx-dialog-content .bg-iris.sc-sdx-dialog-content{background-color:#6f5ccb}/*!@.sdx--dark-theme .bg-iris--active*/.sdx--dark-theme.sc-sdx-dialog-content .bg-iris--active.sc-sdx-dialog-content{background-color:#7867ce}/*!@.sdx--dark-theme .bg-orchid*/.sdx--dark-theme.sc-sdx-dialog-content .bg-orchid.sc-sdx-dialog-content{background-color:#a54c9b}/*!@.sdx--dark-theme .bg-orchid--active*/.sdx--dark-theme.sc-sdx-dialog-content .bg-orchid--active.sc-sdx-dialog-content{background-color:#b053a5}/*!@.sdx--dark-theme .bg-pink*/.sdx--dark-theme.sc-sdx-dialog-content .bg-pink.sc-sdx-dialog-content{background-color:#d41d56}/*!@.sdx--dark-theme .bg-pink--active*/.sdx--dark-theme.sc-sdx-dialog-content .bg-pink--active.sc-sdx-dialog-content{background-color:#e1245f}/*!@.sdx--dark-theme .bg-int-blue*/.sdx--dark-theme.sc-sdx-dialog-content .bg-int-blue.sc-sdx-dialog-content{background-color:#0a71e9}/*!@.sdx--dark-theme .bg-int-blue--active*/.sdx--dark-theme.sc-sdx-dialog-content .bg-int-blue--active.sc-sdx-dialog-content{background-color:#147df5}/*!@.sdx--dark-theme .bg-int-blue2*/.sdx--dark-theme.sc-sdx-dialog-content .bg-int-blue2.sc-sdx-dialog-content{background-color:#4294ff}/*!@.sdx--dark-theme .bg-int-blue2--active*/.sdx--dark-theme.sc-sdx-dialog-content .bg-int-blue2--active.sc-sdx-dialog-content{background-color:#5ca3ff}/*!@.sdx--dark-theme .bg-int-gray*/.sdx--dark-theme.sc-sdx-dialog-content .bg-int-gray.sc-sdx-dialog-content{background-color:#adadad}/*!@.sdx--dark-theme .bg-int-gray--active*/.sdx--dark-theme.sc-sdx-dialog-content .bg-int-gray--active.sc-sdx-dialog-content{background-color:#d6d6d6}/*!@.sdx--dark-theme .bg-int-green*/.sdx--dark-theme.sc-sdx-dialog-content .bg-int-green.sc-sdx-dialog-content{background-color:#1c8912}/*!@.sdx--dark-theme .bg-int-green--active*/.sdx--dark-theme.sc-sdx-dialog-content .bg-int-green--active.sc-sdx-dialog-content{background-color:#1f9414}/*!@.sdx--dark-theme .bg-int-green2*/.sdx--dark-theme.sc-sdx-dialog-content .bg-int-green2.sc-sdx-dialog-content{background-color:#21a716}/*!@.sdx--dark-theme .bg-int-green2--active*/.sdx--dark-theme.sc-sdx-dialog-content .bg-int-green2--active.sc-sdx-dialog-content{background-color:#55c24a}/*!@.sdx--dark-theme .bg-int-red*/.sdx--dark-theme.sc-sdx-dialog-content .bg-int-red.sc-sdx-dialog-content{background-color:#eb1224}/*!@.sdx--dark-theme .bg-int-red--active*/.sdx--dark-theme.sc-sdx-dialog-content .bg-int-red--active.sc-sdx-dialog-content{background-color:#ef2e3e}/*!@.sdx--dark-theme .bg-int-red2*/.sdx--dark-theme.sc-sdx-dialog-content .bg-int-red2.sc-sdx-dialog-content{background-color:#f35d6a}/*!@.sdx--dark-theme .bg-int-red2--active*/.sdx--dark-theme.sc-sdx-dialog-content .bg-int-red2--active.sc-sdx-dialog-content{background-color:#fe7e89}/*!@.sdx--dark-theme .bg-int-orange*/.sdx--dark-theme.sc-sdx-dialog-content .bg-int-orange.sc-sdx-dialog-content{background-color:#ce4a0c}/*!@.sdx--dark-theme .bg-int-orange--active*/.sdx--dark-theme.sc-sdx-dialog-content .bg-int-orange--active.sc-sdx-dialog-content{background-color:#de4f0d}/*!@.sdx--dark-theme .bg-int-orange2*/.sdx--dark-theme.sc-sdx-dialog-content .bg-int-orange2.sc-sdx-dialog-content{background-color:#f26726}/*!@.sdx--dark-theme .bg-int-orange2--active*/.sdx--dark-theme.sc-sdx-dialog-content .bg-int-orange2--active.sc-sdx-dialog-content{background-color:#f37b46}/*!@:host(:not([class*=col-])) .component*/.sc-sdx-dialog-content-h:not([class*=col-]) .component.sc-sdx-dialog-content{width:calc(100vw - 0px)}@media (min-width: 480px){/*!@:host(:not([class*=col-])) .component*/.sc-sdx-dialog-content-h:not([class*=col-]) .component.sc-sdx-dialog-content{width:auto}}/*!@:host*/.sc-sdx-dialog-content-h{display:none;padding-left:0px !important;padding-right:0px !important}@media (min-width: 480px){/*!@:host*/.sc-sdx-dialog-content-h{padding-left:32px !important;padding-right:32px !important}}/*!@.component*/.component.sc-sdx-dialog-content{background:white;box-shadow:0 0 4px rgba(0, 0, 0, 0.2);border-radius:6px}@media (max-width: 479px){/*!@.component*/.component.sc-sdx-dialog-content{min-height:max(300px, 60vh);border-radius:8px 8px 0 0}}/*!@.component.notification .notification-header*/.component.notification.sc-sdx-dialog-content .notification-header.sc-sdx-dialog-content{position:relative;display:flex;flex-direction:column;align-items:center;justify-content:center;height:122px;color:#fff;border-radius:6px;background-size:100% 100%}@media (max-width: 479px){/*!@.component.notification .notification-header*/.component.notification.sc-sdx-dialog-content .notification-header.sc-sdx-dialog-content{border-radius:8px 8px 0 0}}/*!@.component.notification .notification-header.alert*/.component.notification.sc-sdx-dialog-content .notification-header.alert.sc-sdx-dialog-content{background-image:url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" viewBox=\"0 0 360 122\" fill=\"rgb(221, 17, 34)\"><path d=\"M0,83.9V0h360v84.5C319,107.3,253.9,122,180.5,122C106.5,122,40.9,107,0,83.9z\"/></svg>')}/*!@.component.notification .notification-header.warning*/.component.notification.sc-sdx-dialog-content .notification-header.warning.sc-sdx-dialog-content{background-image:url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" viewBox=\"0 0 360 122\" fill=\"rgb(207, 74, 12)\"><path d=\"M0,83.9V0h360v84.5C319,107.3,253.9,122,180.5,122C106.5,122,40.9,107,0,83.9z\"/></svg>')}/*!@.component.notification .notification-header.general*/.component.notification.sc-sdx-dialog-content .notification-header.general.sc-sdx-dialog-content{background-image:url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" viewBox=\"0 0 360 122\" fill=\"rgb(8, 106, 219)\"><path d=\"M0,83.9V0h360v84.5C319,107.3,253.9,122,180.5,122C106.5,122,40.9,107,0,83.9z\"/></svg>')}/*!@.component.notification .notification-header.confirmation*/.component.notification.sc-sdx-dialog-content .notification-header.confirmation.sc-sdx-dialog-content{background-image:url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" viewBox=\"0 0 360 122\" fill=\"rgb(27, 135, 18)\"><path d=\"M0,83.9V0h360v84.5C319,107.3,253.9,122,180.5,122C106.5,122,40.9,107,0,83.9z\"/></svg>')}/*!@.component.notification .notification-header.gradient*/.component.notification.sc-sdx-dialog-content .notification-header.gradient.sc-sdx-dialog-content{-webkit-mask-image:url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" viewBox=\"0 0 360 122\" fill=\"rgb(0, 0, 0)\"><path d=\"M0,83.9V0h360v84.5C319,107.3,253.9,122,180.5,122C106.5,122,40.9,107,0,83.9z\"/></svg>');-webkit-mask-size:100.1%;mask-image:url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" viewBox=\"0 0 360 122\" fill=\"rgb(0, 0, 0)\"><path d=\"M0,83.9V0h360v84.5C319,107.3,253.9,122,180.5,122C106.5,122,40.9,107,0,83.9z\"/></svg>');mask-size:100% 100%}@media (max-width: 479px){/*!@.component.notification .notification-header.gradient*/.component.notification.sc-sdx-dialog-content .notification-header.gradient.sc-sdx-dialog-content{-webkit-mask-size:450px 100%;mask-size:450px 100%;-webkit-mask-position:center center;mask-position:center center}}/*!@.component.notification .notification-header sdx-button*/.component.notification.sc-sdx-dialog-content .notification-header.sc-sdx-dialog-content sdx-button.sc-sdx-dialog-content{position:absolute;right:10px;top:10px}/*!@.component.notification .notification-header sdx-icon*/.component.notification.sc-sdx-dialog-content .notification-header.sc-sdx-dialog-content sdx-icon.sc-sdx-dialog-content{font-size:80px}/*!@.component.notification .headline*/.component.notification.sc-sdx-dialog-content .headline.sc-sdx-dialog-content{display:flex;justify-content:center;padding:24px 16px 0}/*!@.component.notification .headline .h2*/.component.notification.sc-sdx-dialog-content .headline.sc-sdx-dialog-content .h2.sc-sdx-dialog-content{-webkit-box-orient:vertical;-webkit-line-clamp:2;display:-webkit-box;overflow:hidden;margin-bottom:0;color:#015;text-align:center}@media (min-width: 480px){/*!@.component.notification .headline*/.component.notification.sc-sdx-dialog-content .headline.sc-sdx-dialog-content{padding:40px 32px 0}}/*!@.component.notification .slot*/.component.notification.sc-sdx-dialog-content .slot.sc-sdx-dialog-content{max-height:calc(\n    var(--sdx-dialog-window-inner-height, 100vh) - 0px -\n      178px - 48px\n  );padding:24px 16px}@media (min-width: 480px){/*!@.component.notification .slot*/.component.notification.sc-sdx-dialog-content .slot.sc-sdx-dialog-content{max-height:calc(\n      var(--sdx-dialog-window-inner-height, 100vh) - 64px -\n        178px\n    )}}@media (min-width: 480px){/*!@.component.notification .slot*/.component.notification.sc-sdx-dialog-content .slot.sc-sdx-dialog-content{padding:24px 32px}}/*!@.component .header*/.component.sc-sdx-dialog-content .header.sc-sdx-dialog-content{display:flex;height:80px;padding-left:24px;justify-content:space-between}/*!@.component .header .label-wrapper*/.component.sc-sdx-dialog-content .header.sc-sdx-dialog-content .label-wrapper.sc-sdx-dialog-content{display:flex;align-items:center;color:#015;padding-right:24px}/*!@.component .header .label-wrapper .h4*/.component.sc-sdx-dialog-content .header.sc-sdx-dialog-content .label-wrapper.sc-sdx-dialog-content .h4.sc-sdx-dialog-content{-webkit-box-orient:vertical;-webkit-line-clamp:2;display:-webkit-box;overflow:hidden;margin-bottom:0;color:#015}/*!@.component .header .label-wrapper sdx-icon*/.component.sc-sdx-dialog-content .header.sc-sdx-dialog-content .label-wrapper.sc-sdx-dialog-content sdx-icon.sc-sdx-dialog-content{margin-left:-3px;margin-right:8px}/*!@.component .header sdx-button*/.component.sc-sdx-dialog-content .header.sc-sdx-dialog-content sdx-button.sc-sdx-dialog-content{margin:10px 10px 0 0}/*!@.component .slot*/.component.sc-sdx-dialog-content .slot.sc-sdx-dialog-content{-webkit-overflow-scrolling:touch;overflow-y:auto;max-height:calc(\n    var(--sdx-dialog-window-inner-height, 100vh) - 0px -\n      80px - 48px\n  );position:relative;padding:24px}@media (min-width: 480px){/*!@.component .slot*/.component.sc-sdx-dialog-content .slot.sc-sdx-dialog-content{max-height:calc(\n      var(--sdx-dialog-window-inner-height, 100vh) - 64px -\n        80px\n    )}}/*!@.component.sdx--dark-theme*/.component.sdx--dark-theme.sc-sdx-dialog-content{background:#242424}/*!@.component.sdx--dark-theme.notification .notification-header*/.component.sdx--dark-theme.notification.sc-sdx-dialog-content .notification-header.sc-sdx-dialog-content{color:#e6e6e6}/*!@.component.sdx--dark-theme.notification .notification-header.alert*/.component.sdx--dark-theme.notification.sc-sdx-dialog-content .notification-header.alert.sc-sdx-dialog-content{background-image:url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" viewBox=\"0 0 360 122\" fill=\"rgb(235, 18, 36)\"><path d=\"M0,83.9V0h360v84.5C319,107.3,253.9,122,180.5,122C106.5,122,40.9,107,0,83.9z\"/></svg>')}/*!@.component.sdx--dark-theme.notification .notification-header.warning*/.component.sdx--dark-theme.notification.sc-sdx-dialog-content .notification-header.warning.sc-sdx-dialog-content{background-image:url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" viewBox=\"0 0 360 122\" fill=\"rgb(206, 74, 12)\"><path d=\"M0,83.9V0h360v84.5C319,107.3,253.9,122,180.5,122C106.5,122,40.9,107,0,83.9z\"/></svg>')}/*!@.component.sdx--dark-theme.notification .notification-header.general*/.component.sdx--dark-theme.notification.sc-sdx-dialog-content .notification-header.general.sc-sdx-dialog-content{background-image:url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" viewBox=\"0 0 360 122\" fill=\"rgb(10, 113, 233)\"><path d=\"M0,83.9V0h360v84.5C319,107.3,253.9,122,180.5,122C106.5,122,40.9,107,0,83.9z\"/></svg>')}/*!@.component.sdx--dark-theme.notification .notification-header.confirmation*/.component.sdx--dark-theme.notification.sc-sdx-dialog-content .notification-header.confirmation.sc-sdx-dialog-content{background-image:url('data:image/svg+xml;charset=UTF-8,<svg xmlns=\"http://www.w3.org/2000/svg\" preserveAspectRatio=\"none\" viewBox=\"0 0 360 122\" fill=\"rgb(28, 137, 18)\"><path d=\"M0,83.9V0h360v84.5C319,107.3,253.9,122,180.5,122C106.5,122,40.9,107,0,83.9z\"/></svg>')}/*!@.component.sdx--dark-theme.notification .headline .h2*/.component.sdx--dark-theme.notification.sc-sdx-dialog-content .headline.sc-sdx-dialog-content .h2.sc-sdx-dialog-content{color:#e6e6e6}/*!@.component.sdx--dark-theme .header .label-wrapper*/.component.sdx--dark-theme.sc-sdx-dialog-content .header.sc-sdx-dialog-content .label-wrapper.sc-sdx-dialog-content{color:#e6e6e6}/*!@.component.sdx--dark-theme .header .label-wrapper .h4*/.component.sdx--dark-theme.sc-sdx-dialog-content .header.sc-sdx-dialog-content .label-wrapper.sc-sdx-dialog-content .h4.sc-sdx-dialog-content{color:#e6e6e6}";

class DialogContent {
  stateChanged({}, prev) {
    const state = this.state.get();
    const prevState = prev.get();
    if (state.display !== prevState.display) {
      this.displayChanged(state);
    }
  }
  onWindowResize() {
    const { display } = this.state.get();
    this.fixedHeightAfterFirstOpen = 0;
    if (display === "open") {
      setCssVariableWindowInnerHeight();
    }
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.fixedHeightAfterFirstOpen = 0;
    this.state = undefined;
    this.fixedHeight = false;
    this.store = new StoreConnection(this, dialogReducer, getInitialState$5(), [
      "label",
      "type",
      "iconName",
      "iconColorClass",
      "display",
      "toggle",
      "notificationType",
    ]);
  }
  connectedCallback() {
    // Register self
    this.store.set("contentEl", this.el);
  }
  disconnectedCallback() {
    // Unregister self
    this.store.set("contentEl", undefined);
  }
  componentDidLoad() {
    this.store.subscribe();
  }
  displayChanged(state) {
    switch (state.display) {
      case "opening":
        setCssVariableWindowInnerHeight();
        disableBodyScroll();
        break;
      case "open":
        const { fixedHeight, fixedHeightAfterFirstOpen, contentEl, el, closeButtonEl, } = this;
        if (fixedHeight && contentEl && !fixedHeightAfterFirstOpen) {
          const contentElHeight = contentEl.getBoundingClientRect().height;
          contentEl.style.height = `${contentElHeight}px`;
          this.fixedHeightAfterFirstOpen = contentElHeight;
        }
        // do not steal focus from child elements (e.g. select filter input field)
        if (!el.contains(document.activeElement)) {
          closeButtonEl === null || closeButtonEl === void 0 ? void 0 : closeButtonEl.doFocus();
        }
        break;
      case "closed":
        enableBodyScroll();
        break;
    }
  }
  getComponentClassNames() {
    const { notificationType } = this.state.get();
    return {
      component: true,
      [getAppearance(this.el)]: true,
      notification: !!notificationType,
    };
  }
  getNotificationHeaderClass() {
    const { notificationType } = this.state.get();
    return {
      "notification-header": true,
      [`${notificationType}`]: true,
    };
  }
  toggle() {
    this.store.set("userInteractionInProgress", true);
    this.state.get().toggle();
    this.store.set("userInteractionInProgress", false);
  }
  createClosebutton(dark) {
    return (hAsync("sdx-button", { theme: "transparent", iconName: "icon-close", iconSize: 2, srHint: "close dialog", background: dark ? "dark" : undefined, onClick: () => this.toggle(), ref: (el) => (this.closeButtonEl = el) }));
  }
  render() {
    const { label, type: typeState, notificationType, iconName, iconColorClass, } = this.state.get();
    return (hAsync("div", { ref: (el) => (this.contentEl = el), class: this.getComponentClassNames(), role: "dialog", "aria-modal": "true", "aria-labelledby": "sdx-dialog-content-label", "aria-describedby": "sdx-dialog-content-description" }, hAsync("sdx-trap-focus", { firstFocusableElement: this.closeButtonEl, lang: this.el.lang }, 
    // modal with default header
    !notificationType && (hAsync("div", { class: "header" }, hAsync("div", { class: "label-wrapper" }, iconName && (hAsync("sdx-icon", { iconName: iconName, colorClass: iconColorClass, size: 2 })), hAsync("h1", { class: "h4", id: "sdx-dialog-content-label" }, label)), typeState === "closable-modal" &&
      this.createClosebutton(false))), 
    // modal with "notification-type"
    notificationType && (hAsync(Fragment, null, hAsync("div", { class: this.getNotificationHeaderClass() }, iconName && hAsync("sdx-icon", { iconName: iconName }), typeState === "closable-modal" &&
      this.createClosebutton(true)), label && (hAsync("div", { class: "headline" }, hAsync("h1", { class: "h2", id: "sdx-dialog-content-label" }, label))))), hAsync("div", { class: "slot", id: "sdx-dialog-content-description", tabindex: 0 }, hAsync("slot", null)))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "state": ["stateChanged"]
  }; }
  static get style() { return dialogContentCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-dialog-content",
    "$members$": {
      "fixedHeight": [4, "fixed-height"],
      "state": [32]
    },
    "$listeners$": [[9, "resize", "onWindowResize"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const dialogToggleCss = "";

class DialogToggle {
  onClick() {
    this.store.set("userInteractionInProgress", true);
    this.state.get().toggle();
    this.store.set("userInteractionInProgress", false);
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.state = undefined;
    this.store = new StoreConnection(this, dialogReducer, getInitialState$5(), [
      "toggle",
    ]);
  }
  connectedCallback() {
    // Register self
    this.store.set("toggleEl", this.el);
  }
  disconnectedCallback() {
    // Unregister self
    this.store.set("toggleEl", undefined);
  }
  componentDidLoad() {
    this.store.subscribe();
  }
  render() {
    return hAsync("slot", null);
  }
  get el() { return getElement(this); }
  static get style() { return dialogToggleCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-dialog-toggle",
    "$members$": {
      "state": [32]
    },
    "$listeners$": [[0, "click", "onClick"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

/**
 * This is a dummy component that does nothing but printing its children.
 * Used only for test or debug purposes.
 */
class Dummy {
  constructor(hostRef) {
    registerInstance(this, hostRef);
  }
  render() {
    return hAsync("slot", null);
  }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-dummy",
    "$members$": undefined,
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/** Built-in value references. */
var Symbol$1 = root.Symbol;

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/** Used for built-in method references. */
var objectProto$1 = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto$1.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString$1 = objectProto$1.toString;

/** Built-in value references. */
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag$1),
      tag = value[symToStringTag$1];

  try {
    value[symToStringTag$1] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol$1 ? Symbol$1.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && baseGetTag(value) == symbolTag);
}

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return arrayMap(value, baseToString) + '';
  }
  if (isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString(value) {
  return value == null ? '' : baseToString(value);
}

/** Used to generate unique IDs. */
var idCounter = 0;

/**
 * Generates a unique ID. If `prefix` is given, the ID is appended to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {string} [prefix=''] The value to prefix the ID with.
 * @returns {string} Returns the unique ID.
 * @example
 *
 * _.uniqueId('contact_');
 * // => 'contact_104'
 *
 * _.uniqueId();
 * // => '105'
 */
function uniqueId(prefix) {
  var id = ++idCounter;
  return toString(prefix) + id;
}

const expandAndCollapseCss = "/*!@:root*/.sc-sdx-expand-and-collapse:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-expand-and-collapse-h,*.sc-sdx-expand-and-collapse,*.sc-sdx-expand-and-collapse:before,*.sc-sdx-expand-and-collapse:after{box-sizing:border-box}/*!@.sr-only*/.sr-only.sc-sdx-expand-and-collapse{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);border:0}/*!@.sr-only-focusable:active, .sr-only-focusable:focus*/.sr-only-focusable.sc-sdx-expand-and-collapse:active,.sr-only-focusable.sc-sdx-expand-and-collapse:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}/*!@.component sdx-accordion-item-header:hover span*/.component.sc-sdx-expand-and-collapse sdx-accordion-item-header.sc-sdx-expand-and-collapse:hover span.sc-sdx-expand-and-collapse{color:#0048cf}/*!@.component sdx-accordion-item-header span*/.component.sc-sdx-expand-and-collapse sdx-accordion-item-header.sc-sdx-expand-and-collapse span.sc-sdx-expand-and-collapse{color:#086adb;transition:color 200ms cubic-bezier(0.4, 0, 0.6, 1)}/*!@.component.sdx--dark-theme sdx-accordion-item-header:hover span*/.component.sdx--dark-theme.sc-sdx-expand-and-collapse sdx-accordion-item-header.sc-sdx-expand-and-collapse:hover span.sc-sdx-expand-and-collapse{color:#5ca3ff}/*!@.component.sdx--dark-theme sdx-accordion-item-header span*/.component.sdx--dark-theme.sc-sdx-expand-and-collapse sdx-accordion-item-header.sc-sdx-expand-and-collapse span.sc-sdx-expand-and-collapse{color:#4294ff}";

class ExpandAndCollapse {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.uniqueId = uniqueId();
    this.open = false;
    this.expandLabel = "";
    this.collapseLabel = "";
    this.arrowPosition = "fixed";
    this.srHint = "";
  }
  toggle() {
    this.open = !this.open;
  }
  getAccordionStyles() {
    return {
      accordion: {
        border: "none",
      },
      header: {
        fontSize: "inherit",
        padding: "0",
        justifyContent: "flex-end",
        alignItems: "flex-start",
      },
      body: {
        margin: this.arrowPosition === "dynamic" ? "0 0 8px 0" : "8px 0 16px 0",
      },
      arrow: {
        top: "12px", // align arrow with first line of label's text
      },
    };
  }
  getComponentClassNames() {
    return {
      component: true,
      [getAppearance(this.el)]: true,
    };
  }
  createHeader() {
    const { arrow, header } = this.getAccordionStyles();
    return (hAsync("sdx-accordion-item-header", { id: this.uniqueId, onClick: () => this.toggle(), arrowStyle: arrow, buttonStyle: header }, hAsync("span", null, this.open ? this.collapseLabel : this.expandLabel), this.srHint && hAsync("span", { class: "sr-only" }, "\u00A0", this.srHint)));
  }
  render() {
    return (hAsync("sdx-accordion", { arrowPosition: "left", componentStyle: this.getAccordionStyles().accordion, class: this.getComponentClassNames() }, hAsync("sdx-accordion-item", { open: this.open }, this.arrowPosition === "fixed" && this.createHeader(), hAsync("sdx-accordion-item-body", { role: "region", "aria-labelledby": this.uniqueId, componentStyle: this.getAccordionStyles().body }, hAsync("slot", null)), this.arrowPosition === "dynamic" && this.createHeader())));
  }
  get el() { return getElement(this); }
  static get style() { return expandAndCollapseCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-expand-and-collapse",
    "$members$": {
      "open": [1028],
      "expandLabel": [1, "expand-label"],
      "collapseLabel": [1, "collapse-label"],
      "arrowPosition": [1, "arrow-position"],
      "srHint": [1, "sr-hint"]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}
/**
 * Emitted when the component's visibility updates.
 * @event
 * @param display "open" | "opening" | "closed" | "closing"
 */
// @ts-ignore just for documentation purposes
ExpandAndCollapse.eventSdxDisplayChange = "sdxdisplaychange";

const figmaCss = "/*!@:root*/.sc-sdx-figma:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-figma-h,*.sc-sdx-figma,*.sc-sdx-figma:before,*.sc-sdx-figma:after{box-sizing:border-box}/*!@.component*/.component.sc-sdx-figma{display:flex;align-items:center;justify-content:center;background-color:#eef3f6;border-radius:12px}/*!@.component sdx-loading-spinner*/.component.sc-sdx-figma sdx-loading-spinner.sc-sdx-figma{position:absolute;visibility:hidden}/*!@.component sdx-loading-spinner.hidden*/.component.sc-sdx-figma sdx-loading-spinner.hidden.sc-sdx-figma{visibility:visible}/*!@.component iframe*/.component.sc-sdx-figma iframe.sc-sdx-figma{border:1px solid #d6d6d6;border-radius:12px}/*!@.component iframe.hidden*/.component.sc-sdx-figma iframe.hidden.sc-sdx-figma{position:fixed;visibility:hidden}/*!@.component.sdx--dark-theme*/.component.sdx--dark-theme.sc-sdx-figma{background-color:#1d1d1d}/*!@.component.sdx--dark-theme iframe*/.component.sdx--dark-theme.sc-sdx-figma iframe.sc-sdx-figma{border-color:#5c5c5c}";

class Figma {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.hasLoaded = false;
    this.showLoadingIndicator = true;
    this.elWidth = 999;
    this.url = "";
    this.height = 450;
    this.allowFullScreen = undefined;
  }
  onMessage(event) {
    var _a;
    // needed because figma just shows a black page while loading
    const elHidden = this.el.offsetParent === null;
    if (event.data === "LOAD_FINISHED" &&
      event.origin.includes("figma.com") &&
      event.source === ((_a = this.iframeEl) === null || _a === void 0 ? void 0 : _a.contentWindow) &&
      !elHidden) {
      this.showLoadingIndicator = false;
      this.hasLoaded = true;
    }
  }
  /**
   * Loads the url from the iFrame if needed.
   */
  async load() {
    var _a;
    if (!this.hasLoaded && this.iframeEl) {
      this.elWidth = this.el.getBoundingClientRect().width; // get width when el is visible
      (_a = this.iframeEl.contentWindow) === null || _a === void 0 ? void 0 : _a.location.replace(`https://www.figma.com/embed?embed_host=share&url=${this.url}`);
    }
  }
  componentWillLoad() {
    // shrink height on mobiles
    if (!bp("md")) {
      this.height = this.height * 0.6;
    }
  }
  componentDidLoad() {
    // start loading if element is visible initially
    if (this.el.offsetParent) {
      this.load();
    }
  }
  getElementsClassNames() {
    return {
      hidden: this.showLoadingIndicator,
    };
  }
  getComponentClassNames() {
    return {
      component: true,
      [getAppearance(this.el)]: true,
    };
  }
  render() {
    return (hAsync("div", { class: this.getComponentClassNames(), style: { height: `${this.height}px` } }, hAsync("sdx-loading-spinner", { class: this.getElementsClassNames(), size: "large" }), hAsync("iframe", { title: "Figma design", ref: (el) => (this.iframeEl = el), class: this.getElementsClassNames(), style: {
        height: `${this.height}px`,
        width: `${this.elWidth}px`,
      }, allowFullScreen: this.allowFullScreen })));
  }
  get el() { return getElement(this); }
  static get style() { return figmaCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-figma",
    "$members$": {
      "url": [1],
      "height": [2],
      "allowFullScreen": [4, "allow-full-screen"],
      "showLoadingIndicator": [32],
      "elWidth": [32],
      "load": [64]
    },
    "$listeners$": [[8, "message", "onMessage"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const filterCss = "/*!@:root*/.sc-sdx-filter:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-filter-h,*.sc-sdx-filter,*.sc-sdx-filter:before,*.sc-sdx-filter:after{box-sizing:border-box}/*!@:host*/.sc-sdx-filter-h{display:block}/*!@.component .scroll-view-wrapper .chips-wrapper*/.component.sc-sdx-filter .scroll-view-wrapper.sc-sdx-filter .chips-wrapper.sc-sdx-filter{display:flex;gap:16px}/*!@.component .scroll-view-wrapper.space*/.component.sc-sdx-filter .scroll-view-wrapper.space.sc-sdx-filter{margin-top:32px}/*!@.component .result*/.component.sc-sdx-filter .result.sc-sdx-filter{display:block;margin-top:16px}";

class Filter {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.sdxdeselectrequest = createEvent(this, "sdxdeselectrequest", 7);
    this.animationEls = new Map();
    this.componentDidLoadComplete = false;
    this.selectedOptionsRemoved = [];
    this.selection = [];
    this.showMoreLabel = translate("Show more filters");
    this.showLessLabel = translate("Show less filters");
    this.resetAllFiltersLabel = translate("Reset all filters");
    this.resultLabel = "";
    this.animated = true;
  }
  onSelectedOptionsChanged(newSelection, oldSelection) {
    // mark options to show remove animation in componentWillUpdate
    oldSelection.forEach((oldOption) => {
      if (!newSelection.includes(oldOption)) {
        this.selectedOptionsRemoved.push(oldOption);
      }
    });
    if (!newSelection.length) {
      this.selectedOptionsRemoved.push(this.resetAllFiltersLabel);
    }
  }
  async componentWillUpdate() {
    await Promise.all(this.selectedOptionsRemoved.map((option) => {
      const animationEl = this.animationEls.get(option);
      this.animationEls.delete(option);
      return animationEl === null || animationEl === void 0 ? void 0 : animationEl.runAnimation("scale-out");
    }));
    this.selectedOptionsRemoved = [];
    // workaround for SDX-1477
    setTimeout(() => { var _a; return (_a = this.scrollViewEl) === null || _a === void 0 ? void 0 : _a.layout(); }, 200);
  }
  componentDidLoad() {
    this.componentDidLoadComplete = true;
  }
  createChipEl(label) {
    const isNew = !this.animationEls.get(label);
    let addAnimationProps = {
      animationName: "scale-in",
    };
    if (isNew && this.componentDidLoadComplete) {
      addAnimationProps = {
        animationName: "scale-out",
        animationNameFirstRender: "scale-in",
      };
    }
    return (hAsync("sdx-animation", { ref: (el) => this.animationEls.set(label, el), key: label, ...addAnimationProps, animationDuration: this.animated ? undefined : 0 }, hAsync("sdx-button", { theme: "chip", label: label, onClick: (e) => {
        this.sdxdeselectrequest.emit({
          label: e.target.label,
        });
      } })));
  }
  getScrollViewWrapperClassNames() {
    return {
      "scroll-view-wrapper": true,
      space: this.selection.length > 0,
    };
  }
  render() {
    return (hAsync("div", { class: "component" }, hAsync("slot", null), this.el.querySelectorAll("[slot=filter-more]").length > 0 && (hAsync("sdx-expand-and-collapse", { "arrow-position": "fixed", "expand-label": this.showMoreLabel, "collapse-label": this.showLessLabel }, hAsync("slot", { name: "filter-more" }))), hAsync("div", { class: this.getScrollViewWrapperClassNames() }, hAsync("sdx-scroll-view", { ref: (el) => (this.scrollViewEl = el) }, hAsync("div", { class: "chips-wrapper" }, this.selection.length > 0 &&
      this.createChipEl(this.resetAllFiltersLabel), this.selection.map((option) => this.createChipEl(option))))), this.resultLabel && hAsync("span", { class: "result" }, this.resultLabel)));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "selection": ["onSelectedOptionsChanged"]
  }; }
  static get style() { return filterCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-filter",
    "$members$": {
      "selection": [16],
      "showMoreLabel": [1, "show-more-label"],
      "showLessLabel": [1, "show-less-label"],
      "resetAllFiltersLabel": [1, "reset-all-filters-label"],
      "resultLabel": [1, "result-label"],
      "animated": [4]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const filterExampleLargeCss = ":root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}:host,*,*:before,*:after{box-sizing:border-box}.results{display:flex;flex-direction:column;gap:16px;margin-top:48px}.results div{background:#eef3f6;border-radius:6px;height:48px}";

class FilterExampleLarge {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.selection = ["SAP", "DOCP"];
    this.maxResults = 10;
    this.service = [
      { value: "sap", label: "SAP" },
      { value: "docp", label: "DOCP" },
      { value: "network", label: "Network" },
      { value: "security", label: "Security" },
      { value: "twint", label: "TWINT" },
      { value: "mastercard", label: "Mastercard" },
      { value: "postfinance", label: "Postfinance" },
      { value: "allegro", label: "Allegro" },
      { value: "bancomat", label: "Bancomat" },
    ];
    this.incident = [
      { value: "resolved", label: "Resolved" },
      { value: "unresolved", label: "Unresolved" },
    ];
    this.priority = [
      { value: "total", label: "Total" },
      { value: "critical", label: "Critical" },
      { value: "high", label: "High" },
      { value: "medium", label: "Medium" },
      { value: "low", label: "Low" },
    ];
    this.connection = [
      { value: "lightning", label: "Lightning" },
      { value: "usb-c", label: "USB-C" },
    ];
    this.os = [
      { value: "android", label: "Android" },
      { value: "ios", label: "Apple iOS" },
    ];
    this.breach = {
      value: "breach",
      label: "Display only with breaches",
    };
    this.unresolved = {
      value: "unresolved",
      label: "Display unresolved",
    };
    this.dateFrom = {
      value: "",
      name: "dateFrom",
      label: "From",
    };
    this.dateTo = {
      value: "",
      name: "dateTo",
      label: "To",
    };
  }
  removeFromSelection(label) {
    this.selection = this.selection.filter((item) => item !== label);
  }
  updateSelectionSingle(label, add) {
    if (add && !this.selection.includes(label)) {
      this.selection = [...this.selection, label];
    }
    else if (!add) {
      this.removeFromSelection(label);
    }
  }
  updateSelectionMultiple(model, selectedOptions) {
    model.forEach((option) => {
      const shouldBeSelected = selectedOptions.find((s) => s.label === option.label);
      const isAlreadySelected = this.selection.includes(option.label);
      if (!shouldBeSelected) {
        this.removeFromSelection(option.label);
      }
      else if (!isAlreadySelected) {
        this.selection = [...this.selection, option.label];
      }
    });
  }
  createDateValue(filterOption) {
    const selectionLabel = this.createDateSelectionLabel(filterOption.label, filterOption.value);
    return this.selection.includes(selectionLabel) ? filterOption.value : "";
  }
  createDateSelectionLabel(label, value) {
    return value ? `${label} ${value}` : "";
  }
  createDateElement(model) {
    return (hAsync("sdx-input", { value: this.createDateValue(model), label: model.label, name: model.name, type: "date", placeholder: "01.01.2023", onInput: (e) => {
        const target = e.target;
        const oldLabel = this.createDateSelectionLabel(model.label, model.value);
        const label = this.createDateSelectionLabel(model.label, target.value);
        model.value = target.value; // update model
        this.updateSelectionSingle(oldLabel, false); // remove old label from selection
        this.updateSelectionSingle(label, !!target.value.length); // add new label to selection if needed
      } }));
  }
  render() {
    const results = this.maxResults - this.selection.length;
    return (hAsync(Host, null, hAsync("sdx-filter", { resultLabel: results > 0 ? `${results} results found` : "", selection: this.selection, onSdxdeselectrequest: (e) => {
        var _a;
        if (((_a = e.detail) === null || _a === void 0 ? void 0 : _a.label) === e.target.resetAllFiltersLabel) {
          this.selection = [];
        }
        else {
          this.removeFromSelection(e.detail.label);
        }
      }, class: "margin-bottom-4" }, hAsync("div", { class: "row" }, hAsync("div", { class: "col-xs-12 col-sm-auto margin-xs-bottom-2 margin-sm-bottom-0" }, hAsync("sdx-select", { multiple: true, label: "Services", onInput: (e) => {
        this.updateSelectionMultiple(this.service, e.target.value);
      } }, this.service.map((item) => (hAsync("sdx-select-option", { value: item, selected: this.selection.includes(item.label) }, item.label))))), hAsync("div", { class: "col-xs-12 col-sm-auto margin-xs-bottom-2 margin-sm-bottom-0" }, hAsync("sdx-select", { multiple: true, label: "Incident type", onInput: (e) => {
        this.updateSelectionMultiple(this.incident, e.target.value);
      } }, this.incident.map((item) => (hAsync("sdx-select-option", { value: item, selected: this.selection.includes(item.label) }, item.label))))), hAsync("div", { class: "col-xs-12 col-sm-auto margin-bottom-2" }, hAsync("sdx-select", { multiple: true, label: "Priority Level", onInput: (e) => {
        this.updateSelectionMultiple(this.priority, e.target.value);
      } }, this.priority.map((item) => (hAsync("sdx-select-option", { value: item, selected: this.selection.includes(item.label) }, item.label)))))), hAsync("div", { class: "row margin-top-2 margin-bottom-4" }, hAsync("div", { class: "col-xs-12 col-sm-auto margin-xs-bottom-2 margin-sm-bottom-0" }, this.createDateElement(this.dateFrom)), hAsync("div", { class: "col-xs-12 col-sm-auto" }, this.createDateElement(this.dateTo))), hAsync("div", { class: "row" }, hAsync("div", { class: "col-xs-12 col-sm-auto margin-xs-bottom-2 margin-sm-bottom-0" }, hAsync("sdx-input-item", { value: this.breach, type: "checkbox", checked: this.selection.includes(this.breach.label), onInput: (e) => {
        const target = e.target;
        this.updateSelectionSingle(target.value.label, target.checked);
      } }, this.breach.label)), hAsync("div", { class: "col-xs-12 col-sm-auto margin-bottom-2" }, hAsync("sdx-input-item", { value: this.unresolved, type: "checkbox", checked: this.selection.includes(this.unresolved.label), onInput: (e) => {
        const target = e.target;
        this.updateSelectionSingle(target.value.label, target.checked);
      } }, this.unresolved.label))), hAsync("div", { class: "row", slot: "filter-more" }, hAsync("div", { class: "col-xs-12 col-sm-auto margin-xs-bottom-2 margin-sm-bottom-0" }, hAsync("sdx-select", { multiple: true, label: "Connections", onInput: (e) => {
        this.updateSelectionMultiple(this.connection, e.target.value);
      } }, this.connection.map((item) => (hAsync("sdx-select-option", { value: item, selected: this.selection.includes(item.label) }, item.label))))), hAsync("div", { class: "col-xs-12 col-sm-auto" }, hAsync("sdx-select", { multiple: true, label: "Operating system", onInput: (e) => {
        this.updateSelectionMultiple(this.os, e.target.value);
      } }, this.os.map((item) => (hAsync("sdx-select-option", { value: item, selected: this.selection.includes(item.label) }, item.label))))))), results > 0 && (hAsync("div", { class: "results" }, [...Array(results)].map(() => (hAsync("div", null, "\u00A0")))))));
  }
  static get style() { return filterExampleLargeCss; }
  static get cmpMeta() { return {
    "$flags$": 0,
    "$tagName$": "sdx-filter-example-large",
    "$members$": {
      "selection": [32],
      "maxResults": [32],
      "service": [32],
      "incident": [32],
      "priority": [32],
      "connection": [32],
      "os": [32],
      "breach": [32],
      "unresolved": [32],
      "dateFrom": [32],
      "dateTo": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

class FilterExampleSmall {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.selection = [];
    this.category = [
      { value: "airpodcases", label: "Airpod cases" },
      { value: "cover", label: "Cover" },
      { value: "headphones", label: "Headphones" },
      { value: "charging-cable", label: "Charging cable" },
    ];
    this.smartphone = [
      { value: "iphone14", label: "iPhone 14" },
      { value: "iphone13", label: "iPhone 13" },
      { value: "iphonese", label: "iPhone SE" },
      { value: "iphone11promax", label: "iPhone 11 Pro Max" },
      { value: "galaxy3", label: "Samsung Galaxy S3" },
      { value: "galaxy9", label: "Samsung Galaxy S9" },
      { value: "lumia925", label: "Nokia Lumia 925" },
      { value: "huaweiP9", label: "Huawei P9" },
      { value: "huaweiP9plus", label: "Huawei P9 Plus" },
      { value: "lg5", label: "LG G5" },
    ];
    this.color = [
      { value: "blue", label: "Blue" },
      { value: "brown", label: "Brown" },
      { value: "green", label: "Green" },
      { value: "orange", label: "Orange" },
      { value: "pink", label: "Pink" },
      { value: "red", label: "Red" },
      { value: "silver", label: "Silver" },
      { value: "violet", label: "Violet" },
      { value: "yellow", label: "Yellow" },
    ];
  }
  removeFromSelection(label) {
    this.selection = this.selection.filter((item) => item !== label);
  }
  updateSelectionMultiple(model, selectedOptions) {
    model.forEach((option) => {
      const shouldBeSelected = selectedOptions.find((s) => s.label === option.label);
      const isAlreadySelected = this.selection.includes(option.label);
      if (!shouldBeSelected) {
        this.removeFromSelection(option.label);
      }
      else if (!isAlreadySelected) {
        this.selection = [...this.selection, option.label];
      }
    });
  }
  render() {
    return (hAsync("sdx-filter", { selection: this.selection, onSdxdeselectrequest: (e) => {
        var _a;
        if (((_a = e.detail) === null || _a === void 0 ? void 0 : _a.label) === e.target.resetAllFiltersLabel) {
          this.selection = [];
        }
        else {
          this.removeFromSelection(e.detail.label);
        }
      }, class: "margin-bottom-4" }, hAsync("div", { style: { display: "flex", gap: "16px" } }, hAsync("sdx-select", { multiple: true, label: "Category", onInput: (e) => {
        this.updateSelectionMultiple(this.category, e.target.value);
      } }, this.category.map((item) => (hAsync("sdx-select-option", { value: item, selected: this.selection.includes(item.label) }, item.label)))), hAsync("sdx-select", { multiple: true, label: "Model", onInput: (e) => {
        this.updateSelectionMultiple(this.smartphone, e.target.value);
      } }, this.smartphone.map((item) => (hAsync("sdx-select-option", { value: item, selected: this.selection.includes(item.label) }, item.label)))), hAsync("sdx-select", { multiple: true, label: "Colours", onInput: (e) => {
        this.updateSelectionMultiple(this.color, e.target.value);
      } }, this.color.map((item) => (hAsync("sdx-select-option", { value: item, selected: this.selection.includes(item.label) }, hAsync("span", { style: {
        background: item.value,
        height: "16px",
        width: "16px",
        borderRadius: "50%",
        display: "inline-block",
        position: "relative",
        top: "2px",
        left: "-3px",
      } }), " ", item.label)))))));
  }
  static get cmpMeta() { return {
    "$flags$": 0,
    "$tagName$": "sdx-filter-example-small",
    "$members$": {
      "selection": [32],
      "category": [32],
      "smartphone": [32],
      "color": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

class Flip {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.direction = "none";
  }
  componentWillLoad() {
    this.el.style.display = "inline-block"; // make transformable
    this.el.style.transform = `scaleX(${this.getFlipTransformStyle("x")}) scaleY(${this.getFlipTransformStyle("y")})`;
  }
  getFlipTransformStyle(axis) {
    const map = {
      none: {
        x: 1,
        y: 1,
      },
      horizontal: {
        x: -1,
        y: 1,
      },
      vertical: {
        x: 1,
        y: -1,
      },
      both: {
        x: -1,
        y: -1,
      },
    };
    return map[this.direction][axis];
  }
  render() {
    return hAsync("slot", null);
  }
  get el() { return getElement(this); }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-flip",
    "$members$": {
      "direction": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

/**
 * A specialized version of `_.reduce` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {*} [accumulator] The initial value.
 * @param {boolean} [initAccum] Specify using the first element of `array` as
 *  the initial value.
 * @returns {*} Returns the accumulated value.
 */
function arrayReduce(array, iteratee, accumulator, initAccum) {
  var index = -1,
      length = array == null ? 0 : array.length;

  if (initAccum && length) {
    accumulator = array[++index];
  }
  while (++index < length) {
    accumulator = iteratee(accumulator, array[index], index, array);
  }
  return accumulator;
}

/**
 * The base implementation of `_.propertyOf` without support for deep paths.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Function} Returns the new accessor function.
 */
function basePropertyOf(object) {
  return function(key) {
    return object == null ? undefined : object[key];
  };
}

/** Used to map Latin Unicode letters to basic Latin letters. */
var deburredLetters = {
  // Latin-1 Supplement block.
  '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  '\xc7': 'C',  '\xe7': 'c',
  '\xd0': 'D',  '\xf0': 'd',
  '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  '\xd1': 'N',  '\xf1': 'n',
  '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  '\xc6': 'Ae', '\xe6': 'ae',
  '\xde': 'Th', '\xfe': 'th',
  '\xdf': 'ss',
  // Latin Extended-A block.
  '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  '\u0134': 'J',  '\u0135': 'j',
  '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  '\u0174': 'W',  '\u0175': 'w',
  '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  '\u0132': 'IJ', '\u0133': 'ij',
  '\u0152': 'Oe', '\u0153': 'oe',
  '\u0149': "'n", '\u017f': 's'
};

/**
 * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
 * letters to basic Latin letters.
 *
 * @private
 * @param {string} letter The matched letter to deburr.
 * @returns {string} Returns the deburred letter.
 */
var deburrLetter = basePropertyOf(deburredLetters);

/** Used to match Latin Unicode letters (excluding mathematical operators). */
var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

/** Used to compose unicode character classes. */
var rsComboMarksRange$1 = '\\u0300-\\u036f',
    reComboHalfMarksRange$1 = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange$1 = '\\u20d0-\\u20ff',
    rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1;

/** Used to compose unicode capture groups. */
var rsCombo$1 = '[' + rsComboRange$1 + ']';

/**
 * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
 * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
 */
var reComboMark = RegExp(rsCombo$1, 'g');

/**
 * Deburrs `string` by converting
 * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
 * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
 * letters to basic Latin letters and removing
 * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to deburr.
 * @returns {string} Returns the deburred string.
 * @example
 *
 * _.deburr('déjà vu');
 * // => 'deja vu'
 */
function deburr(string) {
  string = toString(string);
  return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
}

/** Used to match words composed of alphanumeric characters. */
var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

/**
 * Splits an ASCII `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function asciiWords(string) {
  return string.match(reAsciiWord) || [];
}

/** Used to detect strings that need a more robust regexp to match words. */
var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

/**
 * Checks if `string` contains a word composed of Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a word is found, else `false`.
 */
function hasUnicodeWord(string) {
  return reHasUnicodeWord.test(string);
}

/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsDingbatRange = '\\u2700-\\u27bf',
    rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
    rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
    rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
    rsPunctuationRange = '\\u2000-\\u206f',
    rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
    rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
    rsVarRange = '\\ufe0e\\ufe0f',
    rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

/** Used to compose unicode capture groups. */
var rsApos$1 = "['\u2019]",
    rsBreak = '[' + rsBreakRange + ']',
    rsCombo = '[' + rsComboRange + ']',
    rsDigits = '\\d+',
    rsDingbat = '[' + rsDingbatRange + ']',
    rsLower = '[' + rsLowerRange + ']',
    rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    rsUpper = '[' + rsUpperRange + ']',
    rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
    rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
    rsOptContrLower = '(?:' + rsApos$1 + '(?:d|ll|m|re|s|t|ve))?',
    rsOptContrUpper = '(?:' + rsApos$1 + '(?:D|LL|M|RE|S|T|VE))?',
    reOptMod = rsModifier + '?',
    rsOptVar = '[' + rsVarRange + ']?',
    rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
    rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq;

/** Used to match complex or compound words. */
var reUnicodeWord = RegExp([
  rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
  rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
  rsUpper + '+' + rsOptContrUpper,
  rsOrdUpper,
  rsOrdLower,
  rsDigits,
  rsEmoji
].join('|'), 'g');

/**
 * Splits a Unicode `string` into an array of its words.
 *
 * @private
 * @param {string} The string to inspect.
 * @returns {Array} Returns the words of `string`.
 */
function unicodeWords(string) {
  return string.match(reUnicodeWord) || [];
}

/**
 * Splits `string` into an array of its words.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to inspect.
 * @param {RegExp|string} [pattern] The pattern to match words.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Array} Returns the words of `string`.
 * @example
 *
 * _.words('fred, barney, & pebbles');
 * // => ['fred', 'barney', 'pebbles']
 *
 * _.words('fred, barney, & pebbles', /[^, ]+/g);
 * // => ['fred', 'barney', '&', 'pebbles']
 */
function words(string, pattern, guard) {
  string = toString(string);
  pattern = guard ? undefined : pattern;

  if (pattern === undefined) {
    return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  }
  return string.match(pattern) || [];
}

/** Used to compose unicode capture groups. */
var rsApos = "['\u2019]";

/** Used to match apostrophes. */
var reApos = RegExp(rsApos, 'g');

/**
 * Creates a function like `_.camelCase`.
 *
 * @private
 * @param {Function} callback The function to combine each word.
 * @returns {Function} Returns the new compounder function.
 */
function createCompounder(callback) {
  return function(string) {
    return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  };
}

/**
 * Converts `string` to
 * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the kebab cased string.
 * @example
 *
 * _.kebabCase('Foo Bar');
 * // => 'foo-bar'
 *
 * _.kebabCase('fooBar');
 * // => 'foo-bar'
 *
 * _.kebabCase('__FOO_BAR__');
 * // => 'foo-bar'
 */
var kebabCase = createCompounder(function(result, word, index) {
  return result + (index ? '-' : '') + word.toLowerCase();
});

let onExternalLinkClickHandler = () => undefined;
function setOnExternalLinkClickHandler(fn) {
  onExternalLinkClickHandler = fn;
}
/**
 * Checks if an item is an external link (a.k.a. a "real" link):
 * Basically, an item without children is considered an external link.
 * However, it could have children that are all hidden (even if it's just one),
 * which would lead to treating the link like one without children (e.g. a
 * deeply nested page that does not appear in the menu, but in the breadcrumbs,
 * just like the "Samsung > Samsung Galaxy Watch 4" example).
 * Additionally, also check for href, because a link that simply opens an
 * sdx-header-menu, is technically also a link (but not an external one).
 * @param item Item to check.
 */
function isExternalLink(item) {
  const children = getVisibleItems(item.children);
  return !!item.href && (!children.length || !!item.hasLeftHandMenu);
}
function getAccordionStyles() {
  return {
    accordion: {
      border: "none",
    },
    header: {
      fontSize: "inherit",
      fontWeight: "inherit",
      lineHeight: "inherit",
      padding: "0",
    },
    arrow: {
      background: "#015", // $color-navy
    },
    body: {
      marginLeft: "8px",
      marginRight: "0",
      marginBottom: "0",
    },
  };
}
function getMaxDepth(items) {
  const itemsDepths = items
    .filter((item) => Number(item.depth))
    .map((item) => item.depth);
  return Math.max(...itemsDepths);
}
function getItemClassNames(item, allItems, activeItems, maxAllowedDepth = 0, depth = 0) {
  const maxDepth = getMaxDepth(allItems);
  const maxDepthEffective = maxDepth < maxAllowedDepth ? maxDepth : maxAllowedDepth;
  return {
    item: true,
    leaf: !getVisibleItems(item.children).length || !!item.hasLeftHandMenu,
    active: activeItems.includes(item),
    deepest: depth === maxDepthEffective,
  };
}
function createLink(item, props = {}, ref = () => undefined) {
  const unique = uniqueId();
  let label = item.label;
  if (item.slot && !item.showLabelOnDesktop) {
    label = undefined;
  }
  return (hAsync("a", { onClick: (e) => {
      if (isExternalLink(item)) {
        onExternalLinkClickHandler(e, item);
      }
    }, href: item.href, class: "link", rel: item.rel, "aria-current": item.active ? "location" : false, "aria-label": item.ariaLabel || item.label || item.iconName, "aria-describedby": unique, "aria-expanded": item.ariaExpanded, ...objectMap(item.dataset, (key, value) => ({
      [`data-${kebabCase(key)}`]: value,
    })), ...props }, item.content ? (item.content) : item.iconName ? (hAsync("span", { class: "icon-label-wrapper", id: unique },
    hAsync("sdx-icon", { size: item.iconSize, iconName: item.iconName, class: { icon: true, [item.iconName]: true } }),
    label && (hAsync("span", { class: "label", ref: ref }, label)),
    item.badge && hAsync("span", { class: "badge" }, item.badge))) : (hAsync("span", { id: unique }, label))));
}
function getVisibleItems(items = []) {
  return items.filter((child) => !child.hidden);
}
function createItemForAccordion(item, allItems, activeItems, arrowPosition, styles, maxAllowedDepth = Infinity, skipLeftHandMenu = false, depth = 0) {
  if (item.hidden) {
    return;
  }
  const { accordion, header, arrow, body } = getAccordionStyles();
  const children = getVisibleItems(item.children);
  depth = depth + 1;
  return (hAsync("li", { class: getItemClassNames(item, allItems, activeItems, maxAllowedDepth, depth) }, children.length &&
    depth < maxAllowedDepth &&
    !(item.hasLeftHandMenu && skipLeftHandMenu) ? (hAsync("sdx-accordion", { arrowPosition: arrowPosition, componentStyle: { ...accordion, ...styles.accordion } },
    hAsync("sdx-accordion-item", { open: activeItems.includes(item) },
      hAsync("sdx-accordion-item-header", { buttonStyle: { ...header, ...styles.header }, arrowStyle: { ...arrow, ...styles.arrow } }, createLink(item, { href: "javascript:;" })),
      hAsync("sdx-accordion-item-body", { componentStyle: { ...body, ...styles.body } },
        hAsync("ul", { class: "list vertical" }, children.map((item) => createItemForAccordion(item, allItems, activeItems, arrowPosition, styles, maxAllowedDepth, skipLeftHandMenu, depth))))))) : (createLink(item))));
}

const headerCss$1 = "/*!@:root*/.sc-sdx-header:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-header-h,*.sc-sdx-header,*.sc-sdx-header:before,*.sc-sdx-header:after{box-sizing:border-box}/*!@.text-body-1,\n.text-standard*/.text-body-1.sc-sdx-header,.text-standard.sc-sdx-header{line-height:24px;letter-spacing:-0.1px;font-size:18px}/*!@.text-body-2,\n.text-small*/.text-body-2.sc-sdx-header,.text-small.sc-sdx-header{line-height:21px;letter-spacing:0;font-size:16px}/*!@h1,\nh2,\nh3,\nh4,\nh5,\nh6,\np*/h1.sc-sdx-header,h2.sc-sdx-header,h3.sc-sdx-header,h4.sc-sdx-header,h5.sc-sdx-header,h6.sc-sdx-header,p.sc-sdx-header{margin:0;text-align:left;word-wrap:break-word}/*!@.h1,\n.h2,\n.h3,\n.h4,\n.h5,\n.h6,\n.hero,\n.d1,\n.d2,\n.d3*/.h1.sc-sdx-header,.h2.sc-sdx-header,.h3.sc-sdx-header,.h4.sc-sdx-header,.h5.sc-sdx-header,.h6.sc-sdx-header,.hero.sc-sdx-header,.d1.sc-sdx-header,.d2.sc-sdx-header,.d3.sc-sdx-header{color:#015}/*!@.h1,\n.h2,\n.text-h1,\n.text-h2,\nh1,\nh2*/.h1.sc-sdx-header,.h2.sc-sdx-header,.text-h1.sc-sdx-header,.text-h2.sc-sdx-header,h1.sc-sdx-header,h2.sc-sdx-header{margin-bottom:32px}/*!@.h1,\n.text-h1,\nh1*/.h1.sc-sdx-header,.text-h1.sc-sdx-header,h1.sc-sdx-header{line-height:40px;letter-spacing:-1px;font-size:32px;font-weight:700}@media (min-width: 1024px){/*!@.h1,\n  .text-h1,\n  h1*/.h1.sc-sdx-header,.text-h1.sc-sdx-header,h1.sc-sdx-header{line-height:48px;letter-spacing:-1.2px;font-size:40px}}/*!@.h2,\n.text-h2,\nh2*/.h2.sc-sdx-header,.text-h2.sc-sdx-header,h2.sc-sdx-header{line-height:32px;letter-spacing:-0.75px;font-size:28px;font-weight:700}@media (min-width: 1024px){/*!@.h2,\n  .text-h2,\n  h2*/.h2.sc-sdx-header,.text-h2.sc-sdx-header,h2.sc-sdx-header{line-height:40px;letter-spacing:-1px;font-size:32px}}/*!@.h3,\n.h4,\n.text-h3,\n.text-h4,\nh3,\nh4*/.h3.sc-sdx-header,.h4.sc-sdx-header,.text-h3.sc-sdx-header,.text-h4.sc-sdx-header,h3.sc-sdx-header,h4.sc-sdx-header{margin-bottom:24px}/*!@.h3,\n.text-h3,\nh3*/.h3.sc-sdx-header,.text-h3.sc-sdx-header,h3.sc-sdx-header{line-height:32px;letter-spacing:-0.35px;font-size:24px;font-weight:600}@media (min-width: 1024px){/*!@.h3,\n  .text-h3,\n  h3*/.h3.sc-sdx-header,.text-h3.sc-sdx-header,h3.sc-sdx-header{line-height:32px;letter-spacing:-0.75px;font-size:28px}}/*!@.h4,\n.text-h4,\nh4*/.h4.sc-sdx-header,.text-h4.sc-sdx-header,h4.sc-sdx-header{line-height:24px;letter-spacing:-0.1px;font-size:20px;font-weight:600}@media (min-width: 1024px){/*!@.h4,\n  .text-h4,\n  h4*/.h4.sc-sdx-header,.text-h4.sc-sdx-header,h4.sc-sdx-header{line-height:32px;letter-spacing:-0.35px;font-size:24px}}/*!@.text-h3.text-compact*/.text-h3.text-compact.sc-sdx-header{line-height:31px}/*!@.text-h4.text-compact*/.text-h4.text-compact.sc-sdx-header{line-height:27px}/*!@.h5,\n.h6,\n.text-h5,\n.text-h6,\nh5,\nh6*/.h5.sc-sdx-header,.h6.sc-sdx-header,.text-h5.sc-sdx-header,.text-h6.sc-sdx-header,h5.sc-sdx-header,h6.sc-sdx-header{margin-bottom:8px}/*!@.h5,\n.text-h5,\nh5*/.h5.sc-sdx-header,.text-h5.sc-sdx-header,h5.sc-sdx-header{line-height:24px;letter-spacing:-0.1px;font-size:18px;font-weight:600}/*!@.h6,\n.text-h6,\nh6*/.h6.sc-sdx-header,.text-h6.sc-sdx-header,h6.sc-sdx-header{line-height:24px;letter-spacing:-0.1px;font-size:16px;font-weight:600}/*!@.paragraph,\np*/.paragraph.sc-sdx-header,p.sc-sdx-header{line-height:24px;letter-spacing:-0.1px;font-size:18px;margin-bottom:32px}/*!@.paragraph:last-child,\np:last-child*/.paragraph.sc-sdx-header:last-child,p.sc-sdx-header:last-child{margin-bottom:0}/*!@.hero,\n.text-hero,\n.d1,\n.text-d1,\n.d2,\n.text-d2,\n.d3,\n.text-d3*/.hero.sc-sdx-header,.text-hero.sc-sdx-header,.d1.sc-sdx-header,.text-d1.sc-sdx-header,.d2.sc-sdx-header,.text-d2.sc-sdx-header,.d3.sc-sdx-header,.text-d3.sc-sdx-header{font-weight:700}/*!@.hero,\n.text-hero*/.hero.sc-sdx-header,.text-hero.sc-sdx-header{line-height:80px;letter-spacing:-1.75px;font-size:70px}@media (min-width: 1024px){/*!@.hero,\n  .text-hero*/.hero.sc-sdx-header,.text-hero.sc-sdx-header{line-height:104px;letter-spacing:-2px;font-size:96px}}/*!@.d1,\n.text-d1*/.d1.sc-sdx-header,.text-d1.sc-sdx-header{line-height:64px;letter-spacing:-1.35px;font-size:54px}@media (min-width: 1024px){/*!@.d1,\n  .text-d1*/.d1.sc-sdx-header,.text-d1.sc-sdx-header{line-height:80px;letter-spacing:-1.75px;font-size:70px}}/*!@.d2,\n.text-d2*/.d2.sc-sdx-header,.text-d2.sc-sdx-header{line-height:56px;letter-spacing:-1.2px;font-size:48px}@media (min-width: 1024px){/*!@.d2,\n  .text-d2*/.d2.sc-sdx-header,.text-d2.sc-sdx-header{line-height:64px;letter-spacing:-1.35px;font-size:54px}}/*!@.d3,\n.text-d3*/.d3.sc-sdx-header,.text-d3.sc-sdx-header{line-height:48px;letter-spacing:-1.2px;font-size:40px}@media (min-width: 1024px){/*!@.d3,\n  .text-d3*/.d3.sc-sdx-header,.text-d3.sc-sdx-header{line-height:56px;letter-spacing:-1.2px;font-size:48px}}/*!@.text-b1*/.text-b1.sc-sdx-header{line-height:24px;letter-spacing:-0.1px;font-size:18px;font-weight:400}/*!@.text-b2*/.text-b2.sc-sdx-header{line-height:21px;letter-spacing:0;font-size:16px;font-weight:400}/*!@.text-sm,\n.text-smaller*/.text-sm.sc-sdx-header,.text-smaller.sc-sdx-header{line-height:18px;letter-spacing:0.1px;font-size:14px;font-weight:400}/*!@.text-compact*/.text-compact.sc-sdx-header{line-height:21px}/*!@.figcaption*/.figcaption.sc-sdx-header{line-height:18px;letter-spacing:0.1px;font-size:14px}/*!@.code*/.code.sc-sdx-header{font-family:monospace;background-color:#f8fafb;border-radius:4px;border:1px solid #d6d6d6;color:#474747;font-size:16px;padding:0 6px}/*!@address*/address.sc-sdx-header{font-style:normal}/*!@strong*/strong.sc-sdx-header{font-weight:600}/*!@em*/em.sc-sdx-header{font-style:italic}/*!@.sdx--dark-theme .code*/.sdx--dark-theme.sc-sdx-header .code.sc-sdx-header{background-color:#242424;color:#d6d6d6}/*!@.font*/.font.sc-sdx-header{font-family:TheSans, sans-serif}/*!@.font--sans*/.font--sans.sc-sdx-header{font-family:TheSans, sans-serif}/*!@.font--serif*/.font--serif.sc-sdx-header{font-family:TheSerif, serif}/*!@.font--light*/.font--light.sc-sdx-header{font-weight:300}/*!@.font--semi-light*/.font--semi-light.sc-sdx-header{font-weight:400}/*!@.font--semi-bold*/.font--semi-bold.sc-sdx-header{font-weight:600}/*!@.sdx--dark-theme .h1,\n.sdx--dark-theme .h2,\n.sdx--dark-theme .h3,\n.sdx--dark-theme .h4,\n.sdx--dark-theme .h5,\n.sdx--dark-theme .h6,\n.sdx--dark-theme .hero,\n.sdx--dark-theme .d1,\n.sdx--dark-theme .d2,\n.sdx--dark-theme .d3*/.sdx--dark-theme.sc-sdx-header .h1.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .h2.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .h3.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .h4.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .h5.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .h6.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .hero.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .d1.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .d2.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .d3.sc-sdx-header{color:unset}/*!@.sdx--dark-theme .h1,\n.sdx--dark-theme .text-h1,\n.sdx--dark-theme h1,\n.sdx--dark-theme .h2,\n.sdx--dark-theme .text-h2,\n.sdx--dark-theme h2,\n.sdx--dark-theme .h3,\n.sdx--dark-theme .text-h3,\n.sdx--dark-theme h3,\n.sdx--dark-theme .h4,\n.sdx--dark-theme .text-h4,\n.sdx--dark-theme h4,\n.sdx--dark-theme .d1,\n.sdx--dark-theme .text-d1,\n.sdx--dark-theme .d2,\n.sdx--dark-theme .text-d2,\n.sdx--dark-theme .d3,\n.sdx--dark-theme .text-d3*/.sdx--dark-theme.sc-sdx-header .h1.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .text-h1.sc-sdx-header,.sdx--dark-theme.sc-sdx-header h1.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .h2.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .text-h2.sc-sdx-header,.sdx--dark-theme.sc-sdx-header h2.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .h3.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .text-h3.sc-sdx-header,.sdx--dark-theme.sc-sdx-header h3.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .h4.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .text-h4.sc-sdx-header,.sdx--dark-theme.sc-sdx-header h4.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .d1.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .text-d1.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .d2.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .text-d2.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .d3.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .text-d3.sc-sdx-header{font-weight:600}/*!@.sdx--dark-theme .p,\n.sdx--dark-theme .paragraph,\n.sdx--dark-theme p*/.sdx--dark-theme.sc-sdx-header .p.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .paragraph.sc-sdx-header,.sdx--dark-theme.sc-sdx-header p.sc-sdx-header{font-weight:500}/*!@.sdx--dark-theme .h1,\n.sdx--dark-theme .text-h1,\n.sdx--dark-theme h1*/.sdx--dark-theme.sc-sdx-header .h1.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .text-h1.sc-sdx-header,.sdx--dark-theme.sc-sdx-header h1.sc-sdx-header{letter-spacing:-0.8px}/*!@.sdx--dark-theme .h2,\n.sdx--dark-theme .text-h2,\n.sdx--dark-theme h2*/.sdx--dark-theme.sc-sdx-header .h2.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .text-h2.sc-sdx-header,.sdx--dark-theme.sc-sdx-header h2.sc-sdx-header{letter-spacing:-0.6px}/*!@.sdx--dark-theme .h3,\n.sdx--dark-theme .text-h3,\n.sdx--dark-theme h3*/.sdx--dark-theme.sc-sdx-header .h3.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .text-h3.sc-sdx-header,.sdx--dark-theme.sc-sdx-header h3.sc-sdx-header{letter-spacing:-0.5px}/*!@.sdx--dark-theme .h4,\n.sdx--dark-theme .text-h4,\n.sdx--dark-theme h4*/.sdx--dark-theme.sc-sdx-header .h4.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .text-h4.sc-sdx-header,.sdx--dark-theme.sc-sdx-header h4.sc-sdx-header{letter-spacing:-0.2px}/*!@.sdx--dark-theme .h5,\n.sdx--dark-theme .text-h5,\n.sdx--dark-theme h5*/.sdx--dark-theme.sc-sdx-header .h5.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .text-h5.sc-sdx-header,.sdx--dark-theme.sc-sdx-header h5.sc-sdx-header{letter-spacing:-0.1px}/*!@.sdx--dark-theme .h6,\n.sdx--dark-theme .text-h6,\n.sdx--dark-theme h6*/.sdx--dark-theme.sc-sdx-header .h6.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .text-h6.sc-sdx-header,.sdx--dark-theme.sc-sdx-header h6.sc-sdx-header{letter-spacing:0px}/*!@.sdx--dark-theme .d1,\n.sdx--dark-theme .text-d1*/.sdx--dark-theme.sc-sdx-header .d1.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .text-d1.sc-sdx-header{letter-spacing:-1.4px}/*!@.sdx--dark-theme .d2,\n.sdx--dark-theme .text-d2*/.sdx--dark-theme.sc-sdx-header .d2.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .text-d2.sc-sdx-header{letter-spacing:-1px}/*!@.sdx--dark-theme .d3,\n.sdx--dark-theme .text-d3*/.sdx--dark-theme.sc-sdx-header .d3.sc-sdx-header,.sdx--dark-theme.sc-sdx-header .text-d3.sc-sdx-header{letter-spacing:-0.9px}/*!@.sdx--dark-theme strong,\n.sdx--dark-theme b*/.sdx--dark-theme.sc-sdx-header strong.sc-sdx-header,.sdx--dark-theme.sc-sdx-header b.sc-sdx-header{color:#fff}/*!@.sdx--dark-theme code*/.sdx--dark-theme.sc-sdx-header code.sc-sdx-header{background-color:#242424;border:1px solid #b1b9be;border-radius:4px;color:#cfd5d9;font-size:16px}/*!@:host ::slotted(sdx-search)*/.sc-sdx-header-h .sc-sdx-header-s>sdx-search{width:200px;color:#015}/*!@.container*/.container.sc-sdx-header{display:flex}@media (min-width: 0){/*!@.container*/.container.sc-sdx-header{margin-left:calc(24px - 4px);margin-right:calc(24px - 4px);padding-left:4px;padding-right:4px;width:auto}}@media (min-width: 1440px){/*!@.container*/.container.sc-sdx-header{margin-left:auto;margin-right:auto;padding-left:12px;padding-right:12px;width:1380px}}/*!@.link*/.link.sc-sdx-header{text-decoration:none;color:#015;transition:color 200ms cubic-bezier(0.4, 0, 0.2, 1);text-underline-offset:4px;white-space:nowrap;outline:none}/*!@.link[href]:hover*/.link[href].sc-sdx-header:hover{color:#0048cf}/*!@.link .icon-label-wrapper*/.link.sc-sdx-header .icon-label-wrapper.sc-sdx-header{position:relative;display:flex;align-items:center;gap:6px}/*!@.link .icon-label-wrapper:hover .badge*/.link.sc-sdx-header .icon-label-wrapper.sc-sdx-header:hover .badge.sc-sdx-header{background:#ba3e06}/*!@.link .icon-label-wrapper .badge*/.link.sc-sdx-header .icon-label-wrapper.sc-sdx-header .badge.sc-sdx-header{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-weight:600;border-radius:18px;color:#fff;font-size:13px;height:18px;line-height:18px;min-width:18px;max-width:50px;text-align:center;padding:0 5px;user-select:none;animation:badge 300ms linear both;background:#cf4a0c;pointer-events:none;transition:background 70ms cubic-bezier(0.4, 0, 0.6, 1);position:absolute;bottom:calc(100% - 13px);left:calc(100% - 9px)}@keyframes badge{0%{transform:scale(1)}25%{transform:scale(1.15)}50%{transform:scale(1)}75%{transform:scale(0.85)}100%{transform:scale(1)}}/*!@.link .initials*/.link.sc-sdx-header .initials.sc-sdx-header{background:#015;height:24px;width:24px;border-radius:100%;color:#fff;font-size:12px;display:flex;justify-content:center;align-items:center}/*!@.push-right*/.push-right.sc-sdx-header{margin-right:auto}/*!@.primary.list .link[href]:hover .icon.icon-214-present, .primary.list .link[href]:hover .icon.icon-present,\n.main.list .link[href]:hover .icon.icon-214-present,\n.main.list .link[href]:hover .icon.icon-present*/.primary.list.sc-sdx-header .link[href].sc-sdx-header:hover .icon.icon-214-present.sc-sdx-header,.primary.list.sc-sdx-header .link[href].sc-sdx-header:hover .icon.icon-present.sc-sdx-header,.main.list.sc-sdx-header .link[href].sc-sdx-header:hover .icon.icon-214-present.sc-sdx-header,.main.list.sc-sdx-header .link[href].sc-sdx-header:hover .icon.icon-present.sc-sdx-header{background:#7f2879}/*!@.primary.list .icon,\n.main.list .icon*/.primary.list.sc-sdx-header .icon.sc-sdx-header,.main.list.sc-sdx-header .icon.sc-sdx-header{display:none}/*!@.primary.list .icon.icon-214-present, .primary.list .icon.icon-present,\n.main.list .icon.icon-214-present,\n.main.list .icon.icon-present*/.primary.list.sc-sdx-header .icon.icon-214-present.sc-sdx-header,.primary.list.sc-sdx-header .icon.icon-present.sc-sdx-header,.main.list.sc-sdx-header .icon.icon-214-present.sc-sdx-header,.main.list.sc-sdx-header .icon.icon-present.sc-sdx-header{display:inline-block;transition:background 200ms cubic-bezier(0.4, 0, 0.2, 1);background:#a63297;color:white;font-size:16px;border-radius:50%;height:24px;width:24px;text-align:center}/*!@.list*/.list.sc-sdx-header{list-style-type:none;margin:0;padding:0;display:flex}/*!@.list .item*/.list.sc-sdx-header .item.sc-sdx-header{display:flex}/*!@.list .item.active.leaf > .link*/.list.sc-sdx-header .item.active.leaf.sc-sdx-header>.link.sc-sdx-header{text-decoration:underline}/*!@.list .item .link*/.list.sc-sdx-header .item.sc-sdx-header .link.sc-sdx-header{display:flex;align-items:center;flex-grow:1}/*!@.list.horizontal:not(:first-of-type)*/.list.horizontal.sc-sdx-header:not(:first-of-type){margin-left:12px}/*!@.list.horizontal:not(:last-of-type):not(.last-of-type)*/.list.horizontal.sc-sdx-header:not(:last-of-type):not(.last-of-type){margin-right:12px}/*!@.list.horizontal > .item:not(:first-of-type)*/.list.horizontal.sc-sdx-header>.item.sc-sdx-header:not(:first-of-type){margin-left:12px}/*!@.list.horizontal > .item:not(:last-of-type):not(.last-of-type)*/.list.horizontal.sc-sdx-header>.item.sc-sdx-header:not(:last-of-type):not(.last-of-type){margin-right:12px}/*!@.list.vertical*/.list.vertical.sc-sdx-header{flex-flow:column}/*!@.list.vertical > .item*/.list.vertical.sc-sdx-header>.item.sc-sdx-header{margin:5px 0}/*!@.list.primary .item.active .toggle .link*/.list.primary.sc-sdx-header .item.active.sc-sdx-header .toggle.sc-sdx-header .link.sc-sdx-header{text-decoration:underline}/*!@.list.secondary .link:not(:hover), .list.tertiary .link:not(:hover)*/.list.secondary.sc-sdx-header .link.sc-sdx-header:not(:hover),.list.tertiary.sc-sdx-header .link.sc-sdx-header:not(:hover){color:#333}/*!@.list.secondary .toggle .link:not(:hover)::before, .list.secondary .toggle .link:not(:hover)::after, .list.tertiary .toggle .link:not(:hover)::before, .list.tertiary .toggle .link:not(:hover)::after*/.list.secondary.sc-sdx-header .toggle.sc-sdx-header .link.sc-sdx-header:not(:hover)::before,.list.secondary.sc-sdx-header .toggle.sc-sdx-header .link.sc-sdx-header:not(:hover)::after,.list.tertiary.sc-sdx-header .toggle.sc-sdx-header .link.sc-sdx-header:not(:hover)::before,.list.tertiary.sc-sdx-header .toggle.sc-sdx-header .link.sc-sdx-header:not(:hover)::after{background:#333}/*!@.list.accordion:not(:first-of-type)*/.list.accordion.sc-sdx-header:not(:first-of-type){padding-top:8px}/*!@.list.accordion:not(:last-of-type)*/.list.accordion.sc-sdx-header:not(:last-of-type){padding-bottom:8px;border-bottom:1px solid #dde3e7}/*!@.list.accordion.main, .list.accordion.left-hand-menu*/.list.accordion.main.sc-sdx-header,.list.accordion.left-hand-menu.sc-sdx-header{font-weight:600}/*!@.list.accordion.main .item.deepest .link, .list.accordion.left-hand-menu .item.deepest .link*/.list.accordion.main.sc-sdx-header .item.deepest.sc-sdx-header .link.sc-sdx-header,.list.accordion.left-hand-menu.sc-sdx-header .item.deepest.sc-sdx-header .link.sc-sdx-header{font-weight:400}/*!@.list.accordion sdx-accordion*/.list.accordion.sc-sdx-header sdx-accordion.sc-sdx-header{width:100%}/*!@.list.accordion sdx-accordion sdx-accordion-item-body > .list*/.list.accordion.sc-sdx-header sdx-accordion.sc-sdx-header sdx-accordion-item-body.sc-sdx-header>.list.sc-sdx-header{margin:5px 0}/*!@.list.accordion sdx-accordion sdx-accordion-item-body > .list > .item:last-of-type*/.list.accordion.sc-sdx-header sdx-accordion.sc-sdx-header sdx-accordion-item-body.sc-sdx-header>.list.sc-sdx-header>.item.sc-sdx-header:last-of-type{margin-bottom:0}/*!@.component*/.component.sc-sdx-header{font-weight:400;font-size:16px}/*!@.component.desktop sdx-header-menu .content*/.component.desktop.sc-sdx-header sdx-header-menu.sc-sdx-header .content.sc-sdx-header{max-height:calc(\n          var(--sdx-dialog-window-inner-height, 100vh) - 128px\n        )}/*!@.component.mobile sdx-header-menu*/.component.mobile.sc-sdx-header sdx-header-menu.sc-sdx-header{position:static}/*!@.component.mobile sdx-header-menu .content*/.component.mobile.sc-sdx-header sdx-header-menu.sc-sdx-header .content.sc-sdx-header{max-height:calc(\n          var(--sdx-dialog-window-inner-height, 100vh) - 88px\n        );margin:0}/*!@.component .wrapper*/.component.sc-sdx-header .wrapper.sc-sdx-header{display:flex;flex-direction:column;position:relative;background:#fff}/*!@.component .wrapper.meta*/.component.sc-sdx-header .wrapper.meta.sc-sdx-header{z-index:50000}/*!@.component .wrapper.main*/.component.sc-sdx-header .wrapper.main.sc-sdx-header{border-bottom:1px solid #dde3e7;z-index:49999;top:0}/*!@.component .wrapper.breadcrumb-list*/.component.sc-sdx-header .wrapper.breadcrumb-list.sc-sdx-header{z-index:49998}/*!@.component .header .meta > .container*/.component.sc-sdx-header .header.sc-sdx-header .meta.sc-sdx-header>.container.sc-sdx-header{height:40px}/*!@.component .header .main > .container*/.component.sc-sdx-header .header.sc-sdx-header .main.sc-sdx-header>.container.sc-sdx-header{height:71px}/*!@.component .header .main > .container > .list .item.active .toggle .link*/.component.sc-sdx-header .header.sc-sdx-header .main.sc-sdx-header>.container.sc-sdx-header>.list.sc-sdx-header .item.active.sc-sdx-header .toggle.sc-sdx-header .link.sc-sdx-header{text-decoration:underline}/*!@.component .header .main > .container > .list:not(:first-of-type)*/.component.sc-sdx-header .header.sc-sdx-header .main.sc-sdx-header>.container.sc-sdx-header>.list.sc-sdx-header:not(:first-of-type){margin-left:16px}/*!@.component .header .main > .container > .list:not(:last-of-type):not(.last-of-type)*/.component.sc-sdx-header .header.sc-sdx-header .main.sc-sdx-header>.container.sc-sdx-header>.list.sc-sdx-header:not(:last-of-type):not(.last-of-type){margin-right:16px}/*!@.component .header .main > .container > .list.logo*/.component.sc-sdx-header .header.sc-sdx-header .main.sc-sdx-header>.container.sc-sdx-header>.list.logo.sc-sdx-header{margin-left:-18px}/*!@.component .header .main > .container > .list.logo .img*/.component.sc-sdx-header .header.sc-sdx-header .main.sc-sdx-header>.container.sc-sdx-header>.list.logo.sc-sdx-header .img.sc-sdx-header{background-size:3600px 40px;background-position:0 0;background-repeat:no-repeat;background-image:url(\"../images/lifeform-spritesheet.png\");width:40px;height:40px;backface-visibility:hidden;min-width:40px;animation:repeatingAnimation 30s steps(90) infinite, initialAnimation 6s steps(90);display:inline-block}@media only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx){/*!@.component .header .main > .container > .list.logo .img*/.component.sc-sdx-header .header.sc-sdx-header .main.sc-sdx-header>.container.sc-sdx-header>.list.logo.sc-sdx-header .img.sc-sdx-header{background-image:url(\"../images/lifeform-spritesheet@2x.png\")}}@keyframes initialAnimation{100%{background-position:-3600px}}@keyframes repeatingAnimation{0%{background-position:0}80%{background-position:0}100%{background-position:-3600px}}/*!@.component .header .main > .container > .list.main .toggle*/.component.sc-sdx-header .header.sc-sdx-header .main.sc-sdx-header>.container.sc-sdx-header>.list.main.sc-sdx-header .toggle.sc-sdx-header{font-weight:600;font-size:20px}/*!@.component .header .breadcrumb-list > .container*/.component.sc-sdx-header .header.sc-sdx-header .breadcrumb-list.sc-sdx-header>.container.sc-sdx-header{font-size:14px}/*!@.component .header .breadcrumb-list > .container .list*/.component.sc-sdx-header .header.sc-sdx-header .breadcrumb-list.sc-sdx-header>.container.sc-sdx-header .list.sc-sdx-header{height:48px}/*!@.component .header .breadcrumb-list > .container .item*/.component.sc-sdx-header .header.sc-sdx-header .breadcrumb-list.sc-sdx-header>.container.sc-sdx-header .item.sc-sdx-header{margin:0}/*!@.component .header .breadcrumb-list > .container .item:first-of-type .label*/.component.sc-sdx-header .header.sc-sdx-header .breadcrumb-list.sc-sdx-header>.container.sc-sdx-header .item.sc-sdx-header:first-of-type .label.sc-sdx-header{display:none}/*!@.component .header .breadcrumb-list > .container .item:not(:first-of-type)::before*/.component.sc-sdx-header .header.sc-sdx-header .breadcrumb-list.sc-sdx-header>.container.sc-sdx-header .item.sc-sdx-header:not(:first-of-type)::before{content:\">\";align-self:center;margin:0 8px}/*!@.component .header .slot-menu-header*/.component.sc-sdx-header .header.sc-sdx-header .slot-menu-header.sc-sdx-header{display:flex;padding:16px}/*!@.component .header .slot-menu-header .title*/.component.sc-sdx-header .header.sc-sdx-header .slot-menu-header.sc-sdx-header .title.sc-sdx-header{flex:1;margin:0}/*!@sdx-button*/sdx-button.sc-sdx-header{color:#015;display:flex;align-items:center}/*!@:host(.sdx-dark-theme) ::slotted(sdx-search)*/.sc-sdx-header-h.sdx-dark-theme .sc-sdx-header-s>sdx-search{color:#e6e6e6}/*!@.component.sdx--dark-theme .link*/.component.sdx--dark-theme.sc-sdx-header .link.sc-sdx-header{color:#e6e6e6}/*!@.component.sdx--dark-theme .link[href]:hover*/.component.sdx--dark-theme.sc-sdx-header .link[href].sc-sdx-header:hover{color:#5ca3ff}/*!@.component.sdx--dark-theme .link .initials*/.component.sdx--dark-theme.sc-sdx-header .link.sc-sdx-header .initials.sc-sdx-header{background:#5c5c5c}/*!@.component.sdx--dark-theme .primary.list .link[href]:hover .icon.icon-214-present, .component.sdx--dark-theme .primary.list .link[href]:hover .icon.icon-present,\n.component.sdx--dark-theme .main.list .link[href]:hover .icon.icon-214-present,\n.component.sdx--dark-theme .main.list .link[href]:hover .icon.icon-present*/.component.sdx--dark-theme.sc-sdx-header .primary.list.sc-sdx-header .link[href].sc-sdx-header:hover .icon.icon-214-present.sc-sdx-header,.component.sdx--dark-theme.sc-sdx-header .primary.list.sc-sdx-header .link[href].sc-sdx-header:hover .icon.icon-present.sc-sdx-header,.component.sdx--dark-theme.sc-sdx-header .main.list.sc-sdx-header .link[href].sc-sdx-header:hover .icon.icon-214-present.sc-sdx-header,.component.sdx--dark-theme.sc-sdx-header .main.list.sc-sdx-header .link[href].sc-sdx-header:hover .icon.icon-present.sc-sdx-header{background:#b053a5}/*!@.component.sdx--dark-theme .primary.list .icon.icon-214-present, .component.sdx--dark-theme .primary.list .icon.icon-present,\n.component.sdx--dark-theme .main.list .icon.icon-214-present,\n.component.sdx--dark-theme .main.list .icon.icon-present*/.component.sdx--dark-theme.sc-sdx-header .primary.list.sc-sdx-header .icon.icon-214-present.sc-sdx-header,.component.sdx--dark-theme.sc-sdx-header .primary.list.sc-sdx-header .icon.icon-present.sc-sdx-header,.component.sdx--dark-theme.sc-sdx-header .main.list.sc-sdx-header .icon.icon-214-present.sc-sdx-header,.component.sdx--dark-theme.sc-sdx-header .main.list.sc-sdx-header .icon.icon-present.sc-sdx-header{background:#a54c9b}/*!@.component.sdx--dark-theme .list.secondary .link:not(:hover), .component.sdx--dark-theme .list.tertiary .link:not(:hover)*/.component.sdx--dark-theme.sc-sdx-header .list.secondary.sc-sdx-header .link.sc-sdx-header:not(:hover),.component.sdx--dark-theme.sc-sdx-header .list.tertiary.sc-sdx-header .link.sc-sdx-header:not(:hover){color:#adadad}/*!@.component.sdx--dark-theme .list.secondary .toggle .link:not(:hover)::before, .component.sdx--dark-theme .list.secondary .toggle .link:not(:hover)::after, .component.sdx--dark-theme .list.tertiary .toggle .link:not(:hover)::before, .component.sdx--dark-theme .list.tertiary .toggle .link:not(:hover)::after*/.component.sdx--dark-theme.sc-sdx-header .list.secondary.sc-sdx-header .toggle.sc-sdx-header .link.sc-sdx-header:not(:hover)::before,.component.sdx--dark-theme.sc-sdx-header .list.secondary.sc-sdx-header .toggle.sc-sdx-header .link.sc-sdx-header:not(:hover)::after,.component.sdx--dark-theme.sc-sdx-header .list.tertiary.sc-sdx-header .toggle.sc-sdx-header .link.sc-sdx-header:not(:hover)::before,.component.sdx--dark-theme.sc-sdx-header .list.tertiary.sc-sdx-header .toggle.sc-sdx-header .link.sc-sdx-header:not(:hover)::after{background:#adadad}/*!@.component.sdx--dark-theme .list.accordion:not(:last-of-type)*/.component.sdx--dark-theme.sc-sdx-header .list.accordion.sc-sdx-header:not(:last-of-type){border-bottom-color:#5c5c5c}/*!@.component.sdx--dark-theme .wrapper*/.component.sdx--dark-theme.sc-sdx-header .wrapper.sc-sdx-header{background:#1d1d1d}/*!@.component.sdx--dark-theme .wrapper.main*/.component.sdx--dark-theme.sc-sdx-header .wrapper.main.sc-sdx-header{border-bottom-color:#707070}/*!@.component.sdx--dark-theme .wrapper.breadcrumb-list*/.component.sdx--dark-theme.sc-sdx-header .wrapper.breadcrumb-list.sc-sdx-header{background:#141414}/*!@sdx-button.sdx--dark-theme*/sdx-button.sdx--dark-theme.sc-sdx-header{color:#adadad}";

class Header {
  navigationChanged() {
    this.parseNavigationIntoState();
    this.createBreadcrumbListScriptEl();
  }
  indexChanged() {
    this.indexParsed = parseJson(this.index);
  }
  loginChanged() {
    this.loginParsed = parseJson(this.login);
  }
  slotsChanged() {
    this.slotsParsed = parseJson(this.slots) || [];
  }
  onWindowScroll() {
    if (!this.componentDidLoadComplete) {
      return;
    }
    this.makeHeaderSticky();
  }
  onWindowResizeDebounced() {
    const innerWidthChanged = innerWidth !== this.innerWidth;
    // Ignore changes in height as they're not relevant for the layout
    // calculations. They're fired e.g. by mobiles when hiding the address bar
    // and can lead to unwanted behavior on some mobile browsers (see SDX-1182).
    if (!innerWidthChanged) {
      return;
    }
    this.innerWidth = innerWidth;
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer);
    }
    this.resizeTimer = setTimeout(() => {
      this.layout();
    }, 10);
  }
  /**
   * Opens a specific slot previously registered in `slots`.
   * @param slot Name that was used to register the slot.
   */
  async openSlot(slot) {
    const sdxHeaderMenuEl = this.slotsWithSdxHeaderMenuEl.get(slot);
    sdxHeaderMenuEl === null || sdxHeaderMenuEl === void 0 ? void 0 : sdxHeaderMenuEl.open();
  }
  /**
   * Closes a specific slot previously registered in `slots`.
   * @param slot Name that was used to register the slot.
   */
  async closeSlot(slot) {
    const sdxHeaderMenuEl = this.slotsWithSdxHeaderMenuEl.get(slot);
    sdxHeaderMenuEl === null || sdxHeaderMenuEl === void 0 ? void 0 : sdxHeaderMenuEl.close();
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.sdxnavigate = createEvent(this, "sdxnavigate", 7);
    this.display = "desktop";
    this.scrollbarWidth = getScrollbarWidth();
    this.innerWidth = innerWidth;
    this.slotLabelEls = [];
    this.openedHeaderMenuEls = [];
    this.componentDidLoadComplete = false;
    this.slotsWithSdxHeaderMenuEl = new Map();
    this.navigation = {};
    this.index = { href: "/" };
    this.login = undefined;
    this.slots = undefined;
    this.animated = true;
    this.indexParsed = parseJson(this.index);
    this.loginParsed = parseJson(this.login);
    this.slotsParsed = parseJson(this.slots) || [];
    this.parseNavigationIntoState();
    this.createBreadcrumbListScriptEl();
    this.leftHandMenuOutletEl =
      document.getElementById("sdx-left-hand-menu-outlet") || undefined;
    setOnExternalLinkClickHandler((e, item) => this.onExternalLinkClick(e, item));
  }
  componentDidLoad() {
    this.layout();
    // Scroll breadcrumbs to the end to show the active breadcrumb on small screens
    if (this.breadcrumbListEl && this.sdxScrollViewEl) {
      const { scrollWidth, clientWidth } = this.breadcrumbListEl;
      // In Firefox 106, scrollWidth at this point is -1px wrong, which makes
      // the right arrow appear even though it's not necessary. However, since
      // there aren't many Firefox users on mobile, let's leave it like that in
      // hope that Firefox will fix it one day.
      this.sdxScrollViewEl.translateX(scrollWidth - clientWidth, false);
    }
    // Append left hand menu (if there)
    if (this.leftHandMenuOutletEl && this.leftHandMenuEl) {
      this.leftHandMenuOutletEl.append(this.leftHandMenuEl);
    }
    this.componentDidLoadComplete = true;
  }
  componentDidUpdate() {
    // Ensure layout is recalculated because when new slots are added, they
    // might have to be hidden for the current display (e.g. mobile).
    this.layout();
  }
  headerMenuDisplayChangeCallback(el, display) {
    // Know if menus are currently open
    if (display === "opening" || display === "closed") {
      this.openedHeaderMenuEls = toggle(this.openedHeaderMenuEls, el);
      if (this.openedHeaderMenuEls.length) {
        disableBodyScroll();
      }
      else {
        enableBodyScroll();
      }
    }
  }
  getParsedNavigationProp() {
    const parsedNavigation = parseJson(this.navigation) || {};
    // Prevent null pointer references by assigning defaults
    return {
      primary: { children: [] },
      secondary: { children: [] },
      tertiary: { children: [] },
      main: { children: [] },
      ...parsedNavigation,
    };
  }
  parseNavigationIntoState() {
    this.navigationParsed = this.getParsedNavigationProp();
    this.allItems = [
      ...flattenBy(this.navigationParsed.primary, "children"),
      ...flattenBy(this.navigationParsed.secondary, "children"),
      ...flattenBy(this.navigationParsed.tertiary, "children"),
      ...flattenBy(this.navigationParsed.main, "children"),
    ].filter((item) => !item.hidden);
    this.activeItems = [
      ...this.getActiveItems(this.navigationParsed.primary),
      ...this.getActiveItems(this.navigationParsed.main),
    ];
    this.breadcrumbList = [
      { ...this.indexParsed, iconName: "icon-home" },
      ...this.getActiveItems(this.navigationParsed.main),
    ];
  }
  onExternalLinkClick(e, item) {
    // Close menu
    this.openedHeaderMenuEls.forEach((el) => el.close());
    this.sdxnavigate.emit({
      event: e,
      item: {
        // just use these 3 properties, see SDX-1281
        label: item.label,
        href: item.href,
        dataset: item.dataset,
      },
    });
  }
  createBreadcrumbListScriptEl() {
    var _a;
    // Delete previous if there
    (_a = this.breadcrumbListScriptEl) === null || _a === void 0 ? void 0 : _a.remove();
    if (!this.hasBreadcrumbs()) {
      return;
    }
    this.breadcrumbListScriptEl = document.createElement("script");
    this.breadcrumbListScriptEl.type = "application/ld+json";
    this.breadcrumbListScriptEl.innerHTML = JSON.stringify(this.createBreadcrumbListSchema());
    this.el.after(this.breadcrumbListScriptEl);
  }
  createListForDesktop(key, ref, content) {
    const items = getVisibleItems(this.navigationParsed[key].children);
    if (!items.length) {
      return;
    }
    return (hAsync("ul", { class: { [key]: true, "list horizontal": true }, role: "navigation", "aria-label": key, ref: ref }, content ? content : items.map((item) => this.createItemForMeta(item))));
  }
  createListForMobile(key, arrowBackground) {
    const items = getVisibleItems(this.navigationParsed[key].children);
    if (!items.length) {
      return;
    }
    return (hAsync("ul", { class: { [key]: true, "list vertical accordion": true }, role: "navigation", "aria-label": key }, items.map((item) => createItemForAccordion(item, this.allItems, this.activeItems, "right", {
      ...(arrowBackground
        ? {
          arrow: {
            background: arrowBackground,
          },
        }
        : undefined),
    }))));
  }
  getActiveItems(item, accumulator = [], depth = 0) {
    if (item.children) {
      depth = depth + 1;
      item.children.forEach((_item) => {
        _item.parent = item;
        _item.depth = depth;
        this.getActiveItems(_item, accumulator, depth);
      });
    }
    else {
      // ...reached leaf, bubble up and collect active items
      let currentItem = item;
      let hasActiveChildren = false;
      while (currentItem.parent) {
        if (currentItem.active || hasActiveChildren) {
          if (!accumulator.includes(currentItem)) {
            accumulator.unshift(currentItem);
          }
          hasActiveChildren = true;
        }
        currentItem = currentItem.parent;
      }
    }
    return accumulator;
  }
  createBreadcrumbListSchema() {
    return {
      "@context": "https://schema.org",
      "@type": "BreadcrumbList",
      itemListElement: this.breadcrumbList
        .filter((item) => item.href || item.active) // skip items without a real link (except the active one, which doesn’t need a link)
        .map((item, i) => ({
        "@type": "ListItem",
        position: i + 1,
        name: item.label,
        item: item.active ? undefined : item.href,
      })),
    };
  }
  hasBreadcrumbs() {
    // Don't show breadcrumbs when "home" is the only item
    return this.breadcrumbList.length > 1;
  }
  hasLeftHandMenu() {
    return !!(this.getLeftHandMenuItems().length && this.leftHandMenuOutletEl);
  }
  getLeftHandMenuItems() {
    var _a;
    const leftHandMenuItemsPosition = this.breadcrumbList.findIndex((item) => item.hasLeftHandMenu);
    return ((_a = this.breadcrumbList[leftHandMenuItemsPosition]) === null || _a === void 0 ? void 0 : _a.children) || [];
  }
  layout() {
    // Clean up from previous layout()
    this.componentEl.classList.remove("desktop");
    this.componentEl.classList.remove("mobile");
    // Strategy is desktop first, then switch to mobile if needed
    this.componentEl.classList.add("desktop");
    this.componentEl.style.display = "block";
    this.metaWrapperEl.style.display = "flex";
    this.hamburgerEl.style.display = "none";
    if (this.mainListEl) {
      this.mainListEl.style.display = "flex";
    }
    if (this.leftHandMenuOutletEl) {
      this.leftHandMenuOutletEl.style.display = "block";
    }
    this.showSecondaryIfEnoughSpace();
    this.showSlotLabelsIfEnoughSpace();
    this.setDisplayToDesktopOrMobile();
    this.makeHeaderSticky();
    this.hidePartsOnMobile();
    // Now that the layout is fully calculated, apply the corresponding height
    // variable.
    this.el.style.height = `var(--sdx-header-height-${this.display}${this.hasBreadcrumbs() ? "-with-breadcrumbs" : ""})`;
  }
  showSecondaryIfEnoughSpace() {
    if (this.secondaryEl) {
      this.secondaryEl.style.display = "none";
    }
    if (this.secondaryListEl) {
      this.secondaryListEl.style.display = "flex";
    }
    const unusedWidth = width(this.metaContainerEl) -
      width(this.primaryListEl, true) -
      width(this.tertiaryListEl, true);
    if (width(this.secondaryListEl, true) > unusedWidth) {
      if (this.secondaryEl) {
        this.secondaryEl.style.display = "flex";
      }
      if (this.secondaryListEl) {
        this.secondaryListEl.style.display = "none";
      }
    }
  }
  showSlotLabelsIfEnoughSpace() {
    this.slotLabelEls.forEach((el) => (el.style.display = "block"));
    const unusedWidth = width(this.mainContainerEl) -
      width(this.swisscomLogoEl, true) -
      width(this.mainListEl, true) -
      width(this.slotsEl, true);
    if (unusedWidth < 0) {
      this.slotLabelEls.forEach((el) => (el.style.display = "none"));
    }
  }
  setDisplayToDesktopOrMobile() {
    const metaElContentWidth = width(this.primaryListEl, true) +
      width(this.secondaryListEl, true) +
      width(this.secondaryEl, true) +
      width(this.tertiaryListEl, true);
    const mainElContentWidth = width(this.swisscomLogoEl, true) +
      width(this.mainListEl, true) +
      width(this.slotsEl, true);
    const hasEnoughSpaceForMetaEl = width(this.metaContainerEl) >= metaElContentWidth;
    const hasEnoughSpaceForMainEl = width(this.mainContainerEl) >= mainElContentWidth;
    this.display =
      hasEnoughSpaceForMetaEl && hasEnoughSpaceForMainEl && bp("lg")
        ? "desktop"
        : "mobile";
  }
  makeHeaderSticky() {
    // Unfortunately, "sticky" can't be use for the whole length of the page,
    // because it only works within its container. It's only being used here
    // for the nice graphical effect when starting to scroll.
    const stickyUntil = this.display === "desktop"
      ? 40 // $header-level0-height
      : 0;
    const isSticky = scrollY < stickyUntil;
    // Reset previously applied styles
    this.el.style.width = "";
    this.metaWrapperEl.style.paddingRight = "";
    this.mainWrapperEl.style.width = "";
    this.mainWrapperEl.style.paddingRight = "";
    this.breadcrumbListWrapperEl.style.paddingRight = "";
    if (isSticky) {
      this.mainWrapperEl.style.position = "sticky";
      this.breadcrumbListWrapperEl.style.top = "";
      if (this.openedHeaderMenuEls.length) {
        // Reserve space for potential scrollbar
        this.el.style.width = "100vw";
        this.metaWrapperEl.style.paddingRight = `${this.scrollbarWidth}px`;
        this.mainWrapperEl.style.paddingRight = `${this.scrollbarWidth}px`;
        this.breadcrumbListWrapperEl.style.paddingRight = `${this.scrollbarWidth}px`;
      }
    }
    else {
      this.mainWrapperEl.style.position = "fixed";
      this.breadcrumbListWrapperEl.style.top = "72px"; // $header-sticky-height
      // Reserve space for potential scrollbar
      this.mainWrapperEl.style.width = "100vw";
      this.metaWrapperEl.style.paddingRight = `${this.scrollbarWidth}px`;
      this.mainWrapperEl.style.paddingRight = `${this.scrollbarWidth}px`;
      this.breadcrumbListWrapperEl.style.paddingRight = `${this.scrollbarWidth}px`;
    }
  }
  hidePartsOnMobile() {
    if (this.display === "desktop") {
      return;
    }
    this.componentEl.classList.remove("desktop");
    this.componentEl.classList.add("mobile");
    this.metaWrapperEl.style.display = "none";
    this.slotLabelEls.forEach((el) => (el.style.display = "none"));
    this.hamburgerEl.style.display = "flex";
    if (this.mainListEl) {
      this.mainListEl.style.display = "none";
    }
    if (this.leftHandMenuOutletEl) {
      this.leftHandMenuOutletEl.style.display = "none";
    }
  }
  createItemForMeta(item) {
    const children = getVisibleItems(item.children);
    return (hAsync("li", { class: getItemClassNames(item, this.allItems, this.activeItems, 2) }, hAsync("sdx-header-menu", { level: "meta", animated: this.animated, displayChangeCallback: (el, display) => this.headerMenuDisplayChangeCallback(el, display) }, createLink(item, {
      href: item.href || "javascript:;",
      slot: "toggle",
    }), !!children.length && (hAsync("div", { slot: "content" }, hAsync("ul", { class: "list vertical" }, children.map((item) => (hAsync("li", { class: getItemClassNames(item, this.allItems, this.activeItems) }, createLink(item))))))))));
  }
  createItemForMain(item) {
    const children = getVisibleItems(item.children);
    const _isExternalLink = isExternalLink(item);
    return (hAsync("li", { class: getItemClassNames(item, this.allItems, this.activeItems, 2), ref: (el) => (item.el = el) }, hAsync("sdx-header-menu", { level: "main", layout: "fixed-left", animated: this.animated, displayChangeCallback: (el, display) => this.headerMenuDisplayChangeCallback(el, display) }, createLink(item, {
      href: _isExternalLink ? item.href : "javascript:;",
      slot: "toggle",
    }), !_isExternalLink && (hAsync("ul", { class: "list vertical accordion main", slot: "content" }, children.map((item) => createItemForAccordion(item, this.allItems, this.activeItems, "right", getAppearance(this.el) === "sdx--light-theme"
      ? {}
      : {
        arrow: {
          background: "#e6e6e6" /* $color-gray-dark-theme */,
        },
      }, 2, true)))))));
  }
  createItemForSlot(slot) {
    return slot.slot ? (hAsync("li", { class: "item" }, hAsync("sdx-header-menu", { level: "main", layout: "fixed-right", class: "slot", animated: this.animated, width: slot.menuWidth, scrollable: slot.scrollable, displayChangeCallback: (el, display) => this.headerMenuDisplayChangeCallback(el, display), ref: (ref) => this.slotsWithSdxHeaderMenuEl.set(slot.slot, ref) }, this.createSlotToggle(slot), hAsync("div", { slot: "content" }, hAsync("div", { class: "slot-menu-header" }, hAsync("div", { class: "h5 title" }, slot.label), hAsync("sdx-button", { theme: "transparent", iconName: "icon-close", iconSize: 2, onClick: () => this.slotsWithSdxHeaderMenuEl.get(slot.slot).toggle() })), hAsync("slot", { name: slot.slot }))))) : (hAsync("li", { class: "item leaf" }, this.createSlotToggle(slot)));
  }
  createSlotToggle(slot) {
    return createLink({
      ...slot,
      iconName: slot.iconName,
      iconSize: 2,
    }, {
      slot: "toggle",
      href: slot.href || "javascript:;",
    }, (el) => {
      if (el) {
        this.slotLabelEls.push(el);
      }
    });
  }
  getComponentClassNames() {
    return {
      [getAppearance(this.el)]: true,
      component: true,
    };
  }
  render() {
    const { secondary, main } = this.navigationParsed;
    // Clear previous entries
    this.slotsWithSdxHeaderMenuEl.clear();
    this.slotLabelEls = [];
    return (hAsync(Host, null, hAsync("div", { class: this.getComponentClassNames(), ref: (el) => (this.componentEl = el), style: {
        // Initially hide the whole component (not to be confused with
        // _reserve-height.scss that sets display: block; to prevent CLS).
        // Otherwise *all* its content is briefly shown (only visible using
        // Network throttling) before layout() has completed.
        // After that, it will be set to visible.
        display: "none",
      } }, hAsync("div", { class: "header" }, hAsync("div", { class: "wrapper meta", ref: (el) => (this.metaWrapperEl = el) }, hAsync("div", { class: "container", ref: (el) => (this.metaContainerEl = el) }, this.createListForDesktop("primary", (el) => (this.primaryListEl = el)), hAsync("div", { class: "push-right" }), this.createListForDesktop("secondary", (el) => (this.secondaryEl = el), this.createItemForMeta(secondary)), this.createListForDesktop("secondary", (el) => (this.secondaryListEl = el)), this.createListForDesktop("tertiary", (el) => (this.tertiaryListEl = el)))), hAsync("div", { class: "wrapper main", ref: (el) => (this.mainWrapperEl = el) }, hAsync("div", { class: "container", ref: (el) => (this.mainContainerEl = el) }, hAsync("ul", { class: "list logo", ref: (el) => (this.swisscomLogoEl = el) }, hAsync("li", { class: "item leaf" }, createLink({
      ...this.indexParsed,
      ariaLabel: "swisscom home",
      content: (hAsync("span", { class: "img", style: {
          backgroundImage: `url(${getAssetPath("./assets/lifeform-spritesheet@2x.png")})`,
        } })),
    }))), this.createListForDesktop("main", (el) => (this.mainListEl = el), getVisibleItems(main.children).map((item) => this.createItemForMain(item))), hAsync("div", { class: "push-right" }), (!!this.slotsParsed.length || this.loginParsed) && (
    // Add .last-of-type because the next list is hidden
    hAsync("ul", { key: "slots" // key because conditional ref
      ,
      class: "list horizontal last-of-type", ref: (el) => (this.slotsEl = el) }, !!this.slotsParsed.length &&
      this.slotsParsed.map((slot) => this.createItemForSlot(slot)), this.loginParsed &&
      this.createItemForSlot({
        ...this.loginParsed,
        iconName: "icon-account",
        showLabelOnDesktop: true,
        content: this.loginParsed.initials ? (hAsync("span", { class: "initials" }, this.loginParsed.initials)) : undefined,
      }))), hAsync("ul", { class: "list horizontal hamburger", ref: (el) => (this.hamburgerEl = el) }, hAsync("li", { class: "item" }, hAsync("sdx-header-menu", { level: "main", layout: "fixed-right", animated: this.animated, displayChangeCallback: (el, display) => this.headerMenuDisplayChangeCallback(el, display) }, createLink({
      iconName: "icon-menu",
      iconSize: 3,
      ariaLabel: "open the menu",
      ariaExpanded: "false",
    }, { href: "javascript:;", slot: "toggle" }), hAsync("div", { slot: "content" }, this.createListForMobile("main", getAppearance(this.el) === "sdx--light-theme"
      ? undefined
      : "#e6e6e6" /* $color-gray-dark-theme */), this.createListForMobile("primary", getAppearance(this.el) === "sdx--light-theme"
      ? undefined
      : "#e6e6e6" /* $color-gray-dark-theme */), this.createListForMobile("secondary", getAppearance(this.el) === "sdx--light-theme"
      ? "#666" /* $color-gray-tint-4 */
      : "#adadad" /* $color-gray-tint-5-dark-theme */), this.createListForMobile("tertiary", getAppearance(this.el) === "sdx--light-theme"
      ? "#666" /* $color-gray-tint-4 */
      : "#adadad" /* $color-gray-tint-5-dark-theme */))))))), hAsync("div", { class: "wrapper breadcrumb-list", ref: (el) => (this.breadcrumbListWrapperEl = el) }, this.hasBreadcrumbs() && (hAsync("nav", { class: "container", "aria-label": "breadcrumb" }, hAsync("sdx-scroll-view", { arrowsHidden: true, ref: (el) => (this.sdxScrollViewEl = el) }, hAsync("ul", { class: "list horizontal", ref: (el) => (this.breadcrumbListEl = el) }, this.breadcrumbList.map((item, i) => (hAsync("li", { class: "item" }, createLink({
      ...item,
      href: i === this.breadcrumbList.length - 1
        ? undefined // don't link last (= active page)
        : item.href,
    }))))))))))), this.hasLeftHandMenu() && (hAsync("sdx-header-left-hand-menu", { items: this.getLeftHandMenuItems(), allItems: this.allItems, activeItems: this.activeItems, ref: (el) => (this.leftHandMenuEl = el) }))));
  }
  static get assetsDirs() { return ["assets"]; }
  get el() { return getElement(this); }
  static get watchers() { return {
    "navigation": ["navigationChanged"],
    "index": ["indexChanged"],
    "login": ["loginChanged"],
    "slots": ["slotsChanged"]
  }; }
  static get style() { return headerCss$1; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-header",
    "$members$": {
      "navigation": [1],
      "index": [1],
      "login": [1],
      "slots": [1],
      "animated": [4],
      "openSlot": [64],
      "closeSlot": [64]
    },
    "$listeners$": [[9, "scroll", "onWindowScroll"], [9, "resize", "onWindowResizeDebounced"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const headerCss = "/*!@:root*/.sc-sdx-header-left-hand-menu:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-header-left-hand-menu-h,*.sc-sdx-header-left-hand-menu,*.sc-sdx-header-left-hand-menu:before,*.sc-sdx-header-left-hand-menu:after{box-sizing:border-box}/*!@.text-body-1,\n.text-standard*/.text-body-1.sc-sdx-header-left-hand-menu,.text-standard.sc-sdx-header-left-hand-menu{line-height:24px;letter-spacing:-0.1px;font-size:18px}/*!@.text-body-2,\n.text-small*/.text-body-2.sc-sdx-header-left-hand-menu,.text-small.sc-sdx-header-left-hand-menu{line-height:21px;letter-spacing:0;font-size:16px}/*!@h1,\nh2,\nh3,\nh4,\nh5,\nh6,\np*/h1.sc-sdx-header-left-hand-menu,h2.sc-sdx-header-left-hand-menu,h3.sc-sdx-header-left-hand-menu,h4.sc-sdx-header-left-hand-menu,h5.sc-sdx-header-left-hand-menu,h6.sc-sdx-header-left-hand-menu,p.sc-sdx-header-left-hand-menu{margin:0;text-align:left;word-wrap:break-word}/*!@.h1,\n.h2,\n.h3,\n.h4,\n.h5,\n.h6,\n.hero,\n.d1,\n.d2,\n.d3*/.h1.sc-sdx-header-left-hand-menu,.h2.sc-sdx-header-left-hand-menu,.h3.sc-sdx-header-left-hand-menu,.h4.sc-sdx-header-left-hand-menu,.h5.sc-sdx-header-left-hand-menu,.h6.sc-sdx-header-left-hand-menu,.hero.sc-sdx-header-left-hand-menu,.d1.sc-sdx-header-left-hand-menu,.d2.sc-sdx-header-left-hand-menu,.d3.sc-sdx-header-left-hand-menu{color:#015}/*!@.h1,\n.h2,\n.text-h1,\n.text-h2,\nh1,\nh2*/.h1.sc-sdx-header-left-hand-menu,.h2.sc-sdx-header-left-hand-menu,.text-h1.sc-sdx-header-left-hand-menu,.text-h2.sc-sdx-header-left-hand-menu,h1.sc-sdx-header-left-hand-menu,h2.sc-sdx-header-left-hand-menu{margin-bottom:32px}/*!@.h1,\n.text-h1,\nh1*/.h1.sc-sdx-header-left-hand-menu,.text-h1.sc-sdx-header-left-hand-menu,h1.sc-sdx-header-left-hand-menu{line-height:40px;letter-spacing:-1px;font-size:32px;font-weight:700}@media (min-width: 1024px){/*!@.h1,\n  .text-h1,\n  h1*/.h1.sc-sdx-header-left-hand-menu,.text-h1.sc-sdx-header-left-hand-menu,h1.sc-sdx-header-left-hand-menu{line-height:48px;letter-spacing:-1.2px;font-size:40px}}/*!@.h2,\n.text-h2,\nh2*/.h2.sc-sdx-header-left-hand-menu,.text-h2.sc-sdx-header-left-hand-menu,h2.sc-sdx-header-left-hand-menu{line-height:32px;letter-spacing:-0.75px;font-size:28px;font-weight:700}@media (min-width: 1024px){/*!@.h2,\n  .text-h2,\n  h2*/.h2.sc-sdx-header-left-hand-menu,.text-h2.sc-sdx-header-left-hand-menu,h2.sc-sdx-header-left-hand-menu{line-height:40px;letter-spacing:-1px;font-size:32px}}/*!@.h3,\n.h4,\n.text-h3,\n.text-h4,\nh3,\nh4*/.h3.sc-sdx-header-left-hand-menu,.h4.sc-sdx-header-left-hand-menu,.text-h3.sc-sdx-header-left-hand-menu,.text-h4.sc-sdx-header-left-hand-menu,h3.sc-sdx-header-left-hand-menu,h4.sc-sdx-header-left-hand-menu{margin-bottom:24px}/*!@.h3,\n.text-h3,\nh3*/.h3.sc-sdx-header-left-hand-menu,.text-h3.sc-sdx-header-left-hand-menu,h3.sc-sdx-header-left-hand-menu{line-height:32px;letter-spacing:-0.35px;font-size:24px;font-weight:600}@media (min-width: 1024px){/*!@.h3,\n  .text-h3,\n  h3*/.h3.sc-sdx-header-left-hand-menu,.text-h3.sc-sdx-header-left-hand-menu,h3.sc-sdx-header-left-hand-menu{line-height:32px;letter-spacing:-0.75px;font-size:28px}}/*!@.h4,\n.text-h4,\nh4*/.h4.sc-sdx-header-left-hand-menu,.text-h4.sc-sdx-header-left-hand-menu,h4.sc-sdx-header-left-hand-menu{line-height:24px;letter-spacing:-0.1px;font-size:20px;font-weight:600}@media (min-width: 1024px){/*!@.h4,\n  .text-h4,\n  h4*/.h4.sc-sdx-header-left-hand-menu,.text-h4.sc-sdx-header-left-hand-menu,h4.sc-sdx-header-left-hand-menu{line-height:32px;letter-spacing:-0.35px;font-size:24px}}/*!@.text-h3.text-compact*/.text-h3.text-compact.sc-sdx-header-left-hand-menu{line-height:31px}/*!@.text-h4.text-compact*/.text-h4.text-compact.sc-sdx-header-left-hand-menu{line-height:27px}/*!@.h5,\n.h6,\n.text-h5,\n.text-h6,\nh5,\nh6*/.h5.sc-sdx-header-left-hand-menu,.h6.sc-sdx-header-left-hand-menu,.text-h5.sc-sdx-header-left-hand-menu,.text-h6.sc-sdx-header-left-hand-menu,h5.sc-sdx-header-left-hand-menu,h6.sc-sdx-header-left-hand-menu{margin-bottom:8px}/*!@.h5,\n.text-h5,\nh5*/.h5.sc-sdx-header-left-hand-menu,.text-h5.sc-sdx-header-left-hand-menu,h5.sc-sdx-header-left-hand-menu{line-height:24px;letter-spacing:-0.1px;font-size:18px;font-weight:600}/*!@.h6,\n.text-h6,\nh6*/.h6.sc-sdx-header-left-hand-menu,.text-h6.sc-sdx-header-left-hand-menu,h6.sc-sdx-header-left-hand-menu{line-height:24px;letter-spacing:-0.1px;font-size:16px;font-weight:600}/*!@.paragraph,\np*/.paragraph.sc-sdx-header-left-hand-menu,p.sc-sdx-header-left-hand-menu{line-height:24px;letter-spacing:-0.1px;font-size:18px;margin-bottom:32px}/*!@.paragraph:last-child,\np:last-child*/.paragraph.sc-sdx-header-left-hand-menu:last-child,p.sc-sdx-header-left-hand-menu:last-child{margin-bottom:0}/*!@.hero,\n.text-hero,\n.d1,\n.text-d1,\n.d2,\n.text-d2,\n.d3,\n.text-d3*/.hero.sc-sdx-header-left-hand-menu,.text-hero.sc-sdx-header-left-hand-menu,.d1.sc-sdx-header-left-hand-menu,.text-d1.sc-sdx-header-left-hand-menu,.d2.sc-sdx-header-left-hand-menu,.text-d2.sc-sdx-header-left-hand-menu,.d3.sc-sdx-header-left-hand-menu,.text-d3.sc-sdx-header-left-hand-menu{font-weight:700}/*!@.hero,\n.text-hero*/.hero.sc-sdx-header-left-hand-menu,.text-hero.sc-sdx-header-left-hand-menu{line-height:80px;letter-spacing:-1.75px;font-size:70px}@media (min-width: 1024px){/*!@.hero,\n  .text-hero*/.hero.sc-sdx-header-left-hand-menu,.text-hero.sc-sdx-header-left-hand-menu{line-height:104px;letter-spacing:-2px;font-size:96px}}/*!@.d1,\n.text-d1*/.d1.sc-sdx-header-left-hand-menu,.text-d1.sc-sdx-header-left-hand-menu{line-height:64px;letter-spacing:-1.35px;font-size:54px}@media (min-width: 1024px){/*!@.d1,\n  .text-d1*/.d1.sc-sdx-header-left-hand-menu,.text-d1.sc-sdx-header-left-hand-menu{line-height:80px;letter-spacing:-1.75px;font-size:70px}}/*!@.d2,\n.text-d2*/.d2.sc-sdx-header-left-hand-menu,.text-d2.sc-sdx-header-left-hand-menu{line-height:56px;letter-spacing:-1.2px;font-size:48px}@media (min-width: 1024px){/*!@.d2,\n  .text-d2*/.d2.sc-sdx-header-left-hand-menu,.text-d2.sc-sdx-header-left-hand-menu{line-height:64px;letter-spacing:-1.35px;font-size:54px}}/*!@.d3,\n.text-d3*/.d3.sc-sdx-header-left-hand-menu,.text-d3.sc-sdx-header-left-hand-menu{line-height:48px;letter-spacing:-1.2px;font-size:40px}@media (min-width: 1024px){/*!@.d3,\n  .text-d3*/.d3.sc-sdx-header-left-hand-menu,.text-d3.sc-sdx-header-left-hand-menu{line-height:56px;letter-spacing:-1.2px;font-size:48px}}/*!@.text-b1*/.text-b1.sc-sdx-header-left-hand-menu{line-height:24px;letter-spacing:-0.1px;font-size:18px;font-weight:400}/*!@.text-b2*/.text-b2.sc-sdx-header-left-hand-menu{line-height:21px;letter-spacing:0;font-size:16px;font-weight:400}/*!@.text-sm,\n.text-smaller*/.text-sm.sc-sdx-header-left-hand-menu,.text-smaller.sc-sdx-header-left-hand-menu{line-height:18px;letter-spacing:0.1px;font-size:14px;font-weight:400}/*!@.text-compact*/.text-compact.sc-sdx-header-left-hand-menu{line-height:21px}/*!@.figcaption*/.figcaption.sc-sdx-header-left-hand-menu{line-height:18px;letter-spacing:0.1px;font-size:14px}/*!@.code*/.code.sc-sdx-header-left-hand-menu{font-family:monospace;background-color:#f8fafb;border-radius:4px;border:1px solid #d6d6d6;color:#474747;font-size:16px;padding:0 6px}/*!@address*/address.sc-sdx-header-left-hand-menu{font-style:normal}/*!@strong*/strong.sc-sdx-header-left-hand-menu{font-weight:600}/*!@em*/em.sc-sdx-header-left-hand-menu{font-style:italic}/*!@.sdx--dark-theme .code*/.sdx--dark-theme.sc-sdx-header-left-hand-menu .code.sc-sdx-header-left-hand-menu{background-color:#242424;color:#d6d6d6}/*!@.font*/.font.sc-sdx-header-left-hand-menu{font-family:TheSans, sans-serif}/*!@.font--sans*/.font--sans.sc-sdx-header-left-hand-menu{font-family:TheSans, sans-serif}/*!@.font--serif*/.font--serif.sc-sdx-header-left-hand-menu{font-family:TheSerif, serif}/*!@.font--light*/.font--light.sc-sdx-header-left-hand-menu{font-weight:300}/*!@.font--semi-light*/.font--semi-light.sc-sdx-header-left-hand-menu{font-weight:400}/*!@.font--semi-bold*/.font--semi-bold.sc-sdx-header-left-hand-menu{font-weight:600}/*!@.sdx--dark-theme .h1,\n.sdx--dark-theme .h2,\n.sdx--dark-theme .h3,\n.sdx--dark-theme .h4,\n.sdx--dark-theme .h5,\n.sdx--dark-theme .h6,\n.sdx--dark-theme .hero,\n.sdx--dark-theme .d1,\n.sdx--dark-theme .d2,\n.sdx--dark-theme .d3*/.sdx--dark-theme.sc-sdx-header-left-hand-menu .h1.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .h2.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .h3.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .h4.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .h5.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .h6.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .hero.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .d1.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .d2.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .d3.sc-sdx-header-left-hand-menu{color:unset}/*!@.sdx--dark-theme .h1,\n.sdx--dark-theme .text-h1,\n.sdx--dark-theme h1,\n.sdx--dark-theme .h2,\n.sdx--dark-theme .text-h2,\n.sdx--dark-theme h2,\n.sdx--dark-theme .h3,\n.sdx--dark-theme .text-h3,\n.sdx--dark-theme h3,\n.sdx--dark-theme .h4,\n.sdx--dark-theme .text-h4,\n.sdx--dark-theme h4,\n.sdx--dark-theme .d1,\n.sdx--dark-theme .text-d1,\n.sdx--dark-theme .d2,\n.sdx--dark-theme .text-d2,\n.sdx--dark-theme .d3,\n.sdx--dark-theme .text-d3*/.sdx--dark-theme.sc-sdx-header-left-hand-menu .h1.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .text-h1.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu h1.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .h2.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .text-h2.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu h2.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .h3.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .text-h3.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu h3.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .h4.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .text-h4.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu h4.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .d1.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .text-d1.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .d2.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .text-d2.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .d3.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .text-d3.sc-sdx-header-left-hand-menu{font-weight:600}/*!@.sdx--dark-theme .p,\n.sdx--dark-theme .paragraph,\n.sdx--dark-theme p*/.sdx--dark-theme.sc-sdx-header-left-hand-menu .p.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .paragraph.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu p.sc-sdx-header-left-hand-menu{font-weight:500}/*!@.sdx--dark-theme .h1,\n.sdx--dark-theme .text-h1,\n.sdx--dark-theme h1*/.sdx--dark-theme.sc-sdx-header-left-hand-menu .h1.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .text-h1.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu h1.sc-sdx-header-left-hand-menu{letter-spacing:-0.8px}/*!@.sdx--dark-theme .h2,\n.sdx--dark-theme .text-h2,\n.sdx--dark-theme h2*/.sdx--dark-theme.sc-sdx-header-left-hand-menu .h2.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .text-h2.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu h2.sc-sdx-header-left-hand-menu{letter-spacing:-0.6px}/*!@.sdx--dark-theme .h3,\n.sdx--dark-theme .text-h3,\n.sdx--dark-theme h3*/.sdx--dark-theme.sc-sdx-header-left-hand-menu .h3.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .text-h3.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu h3.sc-sdx-header-left-hand-menu{letter-spacing:-0.5px}/*!@.sdx--dark-theme .h4,\n.sdx--dark-theme .text-h4,\n.sdx--dark-theme h4*/.sdx--dark-theme.sc-sdx-header-left-hand-menu .h4.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .text-h4.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu h4.sc-sdx-header-left-hand-menu{letter-spacing:-0.2px}/*!@.sdx--dark-theme .h5,\n.sdx--dark-theme .text-h5,\n.sdx--dark-theme h5*/.sdx--dark-theme.sc-sdx-header-left-hand-menu .h5.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .text-h5.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu h5.sc-sdx-header-left-hand-menu{letter-spacing:-0.1px}/*!@.sdx--dark-theme .h6,\n.sdx--dark-theme .text-h6,\n.sdx--dark-theme h6*/.sdx--dark-theme.sc-sdx-header-left-hand-menu .h6.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .text-h6.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu h6.sc-sdx-header-left-hand-menu{letter-spacing:0px}/*!@.sdx--dark-theme .d1,\n.sdx--dark-theme .text-d1*/.sdx--dark-theme.sc-sdx-header-left-hand-menu .d1.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .text-d1.sc-sdx-header-left-hand-menu{letter-spacing:-1.4px}/*!@.sdx--dark-theme .d2,\n.sdx--dark-theme .text-d2*/.sdx--dark-theme.sc-sdx-header-left-hand-menu .d2.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .text-d2.sc-sdx-header-left-hand-menu{letter-spacing:-1px}/*!@.sdx--dark-theme .d3,\n.sdx--dark-theme .text-d3*/.sdx--dark-theme.sc-sdx-header-left-hand-menu .d3.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu .text-d3.sc-sdx-header-left-hand-menu{letter-spacing:-0.9px}/*!@.sdx--dark-theme strong,\n.sdx--dark-theme b*/.sdx--dark-theme.sc-sdx-header-left-hand-menu strong.sc-sdx-header-left-hand-menu,.sdx--dark-theme.sc-sdx-header-left-hand-menu b.sc-sdx-header-left-hand-menu{color:#fff}/*!@.sdx--dark-theme code*/.sdx--dark-theme.sc-sdx-header-left-hand-menu code.sc-sdx-header-left-hand-menu{background-color:#242424;border:1px solid #b1b9be;border-radius:4px;color:#cfd5d9;font-size:16px}/*!@:host ::slotted(sdx-search)*/.sc-sdx-header-left-hand-menu-h .sc-sdx-header-left-hand-menu-s>sdx-search{width:200px;color:#015}/*!@.container*/.container.sc-sdx-header-left-hand-menu{display:flex}@media (min-width: 0){/*!@.container*/.container.sc-sdx-header-left-hand-menu{margin-left:calc(24px - 4px);margin-right:calc(24px - 4px);padding-left:4px;padding-right:4px;width:auto}}@media (min-width: 1440px){/*!@.container*/.container.sc-sdx-header-left-hand-menu{margin-left:auto;margin-right:auto;padding-left:12px;padding-right:12px;width:1380px}}/*!@.link*/.link.sc-sdx-header-left-hand-menu{text-decoration:none;color:#015;transition:color 200ms cubic-bezier(0.4, 0, 0.2, 1);text-underline-offset:4px;white-space:nowrap;outline:none}/*!@.link[href]:hover*/.link[href].sc-sdx-header-left-hand-menu:hover{color:#0048cf}/*!@.link .icon-label-wrapper*/.link.sc-sdx-header-left-hand-menu .icon-label-wrapper.sc-sdx-header-left-hand-menu{position:relative;display:flex;align-items:center;gap:6px}/*!@.link .icon-label-wrapper:hover .badge*/.link.sc-sdx-header-left-hand-menu .icon-label-wrapper.sc-sdx-header-left-hand-menu:hover .badge.sc-sdx-header-left-hand-menu{background:#ba3e06}/*!@.link .icon-label-wrapper .badge*/.link.sc-sdx-header-left-hand-menu .icon-label-wrapper.sc-sdx-header-left-hand-menu .badge.sc-sdx-header-left-hand-menu{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-weight:600;border-radius:18px;color:#fff;font-size:13px;height:18px;line-height:18px;min-width:18px;max-width:50px;text-align:center;padding:0 5px;user-select:none;animation:badge 300ms linear both;background:#cf4a0c;pointer-events:none;transition:background 70ms cubic-bezier(0.4, 0, 0.6, 1);position:absolute;bottom:calc(100% - 13px);left:calc(100% - 9px)}@keyframes badge{0%{transform:scale(1)}25%{transform:scale(1.15)}50%{transform:scale(1)}75%{transform:scale(0.85)}100%{transform:scale(1)}}/*!@.link .initials*/.link.sc-sdx-header-left-hand-menu .initials.sc-sdx-header-left-hand-menu{background:#015;height:24px;width:24px;border-radius:100%;color:#fff;font-size:12px;display:flex;justify-content:center;align-items:center}/*!@.push-right*/.push-right.sc-sdx-header-left-hand-menu{margin-right:auto}/*!@.primary.list .link[href]:hover .icon.icon-214-present, .primary.list .link[href]:hover .icon.icon-present,\n.main.list .link[href]:hover .icon.icon-214-present,\n.main.list .link[href]:hover .icon.icon-present*/.primary.list.sc-sdx-header-left-hand-menu .link[href].sc-sdx-header-left-hand-menu:hover .icon.icon-214-present.sc-sdx-header-left-hand-menu,.primary.list.sc-sdx-header-left-hand-menu .link[href].sc-sdx-header-left-hand-menu:hover .icon.icon-present.sc-sdx-header-left-hand-menu,.main.list.sc-sdx-header-left-hand-menu .link[href].sc-sdx-header-left-hand-menu:hover .icon.icon-214-present.sc-sdx-header-left-hand-menu,.main.list.sc-sdx-header-left-hand-menu .link[href].sc-sdx-header-left-hand-menu:hover .icon.icon-present.sc-sdx-header-left-hand-menu{background:#7f2879}/*!@.primary.list .icon,\n.main.list .icon*/.primary.list.sc-sdx-header-left-hand-menu .icon.sc-sdx-header-left-hand-menu,.main.list.sc-sdx-header-left-hand-menu .icon.sc-sdx-header-left-hand-menu{display:none}/*!@.primary.list .icon.icon-214-present, .primary.list .icon.icon-present,\n.main.list .icon.icon-214-present,\n.main.list .icon.icon-present*/.primary.list.sc-sdx-header-left-hand-menu .icon.icon-214-present.sc-sdx-header-left-hand-menu,.primary.list.sc-sdx-header-left-hand-menu .icon.icon-present.sc-sdx-header-left-hand-menu,.main.list.sc-sdx-header-left-hand-menu .icon.icon-214-present.sc-sdx-header-left-hand-menu,.main.list.sc-sdx-header-left-hand-menu .icon.icon-present.sc-sdx-header-left-hand-menu{display:inline-block;transition:background 200ms cubic-bezier(0.4, 0, 0.2, 1);background:#a63297;color:white;font-size:16px;border-radius:50%;height:24px;width:24px;text-align:center}/*!@.list*/.list.sc-sdx-header-left-hand-menu{list-style-type:none;margin:0;padding:0;display:flex}/*!@.list .item*/.list.sc-sdx-header-left-hand-menu .item.sc-sdx-header-left-hand-menu{display:flex}/*!@.list .item.active.leaf > .link*/.list.sc-sdx-header-left-hand-menu .item.active.leaf.sc-sdx-header-left-hand-menu>.link.sc-sdx-header-left-hand-menu{text-decoration:underline}/*!@.list .item .link*/.list.sc-sdx-header-left-hand-menu .item.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu{display:flex;align-items:center;flex-grow:1}/*!@.list.horizontal:not(:first-of-type)*/.list.horizontal.sc-sdx-header-left-hand-menu:not(:first-of-type){margin-left:12px}/*!@.list.horizontal:not(:last-of-type):not(.last-of-type)*/.list.horizontal.sc-sdx-header-left-hand-menu:not(:last-of-type):not(.last-of-type){margin-right:12px}/*!@.list.horizontal > .item:not(:first-of-type)*/.list.horizontal.sc-sdx-header-left-hand-menu>.item.sc-sdx-header-left-hand-menu:not(:first-of-type){margin-left:12px}/*!@.list.horizontal > .item:not(:last-of-type):not(.last-of-type)*/.list.horizontal.sc-sdx-header-left-hand-menu>.item.sc-sdx-header-left-hand-menu:not(:last-of-type):not(.last-of-type){margin-right:12px}/*!@.list.vertical*/.list.vertical.sc-sdx-header-left-hand-menu{flex-flow:column}/*!@.list.vertical > .item*/.list.vertical.sc-sdx-header-left-hand-menu>.item.sc-sdx-header-left-hand-menu{margin:5px 0}/*!@.list.primary .item.active .toggle .link*/.list.primary.sc-sdx-header-left-hand-menu .item.active.sc-sdx-header-left-hand-menu .toggle.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu{text-decoration:underline}/*!@.list.secondary .link:not(:hover), .list.tertiary .link:not(:hover)*/.list.secondary.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu:not(:hover),.list.tertiary.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu:not(:hover){color:#333}/*!@.list.secondary .toggle .link:not(:hover)::before, .list.secondary .toggle .link:not(:hover)::after, .list.tertiary .toggle .link:not(:hover)::before, .list.tertiary .toggle .link:not(:hover)::after*/.list.secondary.sc-sdx-header-left-hand-menu .toggle.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu:not(:hover)::before,.list.secondary.sc-sdx-header-left-hand-menu .toggle.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu:not(:hover)::after,.list.tertiary.sc-sdx-header-left-hand-menu .toggle.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu:not(:hover)::before,.list.tertiary.sc-sdx-header-left-hand-menu .toggle.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu:not(:hover)::after{background:#333}/*!@.list.accordion:not(:first-of-type)*/.list.accordion.sc-sdx-header-left-hand-menu:not(:first-of-type){padding-top:8px}/*!@.list.accordion:not(:last-of-type)*/.list.accordion.sc-sdx-header-left-hand-menu:not(:last-of-type){padding-bottom:8px;border-bottom:1px solid #dde3e7}/*!@.list.accordion.main, .list.accordion.left-hand-menu*/.list.accordion.main.sc-sdx-header-left-hand-menu,.list.accordion.left-hand-menu.sc-sdx-header-left-hand-menu{font-weight:600}/*!@.list.accordion.main .item.deepest .link, .list.accordion.left-hand-menu .item.deepest .link*/.list.accordion.main.sc-sdx-header-left-hand-menu .item.deepest.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu,.list.accordion.left-hand-menu.sc-sdx-header-left-hand-menu .item.deepest.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu{font-weight:400}/*!@.list.accordion sdx-accordion*/.list.accordion.sc-sdx-header-left-hand-menu sdx-accordion.sc-sdx-header-left-hand-menu{width:100%}/*!@.list.accordion sdx-accordion sdx-accordion-item-body > .list*/.list.accordion.sc-sdx-header-left-hand-menu sdx-accordion.sc-sdx-header-left-hand-menu sdx-accordion-item-body.sc-sdx-header-left-hand-menu>.list.sc-sdx-header-left-hand-menu{margin:5px 0}/*!@.list.accordion sdx-accordion sdx-accordion-item-body > .list > .item:last-of-type*/.list.accordion.sc-sdx-header-left-hand-menu sdx-accordion.sc-sdx-header-left-hand-menu sdx-accordion-item-body.sc-sdx-header-left-hand-menu>.list.sc-sdx-header-left-hand-menu>.item.sc-sdx-header-left-hand-menu:last-of-type{margin-bottom:0}/*!@.component*/.component.sc-sdx-header-left-hand-menu{font-weight:400;font-size:16px}/*!@.component.desktop sdx-header-menu .content*/.component.desktop.sc-sdx-header-left-hand-menu sdx-header-menu.sc-sdx-header-left-hand-menu .content.sc-sdx-header-left-hand-menu{max-height:calc(\n          var(--sdx-dialog-window-inner-height, 100vh) - 128px\n        )}/*!@.component.mobile sdx-header-menu*/.component.mobile.sc-sdx-header-left-hand-menu sdx-header-menu.sc-sdx-header-left-hand-menu{position:static}/*!@.component.mobile sdx-header-menu .content*/.component.mobile.sc-sdx-header-left-hand-menu sdx-header-menu.sc-sdx-header-left-hand-menu .content.sc-sdx-header-left-hand-menu{max-height:calc(\n          var(--sdx-dialog-window-inner-height, 100vh) - 88px\n        );margin:0}/*!@.component .wrapper*/.component.sc-sdx-header-left-hand-menu .wrapper.sc-sdx-header-left-hand-menu{display:flex;flex-direction:column;position:relative;background:#fff}/*!@.component .wrapper.meta*/.component.sc-sdx-header-left-hand-menu .wrapper.meta.sc-sdx-header-left-hand-menu{z-index:50000}/*!@.component .wrapper.main*/.component.sc-sdx-header-left-hand-menu .wrapper.main.sc-sdx-header-left-hand-menu{border-bottom:1px solid #dde3e7;z-index:49999;top:0}/*!@.component .wrapper.breadcrumb-list*/.component.sc-sdx-header-left-hand-menu .wrapper.breadcrumb-list.sc-sdx-header-left-hand-menu{z-index:49998}/*!@.component .header .meta > .container*/.component.sc-sdx-header-left-hand-menu .header.sc-sdx-header-left-hand-menu .meta.sc-sdx-header-left-hand-menu>.container.sc-sdx-header-left-hand-menu{height:40px}/*!@.component .header .main > .container*/.component.sc-sdx-header-left-hand-menu .header.sc-sdx-header-left-hand-menu .main.sc-sdx-header-left-hand-menu>.container.sc-sdx-header-left-hand-menu{height:71px}/*!@.component .header .main > .container > .list .item.active .toggle .link*/.component.sc-sdx-header-left-hand-menu .header.sc-sdx-header-left-hand-menu .main.sc-sdx-header-left-hand-menu>.container.sc-sdx-header-left-hand-menu>.list.sc-sdx-header-left-hand-menu .item.active.sc-sdx-header-left-hand-menu .toggle.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu{text-decoration:underline}/*!@.component .header .main > .container > .list:not(:first-of-type)*/.component.sc-sdx-header-left-hand-menu .header.sc-sdx-header-left-hand-menu .main.sc-sdx-header-left-hand-menu>.container.sc-sdx-header-left-hand-menu>.list.sc-sdx-header-left-hand-menu:not(:first-of-type){margin-left:16px}/*!@.component .header .main > .container > .list:not(:last-of-type):not(.last-of-type)*/.component.sc-sdx-header-left-hand-menu .header.sc-sdx-header-left-hand-menu .main.sc-sdx-header-left-hand-menu>.container.sc-sdx-header-left-hand-menu>.list.sc-sdx-header-left-hand-menu:not(:last-of-type):not(.last-of-type){margin-right:16px}/*!@.component .header .main > .container > .list.logo*/.component.sc-sdx-header-left-hand-menu .header.sc-sdx-header-left-hand-menu .main.sc-sdx-header-left-hand-menu>.container.sc-sdx-header-left-hand-menu>.list.logo.sc-sdx-header-left-hand-menu{margin-left:-18px}/*!@.component .header .main > .container > .list.logo .img*/.component.sc-sdx-header-left-hand-menu .header.sc-sdx-header-left-hand-menu .main.sc-sdx-header-left-hand-menu>.container.sc-sdx-header-left-hand-menu>.list.logo.sc-sdx-header-left-hand-menu .img.sc-sdx-header-left-hand-menu{background-size:3600px 40px;background-position:0 0;background-repeat:no-repeat;background-image:url(\"../images/lifeform-spritesheet.png\");width:40px;height:40px;backface-visibility:hidden;min-width:40px;animation:repeatingAnimation 30s steps(90) infinite, initialAnimation 6s steps(90);display:inline-block}@media only screen and (-webkit-min-device-pixel-ratio: 2), only screen and (min--moz-device-pixel-ratio: 2), only screen and (-o-min-device-pixel-ratio: 2/1), only screen and (min-device-pixel-ratio: 2), only screen and (min-resolution: 192dpi), only screen and (min-resolution: 2dppx){/*!@.component .header .main > .container > .list.logo .img*/.component.sc-sdx-header-left-hand-menu .header.sc-sdx-header-left-hand-menu .main.sc-sdx-header-left-hand-menu>.container.sc-sdx-header-left-hand-menu>.list.logo.sc-sdx-header-left-hand-menu .img.sc-sdx-header-left-hand-menu{background-image:url(\"../images/lifeform-spritesheet@2x.png\")}}@keyframes initialAnimation{100%{background-position:-3600px}}@keyframes repeatingAnimation{0%{background-position:0}80%{background-position:0}100%{background-position:-3600px}}/*!@.component .header .main > .container > .list.main .toggle*/.component.sc-sdx-header-left-hand-menu .header.sc-sdx-header-left-hand-menu .main.sc-sdx-header-left-hand-menu>.container.sc-sdx-header-left-hand-menu>.list.main.sc-sdx-header-left-hand-menu .toggle.sc-sdx-header-left-hand-menu{font-weight:600;font-size:20px}/*!@.component .header .breadcrumb-list > .container*/.component.sc-sdx-header-left-hand-menu .header.sc-sdx-header-left-hand-menu .breadcrumb-list.sc-sdx-header-left-hand-menu>.container.sc-sdx-header-left-hand-menu{font-size:14px}/*!@.component .header .breadcrumb-list > .container .list*/.component.sc-sdx-header-left-hand-menu .header.sc-sdx-header-left-hand-menu .breadcrumb-list.sc-sdx-header-left-hand-menu>.container.sc-sdx-header-left-hand-menu .list.sc-sdx-header-left-hand-menu{height:48px}/*!@.component .header .breadcrumb-list > .container .item*/.component.sc-sdx-header-left-hand-menu .header.sc-sdx-header-left-hand-menu .breadcrumb-list.sc-sdx-header-left-hand-menu>.container.sc-sdx-header-left-hand-menu .item.sc-sdx-header-left-hand-menu{margin:0}/*!@.component .header .breadcrumb-list > .container .item:first-of-type .label*/.component.sc-sdx-header-left-hand-menu .header.sc-sdx-header-left-hand-menu .breadcrumb-list.sc-sdx-header-left-hand-menu>.container.sc-sdx-header-left-hand-menu .item.sc-sdx-header-left-hand-menu:first-of-type .label.sc-sdx-header-left-hand-menu{display:none}/*!@.component .header .breadcrumb-list > .container .item:not(:first-of-type)::before*/.component.sc-sdx-header-left-hand-menu .header.sc-sdx-header-left-hand-menu .breadcrumb-list.sc-sdx-header-left-hand-menu>.container.sc-sdx-header-left-hand-menu .item.sc-sdx-header-left-hand-menu:not(:first-of-type)::before{content:\">\";align-self:center;margin:0 8px}/*!@.component .header .slot-menu-header*/.component.sc-sdx-header-left-hand-menu .header.sc-sdx-header-left-hand-menu .slot-menu-header.sc-sdx-header-left-hand-menu{display:flex;padding:16px}/*!@.component .header .slot-menu-header .title*/.component.sc-sdx-header-left-hand-menu .header.sc-sdx-header-left-hand-menu .slot-menu-header.sc-sdx-header-left-hand-menu .title.sc-sdx-header-left-hand-menu{flex:1;margin:0}/*!@sdx-button*/sdx-button.sc-sdx-header-left-hand-menu{color:#015;display:flex;align-items:center}/*!@:host(.sdx-dark-theme) ::slotted(sdx-search)*/.sc-sdx-header-left-hand-menu-h.sdx-dark-theme .sc-sdx-header-left-hand-menu-s>sdx-search{color:#e6e6e6}/*!@.component.sdx--dark-theme .link*/.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu{color:#e6e6e6}/*!@.component.sdx--dark-theme .link[href]:hover*/.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .link[href].sc-sdx-header-left-hand-menu:hover{color:#5ca3ff}/*!@.component.sdx--dark-theme .link .initials*/.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu .initials.sc-sdx-header-left-hand-menu{background:#5c5c5c}/*!@.component.sdx--dark-theme .primary.list .link[href]:hover .icon.icon-214-present, .component.sdx--dark-theme .primary.list .link[href]:hover .icon.icon-present,\n.component.sdx--dark-theme .main.list .link[href]:hover .icon.icon-214-present,\n.component.sdx--dark-theme .main.list .link[href]:hover .icon.icon-present*/.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .primary.list.sc-sdx-header-left-hand-menu .link[href].sc-sdx-header-left-hand-menu:hover .icon.icon-214-present.sc-sdx-header-left-hand-menu,.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .primary.list.sc-sdx-header-left-hand-menu .link[href].sc-sdx-header-left-hand-menu:hover .icon.icon-present.sc-sdx-header-left-hand-menu,.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .main.list.sc-sdx-header-left-hand-menu .link[href].sc-sdx-header-left-hand-menu:hover .icon.icon-214-present.sc-sdx-header-left-hand-menu,.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .main.list.sc-sdx-header-left-hand-menu .link[href].sc-sdx-header-left-hand-menu:hover .icon.icon-present.sc-sdx-header-left-hand-menu{background:#b053a5}/*!@.component.sdx--dark-theme .primary.list .icon.icon-214-present, .component.sdx--dark-theme .primary.list .icon.icon-present,\n.component.sdx--dark-theme .main.list .icon.icon-214-present,\n.component.sdx--dark-theme .main.list .icon.icon-present*/.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .primary.list.sc-sdx-header-left-hand-menu .icon.icon-214-present.sc-sdx-header-left-hand-menu,.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .primary.list.sc-sdx-header-left-hand-menu .icon.icon-present.sc-sdx-header-left-hand-menu,.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .main.list.sc-sdx-header-left-hand-menu .icon.icon-214-present.sc-sdx-header-left-hand-menu,.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .main.list.sc-sdx-header-left-hand-menu .icon.icon-present.sc-sdx-header-left-hand-menu{background:#a54c9b}/*!@.component.sdx--dark-theme .list.secondary .link:not(:hover), .component.sdx--dark-theme .list.tertiary .link:not(:hover)*/.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .list.secondary.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu:not(:hover),.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .list.tertiary.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu:not(:hover){color:#adadad}/*!@.component.sdx--dark-theme .list.secondary .toggle .link:not(:hover)::before, .component.sdx--dark-theme .list.secondary .toggle .link:not(:hover)::after, .component.sdx--dark-theme .list.tertiary .toggle .link:not(:hover)::before, .component.sdx--dark-theme .list.tertiary .toggle .link:not(:hover)::after*/.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .list.secondary.sc-sdx-header-left-hand-menu .toggle.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu:not(:hover)::before,.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .list.secondary.sc-sdx-header-left-hand-menu .toggle.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu:not(:hover)::after,.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .list.tertiary.sc-sdx-header-left-hand-menu .toggle.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu:not(:hover)::before,.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .list.tertiary.sc-sdx-header-left-hand-menu .toggle.sc-sdx-header-left-hand-menu .link.sc-sdx-header-left-hand-menu:not(:hover)::after{background:#adadad}/*!@.component.sdx--dark-theme .list.accordion:not(:last-of-type)*/.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .list.accordion.sc-sdx-header-left-hand-menu:not(:last-of-type){border-bottom-color:#5c5c5c}/*!@.component.sdx--dark-theme .wrapper*/.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .wrapper.sc-sdx-header-left-hand-menu{background:#1d1d1d}/*!@.component.sdx--dark-theme .wrapper.main*/.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .wrapper.main.sc-sdx-header-left-hand-menu{border-bottom-color:#707070}/*!@.component.sdx--dark-theme .wrapper.breadcrumb-list*/.component.sdx--dark-theme.sc-sdx-header-left-hand-menu .wrapper.breadcrumb-list.sc-sdx-header-left-hand-menu{background:#141414}/*!@sdx-button.sdx--dark-theme*/sdx-button.sdx--dark-theme.sc-sdx-header-left-hand-menu{color:#adadad}";

/**
 * @private
 */
class HeaderLeftHandMenu {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.items = [];
    this.allItems = [];
    this.activeItems = [];
  }
  getComponentClassNames() {
    return {
      [getAppearance(this.el)]: true,
      component: true,
    };
  }
  render() {
    return (hAsync("nav", { class: this.getComponentClassNames() }, hAsync("ul", { class: "list vertical accordion left-hand-menu" }, this.items.map((item) => createItemForAccordion(item, this.allItems, this.activeItems, "left", {
      body: { marginLeft: "23px" },
      arrow: {
        background: getAppearance(this.el) === "sdx--light-theme"
          ? "#015" /* $color-navy */
          : "#adadad" /* $color-gray-dark-theme*/,
      },
    }, 2)))));
  }
  get el() { return getElement(this); }
  static get style() { return headerCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-header-left-hand-menu",
    "$members$": {
      "items": [16],
      "allItems": [16],
      "activeItems": [16]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const headerMenuCss = ":root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}:host,*,*:before,*:after{box-sizing:border-box}sdx-header-menu{display:flex;height:100%;position:relative}sdx-header-menu:not(.slot) .content{padding:16px}sdx-header-menu.scrollable .content{-webkit-overflow-scrolling:touch;overflow-y:auto}sdx-header-menu.main .content,sdx-header-menu.meta .content{top:calc(100% + 1px)}sdx-header-menu.meta .toggle.arrow .link{position:relative;padding-right:21px}sdx-header-menu.meta .toggle.arrow .link::before,sdx-header-menu.meta .toggle.arrow .link::after{position:absolute;top:50%;transition:all 200ms cubic-bezier(0.4, 0, 0.2, 1);border-radius:2px;background:#015;width:10px;height:2px;backface-visibility:hidden;content:\"\"}sdx-header-menu.meta .toggle.arrow .link::before{left:0}sdx-header-menu.meta .toggle.arrow .link::after{left:6px}sdx-header-menu.meta .toggle.arrow .link::before{transform:rotate(45deg)}sdx-header-menu.meta .toggle.arrow .link::after{transform:rotate(-45deg)}sdx-header-menu.meta .toggle.arrow .link::before{left:auto;right:6px}sdx-header-menu.meta .toggle.arrow .link::after{left:auto;right:0}sdx-header-menu.meta .toggle.arrow .link:hover::before,sdx-header-menu.meta .toggle.arrow .link:hover::after{background:#0048cf}sdx-header-menu.meta .toggle.arrow.open .link::before,sdx-header-menu.meta .toggle.arrow.opening .link::before{transform:rotate(-45deg)}sdx-header-menu.meta .toggle.arrow.open .link::after,sdx-header-menu.meta .toggle.arrow.opening .link::after{transform:rotate(45deg)}sdx-header-menu.meta .toggle.arrow.open .link:not(:hover)::before,sdx-header-menu.meta .toggle.arrow.open .link:not(:hover)::after,sdx-header-menu.meta .toggle.arrow.opening .link:not(:hover)::before,sdx-header-menu.meta .toggle.arrow.opening .link:not(:hover)::after{background:#086adb}sdx-header-menu.meta .content{top:100%}sdx-header-menu.auto .content{padding-top:0;padding-bottom:8px}sdx-header-menu.fixed-left .content,sdx-header-menu.fixed-right .content{width:100%}@media (min-width: 480px){sdx-header-menu.fixed-left .content,sdx-header-menu.fixed-right .content{width:360px}}sdx-header-menu.fixed-left .content .link,sdx-header-menu.fixed-right .content .link{white-space:normal}sdx-header-menu.fixed-right .content{right:0;margin-right:-16px}sdx-header-menu .toggle{display:flex;cursor:pointer}sdx-header-menu .toggle.open .link:not(:hover),sdx-header-menu .toggle.opening .link:not(:hover){color:#086adb}sdx-header-menu .content{position:absolute;background:#fff;margin-left:-16px;border-radius:0 0 3px 3px;border:1px solid #dde3e7;border-top:0;display:none}sdx-header-menu.sdx--dark-theme.meta .toggle.arrow .link::before,sdx-header-menu.sdx--dark-theme.meta .toggle.arrow .link::after{background:#adadad}sdx-header-menu.sdx--dark-theme.meta .toggle.arrow .link:hover::before,sdx-header-menu.sdx--dark-theme.meta .toggle.arrow .link:hover::after{background:#5ca3ff}sdx-header-menu.sdx--dark-theme.meta .toggle.arrow.open .link:not(:hover)::before,sdx-header-menu.sdx--dark-theme.meta .toggle.arrow.open .link:not(:hover)::after,sdx-header-menu.sdx--dark-theme.meta .toggle.arrow.opening .link:not(:hover)::before,sdx-header-menu.sdx--dark-theme.meta .toggle.arrow.opening .link:not(:hover)::after{background:#4294ff}sdx-header-menu.sdx--dark-theme .toggle.open .link:not(:hover),sdx-header-menu.sdx--dark-theme .toggle.opening .link:not(:hover){color:#4294ff}sdx-header-menu.sdx--dark-theme .content{background:#1d1d1d;border-color:#707070}";

/**
 * @private
 */
class HeaderMenu {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.animationDuration = 200;
    this.display = "closed";
    this.level = "meta";
    this.layout = "auto";
    this.width = undefined;
    this.scrollable = true;
    this.displayChangeCallback = () => undefined;
    this.animated = true;
  }
  displayChanged() {
    if (this.display === "opening") {
      setCssVariableWindowInnerHeight();
    }
    this.displayChangeCallback(this.el, this.display);
  }
  onWindowResize() {
    if (this.display === "open") {
      setCssVariableWindowInnerHeight();
    }
  }
  async toggle() {
    if (this.display === "open" || this.display === "opening") {
      this.close();
    }
    else {
      this.open();
    }
  }
  async open() {
    if (this.display === "open" || this.display === "opening") {
      return;
    }
    const contentEl = this.contentEl;
    const slotContainerEl = this.slotContainerEl;
    const sdxBackdropEl = this.sdxBackdropEl;
    this.display = "opening";
    appendToOverlayOutlet(sdxBackdropEl, document.body, this.el);
    anime.set(sdxBackdropEl, { display: "block" });
    anime.set(contentEl, {
      transformOrigin: "50% 0",
      display: "block",
      scaleY: 0,
      opacity: 0.2,
    });
    anime.set(slotContainerEl, { opacity: 0 });
    anime
      .timeline({
      duration: this.animated ? this.animationDuration : 0,
      easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
      complete: () => {
        var _a;
        (_a = this.trapFocusEl) === null || _a === void 0 ? void 0 : _a.doFocus();
        this.display = "open";
      },
    })
      .add({
      targets: sdxBackdropEl,
      backdropFilter: [
        "blur(0px) brightness(100%)",
        "blur(4px) brightness(50%)",
      ],
    })
      .add({
      targets: contentEl,
      opacity: 1,
      scaleY: 1,
    }, 0)
      .add({
      targets: slotContainerEl,
      opacity: 1,
    });
  }
  async close() {
    if (this.display === "closed" || this.display === "closing") {
      return;
    }
    const contentEl = this.contentEl;
    const sdxBackdropEl = this.sdxBackdropEl;
    this.display = "closing";
    anime
      .timeline({
      duration: this.animated ? this.animationDuration : 0,
      easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
      complete: () => {
        anime.set([sdxBackdropEl, contentEl], { display: "none" });
        appendToOverlayOutlet(sdxBackdropEl, this.el, this.el);
        // Set focus to the toggle element
        const toggleSlotEl = this.el.querySelector("[slot='toggle']");
        toggleSlotEl.focus();
        this.display = "closed";
      },
    })
      .add({
      targets: sdxBackdropEl,
      backdropFilter: "blur(0px) brightness(100%)",
    })
      .add({
      targets: contentEl,
      opacity: 0.2,
      scaleY: 0,
    }, 0);
  }
  /**
   * @private
   * Calls close(), but only when the component is allowed to be closed.
   */
  async requestToClose(e) {
    if (!(this.toggleEl && this.contentEl && this.display === "open")) {
      return;
    }
    if (e instanceof KeyboardEvent) {
      if (e.key === "Escape") {
        this.close();
      }
      return;
    }
    const didClickOnToggleEl = e.composedPath().includes(this.toggleEl);
    const didClickOnContentEl = e.composedPath().includes(this.contentEl);
    if (didClickOnToggleEl) {
      // Already handled in local click handler
      return;
    }
    if (didClickOnContentEl) {
      // Keep open
      return;
    }
    // Clicked somewhere else on window
    this.close();
  }
  getBackdropZIndex() {
    const zIndex = 50000 - 3; // $zindex-navigation
    switch (this.level) {
      case "meta":
        return `${zIndex + 2}`; // overlap "main" and "meta"
      case "main":
        return `${zIndex + 1}`; // overlap "meta"
      default:
        // "meta"
        return `${zIndex}`;
    }
  }
  componentDidLoad() {
    anime.set(this.contentEl, { display: "none" });
  }
  onToggleClick() {
    if (!hasSlot(this.el, "content")) {
      return;
    }
    this.toggle();
  }
  getHostClassNames() {
    return {
      scrollable: this.scrollable,
      [getAppearance(this.el)]: true,
      [this.layout]: true,
      [this.level]: true,
    };
  }
  getToggleClassNames() {
    return {
      toggle: true,
      arrow: hasSlot(this.el, "content"),
      [this.display]: true,
    };
  }
  getContentClassNames() {
    return {
      content: true,
    };
  }
  render() {
    return (hAsync(Host, { class: this.getHostClassNames() }, hAsync("span", { class: this.getToggleClassNames(), onClick: () => this.onToggleClick(), ref: (el) => (this.toggleEl = el) }, hAsync("slot", { name: "toggle" })), hAsync("div", { class: this.getContentClassNames(), style: { width: this.width }, ref: (el) => (this.contentEl = el) }, hAsync("sdx-trap-focus", { ref: (el) => (this.trapFocusEl = el), lang: this.el.lang }, hAsync("nav", { ref: (el) => (this.slotContainerEl = el), "data-nosnippet": true }, hAsync("slot", { name: "content" })))), hAsync("sdx-backdrop", { ref: (el) => (this.sdxBackdropEl = el), style: { zIndex: this.getBackdropZIndex() } })));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "display": ["displayChanged"]
  }; }
  static get style() { return headerMenuCss; }
  static get cmpMeta() { return {
    "$flags$": 4,
    "$tagName$": "sdx-header-menu",
    "$members$": {
      "level": [1],
      "layout": [1],
      "width": [1],
      "scrollable": [4],
      "displayChangeCallback": [16],
      "animated": [4],
      "display": [32],
      "toggle": [64],
      "open": [64],
      "close": [64],
      "requestToClose": [64]
    },
    "$listeners$": [[9, "resize", "onWindowResize"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const iconCss = "/*!@:root*/.sc-sdx-icon:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-icon-h,*.sc-sdx-icon,*.sc-sdx-icon:before,*.sc-sdx-icon:after{box-sizing:border-box}/*!@.white*/.white.sc-sdx-icon{color:#fff}/*!@.navy*/.navy.sc-sdx-icon{color:#015}/*!@.blue*/.blue.sc-sdx-icon{color:#086adb}/*!@.blue-40, .blue-tint-2*/.blue-40.sc-sdx-icon,.blue-tint-2.sc-sdx-icon{color:#a2cdf4}/*!@.blue-20, .blue-tint-3*/.blue-20.sc-sdx-icon,.blue-tint-3.sc-sdx-icon{color:#d1e6f9}/*!@.aluminium,\n.aluminum*/.aluminium.sc-sdx-icon,.aluminum.sc-sdx-icon{color:#dde3e7}/*!@.aluminium-80, .aluminium-tint-2,\n.aluminum-80,\n.aluminum-tint-2*/.aluminium-80.sc-sdx-icon,.aluminium-tint-2.sc-sdx-icon,.aluminum-80.sc-sdx-icon,.aluminum-tint-2.sc-sdx-icon{color:#e4e9ec}/*!@.horizon*/.horizon.sc-sdx-icon{color:#eef3f6}/*!@.horizon-40, .horizon-tint-2*/.horizon-40.sc-sdx-icon,.horizon-tint-2.sc-sdx-icon{color:#f8fafb}/*!@.gray*/.gray.sc-sdx-icon{color:#333}/*!@.gray-90, .gray-tint-2*/.gray-90.sc-sdx-icon,.gray-tint-2.sc-sdx-icon{color:#474747}/*!@.gray-80, .gray-tint-3*/.gray-80.sc-sdx-icon,.gray-tint-3.sc-sdx-icon{color:#5c5c5c}/*!@.gray-mid, .gray-tint-4*/.gray-mid.sc-sdx-icon,.gray-tint-4.sc-sdx-icon{color:#666}/*!@.gray-60, .gray-tint-5*/.gray-60.sc-sdx-icon,.gray-tint-5.sc-sdx-icon{color:#858585}/*!@.gray-40, .gray-tint-6*/.gray-40.sc-sdx-icon,.gray-tint-6.sc-sdx-icon{color:#adadad}/*!@.gray-light, .gray-tint-7*/.gray-light.sc-sdx-icon,.gray-tint-7.sc-sdx-icon{color:#bbb}/*!@.gray-20, .gray-tint-8*/.gray-20.sc-sdx-icon,.gray-tint-8.sc-sdx-icon{color:#d6d6d6}/*!@.sc-blue*/.sc-blue.sc-sdx-icon{color:#1af}/*!@.sc-red*/.sc-red.sc-sdx-icon{color:#d12}/*!@.sc-purple*/.sc-purple.sc-sdx-icon{color:#5944c6}/*!@.sc-navy*/.sc-navy.sc-sdx-icon{color:#015}/*!@.sc-white*/.sc-white.sc-sdx-icon{color:#fff}/*!@.sc-gray*/.sc-gray.sc-sdx-icon{color:#333}/*!@.sc-gray-mid*/.sc-gray-mid.sc-sdx-icon{color:#666}/*!@.sc-gray-light*/.sc-gray-light.sc-sdx-icon{color:#bbb}/*!@.int-blue*/.int-blue.sc-sdx-icon{color:#086adb}/*!@.int-blue--active*/.int-blue--active.sc-sdx-icon{color:#0048cf}/*!@.int-gray*/.int-gray.sc-sdx-icon{color:#cfd5d9}/*!@.int-gray--active*/.int-gray--active.sc-sdx-icon{color:#b1b9be}/*!@.int-green*/.int-green.sc-sdx-icon{color:#1b8712}/*!@.int-green--active*/.int-green--active.sc-sdx-icon{color:#0d6f2c}/*!@.int-red*/.int-red.sc-sdx-icon{color:#d12}/*!@.int-red--active*/.int-red--active.sc-sdx-icon{color:#be0000}/*!@.int-orange*/.int-orange.sc-sdx-icon{color:#cf4a0c}/*!@.int-orange--active*/.int-orange--active.sc-sdx-icon{color:#ba3e06}/*!@.azure*/.azure.sc-sdx-icon{color:#1781e3}/*!@.azure--active*/.azure--active.sc-sdx-icon{color:#0851da}/*!@.orchid*/.orchid.sc-sdx-icon{color:#a63297}/*!@.orchid--active*/.orchid--active.sc-sdx-icon{color:#7f2879}/*!@.orchid-tint-2*/.orchid-tint-2.sc-sdx-icon{color:#ab449f}/*!@.orchid-tint-3*/.orchid-tint-3.sc-sdx-icon{color:#b458a8}/*!@.orchid-tint-4*/.orchid-tint-4.sc-sdx-icon{color:#bb6ab1}/*!@.orchid-tint-5*/.orchid-tint-5.sc-sdx-icon{color:#c47fbb}/*!@.orchid-tint-6*/.orchid-tint-6.sc-sdx-icon{color:#cb91c2}/*!@.orchid-tint-7*/.orchid-tint-7.sc-sdx-icon{color:#d2a4cc}/*!@.orchid-tint-8*/.orchid-tint-8.sc-sdx-icon{color:#dab7d5}/*!@.iris*/.iris.sc-sdx-icon{color:#5944c6}/*!@.iris--active*/.iris--active.sc-sdx-icon{color:#42389e}/*!@.iris-tint-2*/.iris-tint-2.sc-sdx-icon{color:#6754c8}/*!@.iris-tint-3*/.iris-tint-3.sc-sdx-icon{color:#7765ce}/*!@.iris-tint-4*/.iris-tint-4.sc-sdx-icon{color:#7177d2}/*!@.iris-tint-5*/.iris-tint-5.sc-sdx-icon{color:#9589d7}/*!@.iris-tint-6*/.iris-tint-6.sc-sdx-icon{color:#a59adb}/*!@.iris-tint-7*/.iris-tint-7.sc-sdx-icon{color:#b4abe0}/*!@.iris-tint-8*/.iris-tint-8.sc-sdx-icon{color:#c3bce2}/*!@.pink*/.pink.sc-sdx-icon{color:#e61e64}/*!@.pink--active*/.pink--active.sc-sdx-icon{color:#bf1b5a}/*!@.pink-tint-2*/.pink-tint-2.sc-sdx-icon{color:#e63a70}/*!@.pink-tint-3*/.pink-tint-3.sc-sdx-icon{color:#e74e7f}/*!@.pink-tint-4*/.pink-tint-4.sc-sdx-icon{color:#e8628d}/*!@.pink-tint-5*/.pink-tint-5.sc-sdx-icon{color:#ea779c}/*!@.pink-tint-6*/.pink-tint-6.sc-sdx-icon{color:#eb8baa}/*!@.pink-tint-7*/.pink-tint-7.sc-sdx-icon{color:#eca0b8}/*!@.pink-tint-8*/.pink-tint-8.sc-sdx-icon{color:#edb4c6}/*!@.apple,\n.petrol,\n.turquoise*/.apple.sc-sdx-icon,.petrol.sc-sdx-icon,.turquoise.sc-sdx-icon{color:#0eaba9}/*!@.apple--active,\n.petrol--active,\n.turquoise--active*/.apple--active.sc-sdx-icon,.petrol--active.sc-sdx-icon,.turquoise--active.sc-sdx-icon{color:#0c847e}/*!@.turquoise-tint-2*/.turquoise-tint-2.sc-sdx-icon{color:#21b1af}/*!@.turquoise-tint-3*/.turquoise-tint-3.sc-sdx-icon{color:#38b8b6}/*!@.turquoise-tint-4*/.turquoise-tint-4.sc-sdx-icon{color:#4cc0bd}/*!@.turquoise-tint-5*/.turquoise-tint-5.sc-sdx-icon{color:#67c7c5}/*!@.turquoise-tint-6*/.turquoise-tint-6.sc-sdx-icon{color:#7ececd}/*!@.turquoise-tint-7*/.turquoise-tint-7.sc-sdx-icon{color:#97d5d4}/*!@.turquoise-tint-8*/.turquoise-tint-8.sc-sdx-icon{color:#a9dbdb}/*!@.sdx--dark-theme .gray*/.sdx--dark-theme.sc-sdx-icon .gray.sc-sdx-icon{color:#e6e6e6}/*!@.sdx--dark-theme .gray-tint-2*/.sdx--dark-theme.sc-sdx-icon .gray-tint-2.sc-sdx-icon{color:#d6d6d6}/*!@.sdx--dark-theme .gray-tint-3*/.sdx--dark-theme.sc-sdx-icon .gray-tint-3.sc-sdx-icon{color:#cfd5d9}/*!@.sdx--dark-theme .gray-tint-4*/.sdx--dark-theme.sc-sdx-icon .gray-tint-4.sc-sdx-icon{color:#b1b9be}/*!@.sdx--dark-theme .gray-tint-5*/.sdx--dark-theme.sc-sdx-icon .gray-tint-5.sc-sdx-icon{color:#adadad}/*!@.sdx--dark-theme .gray-tint-6*/.sdx--dark-theme.sc-sdx-icon .gray-tint-6.sc-sdx-icon{color:#8c8c8c}/*!@.sdx--dark-theme .gray-tint-7*/.sdx--dark-theme.sc-sdx-icon .gray-tint-7.sc-sdx-icon{color:#707070}/*!@.sdx--dark-theme .gray-tint-8*/.sdx--dark-theme.sc-sdx-icon .gray-tint-8.sc-sdx-icon{color:#5c5c5c}/*!@.sdx--dark-theme .dusk*/.sdx--dark-theme.sc-sdx-icon .dusk.sc-sdx-icon{color:#141414}/*!@.sdx--dark-theme .dusk-tint-2*/.sdx--dark-theme.sc-sdx-icon .dusk-tint-2.sc-sdx-icon{color:#1d1d1d}/*!@.sdx--dark-theme .dusk-tint-3*/.sdx--dark-theme.sc-sdx-icon .dusk-tint-3.sc-sdx-icon{color:#222}/*!@.sdx--dark-theme .dusk-tint-4*/.sdx--dark-theme.sc-sdx-icon .dusk-tint-4.sc-sdx-icon{color:#242424}/*!@.sdx--dark-theme .int-blue*/.sdx--dark-theme.sc-sdx-icon .int-blue.sc-sdx-icon{color:#0a71e9}/*!@.sdx--dark-theme .int-blue--active*/.sdx--dark-theme.sc-sdx-icon .int-blue--active.sc-sdx-icon{color:#147df5}/*!@.sdx--dark-theme .int-blue2*/.sdx--dark-theme.sc-sdx-icon .int-blue2.sc-sdx-icon{color:#4294ff}/*!@.sdx--dark-theme .int-blue2--active*/.sdx--dark-theme.sc-sdx-icon .int-blue2--active.sc-sdx-icon{color:#5ca3ff}/*!@.sdx--dark-theme .int-gray*/.sdx--dark-theme.sc-sdx-icon .int-gray.sc-sdx-icon{color:#adadad}/*!@.sdx--dark-theme .int-gray--active*/.sdx--dark-theme.sc-sdx-icon .int-gray--active.sc-sdx-icon{color:#d6d6d6}/*!@.sdx--dark-theme .int-green*/.sdx--dark-theme.sc-sdx-icon .int-green.sc-sdx-icon{color:#1c8912}/*!@.sdx--dark-theme .int-green--active*/.sdx--dark-theme.sc-sdx-icon .int-green--active.sc-sdx-icon{color:#0d6f2c}/*!@.sdx--dark-theme .int-green2*/.sdx--dark-theme.sc-sdx-icon .int-green2.sc-sdx-icon{color:#21a716}/*!@.sdx--dark-theme .int-red*/.sdx--dark-theme.sc-sdx-icon .int-red.sc-sdx-icon{color:#eb1224}/*!@.sdx--dark-theme .int-red--active*/.sdx--dark-theme.sc-sdx-icon .int-red--active.sc-sdx-icon{color:#be0000}/*!@.sdx--dark-theme .int-red2*/.sdx--dark-theme.sc-sdx-icon .int-red2.sc-sdx-icon{color:#f35d6a}/*!@.sdx--dark-theme .int-red2--active*/.sdx--dark-theme.sc-sdx-icon .int-red2--active.sc-sdx-icon{color:#fe7e89}/*!@.sdx--dark-theme .int-orange*/.sdx--dark-theme.sc-sdx-icon .int-orange.sc-sdx-icon{color:#ce4a0c}/*!@.sdx--dark-theme .int-orange--active*/.sdx--dark-theme.sc-sdx-icon .int-orange--active.sc-sdx-icon{color:#de4f0d}/*!@.sdx--dark-theme .int-orange-2*/.sdx--dark-theme.sc-sdx-icon .int-orange-2.sc-sdx-icon{color:#f26726}/*!@.sdx--dark-theme .int-orange-2--active*/.sdx--dark-theme.sc-sdx-icon .int-orange-2--active.sc-sdx-icon{color:#f37b46}/*!@.sdx--dark-theme .azure*/.sdx--dark-theme.sc-sdx-icon .azure.sc-sdx-icon{color:#136fc3}/*!@.sdx--dark-theme .azure--active*/.sdx--dark-theme.sc-sdx-icon .azure--active.sc-sdx-icon{color:#1578d3}/*!@.sdx--dark-theme .orchid*/.sdx--dark-theme.sc-sdx-icon .orchid.sc-sdx-icon{color:#a54c9b}/*!@.sdx--dark-theme .orchid--active*/.sdx--dark-theme.sc-sdx-icon .orchid--active.sc-sdx-icon{color:#b053a5}/*!@.sdx--dark-theme .iris*/.sdx--dark-theme.sc-sdx-icon .iris.sc-sdx-icon{color:#6f5ccb}/*!@.sdx--dark-theme .iris--active*/.sdx--dark-theme.sc-sdx-icon .iris--active.sc-sdx-icon{color:#7867ce}/*!@.sdx--dark-theme .pink*/.sdx--dark-theme.sc-sdx-icon .pink.sc-sdx-icon{color:#d41d56}/*!@.sdx--dark-theme .pink--active*/.sdx--dark-theme.sc-sdx-icon .pink--active.sc-sdx-icon{color:#e1245f}/*!@.sdx--dark-theme .turquoise*/.sdx--dark-theme.sc-sdx-icon .turquoise.sc-sdx-icon{color:#0a7b7a}/*!@.sdx--dark-theme .turquoise--active*/.sdx--dark-theme.sc-sdx-icon .turquoise--active.sc-sdx-icon{color:#0b8483}/*!@.sr-only*/.sr-only.sc-sdx-icon{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);border:0}/*!@.sr-only-focusable:active, .sr-only-focusable:focus*/.sr-only-focusable.sc-sdx-icon:active,.sr-only-focusable.sc-sdx-icon:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}/*!@.icon*/.icon.sc-sdx-icon{display:inline-block;text-transform:none;text-decoration:none;text-rendering:auto;line-height:1;font-family:\"sdx-icons\";font-size:inherit;font-weight:normal;font-style:normal;font-variant:normal;font-variant-ligatures:normal;font-variant-caps:normal;font-variant-numeric:normal;font-stretch:normal;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}/*!@.icon--s1*/.icon--s1.sc-sdx-icon{font-size:16px}/*!@.icon--s2*/.icon--s2.sc-sdx-icon{font-size:24px}/*!@.icon--s3*/.icon--s3.sc-sdx-icon{font-size:32px}/*!@.icon--s4*/.icon--s4.sc-sdx-icon{font-size:40px}/*!@.icon--s5*/.icon--s5.sc-sdx-icon{font-size:48px}/*!@.icon--s6*/.icon--s6.sc-sdx-icon{font-size:56px}/*!@.icon--flip-horizontal*/.icon--flip-horizontal.sc-sdx-icon{transform:scale(-1, 1)}/*!@.icon--flip-vertical*/.icon--flip-vertical.sc-sdx-icon{transform:scale(1, -1)}/*!@.icon--flip-horizontal-vertical*/.icon--flip-horizontal-vertical.sc-sdx-icon{transform:scale(-1, -1)}/*!@.icon--excel*/.icon--excel.sc-sdx-icon{color:#008236}/*!@.icon--powerpoint*/.icon--powerpoint.sc-sdx-icon{color:#e86416}/*!@.icon--word*/.icon--word.sc-sdx-icon{color:#1781e3}/*!@.icon--pdf*/.icon--pdf.sc-sdx-icon{color:#d12}/*!@.icon-001-account::before,\n.icon-account::before*/.icon-001-account.sc-sdx-icon::before,.icon-account.sc-sdx-icon::before{content:\"\\e001\"}/*!@.icon-002-arrow-down::before,\n.icon-arrow-down::before*/.icon-002-arrow-down.sc-sdx-icon::before,.icon-arrow-down.sc-sdx-icon::before{content:\"\\e002\"}/*!@.icon-003-arrow-left::before,\n.icon-arrow-left::before*/.icon-003-arrow-left.sc-sdx-icon::before,.icon-arrow-left.sc-sdx-icon::before{content:\"\\e003\"}/*!@.icon-004-arrow-right::before,\n.icon-arrow-right::before*/.icon-004-arrow-right.sc-sdx-icon::before,.icon-arrow-right.sc-sdx-icon::before{content:\"\\e004\"}/*!@.icon-005-arrow-up::before,\n.icon-arrow-up::before*/.icon-005-arrow-up.sc-sdx-icon::before,.icon-arrow-up.sc-sdx-icon::before{content:\"\\e005\"}/*!@.icon-006-attachment::before,\n.icon-attachment::before*/.icon-006-attachment.sc-sdx-icon::before,.icon-attachment.sc-sdx-icon::before{content:\"\\e006\"}/*!@.icon-007-backup::before,\n.icon-backup::before*/.icon-007-backup.sc-sdx-icon::before,.icon-backup.sc-sdx-icon::before{content:\"\\e007\"}/*!@.icon-008-bin::before,\n.icon-bin::before*/.icon-008-bin.sc-sdx-icon::before,.icon-bin.sc-sdx-icon::before{content:\"\\e008\"}/*!@.icon-009-calendar::before,\n.icon-calendar::before*/.icon-009-calendar.sc-sdx-icon::before,.icon-calendar.sc-sdx-icon::before{content:\"\\e009\"}/*!@.icon-010-cancel::before,\n.icon-cancel::before*/.icon-010-cancel.sc-sdx-icon::before,.icon-cancel.sc-sdx-icon::before{content:\"\\e00a\"}/*!@.icon-011-check-mark::before,\n.icon-check-mark::before*/.icon-011-check-mark.sc-sdx-icon::before,.icon-check-mark.sc-sdx-icon::before{content:\"\\e00b\"}/*!@.icon-012-check-mark-2-circle::before,\n.icon-check-mark-2-circle::before,\n.icon-012-check-mark-circle::before,\n.icon-check-mark-circle::before*/.icon-012-check-mark-2-circle.sc-sdx-icon::before,.icon-check-mark-2-circle.sc-sdx-icon::before,.icon-012-check-mark-circle.sc-sdx-icon::before,.icon-check-mark-circle.sc-sdx-icon::before{content:\"\\e00c\"}/*!@.icon-013-chevron-normal-down::before,\n.icon-chevron-normal-down::before,\n.icon-013-chevron-down::before,\n.icon-chevron-down::before*/.icon-013-chevron-normal-down.sc-sdx-icon::before,.icon-chevron-normal-down.sc-sdx-icon::before,.icon-013-chevron-down.sc-sdx-icon::before,.icon-chevron-down.sc-sdx-icon::before{content:\"\\e00d\"}/*!@.icon-014-chevron-normal-left::before,\n.icon-chevron-normal-left::before,\n.icon-014-chevron-left::before,\n.icon-chevron-left::before*/.icon-014-chevron-normal-left.sc-sdx-icon::before,.icon-chevron-normal-left.sc-sdx-icon::before,.icon-014-chevron-left.sc-sdx-icon::before,.icon-chevron-left.sc-sdx-icon::before{content:\"\\e00e\"}/*!@.icon-015-chevron-normal-right::before,\n.icon-chevron-normal-right::before,\n.icon-015-chevron-right::before,\n.icon-chevron-right::before*/.icon-015-chevron-normal-right.sc-sdx-icon::before,.icon-chevron-normal-right.sc-sdx-icon::before,.icon-015-chevron-right.sc-sdx-icon::before,.icon-chevron-right.sc-sdx-icon::before{content:\"\\e00f\"}/*!@.icon-016-chevron-normal-up::before,\n.icon-chevron-normal-up::before,\n.icon-016-chevron-up::before,\n.icon-chevron-up::before*/.icon-016-chevron-normal-up.sc-sdx-icon::before,.icon-chevron-normal-up.sc-sdx-icon::before,.icon-016-chevron-up.sc-sdx-icon::before,.icon-chevron-up.sc-sdx-icon::before{content:\"\\e010\"}/*!@.icon-017-chevron-flat-down::before,\n.icon-chevron-flat-down::before*/.icon-017-chevron-flat-down.sc-sdx-icon::before,.icon-chevron-flat-down.sc-sdx-icon::before{content:\"\\e011\"}/*!@.icon-018-chevron-flat-left::before,\n.icon-chevron-flat-left::before*/.icon-018-chevron-flat-left.sc-sdx-icon::before,.icon-chevron-flat-left.sc-sdx-icon::before{content:\"\\e012\"}/*!@.icon-019-chevron-flat-right::before,\n.icon-chevron-flat-right::before*/.icon-019-chevron-flat-right.sc-sdx-icon::before,.icon-chevron-flat-right.sc-sdx-icon::before{content:\"\\e013\"}/*!@.icon-020-chevron-flat-up::before,\n.icon-chevron-flat-up::before*/.icon-020-chevron-flat-up.sc-sdx-icon::before,.icon-chevron-flat-up.sc-sdx-icon::before{content:\"\\e014\"}/*!@.icon-021-clock::before,\n.icon-clock::before*/.icon-021-clock.sc-sdx-icon::before,.icon-clock.sc-sdx-icon::before{content:\"\\e015\"}/*!@.icon-022-close::before,\n.icon-close::before*/.icon-022-close.sc-sdx-icon::before,.icon-close.sc-sdx-icon::before{content:\"\\e016\"}/*!@.icon-023-download::before,\n.icon-download::before*/.icon-023-download.sc-sdx-icon::before,.icon-download.sc-sdx-icon::before{content:\"\\e017\"}/*!@.icon-024-download-cloud::before,\n.icon-download-cloud::before*/.icon-024-download-cloud.sc-sdx-icon::before,.icon-download-cloud.sc-sdx-icon::before{content:\"\\e018\"}/*!@.icon-025-edit::before,\n.icon-edit::before*/.icon-025-edit.sc-sdx-icon::before,.icon-edit.sc-sdx-icon::before{content:\"\\e019\"}/*!@.icon-026-exclamation-mark-circle::before,\n.icon-exclamation-mark-circle::before*/.icon-026-exclamation-mark-circle.sc-sdx-icon::before,.icon-exclamation-mark-circle.sc-sdx-icon::before{content:\"\\e01a\"}/*!@.icon-027-flag::before,\n.icon-flag::before*/.icon-027-flag.sc-sdx-icon::before,.icon-flag.sc-sdx-icon::before{content:\"\\e01b\"}/*!@.icon-028-folder-new::before,\n.icon-folder-new::before*/.icon-028-folder-new.sc-sdx-icon::before,.icon-folder-new.sc-sdx-icon::before{content:\"\\e01c\"}/*!@.icon-029-folder-video::before,\n.icon-folder-video::before*/.icon-029-folder-video.sc-sdx-icon::before,.icon-folder-video.sc-sdx-icon::before{content:\"\\e01d\"}/*!@.icon-030-forward::before,\n.icon-forward::before*/.icon-030-forward.sc-sdx-icon::before,.icon-forward.sc-sdx-icon::before{content:\"\\e01e\"}/*!@.icon-031-forward-filled::before,\n.icon-forward-filled::before*/.icon-031-forward-filled.sc-sdx-icon::before,.icon-forward-filled.sc-sdx-icon::before{content:\"\\e01f\"}/*!@.icon-032-forward-message::before,\n.icon-forward-message::before*/.icon-032-forward-message.sc-sdx-icon::before,.icon-forward-message.sc-sdx-icon::before{content:\"\\e020\"}/*!@.icon-033-forward-message-2::before,\n.icon-forward-message-2::before*/.icon-033-forward-message-2.sc-sdx-icon::before,.icon-forward-message-2.sc-sdx-icon::before{content:\"\\e021\"}/*!@.icon-034-fullscreen-enter::before,\n.icon-fullscreen-enter::before*/.icon-034-fullscreen-enter.sc-sdx-icon::before,.icon-fullscreen-enter.sc-sdx-icon::before{content:\"\\e022\"}/*!@.icon-035-fullscreen-enter-2::before,\n.icon-fullscreen-enter-2::before*/.icon-035-fullscreen-enter-2.sc-sdx-icon::before,.icon-fullscreen-enter-2.sc-sdx-icon::before{content:\"\\e023\"}/*!@.icon-036-fullscreen-leave::before,\n.icon-fullscreen-leave::before*/.icon-036-fullscreen-leave.sc-sdx-icon::before,.icon-fullscreen-leave.sc-sdx-icon::before{content:\"\\e024\"}/*!@.icon-037-fullscreen-leave-2::before,\n.icon-fullscreen-leave-2::before*/.icon-037-fullscreen-leave-2.sc-sdx-icon::before,.icon-fullscreen-leave-2.sc-sdx-icon::before{content:\"\\e025\"}/*!@.icon-038-go-to-end::before,\n.icon-go-to-end::before*/.icon-038-go-to-end.sc-sdx-icon::before,.icon-go-to-end.sc-sdx-icon::before{content:\"\\e026\"}/*!@.icon-039-go-to-end-filled::before,\n.icon-go-to-end-filled::before*/.icon-039-go-to-end-filled.sc-sdx-icon::before,.icon-go-to-end-filled.sc-sdx-icon::before{content:\"\\e027\"}/*!@.icon-040-go-to-start::before,\n.icon-go-to-start::before*/.icon-040-go-to-start.sc-sdx-icon::before,.icon-go-to-start.sc-sdx-icon::before{content:\"\\e028\"}/*!@.icon-041-go-to-start-filled::before,\n.icon-go-to-start-filled::before*/.icon-041-go-to-start-filled.sc-sdx-icon::before,.icon-go-to-start-filled.sc-sdx-icon::before{content:\"\\e029\"}/*!@.icon-042-group::before,\n.icon-group::before*/.icon-042-group.sc-sdx-icon::before,.icon-group.sc-sdx-icon::before{content:\"\\e02a\"}/*!@.icon-043-heart::before,\n.icon-heart::before*/.icon-043-heart.sc-sdx-icon::before,.icon-heart.sc-sdx-icon::before{content:\"\\e02b\"}/*!@.icon-044-home::before,\n.icon-home::before*/.icon-044-home.sc-sdx-icon::before,.icon-home.sc-sdx-icon::before{content:\"\\e02c\"}/*!@.icon-045-hourglass::before,\n.icon-hourglass::before*/.icon-045-hourglass.sc-sdx-icon::before,.icon-hourglass.sc-sdx-icon::before{content:\"\\e02d\"}/*!@.icon-046-information-circle::before,\n.icon-information-circle::before*/.icon-046-information-circle.sc-sdx-icon::before,.icon-information-circle.sc-sdx-icon::before{content:\"\\e02e\"}/*!@.icon-047-key::before,\n.icon-key::before*/.icon-047-key.sc-sdx-icon::before,.icon-key.sc-sdx-icon::before{content:\"\\e02f\"}/*!@.icon-048-link::before,\n.icon-link::before*/.icon-048-link.sc-sdx-icon::before,.icon-link.sc-sdx-icon::before{content:\"\\e030\"}/*!@.icon-049-lock::before,\n.icon-lock::before*/.icon-049-lock.sc-sdx-icon::before,.icon-lock.sc-sdx-icon::before{content:\"\\e031\"}/*!@.icon-050-menu::before,\n.icon-menu::before*/.icon-050-menu.sc-sdx-icon::before,.icon-menu.sc-sdx-icon::before{content:\"\\e032\"}/*!@.icon-051-message::before,\n.icon-message::before*/.icon-051-message.sc-sdx-icon::before,.icon-message.sc-sdx-icon::before{content:\"\\e033\"}/*!@.icon-052-minus::before,\n.icon-minus::before*/.icon-052-minus.sc-sdx-icon::before,.icon-minus.sc-sdx-icon::before{content:\"\\e034\"}/*!@.icon-053-more::before,\n.icon-more::before*/.icon-053-more.sc-sdx-icon::before,.icon-more.sc-sdx-icon::before{content:\"\\e035\"}/*!@.icon-054-new::before,\n.icon-new::before*/.icon-054-new.sc-sdx-icon::before,.icon-new.sc-sdx-icon::before{content:\"\\e036\"}/*!@.icon-055-okay::before,\n.icon-okay::before*/.icon-055-okay.sc-sdx-icon::before,.icon-okay.sc-sdx-icon::before{content:\"\\e037\"}/*!@.icon-056-pause::before,\n.icon-pause::before*/.icon-056-pause.sc-sdx-icon::before,.icon-pause.sc-sdx-icon::before{content:\"\\e038\"}/*!@.icon-057-pause-filled::before,\n.icon-pause-filled::before*/.icon-057-pause-filled.sc-sdx-icon::before,.icon-pause-filled.sc-sdx-icon::before{content:\"\\e039\"}/*!@.icon-058-person::before,\n.icon-person::before*/.icon-058-person.sc-sdx-icon::before,.icon-person.sc-sdx-icon::before{content:\"\\e03a\"}/*!@.icon-059-play::before,\n.icon-play::before*/.icon-059-play.sc-sdx-icon::before,.icon-play.sc-sdx-icon::before{content:\"\\e03b\"}/*!@.icon-060-play-filled::before,\n.icon-play-filled::before*/.icon-060-play-filled.sc-sdx-icon::before,.icon-play-filled.sc-sdx-icon::before{content:\"\\e03c\"}/*!@.icon-061-plus::before,\n.icon-plus::before*/.icon-061-plus.sc-sdx-icon::before,.icon-plus.sc-sdx-icon::before{content:\"\\e03d\"}/*!@.icon-062-question-mark-circle::before,\n.icon-question-mark-circle::before*/.icon-062-question-mark-circle.sc-sdx-icon::before,.icon-question-mark-circle.sc-sdx-icon::before{content:\"\\e03e\"}/*!@.icon-063-record::before,\n.icon-record::before*/.icon-063-record.sc-sdx-icon::before,.icon-record.sc-sdx-icon::before{content:\"\\e03f\"}/*!@.icon-064-record-filled::before,\n.icon-record-filled::before*/.icon-064-record-filled.sc-sdx-icon::before,.icon-record-filled.sc-sdx-icon::before{content:\"\\e040\"}/*!@.icon-065-rename::before,\n.icon-rename::before*/.icon-065-rename.sc-sdx-icon::before,.icon-rename.sc-sdx-icon::before{content:\"\\e041\"}/*!@.icon-066-replay::before,\n.icon-replay::before*/.icon-066-replay.sc-sdx-icon::before,.icon-replay.sc-sdx-icon::before{content:\"\\e042\"}/*!@.icon-067-reply-message::before,\n.icon-reply-message::before*/.icon-067-reply-message.sc-sdx-icon::before,.icon-reply-message.sc-sdx-icon::before{content:\"\\e043\"}/*!@.icon-068-reply-message-2::before,\n.icon-reply-message-2::before*/.icon-068-reply-message-2.sc-sdx-icon::before,.icon-reply-message-2.sc-sdx-icon::before{content:\"\\e044\"}/*!@.icon-069-reply-message-all::before,\n.icon-reply-message-all::before*/.icon-069-reply-message-all.sc-sdx-icon::before,.icon-reply-message-all.sc-sdx-icon::before{content:\"\\e045\"}/*!@.icon-070-reply-message-all-2::before,\n.icon-reply-message-all-2::before*/.icon-070-reply-message-all-2.sc-sdx-icon::before,.icon-reply-message-all-2.sc-sdx-icon::before{content:\"\\e046\"}/*!@.icon-071-retry::before,\n.icon-retry::before*/.icon-071-retry.sc-sdx-icon::before,.icon-retry.sc-sdx-icon::before{content:\"\\e047\"}/*!@.icon-072-rewind::before,\n.icon-rewind::before*/.icon-072-rewind.sc-sdx-icon::before,.icon-rewind.sc-sdx-icon::before{content:\"\\e048\"}/*!@.icon-073-rewind-filled::before,\n.icon-rewind-filled::before*/.icon-073-rewind-filled.sc-sdx-icon::before,.icon-rewind-filled.sc-sdx-icon::before{content:\"\\e049\"}/*!@.icon-074-save::before,\n.icon-save::before*/.icon-074-save.sc-sdx-icon::before,.icon-save.sc-sdx-icon::before{content:\"\\e04a\"}/*!@.icon-075-save-2::before,\n.icon-save-2::before*/.icon-075-save-2.sc-sdx-icon::before,.icon-save-2.sc-sdx-icon::before{content:\"\\e04b\"}/*!@.icon-076-save-3::before,\n.icon-save-3::before*/.icon-076-save-3.sc-sdx-icon::before,.icon-save-3.sc-sdx-icon::before{content:\"\\e04c\"}/*!@.icon-077-search::before,\n.icon-search::before*/.icon-077-search.sc-sdx-icon::before,.icon-search.sc-sdx-icon::before{content:\"\\e04d\"}/*!@.icon-078-settings::before,\n.icon-settings::before*/.icon-078-settings.sc-sdx-icon::before,.icon-settings.sc-sdx-icon::before{content:\"\\e04e\"}/*!@.icon-079-shopping-trolley::before,\n.icon-shopping-trolley::before*/.icon-079-shopping-trolley.sc-sdx-icon::before,.icon-shopping-trolley.sc-sdx-icon::before{content:\"\\e04f\"}/*!@.icon-080-speech-bubble::before,\n.icon-speech-bubble::before*/.icon-080-speech-bubble.sc-sdx-icon::before,.icon-speech-bubble.sc-sdx-icon::before{content:\"\\e050\"}/*!@.icon-081-standby::before,\n.icon-standby::before*/.icon-081-standby.sc-sdx-icon::before,.icon-standby.sc-sdx-icon::before{content:\"\\e051\"}/*!@.icon-082-star::before,\n.icon-star::before*/.icon-082-star.sc-sdx-icon::before,.icon-star.sc-sdx-icon::before{content:\"\\e052\"}/*!@.icon-083-stop::before,\n.icon-stop::before*/.icon-083-stop.sc-sdx-icon::before,.icon-stop.sc-sdx-icon::before{content:\"\\e053\"}/*!@.icon-084-stop-filled::before,\n.icon-stop-filled::before*/.icon-084-stop-filled.sc-sdx-icon::before,.icon-stop-filled.sc-sdx-icon::before{content:\"\\e054\"}/*!@.icon-085-synchronise::before,\n.icon-synchronise::before*/.icon-085-synchronise.sc-sdx-icon::before,.icon-synchronise.sc-sdx-icon::before{content:\"\\e055\"}/*!@.icon-086-thumb-up::before,\n.icon-thumb-up::before*/.icon-086-thumb-up.sc-sdx-icon::before,.icon-thumb-up.sc-sdx-icon::before{content:\"\\e056\"}/*!@.icon-087-upload::before,\n.icon-upload::before*/.icon-087-upload.sc-sdx-icon::before,.icon-upload.sc-sdx-icon::before{content:\"\\e057\"}/*!@.icon-088-upload-cloud::before,\n.icon-upload-cloud::before*/.icon-088-upload-cloud.sc-sdx-icon::before,.icon-upload-cloud.sc-sdx-icon::before{content:\"\\e058\"}/*!@.icon-089-volume-fortissimo::before,\n.icon-volume-fortissimo::before*/.icon-089-volume-fortissimo.sc-sdx-icon::before,.icon-volume-fortissimo.sc-sdx-icon::before{content:\"\\e059\"}/*!@.icon-090-volume-forte::before,\n.icon-volume-forte::before*/.icon-090-volume-forte.sc-sdx-icon::before,.icon-volume-forte.sc-sdx-icon::before{content:\"\\e05a\"}/*!@.icon-091-volume-piano::before,\n.icon-volume-piano::before*/.icon-091-volume-piano.sc-sdx-icon::before,.icon-volume-piano.sc-sdx-icon::before{content:\"\\e05b\"}/*!@.icon-092-volume-pianissimo::before,\n.icon-volume-pianissimo::before*/.icon-092-volume-pianissimo.sc-sdx-icon::before,.icon-volume-pianissimo.sc-sdx-icon::before{content:\"\\e05c\"}/*!@.icon-093-volume-mute::before,\n.icon-volume-mute::before*/.icon-093-volume-mute.sc-sdx-icon::before,.icon-volume-mute.sc-sdx-icon::before{content:\"\\e05d\"}/*!@.icon-094-warning::before,\n.icon-warning::before*/.icon-094-warning.sc-sdx-icon::before,.icon-warning.sc-sdx-icon::before{content:\"\\e05e\"}/*!@.icon-095-zoom-in::before,\n.icon-zoom-in::before*/.icon-095-zoom-in.sc-sdx-icon::before,.icon-zoom-in.sc-sdx-icon::before{content:\"\\e05f\"}/*!@.icon-096-zoom-out::before,\n.icon-zoom-out::before*/.icon-096-zoom-out.sc-sdx-icon::before,.icon-zoom-out.sc-sdx-icon::before{content:\"\\e060\"}/*!@.icon-097-suitcase::before,\n.icon-suitcase::before*/.icon-097-suitcase.sc-sdx-icon::before,.icon-suitcase.sc-sdx-icon::before{content:\"\\e061\"}/*!@.icon-098-ambulance::before,\n.icon-ambulance::before*/.icon-098-ambulance.sc-sdx-icon::before,.icon-ambulance.sc-sdx-icon::before{content:\"\\e062\"}/*!@.icon-099-ambulance-2::before,\n.icon-ambulance-2::before*/.icon-099-ambulance-2.sc-sdx-icon::before,.icon-ambulance-2.sc-sdx-icon::before{content:\"\\e063\"}/*!@.icon-100-van::before,\n.icon-van::before*/.icon-100-van.sc-sdx-icon::before,.icon-van.sc-sdx-icon::before{content:\"\\e064\"}/*!@.icon-101-delivery::before,\n.icon-delivery::before*/.icon-101-delivery.sc-sdx-icon::before,.icon-delivery.sc-sdx-icon::before{content:\"\\e065\"}/*!@.icon-102-delivery-2::before,\n.icon-delivery-2::before*/.icon-102-delivery-2.sc-sdx-icon::before,.icon-delivery-2.sc-sdx-icon::before{content:\"\\e066\"}/*!@.icon-103-applications::before,\n.icon-applications::before*/.icon-103-applications.sc-sdx-icon::before,.icon-applications.sc-sdx-icon::before{content:\"\\e067\"}/*!@.icon-104-assistant::before,\n.icon-assistant::before*/.icon-104-assistant.sc-sdx-icon::before,.icon-assistant.sc-sdx-icon::before{content:\"\\e068\"}/*!@.icon-105-call-centre::before,\n.icon-call-centre::before*/.icon-105-call-centre.sc-sdx-icon::before,.icon-call-centre.sc-sdx-icon::before{content:\"\\e069\"}/*!@.icon-106-bill::before,\n.icon-bill::before*/.icon-106-bill.sc-sdx-icon::before,.icon-bill.sc-sdx-icon::before{content:\"\\e06a\"}/*!@.icon-107-child-protection::before,\n.icon-child-protection::before*/.icon-107-child-protection.sc-sdx-icon::before,.icon-child-protection.sc-sdx-icon::before{content:\"\\e06b\"}/*!@.icon-108-coins::before,\n.icon-coins::before*/.icon-108-coins.sc-sdx-icon::before,.icon-coins.sc-sdx-icon::before{content:\"\\e06c\"}/*!@.icon-109-compass::before,\n.icon-compass::before*/.icon-109-compass.sc-sdx-icon::before,.icon-compass.sc-sdx-icon::before{content:\"\\e06d\"}/*!@.icon-110-mobile-phone::before,\n.icon-mobile-phone::before*/.icon-110-mobile-phone.sc-sdx-icon::before,.icon-mobile-phone.sc-sdx-icon::before{content:\"\\e06e\"}/*!@.icon-111-smartphone::before,\n.icon-smartphone::before*/.icon-111-smartphone.sc-sdx-icon::before,.icon-smartphone.sc-sdx-icon::before{content:\"\\e06f\"}/*!@.icon-112-tablet::before,\n.icon-tablet::before*/.icon-112-tablet.sc-sdx-icon::before,.icon-tablet.sc-sdx-icon::before{content:\"\\e070\"}/*!@.icon-113-laptop::before,\n.icon-laptop::before*/.icon-113-laptop.sc-sdx-icon::before,.icon-laptop.sc-sdx-icon::before{content:\"\\e071\"}/*!@.icon-114-computer::before,\n.icon-computer::before*/.icon-114-computer.sc-sdx-icon::before,.icon-computer.sc-sdx-icon::before{content:\"\\e072\"}/*!@.icon-115-workstation::before,\n.icon-workstation::before*/.icon-115-workstation.sc-sdx-icon::before,.icon-workstation.sc-sdx-icon::before{content:\"\\e073\"}/*!@.icon-116-credit-card::before,\n.icon-credit-card::before*/.icon-116-credit-card.sc-sdx-icon::before,.icon-credit-card.sc-sdx-icon::before{content:\"\\e074\"}/*!@.icon-117-directory::before,\n.icon-directory::before*/.icon-117-directory.sc-sdx-icon::before,.icon-directory.sc-sdx-icon::before{content:\"\\e075\"}/*!@.icon-118-document::before,\n.icon-document::before*/.icon-118-document.sc-sdx-icon::before,.icon-document.sc-sdx-icon::before{content:\"\\e076\"}/*!@.icon-119-document-new::before,\n.icon-document-new::before*/.icon-119-document-new.sc-sdx-icon::before,.icon-document-new.sc-sdx-icon::before{content:\"\\e077\"}/*!@.icon-120-document-excel::before,\n.icon-document-excel::before*/.icon-120-document-excel.sc-sdx-icon::before,.icon-document-excel.sc-sdx-icon::before{content:\"\\e078\"}/*!@.icon-121-document-powerpoint::before,\n.icon-document-powerpoint::before*/.icon-121-document-powerpoint.sc-sdx-icon::before,.icon-document-powerpoint.sc-sdx-icon::before{content:\"\\e079\"}/*!@.icon-122-document-word::before,\n.icon-document-word::before*/.icon-122-document-word.sc-sdx-icon::before,.icon-document-word.sc-sdx-icon::before{content:\"\\e07a\"}/*!@.icon-123-document-pdf::before,\n.icon-document-pdf::before*/.icon-123-document-pdf.sc-sdx-icon::before,.icon-document-pdf.sc-sdx-icon::before{content:\"\\e07b\"}/*!@.icon-124-document-txt::before,\n.icon-document-txt::before*/.icon-124-document-txt.sc-sdx-icon::before,.icon-document-txt.sc-sdx-icon::before{content:\"\\e07c\"}/*!@.icon-125-document-zip::before,\n.icon-document-zip::before*/.icon-125-document-zip.sc-sdx-icon::before,.icon-document-zip.sc-sdx-icon::before{content:\"\\e07d\"}/*!@.icon-126-document-code::before,\n.icon-document-code::before*/.icon-126-document-code.sc-sdx-icon::before,.icon-document-code.sc-sdx-icon::before{content:\"\\e07e\"}/*!@.icon-127-e-mail::before,\n.icon-e-mail::before*/.icon-127-e-mail.sc-sdx-icon::before,.icon-e-mail.sc-sdx-icon::before{content:\"\\e07f\"}/*!@.icon-128-film-camera::before,\n.icon-film-camera::before*/.icon-128-film-camera.sc-sdx-icon::before,.icon-film-camera.sc-sdx-icon::before{content:\"\\e080\"}/*!@.icon-129-film-camera-2::before,\n.icon-film-camera-2::before*/.icon-129-film-camera-2.sc-sdx-icon::before,.icon-film-camera-2.sc-sdx-icon::before{content:\"\\e081\"}/*!@.icon-130-film-camera-3::before,\n.icon-film-camera-3::before*/.icon-130-film-camera-3.sc-sdx-icon::before,.icon-film-camera-3.sc-sdx-icon::before{content:\"\\e082\"}/*!@.icon-131-film-reel::before,\n.icon-film-reel::before*/.icon-131-film-reel.sc-sdx-icon::before,.icon-film-reel.sc-sdx-icon::before{content:\"\\e083\"}/*!@.icon-132-folder::before,\n.icon-folder::before*/.icon-132-folder.sc-sdx-icon::before,.icon-folder.sc-sdx-icon::before{content:\"\\e084\"}/*!@.icon-133-football::before,\n.icon-football::before*/.icon-133-football.sc-sdx-icon::before,.icon-football.sc-sdx-icon::before{content:\"\\e085\"}/*!@.icon-134-game::before,\n.icon-game::before*/.icon-134-game.sc-sdx-icon::before,.icon-game.sc-sdx-icon::before{content:\"\\e086\"}/*!@.icon-135-gaming::before,\n.icon-gaming::before*/.icon-135-gaming.sc-sdx-icon::before,.icon-gaming.sc-sdx-icon::before{content:\"\\e087\"}/*!@.icon-136-globe::before,\n.icon-globe::before*/.icon-136-globe.sc-sdx-icon::before,.icon-globe.sc-sdx-icon::before{content:\"\\e088\"}/*!@.icon-137-handset::before,\n.icon-handset::before*/.icon-137-handset.sc-sdx-icon::before,.icon-handset.sc-sdx-icon::before{content:\"\\e089\"}/*!@.icon-138-headphone::before,\n.icon-headphone::before*/.icon-138-headphone.sc-sdx-icon::before,.icon-headphone.sc-sdx-icon::before{content:\"\\e08a\"}/*!@.icon-139-headset::before,\n.icon-headset::before*/.icon-139-headset.sc-sdx-icon::before,.icon-headset.sc-sdx-icon::before{content:\"\\e08b\"}/*!@.icon-140-index-card::before,\n.icon-index-card::before*/.icon-140-index-card.sc-sdx-icon::before,.icon-index-card.sc-sdx-icon::before{content:\"\\e08c\"}/*!@.icon-141-leaf::before,\n.icon-leaf::before*/.icon-141-leaf.sc-sdx-icon::before,.icon-leaf.sc-sdx-icon::before{content:\"\\e08d\"}/*!@.icon-142-lifesaver::before,\n.icon-lifesaver::before*/.icon-142-lifesaver.sc-sdx-icon::before,.icon-lifesaver.sc-sdx-icon::before{content:\"\\e08e\"}/*!@.icon-143-modem-wlan::before,\n.icon-modem-wlan::before*/.icon-143-modem-wlan.sc-sdx-icon::before,.icon-modem-wlan.sc-sdx-icon::before{content:\"\\e08f\"}/*!@.icon-144-movie::before,\n.icon-movie::before*/.icon-144-movie.sc-sdx-icon::before,.icon-movie.sc-sdx-icon::before{content:\"\\e090\"}/*!@.icon-145-movie-2::before,\n.icon-movie-2::before*/.icon-145-movie-2.sc-sdx-icon::before,.icon-movie-2.sc-sdx-icon::before{content:\"\\e091\"}/*!@.icon-146-movie-3::before,\n.icon-movie-3::before*/.icon-146-movie-3.sc-sdx-icon::before,.icon-movie-3.sc-sdx-icon::before{content:\"\\e092\"}/*!@.icon-147-svod::before,\n.icon-svod::before*/.icon-147-svod.sc-sdx-icon::before,.icon-svod.sc-sdx-icon::before{content:\"\\e093\"}/*!@.icon-148-music::before,\n.icon-music::before*/.icon-148-music.sc-sdx-icon::before,.icon-music.sc-sdx-icon::before{content:\"\\e094\"}/*!@.icon-149-navigation::before,\n.icon-navigation::before*/.icon-149-navigation.sc-sdx-icon::before,.icon-navigation.sc-sdx-icon::before{content:\"\\e095\"}/*!@.icon-150-network::before,\n.icon-network::before*/.icon-150-network.sc-sdx-icon::before,.icon-network.sc-sdx-icon::before{content:\"\\e096\"}/*!@.icon-151-office::before,\n.icon-office::before*/.icon-151-office.sc-sdx-icon::before,.icon-office.sc-sdx-icon::before{content:\"\\e097\"}/*!@.icon-152-phone-basic::before,\n.icon-phone-basic::before*/.icon-152-phone-basic.sc-sdx-icon::before,.icon-phone-basic.sc-sdx-icon::before{content:\"\\e098\"}/*!@.icon-153-phone-pro::before,\n.icon-phone-pro::before*/.icon-153-phone-pro.sc-sdx-icon::before,.icon-phone-pro.sc-sdx-icon::before{content:\"\\e099\"}/*!@.icon-154-photo::before,\n.icon-photo::before*/.icon-154-photo.sc-sdx-icon::before,.icon-photo.sc-sdx-icon::before{content:\"\\e09a\"}/*!@.icon-155-photo-camera::before,\n.icon-photo-camera::before*/.icon-155-photo-camera.sc-sdx-icon::before,.icon-photo-camera.sc-sdx-icon::before{content:\"\\e09b\"}/*!@.icon-156-postcard::before,\n.icon-postcard::before*/.icon-156-postcard.sc-sdx-icon::before,.icon-postcard.sc-sdx-icon::before{content:\"\\e09c\"}/*!@.icon-157-printer::before,\n.icon-printer::before*/.icon-157-printer.sc-sdx-icon::before,.icon-printer.sc-sdx-icon::before{content:\"\\e09d\"}/*!@.icon-158-radio::before,\n.icon-radio::before*/.icon-158-radio.sc-sdx-icon::before,.icon-radio.sc-sdx-icon::before{content:\"\\e09e\"}/*!@.icon-159-rss-feed::before,\n.icon-rss-feed::before*/.icon-159-rss-feed.sc-sdx-icon::before,.icon-rss-feed.sc-sdx-icon::before{content:\"\\e09f\"}/*!@.icon-160-wlan::before,\n.icon-wlan::before*/.icon-160-wlan.sc-sdx-icon::before,.icon-wlan.sc-sdx-icon::before{content:\"\\e0a0\"}/*!@.icon-161-signal::before,\n.icon-signal::before*/.icon-161-signal.sc-sdx-icon::before,.icon-signal.sc-sdx-icon::before{content:\"\\e0a1\"}/*!@.icon-162-server::before,\n.icon-server::before*/.icon-162-server.sc-sdx-icon::before,.icon-server.sc-sdx-icon::before{content:\"\\e0a2\"}/*!@.icon-server::before*/.icon-server.sc-sdx-icon::before{content:\"\\e0cb\"}/*!@.icon-163-sms::before,\n.icon-sms::before*/.icon-163-sms.sc-sdx-icon::before,.icon-sms.sc-sdx-icon::before{content:\"\\e0a3\"}/*!@.icon-164-translation::before,\n.icon-translation::before*/.icon-164-translation.sc-sdx-icon::before,.icon-translation.sc-sdx-icon::before{content:\"\\e0a4\"}/*!@.icon-165-transmitter::before,\n.icon-transmitter::before*/.icon-165-transmitter.sc-sdx-icon::before,.icon-transmitter.sc-sdx-icon::before{content:\"\\e0a5\"}/*!@.icon-166-tv::before,\n.icon-tv::before*/.icon-166-tv.sc-sdx-icon::before,.icon-tv.sc-sdx-icon::before{content:\"\\e0a6\"}/*!@.icon-167-tv-hd::before,\n.icon-tv-hd::before*/.icon-167-tv-hd.sc-sdx-icon::before,.icon-tv-hd.sc-sdx-icon::before{content:\"\\e0a7\"}/*!@.icon-168-tv-2-0::before,\n.icon-tv-2-0::before*/.icon-168-tv-2-0.sc-sdx-icon::before,.icon-tv-2-0.sc-sdx-icon::before{content:\"\\e0a8\"}/*!@.icon-169-video-tape::before,\n.icon-video-tape::before*/.icon-169-video-tape.sc-sdx-icon::before,.icon-video-tape.sc-sdx-icon::before{content:\"\\e0a9\"}/*!@.icon-170-video-tape-2::before,\n.icon-video-tape-2::before*/.icon-170-video-tape-2.sc-sdx-icon::before,.icon-video-tape-2.sc-sdx-icon::before{content:\"\\e0aa\"}/*!@.icon-171-wearable-watch::before,\n.icon-wearable-watch::before*/.icon-171-wearable-watch.sc-sdx-icon::before,.icon-wearable-watch.sc-sdx-icon::before{content:\"\\e0ab\"}/*!@.icon-172-weather-cloud::before,\n.icon-weather-cloud::before*/.icon-172-weather-cloud.sc-sdx-icon::before,.icon-weather-cloud.sc-sdx-icon::before{content:\"\\e0ac\"}/*!@.icon-173-weather-rain::before,\n.icon-weather-rain::before*/.icon-173-weather-rain.sc-sdx-icon::before,.icon-weather-rain.sc-sdx-icon::before{content:\"\\e0ad\"}/*!@.icon-174-weather-rain-unsettled::before,\n.icon-weather-rain-unsettled::before*/.icon-174-weather-rain-unsettled.sc-sdx-icon::before,.icon-weather-rain-unsettled.sc-sdx-icon::before{content:\"\\e0ae\"}/*!@.icon-175-weather-snow::before,\n.icon-weather-snow::before*/.icon-175-weather-snow.sc-sdx-icon::before,.icon-weather-snow.sc-sdx-icon::before{content:\"\\e0af\"}/*!@.icon-176-weather-snow-unsettled::before,\n.icon-weather-snow-unsettled::before*/.icon-176-weather-snow-unsettled.sc-sdx-icon::before,.icon-weather-snow-unsettled.sc-sdx-icon::before{content:\"\\e0b0\"}/*!@.icon-177-weather-storm::before,\n.icon-weather-storm::before*/.icon-177-weather-storm.sc-sdx-icon::before,.icon-weather-storm.sc-sdx-icon::before{content:\"\\e0b1\"}/*!@.icon-178-weather-storm-unsettled::before,\n.icon-weather-storm-unsettled::before*/.icon-178-weather-storm-unsettled.sc-sdx-icon::before,.icon-weather-storm-unsettled.sc-sdx-icon::before{content:\"\\e0b2\"}/*!@.icon-179-weather-sun::before,\n.icon-weather-sun::before*/.icon-179-weather-sun.sc-sdx-icon::before,.icon-weather-sun.sc-sdx-icon::before{content:\"\\e0b3\"}/*!@.icon-180-weather-sun-unsettled::before,\n.icon-weather-sun-unsettled::before*/.icon-180-weather-sun-unsettled.sc-sdx-icon::before,.icon-weather-sun-unsettled.sc-sdx-icon::before{content:\"\\e0b4\"}/*!@.icon-181-inbox-1::before,\n.icon-inbox-1::before,\n.icon-181-inbox::before,\n.icon-inbox::before*/.icon-181-inbox-1.sc-sdx-icon::before,.icon-inbox-1.sc-sdx-icon::before,.icon-181-inbox.sc-sdx-icon::before,.icon-inbox.sc-sdx-icon::before{content:\"\\e0b5\"}/*!@.icon-inbox::before*/.icon-inbox.sc-sdx-icon::before{content:\"\\e0bd\"}/*!@.icon-182-drafts-3::before,\n.icon-drafts-3::before,\n.icon-182-drafts::before,\n.icon-drafts::before*/.icon-182-drafts-3.sc-sdx-icon::before,.icon-drafts-3.sc-sdx-icon::before,.icon-182-drafts.sc-sdx-icon::before,.icon-drafts.sc-sdx-icon::before{content:\"\\e0b6\"}/*!@.icon-drafts::before*/.icon-drafts.sc-sdx-icon::before{content:\"\\e0be\"}/*!@.icon-183-sent-6::before,\n.icon-sent-6::before,\n.icon-183-sent::before,\n.icon-sent::before*/.icon-183-sent-6.sc-sdx-icon::before,.icon-sent-6.sc-sdx-icon::before,.icon-183-sent.sc-sdx-icon::before,.icon-sent.sc-sdx-icon::before{content:\"\\e0b7\"}/*!@.icon-sent::before*/.icon-sent.sc-sdx-icon::before{content:\"\\e0bf\"}/*!@.icon-184-sent-2::before,\n.icon-sent-2::before*/.icon-184-sent-2.sc-sdx-icon::before,.icon-sent-2.sc-sdx-icon::before{content:\"\\e0b8\"}/*!@.icon-sent-2::before*/.icon-sent-2.sc-sdx-icon::before{content:\"\\e0c0\"}/*!@.icon-185-inbox-2::before,\n.icon-inbox-2::before,\n.icon-185-inbox::before,\n.icon-inbox::before*/.icon-185-inbox-2.sc-sdx-icon::before,.icon-inbox-2.sc-sdx-icon::before,.icon-185-inbox.sc-sdx-icon::before,.icon-inbox.sc-sdx-icon::before{content:\"\\e0b9\"}/*!@.icon-186-drafts::before,\n.icon-drafts::before*/.icon-186-drafts.sc-sdx-icon::before,.icon-drafts.sc-sdx-icon::before{content:\"\\e0ba\"}/*!@.icon-187-sent::before,\n.icon-sent::before*/.icon-187-sent.sc-sdx-icon::before,.icon-sent.sc-sdx-icon::before{content:\"\\e0bb\"}/*!@.icon-188-sent-3::before,\n.icon-sent-3::before,\n.icon-188-sent-2::before,\n.icon-sent-2::before*/.icon-188-sent-3.sc-sdx-icon::before,.icon-sent-3.sc-sdx-icon::before,.icon-188-sent-2.sc-sdx-icon::before,.icon-sent-2.sc-sdx-icon::before{content:\"\\e0bc\"}/*!@.icon-189-inbox-3::before,\n.icon-inbox-3::before,\n.icon-189-inbox::before,\n.icon-inbox::before*/.icon-189-inbox-3.sc-sdx-icon::before,.icon-inbox-3.sc-sdx-icon::before,.icon-189-inbox.sc-sdx-icon::before,.icon-inbox.sc-sdx-icon::before{content:\"\\e0bd\"}/*!@.icon-190-drafts-2::before,\n.icon-drafts-2::before,\n.icon-190-drafts::before,\n.icon-drafts::before*/.icon-190-drafts-2.sc-sdx-icon::before,.icon-drafts-2.sc-sdx-icon::before,.icon-190-drafts.sc-sdx-icon::before,.icon-drafts.sc-sdx-icon::before{content:\"\\e0be\"}/*!@.icon-191-sent-5::before,\n.icon-sent-5::before,\n.icon-191-sent::before,\n.icon-sent::before*/.icon-191-sent-5.sc-sdx-icon::before,.icon-sent-5.sc-sdx-icon::before,.icon-191-sent.sc-sdx-icon::before,.icon-sent.sc-sdx-icon::before{content:\"\\e0bf\"}/*!@.icon-192-sent-4::before,\n.icon-sent-4::before,\n.icon-192-sent-2::before,\n.icon-sent-2::before*/.icon-192-sent-4.sc-sdx-icon::before,.icon-sent-4.sc-sdx-icon::before,.icon-192-sent-2.sc-sdx-icon::before,.icon-sent-2.sc-sdx-icon::before{content:\"\\e0c0\"}/*!@.icon-193-website::before,\n.icon-website::before*/.icon-193-website.sc-sdx-icon::before,.icon-website.sc-sdx-icon::before{content:\"\\e0c1\"}/*!@.icon-194-website-2::before,\n.icon-website-2::before*/.icon-194-website-2.sc-sdx-icon::before,.icon-website-2.sc-sdx-icon::before{content:\"\\e0c2\"}/*!@.icon-195-heart-filled::before,\n.icon-heart-filled::before*/.icon-195-heart-filled.sc-sdx-icon::before,.icon-heart-filled.sc-sdx-icon::before{content:\"\\e0c3\"}/*!@.icon-196-exclamation-mark::before,\n.icon-exclamation-mark::before*/.icon-196-exclamation-mark.sc-sdx-icon::before,.icon-exclamation-mark.sc-sdx-icon::before{content:\"\\e0c4\"}/*!@.icon-197-share::before,\n.icon-share::before*/.icon-197-share.sc-sdx-icon::before,.icon-share.sc-sdx-icon::before{content:\"\\e0c5\"}/*!@.icon-198-chevron-small-down::before,\n.icon-chevron-small-down::before,\n.icon-198-chevron-down-small::before,\n.icon-chevron-down-small::before*/.icon-198-chevron-small-down.sc-sdx-icon::before,.icon-chevron-small-down.sc-sdx-icon::before,.icon-198-chevron-down-small.sc-sdx-icon::before,.icon-chevron-down-small.sc-sdx-icon::before{content:\"\\e0c6\"}/*!@.icon-199-chevron-small-up::before,\n.icon-chevron-small-up::before,\n.icon-199-chevron-up-small::before,\n.icon-chevron-up-small::before*/.icon-199-chevron-small-up.sc-sdx-icon::before,.icon-chevron-small-up.sc-sdx-icon::before,.icon-199-chevron-up-small.sc-sdx-icon::before,.icon-chevron-up-small.sc-sdx-icon::before{content:\"\\e0c7\"}/*!@.icon-200-chevron-small-left::before,\n.icon-chevron-small-left::before,\n.icon-200-chevron-left-small::before,\n.icon-chevron-left-small::before*/.icon-200-chevron-small-left.sc-sdx-icon::before,.icon-chevron-small-left.sc-sdx-icon::before,.icon-200-chevron-left-small.sc-sdx-icon::before,.icon-chevron-left-small.sc-sdx-icon::before{content:\"\\e0c8\"}/*!@.icon-201-chevron-small-right::before,\n.icon-chevron-small-right::before,\n.icon-201-chevron-right-small::before,\n.icon-chevron-right-small::before*/.icon-201-chevron-small-right.sc-sdx-icon::before,.icon-chevron-small-right.sc-sdx-icon::before,.icon-201-chevron-right-small.sc-sdx-icon::before,.icon-chevron-right-small.sc-sdx-icon::before{content:\"\\e0c9\"}/*!@.icon-202-clear-circle::before,\n.icon-clear-circle::before*/.icon-202-clear-circle.sc-sdx-icon::before,.icon-clear-circle.sc-sdx-icon::before{content:\"\\e0ca\"}/*!@.icon-203-server::before,\n.icon-server::before*/.icon-203-server.sc-sdx-icon::before,.icon-server.sc-sdx-icon::before{content:\"\\e0cb\"}/*!@.icon-204-cd::before,\n.icon-cd::before*/.icon-204-cd.sc-sdx-icon::before,.icon-cd.sc-sdx-icon::before{content:\"\\e0cc\"}/*!@.icon-205-bundle::before,\n.icon-bundle::before*/.icon-205-bundle.sc-sdx-icon::before,.icon-bundle.sc-sdx-icon::before{content:\"\\e0cd\"}/*!@.icon-206-database::before,\n.icon-database::before*/.icon-206-database.sc-sdx-icon::before,.icon-database.sc-sdx-icon::before{content:\"\\e0ce\"}/*!@.icon-207-firewall::before,\n.icon-firewall::before*/.icon-207-firewall.sc-sdx-icon::before,.icon-firewall.sc-sdx-icon::before{content:\"\\e0cf\"}/*!@.icon-208-proxy-server::before,\n.icon-proxy-server::before*/.icon-208-proxy-server.sc-sdx-icon::before,.icon-proxy-server.sc-sdx-icon::before{content:\"\\e0d0\"}/*!@.icon-209-set-top-box::before,\n.icon-set-top-box::before,\n.icon-209-settopbox::before,\n.icon-settopbox::before*/.icon-209-set-top-box.sc-sdx-icon::before,.icon-set-top-box.sc-sdx-icon::before,.icon-209-settopbox.sc-sdx-icon::before,.icon-settopbox.sc-sdx-icon::before{content:\"\\e0d1\"}/*!@.icon-210-puzzle::before,\n.icon-puzzle::before*/.icon-210-puzzle.sc-sdx-icon::before,.icon-puzzle.sc-sdx-icon::before{content:\"\\e0d2\"}/*!@.icon-211-skull::before,\n.icon-skull::before*/.icon-211-skull.sc-sdx-icon::before,.icon-skull.sc-sdx-icon::before{content:\"\\e0d3\"}/*!@.icon-212-fire::before,\n.icon-fire::before*/.icon-212-fire.sc-sdx-icon::before,.icon-fire.sc-sdx-icon::before{content:\"\\e0d4\"}/*!@.icon-213-setting::before,\n.icon-setting::before*/.icon-213-setting.sc-sdx-icon::before,.icon-setting.sc-sdx-icon::before{content:\"\\e0d5\"}/*!@.icon-214-present::before,\n.icon-present::before*/.icon-214-present.sc-sdx-icon::before,.icon-present.sc-sdx-icon::before{content:\"\\e0d6\"}/*!@.icon-215-certificate::before,\n.icon-certificate::before*/.icon-215-certificate.sc-sdx-icon::before,.icon-certificate.sc-sdx-icon::before{content:\"\\e0d7\"}/*!@.icon-216-waypointer::before,\n.icon-waypointer::before*/.icon-216-waypointer.sc-sdx-icon::before,.icon-waypointer.sc-sdx-icon::before{content:\"\\e0d8\"}/*!@.icon-217-eye::before,\n.icon-eye::before*/.icon-217-eye.sc-sdx-icon::before,.icon-eye.sc-sdx-icon::before{content:\"\\e0d9\"}/*!@.icon-218-eye-shut::before,\n.icon-eye-shut::before*/.icon-218-eye-shut.sc-sdx-icon::before,.icon-eye-shut.sc-sdx-icon::before{content:\"\\e0da\"}/*!@.icon-219-runtime::before,\n.icon-runtime::before*/.icon-219-runtime.sc-sdx-icon::before,.icon-runtime.sc-sdx-icon::before{content:\"\\e0db\"}/*!@.icon-220-list::before,\n.icon-list::before*/.icon-220-list.sc-sdx-icon::before,.icon-list.sc-sdx-icon::before{content:\"\\e0dc\"}/*!@.icon-221-topology::before,\n.icon-topology::before*/.icon-221-topology.sc-sdx-icon::before,.icon-topology.sc-sdx-icon::before{content:\"\\e0dd\"}/*!@.icon-222-blueprint::before,\n.icon-blueprint::before*/.icon-222-blueprint.sc-sdx-icon::before,.icon-blueprint.sc-sdx-icon::before{content:\"\\e0de\"}/*!@.icon-223-map-pointer::before,\n.icon-map-pointer::before*/.icon-223-map-pointer.sc-sdx-icon::before,.icon-map-pointer.sc-sdx-icon::before{content:\"\\e0df\"}/*!@.icon-224-console::before,\n.icon-console::before*/.icon-224-console.sc-sdx-icon::before,.icon-console.sc-sdx-icon::before{content:\"\\e0e0\"}/*!@.icon-225-reboot::before,\n.icon-reboot::before*/.icon-225-reboot.sc-sdx-icon::before,.icon-reboot.sc-sdx-icon::before{content:\"\\e0e1\"}/*!@.icon-226-reprovision::before,\n.icon-reprovision::before*/.icon-226-reprovision.sc-sdx-icon::before,.icon-reprovision.sc-sdx-icon::before{content:\"\\e0e2\"}/*!@.icon-227-speech-bubble-filled::before,\n.icon-speech-bubble-filled::before*/.icon-227-speech-bubble-filled.sc-sdx-icon::before,.icon-speech-bubble-filled.sc-sdx-icon::before{content:\"\\e0e3\"}/*!@.icon-228-star-filled::before,\n.icon-star-filled::before*/.icon-228-star-filled.sc-sdx-icon::before,.icon-star-filled.sc-sdx-icon::before{content:\"\\e0e4\"}/*!@.icon-229-gateway::before,\n.icon-gateway::before*/.icon-229-gateway.sc-sdx-icon::before,.icon-gateway.sc-sdx-icon::before{content:\"\\e0e5\"}/*!@.icon-230-flash::before,\n.icon-flash::before*/.icon-230-flash.sc-sdx-icon::before,.icon-flash.sc-sdx-icon::before{content:\"\\e0e6\"}/*!@.icon-231-rocket::before,\n.icon-rocket::before*/.icon-231-rocket.sc-sdx-icon::before,.icon-rocket.sc-sdx-icon::before{content:\"\\e0e7\"}/*!@.icon-232-robot-neutral::before,\n.icon-robot-neutral::before*/.icon-232-robot-neutral.sc-sdx-icon::before,.icon-robot-neutral.sc-sdx-icon::before{content:\"\\e0e8\"}/*!@.icon-233-robot-happy::before,\n.icon-robot-happy::before*/.icon-233-robot-happy.sc-sdx-icon::before,.icon-robot-happy.sc-sdx-icon::before{content:\"\\e0e9\"}/*!@.icon-234-robot-smile::before,\n.icon-robot-smile::before*/.icon-234-robot-smile.sc-sdx-icon::before,.icon-robot-smile.sc-sdx-icon::before{content:\"\\e0ea\"}/*!@.icon-235-robot-laughing::before,\n.icon-robot-laughing::before*/.icon-235-robot-laughing.sc-sdx-icon::before,.icon-robot-laughing.sc-sdx-icon::before{content:\"\\e0eb\"}/*!@.icon-236-robot-wink-1::before,\n.icon-robot-wink-1::before,\n.icon-236-robot-wink::before,\n.icon-robot-wink::before*/.icon-236-robot-wink-1.sc-sdx-icon::before,.icon-robot-wink-1.sc-sdx-icon::before,.icon-236-robot-wink.sc-sdx-icon::before,.icon-robot-wink.sc-sdx-icon::before{content:\"\\e0ec\"}/*!@.icon-237-robot-relaxed::before,\n.icon-robot-relaxed::before*/.icon-237-robot-relaxed.sc-sdx-icon::before,.icon-robot-relaxed.sc-sdx-icon::before{content:\"\\e0ed\"}/*!@.icon-238-robot-surprized::before,\n.icon-robot-surprized::before*/.icon-238-robot-surprized.sc-sdx-icon::before,.icon-robot-surprized.sc-sdx-icon::before{content:\"\\e0ee\"}/*!@.icon-239-robot-confused::before,\n.icon-robot-confused::before*/.icon-239-robot-confused.sc-sdx-icon::before,.icon-robot-confused.sc-sdx-icon::before{content:\"\\e0ef\"}/*!@.icon-240-robot-sad::before,\n.icon-robot-sad::before*/.icon-240-robot-sad.sc-sdx-icon::before,.icon-robot-sad.sc-sdx-icon::before{content:\"\\e0f0\"}/*!@.icon-241-robot-broken::before,\n.icon-robot-broken::before*/.icon-241-robot-broken.sc-sdx-icon::before,.icon-robot-broken.sc-sdx-icon::before{content:\"\\e0f1\"}/*!@.icon-242-umbrella::before,\n.icon-umbrella::before*/.icon-242-umbrella.sc-sdx-icon::before,.icon-umbrella.sc-sdx-icon::before{content:\"\\e0f2\"}/*!@.icon-243-security::before,\n.icon-security::before*/.icon-243-security.sc-sdx-icon::before,.icon-security.sc-sdx-icon::before{content:\"\\e0f3\"}/*!@.icon-244-routed-network::before,\n.icon-routed-network::before*/.icon-244-routed-network.sc-sdx-icon::before,.icon-routed-network.sc-sdx-icon::before{content:\"\\e0f4\"}/*!@.icon-245-ip-sets::before,\n.icon-ip-sets::before*/.icon-245-ip-sets.sc-sdx-icon::before,.icon-ip-sets.sc-sdx-icon::before{content:\"\\e0f5\"}/*!@.icon-246-resource-pool::before,\n.icon-resource-pool::before*/.icon-246-resource-pool.sc-sdx-icon::before,.icon-resource-pool.sc-sdx-icon::before{content:\"\\e0f6\"}/*!@.icon-247-edge::before,\n.icon-edge::before*/.icon-247-edge.sc-sdx-icon::before,.icon-edge.sc-sdx-icon::before{content:\"\\e0f7\"}/*!@.icon-248-switch::before,\n.icon-switch::before*/.icon-248-switch.sc-sdx-icon::before,.icon-switch.sc-sdx-icon::before{content:\"\\e0f8\"}/*!@.icon-249-processor::before,\n.icon-processor::before*/.icon-249-processor.sc-sdx-icon::before,.icon-processor.sc-sdx-icon::before{content:\"\\e0f9\"}/*!@.icon-250-distributed-network::before,\n.icon-distributed-network::before*/.icon-250-distributed-network.sc-sdx-icon::before,.icon-distributed-network.sc-sdx-icon::before{content:\"\\e0fa\"}/*!@.icon-251-legacy-network::before,\n.icon-legacy-network::before*/.icon-251-legacy-network.sc-sdx-icon::before,.icon-legacy-network.sc-sdx-icon::before{content:\"\\e0fb\"}/*!@.icon-252-star-half::before,\n.icon-star-half::before*/.icon-252-star-half.sc-sdx-icon::before,.icon-star-half.sc-sdx-icon::before{content:\"\\e0fc\"}/*!@.icon-253-filter::before,\n.icon-filter::before*/.icon-253-filter.sc-sdx-icon::before,.icon-filter.sc-sdx-icon::before{content:\"\\e0fd\"}/*!@.icon-254-idcard::before,\n.icon-idcard::before,\n.icon-254_idcard::before*/.icon-254-idcard.sc-sdx-icon::before,.icon-idcard.sc-sdx-icon::before,.icon-254_idcard.sc-sdx-icon::before{content:\"\\e0fe\"}/*!@.icon-255-passport::before,\n.icon-passport::before,\n.icon-255_passport::before*/.icon-255-passport.sc-sdx-icon::before,.icon-passport.sc-sdx-icon::before,.icon-255_passport.sc-sdx-icon::before{content:\"\\e0ff\"}/*!@.icon-256-thumb-up-filled::before,\n.icon-thumb-up-filled::before,\n.icon-256_thumb_up_filled::before*/.icon-256-thumb-up-filled.sc-sdx-icon::before,.icon-thumb-up-filled.sc-sdx-icon::before,.icon-256_thumb_up_filled.sc-sdx-icon::before{content:\"\\e100\"}/*!@.icon-257-tag::before,\n.icon-tag::before,\n.icon-257_tag::before*/.icon-257-tag.sc-sdx-icon::before,.icon-tag.sc-sdx-icon::before,.icon-257_tag.sc-sdx-icon::before{content:\"\\e101\"}/*!@.icon-258-bell::before,\n.icon-bell::before,\n.icon-258_bell::before*/.icon-258-bell.sc-sdx-icon::before,.icon-bell.sc-sdx-icon::before,.icon-258_bell.sc-sdx-icon::before{content:\"\\e102\"}/*!@.icon-259-flash-multiple::before,\n.icon-flash-multiple::before,\n.icon-259_flash_multiple::before*/.icon-259-flash-multiple.sc-sdx-icon::before,.icon-flash-multiple.sc-sdx-icon::before,.icon-259_flash_multiple.sc-sdx-icon::before{content:\"\\e103\"}/*!@.icon-260-lightbulb::before,\n.icon-lightbulb::before,\n.icon-260_lightbulb::before*/.icon-260-lightbulb.sc-sdx-icon::before,.icon-lightbulb.sc-sdx-icon::before,.icon-260_lightbulb.sc-sdx-icon::before{content:\"\\e104\"}/*!@.icon-261-devices::before,\n.icon-devices::before,\n.icon-261_devices::before*/.icon-261-devices.sc-sdx-icon::before,.icon-devices.sc-sdx-icon::before,.icon-261_devices.sc-sdx-icon::before{content:\"\\e105\"}/*!@.icon-262-smartphones-multiple::before,\n.icon-smartphones-multiple::before,\n.icon-262_smartphone_multiple::before*/.icon-262-smartphones-multiple.sc-sdx-icon::before,.icon-smartphones-multiple.sc-sdx-icon::before,.icon-262_smartphone_multiple.sc-sdx-icon::before{content:\"\\e106\"}/*!@.icon-263-document-indesign::before,\n.icon-document-indesign::before,\n.icon-263_document_indesign::before*/.icon-263-document-indesign.sc-sdx-icon::before,.icon-document-indesign.sc-sdx-icon::before,.icon-263_document_indesign.sc-sdx-icon::before{content:\"\\e107\"}/*!@.icon-264-document-illustrator::before,\n.icon-document-illustrator::before,\n.icon-264_document_illustrator::before*/.icon-264-document-illustrator.sc-sdx-icon::before,.icon-document-illustrator.sc-sdx-icon::before,.icon-264_document_illustrator.sc-sdx-icon::before{content:\"\\e108\"}/*!@.icon-265-document-onenote::before,\n.icon-document-onenote::before,\n.icon-265_document_onenote::before*/.icon-265-document-onenote.sc-sdx-icon::before,.icon-document-onenote.sc-sdx-icon::before,.icon-265_document_onenote.sc-sdx-icon::before{content:\"\\e109\"}/*!@.icon-266-document-eps::before,\n.icon-document-eps::before,\n.icon-266_document_eps::before*/.icon-266-document-eps.sc-sdx-icon::before,.icon-document-eps.sc-sdx-icon::before,.icon-266_document_eps.sc-sdx-icon::before{content:\"\\e10a\"}/*!@.icon-267-document-photoshop::before,\n.icon-document-photoshop::before,\n.icon-267_document_photoshop::before*/.icon-267-document-photoshop.sc-sdx-icon::before,.icon-document-photoshop.sc-sdx-icon::before,.icon-267_document_photoshop.sc-sdx-icon::before{content:\"\\e10b\"}/*!@.icon-268-document-visio::before,\n.icon-document-visio::before,\n.icon-268_document_visio::before*/.icon-268-document-visio.sc-sdx-icon::before,.icon-document-visio.sc-sdx-icon::before,.icon-268_document_visio.sc-sdx-icon::before{content:\"\\e10c\"}/*!@.icon-269-document-publisher::before,\n.icon-document-publisher::before,\n.icon-269_document_publisher::before*/.icon-269-document-publisher.sc-sdx-icon::before,.icon-document-publisher.sc-sdx-icon::before,.icon-269_document_publisher.sc-sdx-icon::before{content:\"\\e10d\"}/*!@.icon-270-document-unknowndoc::before,\n.icon-document-unknowndoc::before,\n.icon-270_document_unknowndoc::before*/.icon-270-document-unknowndoc.sc-sdx-icon::before,.icon-document-unknowndoc.sc-sdx-icon::before,.icon-270_document_unknowndoc.sc-sdx-icon::before{content:\"\\e10e\"}/*!@.icon-271-shop::before,\n.icon-shop::before,\n.icon-271_shop::before*/.icon-271-shop.sc-sdx-icon::before,.icon-shop.sc-sdx-icon::before,.icon-271_shop.sc-sdx-icon::before{content:\"\\e10f\"}/*!@.icon-272-scissors::before,\n.icon-scissors::before,\n.icon-272_scissors::before*/.icon-272-scissors.sc-sdx-icon::before,.icon-scissors.sc-sdx-icon::before,.icon-272_scissors.sc-sdx-icon::before{content:\"\\e110\"}/*!@.icon-273-battery::before,\n.icon-battery::before,\n.icon-273_battery::before*/.icon-273-battery.sc-sdx-icon::before,.icon-battery.sc-sdx-icon::before,.icon-273_battery.sc-sdx-icon::before{content:\"\\e111\"}/*!@.icon-274-battery-3::before,\n.icon-battery-3::before,\n.icon-274_battery_3::before*/.icon-274-battery-3.sc-sdx-icon::before,.icon-battery-3.sc-sdx-icon::before,.icon-274_battery_3.sc-sdx-icon::before{content:\"\\e112\"}/*!@.icon-275-battery-2::before,\n.icon-battery-2::before,\n.icon-275_battery_2::before*/.icon-275-battery-2.sc-sdx-icon::before,.icon-battery-2.sc-sdx-icon::before,.icon-275_battery_2.sc-sdx-icon::before{content:\"\\e113\"}/*!@.icon-276-battery-1::before,\n.icon-battery-1::before,\n.icon-276_battery_1::before*/.icon-276-battery-1.sc-sdx-icon::before,.icon-battery-1.sc-sdx-icon::before,.icon-276_battery_1.sc-sdx-icon::before{content:\"\\e114\"}/*!@.icon-277-battery-0::before,\n.icon-battery-0::before,\n.icon-277_battery_0::before*/.icon-277-battery-0.sc-sdx-icon::before,.icon-battery-0.sc-sdx-icon::before,.icon-277_battery_0.sc-sdx-icon::before{content:\"\\e115\"}/*!@.icon-278-battery-empty::before,\n.icon-battery-empty::before,\n.icon-278_battery_empty::before*/.icon-278-battery-empty.sc-sdx-icon::before,.icon-battery-empty.sc-sdx-icon::before,.icon-278_battery_empty.sc-sdx-icon::before{content:\"\\e116\"}/*!@.icon-279-mouse::before,\n.icon-mouse::before,\n.icon-279_mouse::before*/.icon-279-mouse.sc-sdx-icon::before,.icon-mouse.sc-sdx-icon::before,.icon-279_mouse.sc-sdx-icon::before{content:\"\\e117\"}/*!@.icon-280-pointer::before,\n.icon-pointer::before,\n.icon-280_pointer::before*/.icon-280-pointer.sc-sdx-icon::before,.icon-pointer.sc-sdx-icon::before,.icon-280_pointer.sc-sdx-icon::before{content:\"\\e118\"}/*!@.icon-281-realmouse::before,\n.icon-realmouse::before,\n.icon-281_realmouse::before*/.icon-281-realmouse.sc-sdx-icon::before,.icon-realmouse.sc-sdx-icon::before,.icon-281_realmouse.sc-sdx-icon::before{content:\"\\e119\"}/*!@.icon-282-bug::before,\n.icon-bug::before,\n.icon-282_bug::before*/.icon-282-bug.sc-sdx-icon::before,.icon-bug.sc-sdx-icon::before,.icon-282_bug.sc-sdx-icon::before{content:\"\\e11a\"}/*!@.icon-283-privacy::before,\n.icon-privacy::before,\n.icon-283_privacy::before*/.icon-283-privacy.sc-sdx-icon::before,.icon-privacy.sc-sdx-icon::before,.icon-283_privacy.sc-sdx-icon::before{content:\"\\e11b\"}/*!@.icon-284-ip::before,\n.icon-ip::before,\n.icon-284_ip::before*/.icon-284-ip.sc-sdx-icon::before,.icon-ip.sc-sdx-icon::before,.icon-284_ip.sc-sdx-icon::before{content:\"\\e11c\"}/*!@.icon-285-patch::before,\n.icon-patch::before,\n.icon-285_patch::before*/.icon-285-patch.sc-sdx-icon::before,.icon-patch.sc-sdx-icon::before,.icon-285_patch.sc-sdx-icon::before{content:\"\\e11d\"}/*!@.icon-286-microphone::before,\n.icon-microphone::before,\n.icon-286_microphone_1::before*/.icon-286-microphone.sc-sdx-icon::before,.icon-microphone.sc-sdx-icon::before,.icon-286_microphone_1.sc-sdx-icon::before{content:\"\\e11e\"}/*!@.icon-287-microphone-filled::before,\n.icon-microphone-filled::before,\n.icon-287_microphone_2::before*/.icon-287-microphone-filled.sc-sdx-icon::before,.icon-microphone-filled.sc-sdx-icon::before,.icon-287_microphone_2.sc-sdx-icon::before{content:\"\\e11f\"}/*!@.icon-288-handset-up::before,\n.icon-handset-up::before,\n.icon-288_handset_up::before*/.icon-288-handset-up.sc-sdx-icon::before,.icon-handset-up.sc-sdx-icon::before,.icon-288_handset_up.sc-sdx-icon::before{content:\"\\e120\"}/*!@.icon-289-handset-up-stroke::before,\n.icon-handset-up-stroke::before,\n.icon-289_handset_up_stroke::before*/.icon-289-handset-up-stroke.sc-sdx-icon::before,.icon-handset-up-stroke.sc-sdx-icon::before,.icon-289_handset_up_stroke.sc-sdx-icon::before{content:\"\\e121\"}/*!@.icon-290-handset-stroke::before,\n.icon-handset-stroke::before,\n.icon-290_handset_stroke::before*/.icon-290-handset-stroke.sc-sdx-icon::before,.icon-handset-stroke.sc-sdx-icon::before,.icon-290_handset_stroke.sc-sdx-icon::before{content:\"\\e122\"}/*!@.icon-291-software::before,\n.icon-software::before,\n.icon-291_software::before*/.icon-291-software.sc-sdx-icon::before,.icon-software.sc-sdx-icon::before,.icon-291_software.sc-sdx-icon::before{content:\"\\e123\"}/*!@.icon-292-dynamic-storage::before,\n.icon-dynamic-storage::before,\n.icon-292_dynamic_storage::before*/.icon-292-dynamic-storage.sc-sdx-icon::before,.icon-dynamic-storage.sc-sdx-icon::before,.icon-292_dynamic_storage.sc-sdx-icon::before{content:\"\\e124\"}/*!@.icon-293-wireless-data::before,\n.icon-wireless-data::before,\n.icon-293_wireless_data::before*/.icon-293-wireless-data.sc-sdx-icon::before,.icon-wireless-data.sc-sdx-icon::before,.icon-293_wireless_data.sc-sdx-icon::before{content:\"\\e125\"}/*!@.icon-294-wireless-voice::before,\n.icon-wireless-voice::before,\n.icon-294_wireless_voice::before*/.icon-294-wireless-voice.sc-sdx-icon::before,.icon-wireless-voice.sc-sdx-icon::before,.icon-294_wireless_voice.sc-sdx-icon::before{content:\"\\e126\"}/*!@.icon-295-lips::before,\n.icon-lips::before,\n.icon-295_lips::before*/.icon-295-lips.sc-sdx-icon::before,.icon-lips.sc-sdx-icon::before,.icon-295_lips.sc-sdx-icon::before{content:\"\\e127\"}/*!@.icon-296-flag-filled::before,\n.icon-flag-filled::before,\n.icon-296_flag-filled::before*/.icon-296-flag-filled.sc-sdx-icon::before,.icon-flag-filled.sc-sdx-icon::before,.icon-296_flag-filled.sc-sdx-icon::before{content:\"\\e128\"}/*!@.icon-297-alarmclock::before,\n.icon-alarmclock::before,\n.icon-297_alarmclock::before*/.icon-297-alarmclock.sc-sdx-icon::before,.icon-alarmclock.sc-sdx-icon::before,.icon-297_alarmclock.sc-sdx-icon::before{content:\"\\e129\"}/*!@.icon-298-copy::before,\n.icon-copy::before,\n.icon-298_copy::before*/.icon-298-copy.sc-sdx-icon::before,.icon-copy.sc-sdx-icon::before,.icon-298_copy.sc-sdx-icon::before{content:\"\\e12a\"}/*!@.icon-299-paste::before,\n.icon-paste::before,\n.icon-299_paste::before*/.icon-299-paste.sc-sdx-icon::before,.icon-paste.sc-sdx-icon::before,.icon-299_paste.sc-sdx-icon::before{content:\"\\e12b\"}/*!@.icon-300-plus-box::before,\n.icon-plus-box::before,\n.icon-300_plus-box::before*/.icon-300-plus-box.sc-sdx-icon::before,.icon-plus-box.sc-sdx-icon::before,.icon-300_plus-box.sc-sdx-icon::before{content:\"\\e12c\"}/*!@.icon-301-minus-box::before,\n.icon-minus-box::before,\n.icon-301_minus-box::before*/.icon-301-minus-box.sc-sdx-icon::before,.icon-minus-box.sc-sdx-icon::before,.icon-301_minus-box.sc-sdx-icon::before{content:\"\\e12d\"}/*!@.icon-302-service::before,\n.icon-service::before,\n.icon-302_service::before*/.icon-302-service.sc-sdx-icon::before,.icon-service.sc-sdx-icon::before,.icon-302_service.sc-sdx-icon::before{content:\"\\e12e\"}/*!@.icon-303-business-phone::before,\n.icon-business-phone::before,\n.icon-303_business-phone::before*/.icon-303-business-phone.sc-sdx-icon::before,.icon-business-phone.sc-sdx-icon::before,.icon-303_business-phone.sc-sdx-icon::before{content:\"\\e12f\"}/*!@.icon-304-accessibility::before,\n.icon-accessibility::before*/.icon-304-accessibility.sc-sdx-icon::before,.icon-accessibility.sc-sdx-icon::before{content:\"\\e130\"}/*!@.icon-305-agile-process::before,\n.icon-agile-process::before*/.icon-305-agile-process.sc-sdx-icon::before,.icon-agile-process.sc-sdx-icon::before{content:\"\\e131\"}/*!@.icon-306-airplaine::before,\n.icon-airplaine::before*/.icon-306-airplaine.sc-sdx-icon::before,.icon-airplaine.sc-sdx-icon::before{content:\"\\e132\"}/*!@.icon-307-alarmcall::before,\n.icon-alarmcall::before*/.icon-307-alarmcall.sc-sdx-icon::before,.icon-alarmcall.sc-sdx-icon::before{content:\"\\e133\"}/*!@.icon-308-auster::before,\n.icon-auster::before*/.icon-308-auster.sc-sdx-icon::before,.icon-auster.sc-sdx-icon::before{content:\"\\e134\"}/*!@.icon-309-barcode::before,\n.icon-barcode::before*/.icon-309-barcode.sc-sdx-icon::before,.icon-barcode.sc-sdx-icon::before{content:\"\\e135\"}/*!@.icon-310-bed::before,\n.icon-bed::before*/.icon-310-bed.sc-sdx-icon::before,.icon-bed.sc-sdx-icon::before{content:\"\\e136\"}/*!@.icon-311-bee::before,\n.icon-bee::before*/.icon-311-bee.sc-sdx-icon::before,.icon-bee.sc-sdx-icon::before{content:\"\\e137\"}/*!@.icon-312-beer::before,\n.icon-beer::before*/.icon-312-beer.sc-sdx-icon::before,.icon-beer.sc-sdx-icon::before{content:\"\\e138\"}/*!@.icon-313-biker::before,\n.icon-biker::before*/.icon-313-biker.sc-sdx-icon::before,.icon-biker.sc-sdx-icon::before{content:\"\\e139\"}/*!@.icon-314-blow-fish::before,\n.icon-blow-fish::before*/.icon-314-blow-fish.sc-sdx-icon::before,.icon-blow-fish.sc-sdx-icon::before{content:\"\\e13a\"}/*!@.icon-315-book::before,\n.icon-book::before*/.icon-315-book.sc-sdx-icon::before,.icon-book.sc-sdx-icon::before{content:\"\\e13b\"}/*!@.icon-316-broom::before,\n.icon-broom::before*/.icon-316-broom.sc-sdx-icon::before,.icon-broom.sc-sdx-icon::before{content:\"\\e13c\"}/*!@.icon-317-bubbles::before,\n.icon-bubbles::before*/.icon-317-bubbles.sc-sdx-icon::before,.icon-bubbles.sc-sdx-icon::before{content:\"\\e13d\"}/*!@.icon-318-bus::before,\n.icon-bus::before*/.icon-318-bus.sc-sdx-icon::before,.icon-bus.sc-sdx-icon::before{content:\"\\e13e\"}/*!@.icon-319-business-network::before,\n.icon-business-network::before*/.icon-319-business-network.sc-sdx-icon::before,.icon-business-network.sc-sdx-icon::before{content:\"\\e13f\"}/*!@.icon-320-buyback::before,\n.icon-buyback::before*/.icon-320-buyback.sc-sdx-icon::before,.icon-buyback.sc-sdx-icon::before{content:\"\\e140\"}/*!@.icon-321-bicycle::before,\n.icon-bicycle::before*/.icon-321-bicycle.sc-sdx-icon::before,.icon-bicycle.sc-sdx-icon::before{content:\"\\e141\"}/*!@.icon-322-cablecar::before,\n.icon-cablecar::before*/.icon-322-cablecar.sc-sdx-icon::before,.icon-cablecar.sc-sdx-icon::before{content:\"\\e142\"}/*!@.icon-323-calculator::before,\n.icon-calculator::before*/.icon-323-calculator.sc-sdx-icon::before,.icon-calculator.sc-sdx-icon::before{content:\"\\e143\"}/*!@.icon-324-call-log::before,\n.icon-call-log::before*/.icon-324-call-log.sc-sdx-icon::before,.icon-call-log.sc-sdx-icon::before{content:\"\\e144\"}/*!@.icon-325-callfilter::before,\n.icon-callfilter::before*/.icon-325-callfilter.sc-sdx-icon::before,.icon-callfilter.sc-sdx-icon::before{content:\"\\e145\"}/*!@.icon-326-car-pooling-2::before,\n.icon-car-pooling-2::before*/.icon-326-car-pooling-2.sc-sdx-icon::before,.icon-car-pooling-2.sc-sdx-icon::before{content:\"\\e146\"}/*!@.icon-327-car-pooling::before,\n.icon-car-pooling::before*/.icon-327-car-pooling.sc-sdx-icon::before,.icon-car-pooling.sc-sdx-icon::before{content:\"\\e147\"}/*!@.icon-328-car-sharing::before,\n.icon-car-sharing::before*/.icon-328-car-sharing.sc-sdx-icon::before,.icon-car-sharing.sc-sdx-icon::before{content:\"\\e148\"}/*!@.icon-329-car::before,\n.icon-car::before*/.icon-329-car.sc-sdx-icon::before,.icon-car.sc-sdx-icon::before{content:\"\\e149\"}/*!@.icon-330-carabiner::before,\n.icon-carabiner::before*/.icon-330-carabiner.sc-sdx-icon::before,.icon-carabiner.sc-sdx-icon::before{content:\"\\e14a\"}/*!@.icon-331-cardreader::before,\n.icon-cardreader::before*/.icon-331-cardreader.sc-sdx-icon::before,.icon-cardreader.sc-sdx-icon::before{content:\"\\e14b\"}/*!@.icon-332-care::before,\n.icon-care::before*/.icon-332-care.sc-sdx-icon::before,.icon-care.sc-sdx-icon::before{content:\"\\e14c\"}/*!@.icon-333-cashdesk::before,\n.icon-cashdesk::before*/.icon-333-cashdesk.sc-sdx-icon::before,.icon-cashdesk.sc-sdx-icon::before{content:\"\\e14d\"}/*!@.icon-334-ccserver::before,\n.icon-ccserver::before*/.icon-334-ccserver.sc-sdx-icon::before,.icon-ccserver.sc-sdx-icon::before{content:\"\\e14e\"}/*!@.icon-335-chairlift::before,\n.icon-chairlift::before*/.icon-335-chairlift.sc-sdx-icon::before,.icon-chairlift.sc-sdx-icon::before{content:\"\\e14f\"}/*!@.icon-336-child-protection-2::before,\n.icon-child-protection-2::before*/.icon-336-child-protection-2.sc-sdx-icon::before,.icon-child-protection-2.sc-sdx-icon::before{content:\"\\e150\"}/*!@.icon-337-cocktail::before,\n.icon-cocktail::before*/.icon-337-cocktail.sc-sdx-icon::before,.icon-cocktail.sc-sdx-icon::before{content:\"\\e151\"}/*!@.icon-338-coffee::before,\n.icon-coffee::before*/.icon-338-coffee.sc-sdx-icon::before,.icon-coffee.sc-sdx-icon::before{content:\"\\e152\"}/*!@.icon-339-combox::before,\n.icon-combox::before*/.icon-339-combox.sc-sdx-icon::before,.icon-combox.sc-sdx-icon::before{content:\"\\e153\"}/*!@.icon-340-computer-monitoring::before,\n.icon-computer-monitoring::before*/.icon-340-computer-monitoring.sc-sdx-icon::before,.icon-computer-monitoring.sc-sdx-icon::before{content:\"\\e154\"}/*!@.icon-341-copier::before,\n.icon-copier::before*/.icon-341-copier.sc-sdx-icon::before,.icon-copier.sc-sdx-icon::before{content:\"\\e155\"}/*!@.icon-342-crab::before,\n.icon-crab::before*/.icon-342-crab.sc-sdx-icon::before,.icon-crab.sc-sdx-icon::before{content:\"\\e156\"}/*!@.icon-343-crime::before,\n.icon-crime::before*/.icon-343-crime.sc-sdx-icon::before,.icon-crime.sc-sdx-icon::before{content:\"\\e157\"}/*!@.icon-344-cross::before,\n.icon-cross::before*/.icon-344-cross.sc-sdx-icon::before,.icon-cross.sc-sdx-icon::before{content:\"\\e158\"}/*!@.icon-345-crowd::before,\n.icon-crowd::before*/.icon-345-crowd.sc-sdx-icon::before,.icon-crowd.sc-sdx-icon::before{content:\"\\e159\"}/*!@.icon-346-crown::before,\n.icon-crown::before*/.icon-346-crown.sc-sdx-icon::before,.icon-crown.sc-sdx-icon::before{content:\"\\e15a\"}/*!@.icon-347-cruiser::before,\n.icon-cruiser::before*/.icon-347-cruiser.sc-sdx-icon::before,.icon-cruiser.sc-sdx-icon::before{content:\"\\e15b\"}/*!@.icon-348-dargebotene-hand::before,\n.icon-dargebotene-hand::before*/.icon-348-dargebotene-hand.sc-sdx-icon::before,.icon-dargebotene-hand.sc-sdx-icon::before{content:\"\\e15c\"}/*!@.icon-349-desktopsharing::before,\n.icon-desktopsharing::before*/.icon-349-desktopsharing.sc-sdx-icon::before,.icon-desktopsharing.sc-sdx-icon::before{content:\"\\e15d\"}/*!@.icon-350-diagram-2::before,\n.icon-diagram-2::before*/.icon-350-diagram-2.sc-sdx-icon::before,.icon-diagram-2.sc-sdx-icon::before{content:\"\\e15e\"}/*!@.icon-351-diagram::before,\n.icon-diagram::before*/.icon-351-diagram.sc-sdx-icon::before,.icon-diagram.sc-sdx-icon::before{content:\"\\e15f\"}/*!@.icon-352-dial::before,\n.icon-dial::before*/.icon-352-dial.sc-sdx-icon::before,.icon-dial.sc-sdx-icon::before{content:\"\\e160\"}/*!@.icon-353-digihome::before,\n.icon-digihome::before*/.icon-353-digihome.sc-sdx-icon::before,.icon-digihome.sc-sdx-icon::before{content:\"\\e161\"}/*!@.icon-354-discjockey::before,\n.icon-discjockey::before*/.icon-354-discjockey.sc-sdx-icon::before,.icon-discjockey.sc-sdx-icon::before{content:\"\\e162\"}/*!@.icon-355-doctor::before,\n.icon-doctor::before*/.icon-355-doctor.sc-sdx-icon::before,.icon-doctor.sc-sdx-icon::before{content:\"\\e163\"}/*!@.icon-356-driverless-car::before,\n.icon-driverless-car::before*/.icon-356-driverless-car.sc-sdx-icon::before,.icon-driverless-car.sc-sdx-icon::before{content:\"\\e164\"}/*!@.icon-357-drone::before,\n.icon-drone::before*/.icon-357-drone.sc-sdx-icon::before,.icon-drone.sc-sdx-icon::before{content:\"\\e165\"}/*!@.icon-358-ebike-2::before,\n.icon-ebike-2::before*/.icon-358-ebike-2.sc-sdx-icon::before,.icon-ebike-2.sc-sdx-icon::before{content:\"\\e166\"}/*!@.icon-359-ebike::before,\n.icon-ebike::before*/.icon-359-ebike.sc-sdx-icon::before,.icon-ebike.sc-sdx-icon::before{content:\"\\e167\"}/*!@.icon-360-ecar::before,\n.icon-ecar::before*/.icon-360-ecar.sc-sdx-icon::before,.icon-ecar.sc-sdx-icon::before{content:\"\\e168\"}/*!@.icon-361-edge-2::before,\n.icon-edge-2::before*/.icon-361-edge-2.sc-sdx-icon::before,.icon-edge-2.sc-sdx-icon::before{content:\"\\e169\"}/*!@.icon-362-elevator::before,\n.icon-elevator::before*/.icon-362-elevator.sc-sdx-icon::before,.icon-elevator.sc-sdx-icon::before{content:\"\\e16a\"}/*!@.icon-363-emotorcycle-2::before,\n.icon-emotorcycle-2::before*/.icon-363-emotorcycle-2.sc-sdx-icon::before,.icon-emotorcycle-2.sc-sdx-icon::before{content:\"\\e16b\"}/*!@.icon-364-emotorcycle::before,\n.icon-emotorcycle::before*/.icon-364-emotorcycle.sc-sdx-icon::before,.icon-emotorcycle.sc-sdx-icon::before{content:\"\\e16c\"}/*!@.icon-365-esim::before,\n.icon-esim::before*/.icon-365-esim.sc-sdx-icon::before,.icon-esim.sc-sdx-icon::before{content:\"\\e16d\"}/*!@.icon-366-ethernet::before,\n.icon-ethernet::before*/.icon-366-ethernet.sc-sdx-icon::before,.icon-ethernet.sc-sdx-icon::before{content:\"\\e16e\"}/*!@.icon-367-exit::before,\n.icon-exit::before*/.icon-367-exit.sc-sdx-icon::before,.icon-exit.sc-sdx-icon::before{content:\"\\e16f\"}/*!@.icon-368-factory::before,\n.icon-factory::before*/.icon-368-factory.sc-sdx-icon::before,.icon-factory.sc-sdx-icon::before{content:\"\\e170\"}/*!@.icon-369-faultclearing::before,\n.icon-faultclearing::before*/.icon-369-faultclearing.sc-sdx-icon::before,.icon-faultclearing.sc-sdx-icon::before{content:\"\\e171\"}/*!@.icon-370-fiber::before,\n.icon-fiber::before*/.icon-370-fiber.sc-sdx-icon::before,.icon-fiber.sc-sdx-icon::before{content:\"\\e172\"}/*!@.icon-371-firebrigade::before,\n.icon-firebrigade::before*/.icon-371-firebrigade.sc-sdx-icon::before,.icon-firebrigade.sc-sdx-icon::before{content:\"\\e173\"}/*!@.icon-372-fish::before,\n.icon-fish::before*/.icon-372-fish.sc-sdx-icon::before,.icon-fish.sc-sdx-icon::before{content:\"\\e174\"}/*!@.icon-373-fitness::before,\n.icon-fitness::before*/.icon-373-fitness.sc-sdx-icon::before,.icon-fitness.sc-sdx-icon::before{content:\"\\e175\"}/*!@.icon-374-flag-filled-wind::before,\n.icon-flag-filled-wind::before*/.icon-374-flag-filled-wind.sc-sdx-icon::before,.icon-flag-filled-wind.sc-sdx-icon::before{content:\"\\e176\"}/*!@.icon-375-flag-wind::before,\n.icon-flag-wind::before*/.icon-375-flag-wind.sc-sdx-icon::before,.icon-flag-wind.sc-sdx-icon::before{content:\"\\e177\"}/*!@.icon-376-fleet-management::before,\n.icon-fleet-management::before*/.icon-376-fleet-management.sc-sdx-icon::before,.icon-fleet-management.sc-sdx-icon::before{content:\"\\e178\"}/*!@.icon-377-food::before,\n.icon-food::before*/.icon-377-food.sc-sdx-icon::before,.icon-food.sc-sdx-icon::before{content:\"\\e179\"}/*!@.icon-378-freighter::before,\n.icon-freighter::before*/.icon-378-freighter.sc-sdx-icon::before,.icon-freighter.sc-sdx-icon::before{content:\"\\e17a\"}/*!@.icon-379-garderobe::before,\n.icon-garderobe::before*/.icon-379-garderobe.sc-sdx-icon::before,.icon-garderobe.sc-sdx-icon::before{content:\"\\e17b\"}/*!@.icon-380-gears-three::before,\n.icon-gears-three::before*/.icon-380-gears-three.sc-sdx-icon::before,.icon-gears-three.sc-sdx-icon::before{content:\"\\e17c\"}/*!@.icon-381-gears::before,\n.icon-gears::before*/.icon-381-gears.sc-sdx-icon::before,.icon-gears.sc-sdx-icon::before{content:\"\\e17d\"}/*!@.icon-382-globe-key::before,\n.icon-globe-key::before*/.icon-382-globe-key.sc-sdx-icon::before,.icon-globe-key.sc-sdx-icon::before{content:\"\\e17e\"}/*!@.icon-383-goggles-3d::before,\n.icon-goggles-3d::before*/.icon-383-goggles-3d.sc-sdx-icon::before,.icon-goggles-3d.sc-sdx-icon::before{content:\"\\e17f\"}/*!@.icon-384-green-laptop::before,\n.icon-green-laptop::before*/.icon-384-green-laptop.sc-sdx-icon::before,.icon-green-laptop.sc-sdx-icon::before{content:\"\\e180\"}/*!@.icon-385-green-mobile::before,\n.icon-green-mobile::before*/.icon-385-green-mobile.sc-sdx-icon::before,.icon-green-mobile.sc-sdx-icon::before{content:\"\\e181\"}/*!@.icon-386-hd-voice::before,\n.icon-hd-voice::before*/.icon-386-hd-voice.sc-sdx-icon::before,.icon-hd-voice.sc-sdx-icon::before{content:\"\\e182\"}/*!@.icon-387-helicopter::before,\n.icon-helicopter::before*/.icon-387-helicopter.sc-sdx-icon::before,.icon-helicopter.sc-sdx-icon::before{content:\"\\e183\"}/*!@.icon-388-helpline::before,\n.icon-helpline::before*/.icon-388-helpline.sc-sdx-icon::before,.icon-helpline.sc-sdx-icon::before{content:\"\\e184\"}/*!@.icon-389-hiking::before,\n.icon-hiking::before*/.icon-389-hiking.sc-sdx-icon::before,.icon-hiking.sc-sdx-icon::before{content:\"\\e185\"}/*!@.icon-390-home-ok::before,\n.icon-home-ok::before*/.icon-390-home-ok.sc-sdx-icon::before,.icon-home-ok.sc-sdx-icon::before{content:\"\\e186\"}/*!@.icon-391-hospital-building::before,\n.icon-hospital-building::before*/.icon-391-hospital-building.sc-sdx-icon::before,.icon-hospital-building.sc-sdx-icon::before{content:\"\\e187\"}/*!@.icon-392-hospital::before,\n.icon-hospital::before*/.icon-392-hospital.sc-sdx-icon::before,.icon-hospital.sc-sdx-icon::before{content:\"\\e188\"}/*!@.icon-393-hotspot-localprodukt::before,\n.icon-hotspot-localprodukt::before*/.icon-393-hotspot-localprodukt.sc-sdx-icon::before,.icon-hotspot-localprodukt.sc-sdx-icon::before{content:\"\\e189\"}/*!@.icon-394-hybrid-drive::before,\n.icon-hybrid-drive::before*/.icon-394-hybrid-drive.sc-sdx-icon::before,.icon-hybrid-drive.sc-sdx-icon::before{content:\"\\e18a\"}/*!@.icon-395-infinity::before,\n.icon-infinity::before*/.icon-395-infinity.sc-sdx-icon::before,.icon-infinity.sc-sdx-icon::before{content:\"\\e18b\"}/*!@.icon-396-informationint::before,\n.icon-informationint::before*/.icon-396-informationint.sc-sdx-icon::before,.icon-informationint.sc-sdx-icon::before{content:\"\\e18c\"}/*!@.icon-397-insert-banknote::before,\n.icon-insert-banknote::before*/.icon-397-insert-banknote.sc-sdx-icon::before,.icon-insert-banknote.sc-sdx-icon::before{content:\"\\e18d\"}/*!@.icon-398-insertcoin::before,\n.icon-insertcoin::before*/.icon-398-insertcoin.sc-sdx-icon::before,.icon-insertcoin.sc-sdx-icon::before{content:\"\\e18e\"}/*!@.icon-399-internet-of-things::before,\n.icon-internet-of-things::before*/.icon-399-internet-of-things.sc-sdx-icon::before,.icon-internet-of-things.sc-sdx-icon::before{content:\"\\e18f\"}/*!@.icon-400-ip-telephone::before,\n.icon-ip-telephone::before*/.icon-400-ip-telephone.sc-sdx-icon::before,.icon-ip-telephone.sc-sdx-icon::before{content:\"\\e190\"}/*!@.icon-401-jelly-fish::before,\n.icon-jelly-fish::before*/.icon-401-jelly-fish.sc-sdx-icon::before,.icon-jelly-fish.sc-sdx-icon::before{content:\"\\e191\"}/*!@.icon-402-juggler::before,\n.icon-juggler::before*/.icon-402-juggler.sc-sdx-icon::before,.icon-juggler.sc-sdx-icon::before{content:\"\\e192\"}/*!@.icon-403-keyboard::before,\n.icon-keyboard::before*/.icon-403-keyboard.sc-sdx-icon::before,.icon-keyboard.sc-sdx-icon::before{content:\"\\e193\"}/*!@.icon-404-laptop-internet::before,\n.icon-laptop-internet::before*/.icon-404-laptop-internet.sc-sdx-icon::before,.icon-laptop-internet.sc-sdx-icon::before{content:\"\\e194\"}/*!@.icon-405-living-room::before,\n.icon-living-room::before*/.icon-405-living-room.sc-sdx-icon::before,.icon-living-room.sc-sdx-icon::before{content:\"\\e195\"}/*!@.icon-406-lowradiation::before,\n.icon-lowradiation::before*/.icon-406-lowradiation.sc-sdx-icon::before,.icon-lowradiation.sc-sdx-icon::before{content:\"\\e196\"}/*!@.icon-407-mail-storge::before,\n.icon-mail-storge::before,\n.icon-407-mail-storage::before,\n.icon-mail-storage::before*/.icon-407-mail-storge.sc-sdx-icon::before,.icon-mail-storge.sc-sdx-icon::before,.icon-407-mail-storage.sc-sdx-icon::before,.icon-mail-storage.sc-sdx-icon::before{content:\"\\e197\"}/*!@.icon-408-mediabox::before,\n.icon-mediabox::before*/.icon-408-mediabox.sc-sdx-icon::before,.icon-mediabox.sc-sdx-icon::before{content:\"\\e198\"}/*!@.icon-409-megaphone::before,\n.icon-megaphone::before*/.icon-409-megaphone.sc-sdx-icon::before,.icon-megaphone.sc-sdx-icon::before{content:\"\\e199\"}/*!@.icon-410-mobile-buyback-2::before,\n.icon-mobile-buyback-2::before*/.icon-410-mobile-buyback-2.sc-sdx-icon::before,.icon-mobile-buyback-2.sc-sdx-icon::before{content:\"\\e19a\"}/*!@.icon-411-mobile-buyback-3::before,\n.icon-mobile-buyback-3::before*/.icon-411-mobile-buyback-3.sc-sdx-icon::before,.icon-mobile-buyback-3.sc-sdx-icon::before{content:\"\\e19b\"}/*!@.icon-412-mobile-buyback::before,\n.icon-mobile-buyback::before*/.icon-412-mobile-buyback.sc-sdx-icon::before,.icon-mobile-buyback.sc-sdx-icon::before{content:\"\\e19c\"}/*!@.icon-413-mobile-internet::before,\n.icon-mobile-internet::before*/.icon-413-mobile-internet.sc-sdx-icon::before,.icon-mobile-internet.sc-sdx-icon::before{content:\"\\e19d\"}/*!@.icon-414-mobile-laptop::before,\n.icon-mobile-laptop::before*/.icon-414-mobile-laptop.sc-sdx-icon::before,.icon-mobile-laptop.sc-sdx-icon::before{content:\"\\e19e\"}/*!@.icon-415-mobile-message::before,\n.icon-mobile-message::before*/.icon-415-mobile-message.sc-sdx-icon::before,.icon-mobile-message.sc-sdx-icon::before{content:\"\\e19f\"}/*!@.icon-416-mobile-payment::before,\n.icon-mobile-payment::before*/.icon-416-mobile-payment.sc-sdx-icon::before,.icon-mobile-payment.sc-sdx-icon::before{content:\"\\e1a0\"}/*!@.icon-417-mobilecall::before,\n.icon-mobilecall::before*/.icon-417-mobilecall.sc-sdx-icon::before,.icon-mobilecall.sc-sdx-icon::before{content:\"\\e1a1\"}/*!@.icon-418-mobileuser::before,\n.icon-mobileuser::before*/.icon-418-mobileuser.sc-sdx-icon::before,.icon-mobileuser.sc-sdx-icon::before{content:\"\\e1a2\"}/*!@.icon-419-modem::before,\n.icon-modem::before*/.icon-419-modem.sc-sdx-icon::before,.icon-modem.sc-sdx-icon::before{content:\"\\e1a3\"}/*!@.icon-420-motorcycle-2::before,\n.icon-motorcycle-2::before*/.icon-420-motorcycle-2.sc-sdx-icon::before,.icon-motorcycle-2.sc-sdx-icon::before{content:\"\\e1a4\"}/*!@.icon-421-motorcycle::before,\n.icon-motorcycle::before*/.icon-421-motorcycle.sc-sdx-icon::before,.icon-motorcycle.sc-sdx-icon::before{content:\"\\e1a5\"}/*!@.icon-422-mountainbiker::before,\n.icon-mountainbiker::before*/.icon-422-mountainbiker.sc-sdx-icon::before,.icon-mountainbiker.sc-sdx-icon::before{content:\"\\e1a6\"}/*!@.icon-423-music-app-2::before,\n.icon-music-app-2::before*/.icon-423-music-app-2.sc-sdx-icon::before,.icon-music-app-2.sc-sdx-icon::before{content:\"\\e1a7\"}/*!@.icon-424-music-app::before,\n.icon-music-app::before*/.icon-424-music-app.sc-sdx-icon::before,.icon-music-app.sc-sdx-icon::before{content:\"\\e1a8\"}/*!@.icon-425-mycloud::before,\n.icon-mycloud::before*/.icon-425-mycloud.sc-sdx-icon::before,.icon-mycloud.sc-sdx-icon::before{content:\"\\e1a9\"}/*!@.icon-426-network-3g::before,\n.icon-network-3g::before*/.icon-426-network-3g.sc-sdx-icon::before,.icon-network-3g.sc-sdx-icon::before{content:\"\\e1aa\"}/*!@.icon-427-network-4g::before,\n.icon-network-4g::before*/.icon-427-network-4g.sc-sdx-icon::before,.icon-network-4g.sc-sdx-icon::before{content:\"\\e1ab\"}/*!@.icon-428-network-4gplus::before,\n.icon-network-4gplus::before*/.icon-428-network-4gplus.sc-sdx-icon::before,.icon-network-4gplus.sc-sdx-icon::before{content:\"\\e1ac\"}/*!@.icon-429-network-5g::before,\n.icon-network-5g::before*/.icon-429-network-5g.sc-sdx-icon::before,.icon-network-5g.sc-sdx-icon::before{content:\"\\e1ad\"}/*!@.icon-430-network-improvement::before,\n.icon-network-improvement::before*/.icon-430-network-improvement.sc-sdx-icon::before,.icon-network-improvement.sc-sdx-icon::before{content:\"\\e1ae\"}/*!@.icon-431-newspaper::before,\n.icon-newspaper::before*/.icon-431-newspaper.sc-sdx-icon::before,.icon-newspaper.sc-sdx-icon::before{content:\"\\e1af\"}/*!@.icon-432-nfc::before,\n.icon-nfc::before*/.icon-432-nfc.sc-sdx-icon::before,.icon-nfc.sc-sdx-icon::before{content:\"\\e1b0\"}/*!@.icon-433-nordic-combined::before,\n.icon-nordic-combined::before*/.icon-433-nordic-combined.sc-sdx-icon::before,.icon-nordic-combined.sc-sdx-icon::before{content:\"\\e1b1\"}/*!@.icon-434-notice::before,\n.icon-notice::before*/.icon-434-notice.sc-sdx-icon::before,.icon-notice.sc-sdx-icon::before{content:\"\\e1b2\"}/*!@.icon-435-nut-and-bolt::before,\n.icon-nut-and-bolt::before*/.icon-435-nut-and-bolt.sc-sdx-icon::before,.icon-nut-and-bolt.sc-sdx-icon::before{content:\"\\e1b3\"}/*!@.icon-436-online-storge::before,\n.icon-online-storge::before,\n.icon-436-online-storage::before,\n.icon-online-storage::before*/.icon-436-online-storge.sc-sdx-icon::before,.icon-online-storge.sc-sdx-icon::before,.icon-436-online-storage.sc-sdx-icon::before,.icon-online-storage.sc-sdx-icon::before{content:\"\\e1b4\"}/*!@.icon-437-parking-garage::before,\n.icon-parking-garage::before*/.icon-437-parking-garage.sc-sdx-icon::before,.icon-parking-garage.sc-sdx-icon::before{content:\"\\e1b5\"}/*!@.icon-438-parking-meter::before,\n.icon-parking-meter::before*/.icon-438-parking-meter.sc-sdx-icon::before,.icon-parking-meter.sc-sdx-icon::before{content:\"\\e1b6\"}/*!@.icon-439-parking-2::before,\n.icon-parking-2::before*/.icon-439-parking-2.sc-sdx-icon::before,.icon-parking-2.sc-sdx-icon::before{content:\"\\e1b7\"}/*!@.icon-440-parking::before,\n.icon-parking::before*/.icon-440-parking.sc-sdx-icon::before,.icon-parking.sc-sdx-icon::before{content:\"\\e1b8\"}/*!@.icon-441-pbx::before,\n.icon-pbx::before*/.icon-441-pbx.sc-sdx-icon::before,.icon-pbx.sc-sdx-icon::before{content:\"\\e1b9\"}/*!@.icon-442-personal-cloud::before,\n.icon-personal-cloud::before*/.icon-442-personal-cloud.sc-sdx-icon::before,.icon-personal-cloud.sc-sdx-icon::before{content:\"\\e1ba\"}/*!@.icon-443-pet-bottle::before,\n.icon-pet-bottle::before*/.icon-443-pet-bottle.sc-sdx-icon::before,.icon-pet-bottle.sc-sdx-icon::before{content:\"\\e1bb\"}/*!@.icon-444-pharmacy::before,\n.icon-pharmacy::before*/.icon-444-pharmacy.sc-sdx-icon::before,.icon-pharmacy.sc-sdx-icon::before{content:\"\\e1bc\"}/*!@.icon-445-phone-security::before,\n.icon-phone-security::before*/.icon-445-phone-security.sc-sdx-icon::before,.icon-phone-security.sc-sdx-icon::before{content:\"\\e1bd\"}/*!@.icon-446-phonecordless::before,\n.icon-phonecordless::before*/.icon-446-phonecordless.sc-sdx-icon::before,.icon-phonecordless.sc-sdx-icon::before{content:\"\\e1be\"}/*!@.icon-447-piggy-bank::before,\n.icon-piggy-bank::before*/.icon-447-piggy-bank.sc-sdx-icon::before,.icon-piggy-bank.sc-sdx-icon::before{content:\"\\e1bf\"}/*!@.icon-448-podium::before,\n.icon-podium::before*/.icon-448-podium.sc-sdx-icon::before,.icon-podium.sc-sdx-icon::before{content:\"\\e1c0\"}/*!@.icon-449-police::before,\n.icon-police::before*/.icon-449-police.sc-sdx-icon::before,.icon-police.sc-sdx-icon::before{content:\"\\e1c1\"}/*!@.icon-450-power::before,\n.icon-power::before*/.icon-450-power.sc-sdx-icon::before,.icon-power.sc-sdx-icon::before{content:\"\\e1c2\"}/*!@.icon-451-prepaid-mobile::before,\n.icon-prepaid-mobile::before*/.icon-451-prepaid-mobile.sc-sdx-icon::before,.icon-prepaid-mobile.sc-sdx-icon::before{content:\"\\e1c3\"}/*!@.icon-452-presentation::before,\n.icon-presentation::before*/.icon-452-presentation.sc-sdx-icon::before,.icon-presentation.sc-sdx-icon::before{content:\"\\e1c4\"}/*!@.icon-453-ray::before,\n.icon-ray::before*/.icon-453-ray.sc-sdx-icon::before,.icon-ray.sc-sdx-icon::before{content:\"\\e1c5\"}/*!@.icon-454-relax::before,\n.icon-relax::before*/.icon-454-relax.sc-sdx-icon::before,.icon-relax.sc-sdx-icon::before{content:\"\\e1c6\"}/*!@.icon-455-remote-control::before,\n.icon-remote-control::before*/.icon-455-remote-control.sc-sdx-icon::before,.icon-remote-control.sc-sdx-icon::before{content:\"\\e1c7\"}/*!@.icon-456-restaurant::before,\n.icon-restaurant::before*/.icon-456-restaurant.sc-sdx-icon::before,.icon-restaurant.sc-sdx-icon::before{content:\"\\e1c8\"}/*!@.icon-457-robot-wink-2::before,\n.icon-robot-wink-2::before*/.icon-457-robot-wink-2.sc-sdx-icon::before,.icon-robot-wink-2.sc-sdx-icon::before{content:\"\\e1c9\"}/*!@.icon-458-runner::before,\n.icon-runner::before*/.icon-458-runner.sc-sdx-icon::before,.icon-runner.sc-sdx-icon::before{content:\"\\e1ca\"}/*!@.icon-459-safety::before,\n.icon-safety::before*/.icon-459-safety.sc-sdx-icon::before,.icon-safety.sc-sdx-icon::before{content:\"\\e1cb\"}/*!@.icon-460-sailer::before,\n.icon-sailer::before*/.icon-460-sailer.sc-sdx-icon::before,.icon-sailer.sc-sdx-icon::before{content:\"\\e1cc\"}/*!@.icon-461-satellitedish::before,\n.icon-satellitedish::before*/.icon-461-satellitedish.sc-sdx-icon::before,.icon-satellitedish.sc-sdx-icon::before{content:\"\\e1cd\"}/*!@.icon-462-satellite::before,\n.icon-satellite::before*/.icon-462-satellite.sc-sdx-icon::before,.icon-satellite.sc-sdx-icon::before{content:\"\\e1ce\"}/*!@.icon-463-scale::before,\n.icon-scale::before*/.icon-463-scale.sc-sdx-icon::before,.icon-scale.sc-sdx-icon::before{content:\"\\e1cf\"}/*!@.icon-464-screen-design::before,\n.icon-screen-design::before*/.icon-464-screen-design.sc-sdx-icon::before,.icon-screen-design.sc-sdx-icon::before{content:\"\\e1d0\"}/*!@.icon-465-searchtext::before,\n.icon-searchtext::before*/.icon-465-searchtext.sc-sdx-icon::before,.icon-searchtext.sc-sdx-icon::before{content:\"\\e1d1\"}/*!@.icon-466-securitycamera::before,\n.icon-securitycamera::before*/.icon-466-securitycamera.sc-sdx-icon::before,.icon-securitycamera.sc-sdx-icon::before{content:\"\\e1d2\"}/*!@.icon-467-selfcheckout::before,\n.icon-selfcheckout::before*/.icon-467-selfcheckout.sc-sdx-icon::before,.icon-selfcheckout.sc-sdx-icon::before{content:\"\\e1d3\"}/*!@.icon-468-server-small::before,\n.icon-server-small::before*/.icon-468-server-small.sc-sdx-icon::before,.icon-server-small.sc-sdx-icon::before{content:\"\\e1d4\"}/*!@.icon-469-shakehands::before,\n.icon-shakehands::before*/.icon-469-shakehands.sc-sdx-icon::before,.icon-shakehands.sc-sdx-icon::before{content:\"\\e1d5\"}/*!@.icon-470-shower::before,\n.icon-shower::before*/.icon-470-shower.sc-sdx-icon::before,.icon-shower.sc-sdx-icon::before{content:\"\\e1d6\"}/*!@.icon-471-silence::before,\n.icon-silence::before*/.icon-471-silence.sc-sdx-icon::before,.icon-silence.sc-sdx-icon::before{content:\"\\e1d7\"}/*!@.icon-472-simkarte::before,\n.icon-simkarte::before*/.icon-472-simkarte.sc-sdx-icon::before,.icon-simkarte.sc-sdx-icon::before{content:\"\\e1d8\"}/*!@.icon-473-ski-biathlon::before,\n.icon-ski-biathlon::before*/.icon-473-ski-biathlon.sc-sdx-icon::before,.icon-ski-biathlon.sc-sdx-icon::before{content:\"\\e1d9\"}/*!@.icon-474-ski-cross-country::before,\n.icon-ski-cross-country::before*/.icon-474-ski-cross-country.sc-sdx-icon::before,.icon-ski-cross-country.sc-sdx-icon::before{content:\"\\e1da\"}/*!@.icon-475-ski-freestyle::before,\n.icon-ski-freestyle::before*/.icon-475-ski-freestyle.sc-sdx-icon::before,.icon-ski-freestyle.sc-sdx-icon::before{content:\"\\e1db\"}/*!@.icon-476-ski-jumping::before,\n.icon-ski-jumping::before*/.icon-476-ski-jumping.sc-sdx-icon::before,.icon-ski-jumping.sc-sdx-icon::before{content:\"\\e1dc\"}/*!@.icon-477-ski-racer::before,\n.icon-ski-racer::before*/.icon-477-ski-racer.sc-sdx-icon::before,.icon-ski-racer.sc-sdx-icon::before{content:\"\\e1dd\"}/*!@.icon-478-ski-telemarking::before,\n.icon-ski-telemarking::before*/.icon-478-ski-telemarking.sc-sdx-icon::before,.icon-ski-telemarking.sc-sdx-icon::before{content:\"\\e1de\"}/*!@.icon-479-ski::before,\n.icon-ski::before*/.icon-479-ski.sc-sdx-icon::before,.icon-ski.sc-sdx-icon::before{content:\"\\e1df\"}/*!@.icon-480-small-meeting::before,\n.icon-small-meeting::before*/.icon-480-small-meeting.sc-sdx-icon::before,.icon-small-meeting.sc-sdx-icon::before{content:\"\\e1e0\"}/*!@.icon-481-smoking::before,\n.icon-smoking::before*/.icon-481-smoking.sc-sdx-icon::before,.icon-smoking.sc-sdx-icon::before{content:\"\\e1e1\"}/*!@.icon-482-snail::before,\n.icon-snail::before*/.icon-482-snail.sc-sdx-icon::before,.icon-snail.sc-sdx-icon::before{content:\"\\e1e2\"}/*!@.icon-483-snow::before,\n.icon-snow::before*/.icon-483-snow.sc-sdx-icon::before,.icon-snow.sc-sdx-icon::before{content:\"\\e1e3\"}/*!@.icon-484-snowboard::before,\n.icon-snowboard::before*/.icon-484-snowboard.sc-sdx-icon::before,.icon-snowboard.sc-sdx-icon::before{content:\"\\e1e4\"}/*!@.icon-485-socialnetwork::before,\n.icon-socialnetwork::before*/.icon-485-socialnetwork.sc-sdx-icon::before,.icon-socialnetwork.sc-sdx-icon::before{content:\"\\e1e5\"}/*!@.icon-486-sos::before,\n.icon-sos::before*/.icon-486-sos.sc-sdx-icon::before,.icon-sos.sc-sdx-icon::before{content:\"\\e1e6\"}/*!@.icon-487-spam::before,\n.icon-spam::before*/.icon-487-spam.sc-sdx-icon::before,.icon-spam.sc-sdx-icon::before{content:\"\\e1e7\"}/*!@.icon-488-spot::before,\n.icon-spot::before*/.icon-488-spot.sc-sdx-icon::before,.icon-spot.sc-sdx-icon::before{content:\"\\e1e8\"}/*!@.icon-489-squid::before,\n.icon-squid::before*/.icon-489-squid.sc-sdx-icon::before,.icon-squid.sc-sdx-icon::before{content:\"\\e1e9\"}/*!@.icon-490-stairs::before,\n.icon-stairs::before*/.icon-490-stairs.sc-sdx-icon::before,.icon-stairs.sc-sdx-icon::before{content:\"\\e1ea\"}/*!@.icon-491-standing-meeting::before,\n.icon-standing-meeting::before*/.icon-491-standing-meeting.sc-sdx-icon::before,.icon-standing-meeting.sc-sdx-icon::before{content:\"\\e1eb\"}/*!@.icon-492-station::before,\n.icon-station::before*/.icon-492-station.sc-sdx-icon::before,.icon-station.sc-sdx-icon::before{content:\"\\e1ec\"}/*!@.icon-493-steeringwheel::before,\n.icon-steeringwheel::before*/.icon-493-steeringwheel.sc-sdx-icon::before,.icon-steeringwheel.sc-sdx-icon::before{content:\"\\e1ed\"}/*!@.icon-494-strong-arm::before,\n.icon-strong-arm::before*/.icon-494-strong-arm.sc-sdx-icon::before,.icon-strong-arm.sc-sdx-icon::before{content:\"\\e1ee\"}/*!@.icon-495-svod-2::before,\n.icon-svod-2::before*/.icon-495-svod-2.sc-sdx-icon::before,.icon-svod-2.sc-sdx-icon::before{content:\"\\e1ef\"}/*!@.icon-496-swiss-1::before,\n.icon-swiss-1::before*/.icon-496-swiss-1.sc-sdx-icon::before,.icon-swiss-1.sc-sdx-icon::before{content:\"\\e1f0\"}/*!@.icon-497-swiss-2::before,\n.icon-swiss-2::before*/.icon-497-swiss-2.sc-sdx-icon::before,.icon-swiss-2.sc-sdx-icon::before{content:\"\\e1f1\"}/*!@.icon-498-switchboarding::before,\n.icon-switchboarding::before*/.icon-498-switchboarding.sc-sdx-icon::before,.icon-switchboarding.sc-sdx-icon::before{content:\"\\e1f2\"}/*!@.icon-499-switchoff::before,\n.icon-switchoff::before*/.icon-499-switchoff.sc-sdx-icon::before,.icon-switchoff.sc-sdx-icon::before{content:\"\\e1f3\"}/*!@.icon-500-taxcard::before,\n.icon-taxcard::before*/.icon-500-taxcard.sc-sdx-icon::before,.icon-taxcard.sc-sdx-icon::before{content:\"\\e1f4\"}/*!@.icon-501-taxcardin::before,\n.icon-taxcardin::before*/.icon-501-taxcardin.sc-sdx-icon::before,.icon-taxcardin.sc-sdx-icon::before{content:\"\\e1f5\"}/*!@.icon-502-taxcardout::before,\n.icon-taxcardout::before*/.icon-502-taxcardout.sc-sdx-icon::before,.icon-taxcardout.sc-sdx-icon::before{content:\"\\e1f6\"}/*!@.icon-503-teddybear::before,\n.icon-teddybear::before*/.icon-503-teddybear.sc-sdx-icon::before,.icon-teddybear.sc-sdx-icon::before{content:\"\\e1f7\"}/*!@.icon-504-telecommunication::before,\n.icon-telecommunication::before*/.icon-504-telecommunication.sc-sdx-icon::before,.icon-telecommunication.sc-sdx-icon::before{content:\"\\e1f8\"}/*!@.icon-505-tent::before,\n.icon-tent::before*/.icon-505-tent.sc-sdx-icon::before,.icon-tent.sc-sdx-icon::before{content:\"\\e1f9\"}/*!@.icon-506-thermometer::before,\n.icon-thermometer::before*/.icon-506-thermometer.sc-sdx-icon::before,.icon-thermometer.sc-sdx-icon::before{content:\"\\e1fa\"}/*!@.icon-507-toilet-f::before,\n.icon-toilet-f::before*/.icon-507-toilet-f.sc-sdx-icon::before,.icon-toilet-f.sc-sdx-icon::before{content:\"\\e1fb\"}/*!@.icon-508-toilet-m::before,\n.icon-toilet-m::before*/.icon-508-toilet-m.sc-sdx-icon::before,.icon-toilet-m.sc-sdx-icon::before{content:\"\\e1fc\"}/*!@.icon-509-toilet-s::before,\n.icon-toilet-s::before*/.icon-509-toilet-s.sc-sdx-icon::before,.icon-toilet-s.sc-sdx-icon::before{content:\"\\e1fd\"}/*!@.icon-510-touchdown::before,\n.icon-touchdown::before*/.icon-510-touchdown.sc-sdx-icon::before,.icon-touchdown.sc-sdx-icon::before{content:\"\\e1fe\"}/*!@.icon-511-trafficinfo::before,\n.icon-trafficinfo::before*/.icon-511-trafficinfo.sc-sdx-icon::before,.icon-trafficinfo.sc-sdx-icon::before{content:\"\\e1ff\"}/*!@.icon-512-trailrunner::before,\n.icon-trailrunner::before*/.icon-512-trailrunner.sc-sdx-icon::before,.icon-trailrunner.sc-sdx-icon::before{content:\"\\e200\"}/*!@.icon-513-train::before,\n.icon-train::before*/.icon-513-train.sc-sdx-icon::before,.icon-train.sc-sdx-icon::before{content:\"\\e201\"}/*!@.icon-514-tv-guide::before,\n.icon-tv-guide::before*/.icon-514-tv-guide.sc-sdx-icon::before,.icon-tv-guide.sc-sdx-icon::before{content:\"\\e202\"}/*!@.icon-515-uhd-tv::before,\n.icon-uhd-tv::before*/.icon-515-uhd-tv.sc-sdx-icon::before,.icon-uhd-tv.sc-sdx-icon::before{content:\"\\e203\"}/*!@.icon-516-usb::before,\n.icon-usb::before*/.icon-516-usb.sc-sdx-icon::before,.icon-usb.sc-sdx-icon::before{content:\"\\e204\"}/*!@.icon-517-user-presence::before,\n.icon-user-presence::before*/.icon-517-user-presence.sc-sdx-icon::before,.icon-user-presence.sc-sdx-icon::before{content:\"\\e205\"}/*!@.icon-518-van-fire-2::before,\n.icon-van-fire-2::before*/.icon-518-van-fire-2.sc-sdx-icon::before,.icon-van-fire-2.sc-sdx-icon::before{content:\"\\e206\"}/*!@.icon-519-van-fire::before,\n.icon-van-fire::before*/.icon-519-van-fire.sc-sdx-icon::before,.icon-van-fire.sc-sdx-icon::before{content:\"\\e207\"}/*!@.icon-520-ventilator::before,\n.icon-ventilator::before*/.icon-520-ventilator.sc-sdx-icon::before,.icon-ventilator.sc-sdx-icon::before{content:\"\\e208\"}/*!@.icon-521-video-call-laptop::before,\n.icon-video-call-laptop::before*/.icon-521-video-call-laptop.sc-sdx-icon::before,.icon-video-call-laptop.sc-sdx-icon::before{content:\"\\e209\"}/*!@.icon-522-video-call-mobile::before,\n.icon-video-call-mobile::before*/.icon-522-video-call-mobile.sc-sdx-icon::before,.icon-video-call-mobile.sc-sdx-icon::before{content:\"\\e20a\"}/*!@.icon-523-virus::before,\n.icon-virus::before*/.icon-523-virus.sc-sdx-icon::before,.icon-virus.sc-sdx-icon::before{content:\"\\e20b\"}/*!@.icon-524-waitingroom::before,\n.icon-waitingroom::before*/.icon-524-waitingroom.sc-sdx-icon::before,.icon-waitingroom.sc-sdx-icon::before{content:\"\\e20c\"}/*!@.icon-525-wearable-glasses::before,\n.icon-wearable-glasses::before*/.icon-525-wearable-glasses.sc-sdx-icon::before,.icon-wearable-glasses.sc-sdx-icon::before{content:\"\\e20d\"}/*!@.icon-526-webcam::before,\n.icon-webcam::before*/.icon-526-webcam.sc-sdx-icon::before,.icon-webcam.sc-sdx-icon::before{content:\"\\e20e\"}/*!@.icon-527-wheelchair::before,\n.icon-wheelchair::before*/.icon-527-wheelchair.sc-sdx-icon::before,.icon-wheelchair.sc-sdx-icon::before{content:\"\\e20f\"}/*!@.icon-528-wireless-charging::before,\n.icon-wireless-charging::before*/.icon-528-wireless-charging.sc-sdx-icon::before,.icon-wireless-charging.sc-sdx-icon::before{content:\"\\e210\"}/*!@.icon-529-qr-code::before,\n.icon-qr-code::before*/.icon-529-qr-code.sc-sdx-icon::before,.icon-qr-code.sc-sdx-icon::before{content:\"\\e211\"}/*!@.icon-530-anticrime::before,\n.icon-anticrime::before*/.icon-530-anticrime.sc-sdx-icon::before,.icon-anticrime.sc-sdx-icon::before{content:\"\\e212\"}/*!@.icon-531-drag-and-drop_filled::before,\n.icon-drag-and-drop_filled::before*/.icon-531-drag-and-drop_filled.sc-sdx-icon::before,.icon-drag-and-drop_filled.sc-sdx-icon::before{content:\"\\e213\"}/*!@.icon-532-cursor-arrow::before,\n.icon-cursor-arrow::before*/.icon-532-cursor-arrow.sc-sdx-icon::before,.icon-cursor-arrow.sc-sdx-icon::before{content:\"\\e214\"}/*!@.icon-533-cursor-arrow-click::before,\n.icon-cursor-arrow-click::before*/.icon-533-cursor-arrow-click.sc-sdx-icon::before,.icon-cursor-arrow-click.sc-sdx-icon::before{content:\"\\e215\"}/*!@.icon-534-cursor-arrow-focus::before,\n.icon-cursor-arrow-focus::before*/.icon-534-cursor-arrow-focus.sc-sdx-icon::before,.icon-cursor-arrow-focus.sc-sdx-icon::before{content:\"\\e216\"}/*!@.icon-535-cursor-hand-click::before,\n.icon-cursor-hand-click::before*/.icon-535-cursor-hand-click.sc-sdx-icon::before,.icon-cursor-hand-click.sc-sdx-icon::before{content:\"\\e217\"}/*!@.icon-536-cursor-hand-focus::before,\n.icon-cursor-hand-focus::before*/.icon-536-cursor-hand-focus.sc-sdx-icon::before,.icon-cursor-hand-focus.sc-sdx-icon::before{content:\"\\e218\"}/*!@.icon-537-lock-open::before,\n.icon-lock-open::before*/.icon-537-lock-open.sc-sdx-icon::before,.icon-lock-open.sc-sdx-icon::before{content:\"\\e219\"}/*!@.icon-538-coupon::before,\n.icon-coupon::before*/.icon-538-coupon.sc-sdx-icon::before,.icon-coupon.sc-sdx-icon::before{content:\"\\e21a\"}/*!@.icon-539-clover::before,\n.icon-clover::before*/.icon-539-clover.sc-sdx-icon::before,.icon-clover.sc-sdx-icon::before{content:\"\\e21b\"}/*!@.icon-540-ticket::before,\n.icon-ticket::before*/.icon-540-ticket.sc-sdx-icon::before,.icon-ticket.sc-sdx-icon::before{content:\"\\e21c\"}/*!@.icon-541-facebook::before,\n.icon-facebook::before*/.icon-541-facebook.sc-sdx-icon::before,.icon-facebook.sc-sdx-icon::before{content:\"\\e21d\"}/*!@.icon-542-instagram::before,\n.icon-instagram::before*/.icon-542-instagram.sc-sdx-icon::before,.icon-instagram.sc-sdx-icon::before{content:\"\\e21e\"}/*!@.icon-543-linkedin::before,\n.icon-linkedin::before*/.icon-543-linkedin.sc-sdx-icon::before,.icon-linkedin.sc-sdx-icon::before{content:\"\\e21f\"}/*!@.icon-544-tiktok::before,\n.icon-tiktok::before*/.icon-544-tiktok.sc-sdx-icon::before,.icon-tiktok.sc-sdx-icon::before{content:\"\\e220\"}/*!@.icon-545-twitter::before,\n.icon-twitter::before*/.icon-545-twitter.sc-sdx-icon::before,.icon-twitter.sc-sdx-icon::before{content:\"\\e221\"}/*!@.icon-546-xing::before,\n.icon-xing::before*/.icon-546-xing.sc-sdx-icon::before,.icon-xing.sc-sdx-icon::before{content:\"\\e222\"}/*!@.icon-547-youtube::before,\n.icon-youtube::before*/.icon-547-youtube.sc-sdx-icon::before,.icon-youtube.sc-sdx-icon::before{content:\"\\e223\"}/*!@.icon-548-drop::before,\n.icon-drop::before*/.icon-548-drop.sc-sdx-icon::before,.icon-drop.sc-sdx-icon::before{content:\"\\e224\"}/*!@.icon-549-ear::before,\n.icon-ear::before*/.icon-549-ear.sc-sdx-icon::before,.icon-ear.sc-sdx-icon::before{content:\"\\e225\"}/*!@.icon-550-abc::before,\n.icon-abc::before*/.icon-550-abc.sc-sdx-icon::before,.icon-abc.sc-sdx-icon::before{content:\"\\e226\"}/*!@.icon-551-alarm::before,\n.icon-alarm::before*/.icon-551-alarm.sc-sdx-icon::before,.icon-alarm.sc-sdx-icon::before{content:\"\\e227\"}/*!@.icon-552-api::before,\n.icon-api::before*/.icon-552-api.sc-sdx-icon::before,.icon-api.sc-sdx-icon::before{content:\"\\e228\"}/*!@.icon-553-bisexual::before,\n.icon-bisexual::before*/.icon-553-bisexual.sc-sdx-icon::before,.icon-bisexual.sc-sdx-icon::before{content:\"\\e229\"}/*!@.icon-554-bowling::before,\n.icon-bowling::before*/.icon-554-bowling.sc-sdx-icon::before,.icon-bowling.sc-sdx-icon::before{content:\"\\e22a\"}/*!@.icon-555-cake::before,\n.icon-cake::before*/.icon-555-cake.sc-sdx-icon::before,.icon-cake.sc-sdx-icon::before{content:\"\\e22b\"}/*!@.icon-556-cardiogram::before,\n.icon-cardiogram::before*/.icon-556-cardiogram.sc-sdx-icon::before,.icon-cardiogram.sc-sdx-icon::before{content:\"\\e22c\"}/*!@.icon-557-cells::before,\n.icon-cells::before*/.icon-557-cells.sc-sdx-icon::before,.icon-cells.sc-sdx-icon::before{content:\"\\e22d\"}/*!@.icon-558-chain-break::before,\n.icon-chain-break::before*/.icon-558-chain-break.sc-sdx-icon::before,.icon-chain-break.sc-sdx-icon::before{content:\"\\e22e\"}/*!@.icon-559-cinema-seat::before,\n.icon-cinema-seat::before*/.icon-559-cinema-seat.sc-sdx-icon::before,.icon-cinema-seat.sc-sdx-icon::before{content:\"\\e22f\"}/*!@.icon-560-cloud-connectivity::before,\n.icon-cloud-connectivity::before*/.icon-560-cloud-connectivity.sc-sdx-icon::before,.icon-cloud-connectivity.sc-sdx-icon::before{content:\"\\e230\"}/*!@.icon-561-cristal::before,\n.icon-cristal::before*/.icon-561-cristal.sc-sdx-icon::before,.icon-cristal.sc-sdx-icon::before{content:\"\\e231\"}/*!@.icon-562-cross-2::before,\n.icon-cross-2::before*/.icon-562-cross-2.sc-sdx-icon::before,.icon-cross-2.sc-sdx-icon::before{content:\"\\e232\"}/*!@.icon-563-crutches::before,\n.icon-crutches::before*/.icon-563-crutches.sc-sdx-icon::before,.icon-crutches.sc-sdx-icon::before{content:\"\\e233\"}/*!@.icon-564-dna::before,\n.icon-dna::before*/.icon-564-dna.sc-sdx-icon::before,.icon-dna.sc-sdx-icon::before{content:\"\\e234\"}/*!@.icon-565-doctors-office::before,\n.icon-doctors-office::before*/.icon-565-doctors-office.sc-sdx-icon::before,.icon-doctors-office.sc-sdx-icon::before{content:\"\\e235\"}/*!@.icon-566-drag-and-drop::before,\n.icon-drag-and-drop::before*/.icon-566-drag-and-drop.sc-sdx-icon::before,.icon-drag-and-drop.sc-sdx-icon::before{content:\"\\e236\"}/*!@.icon-567-erasor::before,\n.icon-erasor::before*/.icon-567-erasor.sc-sdx-icon::before,.icon-erasor.sc-sdx-icon::before{content:\"\\e237\"}/*!@.icon-568-feminin::before,\n.icon-feminin::before*/.icon-568-feminin.sc-sdx-icon::before,.icon-feminin.sc-sdx-icon::before{content:\"\\e238\"}/*!@.icon-569-flask::before,\n.icon-flask::before*/.icon-569-flask.sc-sdx-icon::before,.icon-flask.sc-sdx-icon::before{content:\"\\e239\"}/*!@.icon-570-hand-sanitiser-V2::before,\n.icon-hand-sanitiser-V2::before*/.icon-570-hand-sanitiser-V2.sc-sdx-icon::before,.icon-hand-sanitiser-V2.sc-sdx-icon::before{content:\"\\e23a\"}/*!@.icon-571-healthy-food::before,\n.icon-healthy-food::before*/.icon-571-healthy-food.sc-sdx-icon::before,.icon-healthy-food.sc-sdx-icon::before{content:\"\\e23b\"}/*!@.icon-572-info-speech-bubble::before,\n.icon-info-speech-bubble::before*/.icon-572-info-speech-bubble.sc-sdx-icon::before,.icon-info-speech-bubble.sc-sdx-icon::before{content:\"\\e23c\"}/*!@.icon-573-it-management::before,\n.icon-it-management::before*/.icon-573-it-management.sc-sdx-icon::before,.icon-it-management.sc-sdx-icon::before{content:\"\\e23d\"}/*!@.icon-574-labor::before,\n.icon-labor::before*/.icon-574-labor.sc-sdx-icon::before,.icon-labor.sc-sdx-icon::before{content:\"\\e23e\"}/*!@.icon-575-lungs::before,\n.icon-lungs::before*/.icon-575-lungs.sc-sdx-icon::before,.icon-lungs.sc-sdx-icon::before{content:\"\\e23f\"}/*!@.icon-576-measure::before,\n.icon-measure::before*/.icon-576-measure.sc-sdx-icon::before,.icon-measure.sc-sdx-icon::before{content:\"\\e240\"}/*!@.icon-577-medicine::before,\n.icon-medicine::before*/.icon-577-medicine.sc-sdx-icon::before,.icon-medicine.sc-sdx-icon::before{content:\"\\e241\"}/*!@.icon-578-medicine-book::before,\n.icon-medicine-book::before*/.icon-578-medicine-book.sc-sdx-icon::before,.icon-medicine-book.sc-sdx-icon::before{content:\"\\e242\"}/*!@.icon-579-microscope::before,\n.icon-microscope::before*/.icon-579-microscope.sc-sdx-icon::before,.icon-microscope.sc-sdx-icon::before{content:\"\\e243\"}/*!@.icon-580-mobile-connectivity::before,\n.icon-mobile-connectivity::before*/.icon-580-mobile-connectivity.sc-sdx-icon::before,.icon-mobile-connectivity.sc-sdx-icon::before{content:\"\\e244\"}/*!@.icon-581-oxygen-tank::before,\n.icon-oxygen-tank::before*/.icon-581-oxygen-tank.sc-sdx-icon::before,.icon-oxygen-tank.sc-sdx-icon::before{content:\"\\e245\"}/*!@.icon-582-photo-landscape::before,\n.icon-photo-landscape::before*/.icon-582-photo-landscape.sc-sdx-icon::before,.icon-photo-landscape.sc-sdx-icon::before{content:\"\\e246\"}/*!@.icon-583-plug-in::before,\n.icon-plug-in::before*/.icon-583-plug-in.sc-sdx-icon::before,.icon-plug-in.sc-sdx-icon::before{content:\"\\e247\"}/*!@.icon-584-popcorn::before,\n.icon-popcorn::before*/.icon-584-popcorn.sc-sdx-icon::before,.icon-popcorn.sc-sdx-icon::before{content:\"\\e248\"}/*!@.icon-585-puls::before,\n.icon-puls::before*/.icon-585-puls.sc-sdx-icon::before,.icon-puls.sc-sdx-icon::before{content:\"\\e249\"}/*!@.icon-586-rabbit::before,\n.icon-rabbit::before*/.icon-586-rabbit.sc-sdx-icon::before,.icon-rabbit.sc-sdx-icon::before{content:\"\\e24a\"}/*!@.icon-587-radiology::before,\n.icon-radiology::before*/.icon-587-radiology.sc-sdx-icon::before,.icon-radiology.sc-sdx-icon::before{content:\"\\e24b\"}/*!@.icon-588-slider::before,\n.icon-slider::before*/.icon-588-slider.sc-sdx-icon::before,.icon-slider.sc-sdx-icon::before{content:\"\\e24c\"}/*!@.icon-589-syringe::before,\n.icon-syringe::before*/.icon-589-syringe.sc-sdx-icon::before,.icon-syringe.sc-sdx-icon::before{content:\"\\e24d\"}/*!@.icon-590-thermometer-2::before,\n.icon-thermometer-2::before*/.icon-590-thermometer-2.sc-sdx-icon::before,.icon-thermometer-2.sc-sdx-icon::before{content:\"\\e24e\"}/*!@.icon-591-tooth::before,\n.icon-tooth::before*/.icon-591-tooth.sc-sdx-icon::before,.icon-tooth.sc-sdx-icon::before{content:\"\\e24f\"}/*!@.icon-592-transfusion::before,\n.icon-transfusion::before*/.icon-592-transfusion.sc-sdx-icon::before,.icon-transfusion.sc-sdx-icon::before{content:\"\\e250\"}/*!@.icon-593-triangle::before,\n.icon-triangle::before*/.icon-593-triangle.sc-sdx-icon::before,.icon-triangle.sc-sdx-icon::before{content:\"\\e251\"}/*!@.icon-594-triangle-filled::before,\n.icon-triangle-filled::before*/.icon-594-triangle-filled.sc-sdx-icon::before,.icon-triangle-filled.sc-sdx-icon::before{content:\"\\e252\"}/*!@.icon-595-weight::before,\n.icon-weight::before*/.icon-595-weight.sc-sdx-icon::before,.icon-weight.sc-sdx-icon::before{content:\"\\e253\"}/*!@.icon-596-remote::before,\n.icon-remote::before*/.icon-596-remote.sc-sdx-icon::before,.icon-remote.sc-sdx-icon::before{content:\"\\e254\"}/*!@.icon-597-send::before,\n.icon-send::before*/.icon-597-send.sc-sdx-icon::before,.icon-send.sc-sdx-icon::before{content:\"\\e255\"}/*!@.icon-598-brain::before,\n.icon-brain::before*/.icon-598-brain.sc-sdx-icon::before,.icon-brain.sc-sdx-icon::before{content:\"\\e256\"}/*!@.icon-599-products::before,\n.icon-products::before*/.icon-599-products.sc-sdx-icon::before,.icon-products.sc-sdx-icon::before{content:\"\\e257\"}/*!@.icon-600-applications-2::before,\n.icon-applications-2::before*/.icon-600-applications-2.sc-sdx-icon::before,.icon-applications-2.sc-sdx-icon::before{content:\"\\e258\"}/*!@.icon-601-digital-signature::before,\n.icon-digital-signature::before*/.icon-601-digital-signature.sc-sdx-icon::before,.icon-digital-signature.sc-sdx-icon::before{content:\"\\e259\"}/*!@.icon-602-smiley::before,\n.icon-smiley::before*/.icon-602-smiley.sc-sdx-icon::before,.icon-smiley.sc-sdx-icon::before{content:\"\\e25a\"}/*!@.icon-603-discord::before,\n.icon-discord::before*/.icon-603-discord.sc-sdx-icon::before,.icon-discord.sc-sdx-icon::before{content:\"\\e25b\"}/*!@.icon-604-twitch::before,\n.icon-twitch::before*/.icon-604-twitch.sc-sdx-icon::before,.icon-twitch.sc-sdx-icon::before{content:\"\\e25c\"}/*!@.icon-605-add-user::before,\n.icon-add-user::before*/.icon-605-add-user.sc-sdx-icon::before,.icon-add-user.sc-sdx-icon::before{content:\"\\f101\"}/*!@.icon-606-biocycle::before,\n.icon-biocycle::before*/.icon-606-biocycle.sc-sdx-icon::before,.icon-biocycle.sc-sdx-icon::before{content:\"\\f102\"}/*!@.icon-607-carbonfootprint::before,\n.icon-carbonfootprint::before*/.icon-607-carbonfootprint.sc-sdx-icon::before,.icon-carbonfootprint.sc-sdx-icon::before{content:\"\\f103\"}/*!@.icon-608-ecofriendly::before,\n.icon-ecofriendly::before*/.icon-608-ecofriendly.sc-sdx-icon::before,.icon-ecofriendly.sc-sdx-icon::before{content:\"\\f104\"}/*!@.icon-609-noplastic::before,\n.icon-noplastic::before*/.icon-609-noplastic.sc-sdx-icon::before,.icon-noplastic.sc-sdx-icon::before{content:\"\\f105\"}/*!@.icon-610-whale::before,\n.icon-whale::before*/.icon-610-whale.sc-sdx-icon::before,.icon-whale.sc-sdx-icon::before{content:\"\\f106\"}/*!@.icon-611-ad::before,\n.icon-ad::before*/.icon-611-ad.sc-sdx-icon::before,.icon-ad.sc-sdx-icon::before{content:\"\\f107\"}/*!@.icon-612-merge-arrow::before,\n.icon-merge-arrow::before*/.icon-612-merge-arrow.sc-sdx-icon::before,.icon-merge-arrow.sc-sdx-icon::before{content:\"\\f108\"}/*!@.icon-613-wlan-1::before,\n.icon-wlan-1::before*/.icon-613-wlan-1.sc-sdx-icon::before,.icon-wlan-1.sc-sdx-icon::before{content:\"\\f109\"}/*!@.icon-614-wlan-2::before,\n.icon-wlan-2::before*/.icon-614-wlan-2.sc-sdx-icon::before,.icon-wlan-2.sc-sdx-icon::before{content:\"\\f10a\"}/*!@.icon-615-wlan-3::before,\n.icon-wlan-3::before*/.icon-615-wlan-3.sc-sdx-icon::before,.icon-wlan-3.sc-sdx-icon::before{content:\"\\f10b\"}/*!@.icon-616-office-search::before,\n.icon-office-search::before*/.icon-616-office-search.sc-sdx-icon::before,.icon-office-search.sc-sdx-icon::before{content:\"\\f10c\"}/*!@.icon-617-stopwatch::before,\n.icon-stopwatch::before*/.icon-617-stopwatch.sc-sdx-icon::before,.icon-stopwatch.sc-sdx-icon::before{content:\"\\f10d\"}/*!@.icon-618-tv-fhd::before,\n.icon-tv-fhd::before*/.icon-618-tv-fhd.sc-sdx-icon::before,.icon-tv-fhd.sc-sdx-icon::before{content:\"\\f10e\"}/*!@.icon-619-food-restaurant::before,\n.icon-food-restaurant::before*/.icon-619-food-restaurant.sc-sdx-icon::before,.icon-food-restaurant.sc-sdx-icon::before{content:\"\\f10f\"}/*!@.icon-620-walk-talk::before,\n.icon-walk-talk::before*/.icon-620-walk-talk.sc-sdx-icon::before,.icon-walk-talk.sc-sdx-icon::before{content:\"\\f110\"}/*!@.icon-621-arrows-double::before,\n.icon-arrows-double::before*/.icon-621-arrows-double.sc-sdx-icon::before,.icon-arrows-double.sc-sdx-icon::before{content:\"\\f111\"}/*!@.icon-622-college-hat::before,\n.icon-college-hat::before*/.icon-622-college-hat.sc-sdx-icon::before,.icon-college-hat.sc-sdx-icon::before{content:\"\\f112\"}/*!@.icon-623-kanban-board::before,\n.icon-kanban-board::before*/.icon-623-kanban-board.sc-sdx-icon::before,.icon-kanban-board.sc-sdx-icon::before{content:\"\\f113\"}/*!@.icon-624-power-saving-mode::before,\n.icon-power-saving-mode::before*/.icon-624-power-saving-mode.sc-sdx-icon::before,.icon-power-saving-mode.sc-sdx-icon::before{content:\"\\f114\"}/*!@.icon-625-chromecast::before,\n.icon-chromecast::before*/.icon-625-chromecast.sc-sdx-icon::before,.icon-chromecast.sc-sdx-icon::before{content:\"\\f115\"}/*!@.icon-626-homeplug::before,\n.icon-homeplug::before*/.icon-626-homeplug.sc-sdx-icon::before,.icon-homeplug.sc-sdx-icon::before{content:\"\\f116\"}/*!@.icon-627-internet-booster::before,\n.icon-internet-booster::before*/.icon-627-internet-booster.sc-sdx-icon::before,.icon-internet-booster.sc-sdx-icon::before{content:\"\\f117\"}/*!@.icon-628-radiator::before,\n.icon-radiator::before*/.icon-628-radiator.sc-sdx-icon::before,.icon-radiator.sc-sdx-icon::before{content:\"\\f118\"}/*!@.icon-629-speaker::before,\n.icon-speaker::before*/.icon-629-speaker.sc-sdx-icon::before,.icon-speaker.sc-sdx-icon::before{content:\"\\f119\"}/*!@.icon-630-washingmachine::before,\n.icon-washingmachine::before*/.icon-630-washingmachine.sc-sdx-icon::before,.icon-washingmachine.sc-sdx-icon::before{content:\"\\f11a\"}/*!@.icon-631-circle-small::before,\n.icon-circle-small::before*/.icon-631-circle-small.sc-sdx-icon::before,.icon-circle-small.sc-sdx-icon::before{content:\"\\f11b\"}/*!@:host*/.sc-sdx-icon-h{display:inline-block}/*!@:host(.size)*/.size.sc-sdx-icon-h{line-height:1}";

class Icon {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.iconName = undefined;
    this.colorClass = "";
    this.size = undefined;
    this.flip = "none";
    this.hidden = false;
    this.srHint = "";
  }
  getClassNames() {
    var _a;
    return {
      icon: true,
      [(_a = this.iconName) !== null && _a !== void 0 ? _a : ""]: true,
      [this.colorClass]: true,
      [`icon--s${this.size}`]: !!this.size,
    };
  }
  render() {
    return (hAsync(Host, { class: { size: !!this.size } }, hAsync("sdx-animation", { animationName: this.hidden ? "scale-out" : "scale-in" }, hAsync("sdx-flip", { direction: this.flip, class: getAppearance(this.el) }, hAsync("span", { class: this.getClassNames(), "aria-hidden": "true" }), this.srHint !== "" && hAsync("span", { class: "sr-only" }, this.srHint)))));
  }
  get el() { return getElement(this); }
  static get style() { return iconCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-icon",
    "$members$": {
      "iconName": [1, "icon-name"],
      "colorClass": [1, "color-class"],
      "size": [2],
      "flip": [1],
      "hidden": [4],
      "srHint": [1, "sr-hint"]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

/**
 * Checks if `value` is `null` or `undefined`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 * @example
 *
 * _.isNil(null);
 * // => true
 *
 * _.isNil(void 0);
 * // => true
 *
 * _.isNil(NaN);
 * // => false
 */
function isNil(value) {
  return value == null;
}

var HOOKS = [
    "onChange",
    "onClose",
    "onDayCreate",
    "onDestroy",
    "onKeyDown",
    "onMonthChange",
    "onOpen",
    "onParseConfig",
    "onReady",
    "onValueUpdate",
    "onYearChange",
    "onPreCalendarPosition",
];
var defaults = {
    _disable: [],
    allowInput: false,
    allowInvalidPreload: false,
    altFormat: "F j, Y",
    altInput: false,
    altInputClass: "form-control input",
    animate: typeof window === "object" &&
        window.navigator.userAgent.indexOf("MSIE") === -1,
    ariaDateFormat: "F j, Y",
    autoFillDefaultTime: true,
    clickOpens: true,
    closeOnSelect: true,
    conjunction: ", ",
    dateFormat: "Y-m-d",
    defaultHour: 12,
    defaultMinute: 0,
    defaultSeconds: 0,
    disable: [],
    disableMobile: false,
    enableSeconds: false,
    enableTime: false,
    errorHandler: function (err) {
        return typeof console !== "undefined" && console.warn(err);
    },
    getWeek: function (givenDate) {
        var date = new Date(givenDate.getTime());
        date.setHours(0, 0, 0, 0);
        date.setDate(date.getDate() + 3 - ((date.getDay() + 6) % 7));
        var week1 = new Date(date.getFullYear(), 0, 4);
        return (1 +
            Math.round(((date.getTime() - week1.getTime()) / 86400000 -
                3 +
                ((week1.getDay() + 6) % 7)) /
                7));
    },
    hourIncrement: 1,
    ignoredFocusElements: [],
    inline: false,
    locale: "default",
    minuteIncrement: 5,
    mode: "single",
    monthSelectorType: "dropdown",
    nextArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M13.207 8.472l-7.854 7.854-0.707-0.707 7.146-7.146-7.146-7.148 0.707-0.707 7.854 7.854z' /></svg>",
    noCalendar: false,
    now: new Date(),
    onChange: [],
    onClose: [],
    onDayCreate: [],
    onDestroy: [],
    onKeyDown: [],
    onMonthChange: [],
    onOpen: [],
    onParseConfig: [],
    onReady: [],
    onValueUpdate: [],
    onYearChange: [],
    onPreCalendarPosition: [],
    plugins: [],
    position: "auto",
    positionElement: undefined,
    prevArrow: "<svg version='1.1' xmlns='http://www.w3.org/2000/svg' xmlns:xlink='http://www.w3.org/1999/xlink' viewBox='0 0 17 17'><g></g><path d='M5.207 8.471l7.146 7.147-0.707 0.707-7.853-7.854 7.854-7.853 0.707 0.707-7.147 7.146z' /></svg>",
    shorthandCurrentMonth: false,
    showMonths: 1,
    static: false,
    time_24hr: false,
    weekNumbers: false,
    wrap: false,
};

var english = {
    weekdays: {
        shorthand: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        longhand: [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday",
        ],
    },
    months: {
        shorthand: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec",
        ],
        longhand: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December",
        ],
    },
    daysInMonth: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    firstDayOfWeek: 0,
    ordinal: function (nth) {
        var s = nth % 100;
        if (s > 3 && s < 21)
            return "th";
        switch (s % 10) {
            case 1:
                return "st";
            case 2:
                return "nd";
            case 3:
                return "rd";
            default:
                return "th";
        }
    },
    rangeSeparator: " to ",
    weekAbbreviation: "Wk",
    scrollTitle: "Scroll to increment",
    toggleTitle: "Click to toggle",
    amPM: ["AM", "PM"],
    yearAriaLabel: "Year",
    monthAriaLabel: "Month",
    hourAriaLabel: "Hour",
    minuteAriaLabel: "Minute",
    time_24hr: false,
};

var pad = function (number, length) {
    if (length === void 0) { length = 2; }
    return ("000" + number).slice(length * -1);
};
var int = function (bool) { return (bool === true ? 1 : 0); };
function debounce$1(fn, wait) {
    var t;
    return function () {
        var _this = this;
        var args = arguments;
        clearTimeout(t);
        t = setTimeout(function () { return fn.apply(_this, args); }, wait);
    };
}
var arrayify = function (obj) {
    return obj instanceof Array ? obj : [obj];
};

function toggleClass(elem, className, bool) {
    if (bool === true)
        return elem.classList.add(className);
    elem.classList.remove(className);
}
function createElement(tag, className, content) {
    var e = window.document.createElement(tag);
    className = className || "";
    content = content || "";
    e.className = className;
    if (content !== undefined)
        e.textContent = content;
    return e;
}
function clearNode(node) {
    while (node.firstChild)
        node.removeChild(node.firstChild);
}
function findParent(node, condition) {
    if (condition(node))
        return node;
    else if (node.parentNode)
        return findParent(node.parentNode, condition);
    return undefined;
}
function createNumberInput(inputClassName, opts) {
    var wrapper = createElement("div", "numInputWrapper"), numInput = createElement("input", "numInput " + inputClassName), arrowUp = createElement("span", "arrowUp"), arrowDown = createElement("span", "arrowDown");
    if (navigator.userAgent.indexOf("MSIE 9.0") === -1) {
        numInput.type = "number";
    }
    else {
        numInput.type = "text";
        numInput.pattern = "\\d*";
    }
    if (opts !== undefined)
        for (var key in opts)
            numInput.setAttribute(key, opts[key]);
    wrapper.appendChild(numInput);
    wrapper.appendChild(arrowUp);
    wrapper.appendChild(arrowDown);
    return wrapper;
}
function getEventTarget(event) {
    try {
        if (typeof event.composedPath === "function") {
            var path = event.composedPath();
            return path[0];
        }
        return event.target;
    }
    catch (error) {
        return event.target;
    }
}

var doNothing = function () { return undefined; };
var monthToStr = function (monthNumber, shorthand, locale) { return locale.months[shorthand ? "shorthand" : "longhand"][monthNumber]; };
var revFormat = {
    D: doNothing,
    F: function (dateObj, monthName, locale) {
        dateObj.setMonth(locale.months.longhand.indexOf(monthName));
    },
    G: function (dateObj, hour) {
        dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
    },
    H: function (dateObj, hour) {
        dateObj.setHours(parseFloat(hour));
    },
    J: function (dateObj, day) {
        dateObj.setDate(parseFloat(day));
    },
    K: function (dateObj, amPM, locale) {
        dateObj.setHours((dateObj.getHours() % 12) +
            12 * int(new RegExp(locale.amPM[1], "i").test(amPM)));
    },
    M: function (dateObj, shortMonth, locale) {
        dateObj.setMonth(locale.months.shorthand.indexOf(shortMonth));
    },
    S: function (dateObj, seconds) {
        dateObj.setSeconds(parseFloat(seconds));
    },
    U: function (_, unixSeconds) { return new Date(parseFloat(unixSeconds) * 1000); },
    W: function (dateObj, weekNum, locale) {
        var weekNumber = parseInt(weekNum);
        var date = new Date(dateObj.getFullYear(), 0, 2 + (weekNumber - 1) * 7, 0, 0, 0, 0);
        date.setDate(date.getDate() - date.getDay() + locale.firstDayOfWeek);
        return date;
    },
    Y: function (dateObj, year) {
        dateObj.setFullYear(parseFloat(year));
    },
    Z: function (_, ISODate) { return new Date(ISODate); },
    d: function (dateObj, day) {
        dateObj.setDate(parseFloat(day));
    },
    h: function (dateObj, hour) {
        dateObj.setHours((dateObj.getHours() >= 12 ? 12 : 0) + parseFloat(hour));
    },
    i: function (dateObj, minutes) {
        dateObj.setMinutes(parseFloat(minutes));
    },
    j: function (dateObj, day) {
        dateObj.setDate(parseFloat(day));
    },
    l: doNothing,
    m: function (dateObj, month) {
        dateObj.setMonth(parseFloat(month) - 1);
    },
    n: function (dateObj, month) {
        dateObj.setMonth(parseFloat(month) - 1);
    },
    s: function (dateObj, seconds) {
        dateObj.setSeconds(parseFloat(seconds));
    },
    u: function (_, unixMillSeconds) {
        return new Date(parseFloat(unixMillSeconds));
    },
    w: doNothing,
    y: function (dateObj, year) {
        dateObj.setFullYear(2000 + parseFloat(year));
    },
};
var tokenRegex = {
    D: "",
    F: "",
    G: "(\\d\\d|\\d)",
    H: "(\\d\\d|\\d)",
    J: "(\\d\\d|\\d)\\w+",
    K: "",
    M: "",
    S: "(\\d\\d|\\d)",
    U: "(.+)",
    W: "(\\d\\d|\\d)",
    Y: "(\\d{4})",
    Z: "(.+)",
    d: "(\\d\\d|\\d)",
    h: "(\\d\\d|\\d)",
    i: "(\\d\\d|\\d)",
    j: "(\\d\\d|\\d)",
    l: "",
    m: "(\\d\\d|\\d)",
    n: "(\\d\\d|\\d)",
    s: "(\\d\\d|\\d)",
    u: "(.+)",
    w: "(\\d\\d|\\d)",
    y: "(\\d{2})",
};
var formats = {
    Z: function (date) { return date.toISOString(); },
    D: function (date, locale, options) {
        return locale.weekdays.shorthand[formats.w(date, locale, options)];
    },
    F: function (date, locale, options) {
        return monthToStr(formats.n(date, locale, options) - 1, false, locale);
    },
    G: function (date, locale, options) {
        return pad(formats.h(date, locale, options));
    },
    H: function (date) { return pad(date.getHours()); },
    J: function (date, locale) {
        return locale.ordinal !== undefined
            ? date.getDate() + locale.ordinal(date.getDate())
            : date.getDate();
    },
    K: function (date, locale) { return locale.amPM[int(date.getHours() > 11)]; },
    M: function (date, locale) {
        return monthToStr(date.getMonth(), true, locale);
    },
    S: function (date) { return pad(date.getSeconds()); },
    U: function (date) { return date.getTime() / 1000; },
    W: function (date, _, options) {
        return options.getWeek(date);
    },
    Y: function (date) { return pad(date.getFullYear(), 4); },
    d: function (date) { return pad(date.getDate()); },
    h: function (date) { return (date.getHours() % 12 ? date.getHours() % 12 : 12); },
    i: function (date) { return pad(date.getMinutes()); },
    j: function (date) { return date.getDate(); },
    l: function (date, locale) {
        return locale.weekdays.longhand[date.getDay()];
    },
    m: function (date) { return pad(date.getMonth() + 1); },
    n: function (date) { return date.getMonth() + 1; },
    s: function (date) { return date.getSeconds(); },
    u: function (date) { return date.getTime(); },
    w: function (date) { return date.getDay(); },
    y: function (date) { return String(date.getFullYear()).substring(2); },
};

var createDateFormatter = function (_a) {
    var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c, _d = _a.isMobile, isMobile = _d === void 0 ? false : _d;
    return function (dateObj, frmt, overrideLocale) {
        var locale = overrideLocale || l10n;
        if (config.formatDate !== undefined && !isMobile) {
            return config.formatDate(dateObj, frmt, locale);
        }
        return frmt
            .split("")
            .map(function (c, i, arr) {
            return formats[c] && arr[i - 1] !== "\\"
                ? formats[c](dateObj, locale, config)
                : c !== "\\"
                    ? c
                    : "";
        })
            .join("");
    };
};
var createDateParser = function (_a) {
    var _b = _a.config, config = _b === void 0 ? defaults : _b, _c = _a.l10n, l10n = _c === void 0 ? english : _c;
    return function (date, givenFormat, timeless, customLocale) {
        if (date !== 0 && !date)
            return undefined;
        var locale = customLocale || l10n;
        var parsedDate;
        var dateOrig = date;
        if (date instanceof Date)
            parsedDate = new Date(date.getTime());
        else if (typeof date !== "string" &&
            date.toFixed !== undefined)
            parsedDate = new Date(date);
        else if (typeof date === "string") {
            var format = givenFormat || (config || defaults).dateFormat;
            var datestr = String(date).trim();
            if (datestr === "today") {
                parsedDate = new Date();
                timeless = true;
            }
            else if (config && config.parseDate) {
                parsedDate = config.parseDate(date, format);
            }
            else if (/Z$/.test(datestr) ||
                /GMT$/.test(datestr)) {
                parsedDate = new Date(date);
            }
            else {
                var matched = void 0, ops = [];
                for (var i = 0, matchIndex = 0, regexStr = ""; i < format.length; i++) {
                    var token = format[i];
                    var isBackSlash = token === "\\";
                    var escaped = format[i - 1] === "\\" || isBackSlash;
                    if (tokenRegex[token] && !escaped) {
                        regexStr += tokenRegex[token];
                        var match = new RegExp(regexStr).exec(date);
                        if (match && (matched = true)) {
                            ops[token !== "Y" ? "push" : "unshift"]({
                                fn: revFormat[token],
                                val: match[++matchIndex],
                            });
                        }
                    }
                    else if (!isBackSlash)
                        regexStr += ".";
                }
                parsedDate =
                    !config || !config.noCalendar
                        ? new Date(new Date().getFullYear(), 0, 1, 0, 0, 0, 0)
                        : new Date(new Date().setHours(0, 0, 0, 0));
                ops.forEach(function (_a) {
                    var fn = _a.fn, val = _a.val;
                    return (parsedDate = fn(parsedDate, val, locale) || parsedDate);
                });
                parsedDate = matched ? parsedDate : undefined;
            }
        }
        if (!(parsedDate instanceof Date && !isNaN(parsedDate.getTime()))) {
            config.errorHandler(new Error("Invalid date provided: " + dateOrig));
            return undefined;
        }
        if (timeless === true)
            parsedDate.setHours(0, 0, 0, 0);
        return parsedDate;
    };
};
function compareDates(date1, date2, timeless) {
    if (timeless === void 0) { timeless = true; }
    if (timeless !== false) {
        return (new Date(date1.getTime()).setHours(0, 0, 0, 0) -
            new Date(date2.getTime()).setHours(0, 0, 0, 0));
    }
    return date1.getTime() - date2.getTime();
}
var isBetween = function (ts, ts1, ts2) {
    return ts > Math.min(ts1, ts2) && ts < Math.max(ts1, ts2);
};
var calculateSecondsSinceMidnight = function (hours, minutes, seconds) {
    return hours * 3600 + minutes * 60 + seconds;
};
var parseSeconds = function (secondsSinceMidnight) {
    var hours = Math.floor(secondsSinceMidnight / 3600), minutes = (secondsSinceMidnight - hours * 3600) / 60;
    return [hours, minutes, secondsSinceMidnight - hours * 3600 - minutes * 60];
};
var duration = {
    DAY: 86400000,
};
function getDefaultHours(config) {
    var hours = config.defaultHour;
    var minutes = config.defaultMinute;
    var seconds = config.defaultSeconds;
    if (config.minDate !== undefined) {
        var minHour = config.minDate.getHours();
        var minMinutes = config.minDate.getMinutes();
        var minSeconds = config.minDate.getSeconds();
        if (hours < minHour) {
            hours = minHour;
        }
        if (hours === minHour && minutes < minMinutes) {
            minutes = minMinutes;
        }
        if (hours === minHour && minutes === minMinutes && seconds < minSeconds)
            seconds = config.minDate.getSeconds();
    }
    if (config.maxDate !== undefined) {
        var maxHr = config.maxDate.getHours();
        var maxMinutes = config.maxDate.getMinutes();
        hours = Math.min(hours, maxHr);
        if (hours === maxHr)
            minutes = Math.min(maxMinutes, minutes);
        if (hours === maxHr && minutes === maxMinutes)
            seconds = config.maxDate.getSeconds();
    }
    return { hours: hours, minutes: minutes, seconds: seconds };
}

if (typeof Object.assign !== "function") {
    Object.assign = function (target) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (!target) {
            throw TypeError("Cannot convert undefined or null to object");
        }
        var _loop_1 = function (source) {
            if (source) {
                Object.keys(source).forEach(function (key) { return (target[key] = source[key]); });
            }
        };
        for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
            var source = args_1[_a];
            _loop_1(source);
        }
        return target;
    };
}

var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __spreadArrays = (undefined && undefined.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var DEBOUNCED_CHANGE_MS = 300;
function FlatpickrInstance(element, instanceConfig) {
    var self = {
        config: __assign(__assign({}, defaults), flatpickr.defaultConfig),
        l10n: english,
    };
    self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
    self._handlers = [];
    self.pluginElements = [];
    self.loadedPlugins = [];
    self._bind = bind;
    self._setHoursFromDate = setHoursFromDate;
    self._positionCalendar = positionCalendar;
    self.changeMonth = changeMonth;
    self.changeYear = changeYear;
    self.clear = clear;
    self.close = close;
    self.onMouseOver = onMouseOver;
    self._createElement = createElement;
    self.createDay = createDay;
    self.destroy = destroy;
    self.isEnabled = isEnabled;
    self.jumpToDate = jumpToDate;
    self.updateValue = updateValue;
    self.open = open;
    self.redraw = redraw;
    self.set = set;
    self.setDate = setDate;
    self.toggle = toggle;
    function setupHelperFunctions() {
        self.utils = {
            getDaysInMonth: function (month, yr) {
                if (month === void 0) { month = self.currentMonth; }
                if (yr === void 0) { yr = self.currentYear; }
                if (month === 1 && ((yr % 4 === 0 && yr % 100 !== 0) || yr % 400 === 0))
                    return 29;
                return self.l10n.daysInMonth[month];
            },
        };
    }
    function init() {
        self.element = self.input = element;
        self.isOpen = false;
        parseConfig();
        setupLocale();
        setupInputs();
        setupDates();
        setupHelperFunctions();
        if (!self.isMobile)
            build();
        bindEvents();
        if (self.selectedDates.length || self.config.noCalendar) {
            if (self.config.enableTime) {
                setHoursFromDate(self.config.noCalendar ? self.latestSelectedDateObj : undefined);
            }
            updateValue(false);
        }
        setCalendarWidth();
        var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        if (!self.isMobile && isSafari) {
            positionCalendar();
        }
        triggerEvent("onReady");
    }
    function getClosestActiveElement() {
        var _a;
        return (((_a = self.calendarContainer) === null || _a === void 0 ? void 0 : _a.getRootNode())
            .activeElement || document.activeElement);
    }
    function bindToInstance(fn) {
        return fn.bind(self);
    }
    function setCalendarWidth() {
        var config = self.config;
        if (config.weekNumbers === false && config.showMonths === 1) {
            return;
        }
        else if (config.noCalendar !== true) {
            window.requestAnimationFrame(function () {
                if (self.calendarContainer !== undefined) {
                    self.calendarContainer.style.visibility = "hidden";
                    self.calendarContainer.style.display = "block";
                }
                if (self.daysContainer !== undefined) {
                    var daysWidth = (self.days.offsetWidth + 1) * config.showMonths;
                    self.daysContainer.style.width = daysWidth + "px";
                    self.calendarContainer.style.width =
                        daysWidth +
                            (self.weekWrapper !== undefined
                                ? self.weekWrapper.offsetWidth
                                : 0) +
                            "px";
                    self.calendarContainer.style.removeProperty("visibility");
                    self.calendarContainer.style.removeProperty("display");
                }
            });
        }
    }
    function updateTime(e) {
        if (self.selectedDates.length === 0) {
            var defaultDate = self.config.minDate === undefined ||
                compareDates(new Date(), self.config.minDate) >= 0
                ? new Date()
                : new Date(self.config.minDate.getTime());
            var defaults = getDefaultHours(self.config);
            defaultDate.setHours(defaults.hours, defaults.minutes, defaults.seconds, defaultDate.getMilliseconds());
            self.selectedDates = [defaultDate];
            self.latestSelectedDateObj = defaultDate;
        }
        if (e !== undefined && e.type !== "blur") {
            timeWrapper(e);
        }
        var prevValue = self._input.value;
        setHoursFromInputs();
        updateValue();
        if (self._input.value !== prevValue) {
            self._debouncedChange();
        }
    }
    function ampm2military(hour, amPM) {
        return (hour % 12) + 12 * int(amPM === self.l10n.amPM[1]);
    }
    function military2ampm(hour) {
        switch (hour % 24) {
            case 0:
            case 12:
                return 12;
            default:
                return hour % 12;
        }
    }
    function setHoursFromInputs() {
        if (self.hourElement === undefined || self.minuteElement === undefined)
            return;
        var hours = (parseInt(self.hourElement.value.slice(-2), 10) || 0) % 24, minutes = (parseInt(self.minuteElement.value, 10) || 0) % 60, seconds = self.secondElement !== undefined
            ? (parseInt(self.secondElement.value, 10) || 0) % 60
            : 0;
        if (self.amPM !== undefined) {
            hours = ampm2military(hours, self.amPM.textContent);
        }
        var limitMinHours = self.config.minTime !== undefined ||
            (self.config.minDate &&
                self.minDateHasTime &&
                self.latestSelectedDateObj &&
                compareDates(self.latestSelectedDateObj, self.config.minDate, true) ===
                    0);
        var limitMaxHours = self.config.maxTime !== undefined ||
            (self.config.maxDate &&
                self.maxDateHasTime &&
                self.latestSelectedDateObj &&
                compareDates(self.latestSelectedDateObj, self.config.maxDate, true) ===
                    0);
        if (self.config.maxTime !== undefined &&
            self.config.minTime !== undefined &&
            self.config.minTime > self.config.maxTime) {
            var minBound = calculateSecondsSinceMidnight(self.config.minTime.getHours(), self.config.minTime.getMinutes(), self.config.minTime.getSeconds());
            var maxBound = calculateSecondsSinceMidnight(self.config.maxTime.getHours(), self.config.maxTime.getMinutes(), self.config.maxTime.getSeconds());
            var currentTime = calculateSecondsSinceMidnight(hours, minutes, seconds);
            if (currentTime > maxBound && currentTime < minBound) {
                var result = parseSeconds(minBound);
                hours = result[0];
                minutes = result[1];
                seconds = result[2];
            }
        }
        else {
            if (limitMaxHours) {
                var maxTime = self.config.maxTime !== undefined
                    ? self.config.maxTime
                    : self.config.maxDate;
                hours = Math.min(hours, maxTime.getHours());
                if (hours === maxTime.getHours())
                    minutes = Math.min(minutes, maxTime.getMinutes());
                if (minutes === maxTime.getMinutes())
                    seconds = Math.min(seconds, maxTime.getSeconds());
            }
            if (limitMinHours) {
                var minTime = self.config.minTime !== undefined
                    ? self.config.minTime
                    : self.config.minDate;
                hours = Math.max(hours, minTime.getHours());
                if (hours === minTime.getHours() && minutes < minTime.getMinutes())
                    minutes = minTime.getMinutes();
                if (minutes === minTime.getMinutes())
                    seconds = Math.max(seconds, minTime.getSeconds());
            }
        }
        setHours(hours, minutes, seconds);
    }
    function setHoursFromDate(dateObj) {
        var date = dateObj || self.latestSelectedDateObj;
        if (date && date instanceof Date) {
            setHours(date.getHours(), date.getMinutes(), date.getSeconds());
        }
    }
    function setHours(hours, minutes, seconds) {
        if (self.latestSelectedDateObj !== undefined) {
            self.latestSelectedDateObj.setHours(hours % 24, minutes, seconds || 0, 0);
        }
        if (!self.hourElement || !self.minuteElement || self.isMobile)
            return;
        self.hourElement.value = pad(!self.config.time_24hr
            ? ((12 + hours) % 12) + 12 * int(hours % 12 === 0)
            : hours);
        self.minuteElement.value = pad(minutes);
        if (self.amPM !== undefined)
            self.amPM.textContent = self.l10n.amPM[int(hours >= 12)];
        if (self.secondElement !== undefined)
            self.secondElement.value = pad(seconds);
    }
    function onYearInput(event) {
        var eventTarget = getEventTarget(event);
        var year = parseInt(eventTarget.value) + (event.delta || 0);
        if (year / 1000 > 1 ||
            (event.key === "Enter" && !/[^\d]/.test(year.toString()))) {
            changeYear(year);
        }
    }
    function bind(element, event, handler, options) {
        if (event instanceof Array)
            return event.forEach(function (ev) { return bind(element, ev, handler, options); });
        if (element instanceof Array)
            return element.forEach(function (el) { return bind(el, event, handler, options); });
        element.addEventListener(event, handler, options);
        self._handlers.push({
            remove: function () { return element.removeEventListener(event, handler, options); },
        });
    }
    function triggerChange() {
        triggerEvent("onChange");
    }
    function bindEvents() {
        if (self.config.wrap) {
            ["open", "close", "toggle", "clear"].forEach(function (evt) {
                Array.prototype.forEach.call(self.element.querySelectorAll("[data-" + evt + "]"), function (el) {
                    return bind(el, "click", self[evt]);
                });
            });
        }
        if (self.isMobile) {
            setupMobile();
            return;
        }
        var debouncedResize = debounce$1(onResize, 50);
        self._debouncedChange = debounce$1(triggerChange, DEBOUNCED_CHANGE_MS);
        if (self.daysContainer && !/iPhone|iPad|iPod/i.test(navigator.userAgent))
            bind(self.daysContainer, "mouseover", function (e) {
                if (self.config.mode === "range")
                    onMouseOver(getEventTarget(e));
            });
        bind(self._input, "keydown", onKeyDown);
        if (self.calendarContainer !== undefined) {
            bind(self.calendarContainer, "keydown", onKeyDown);
        }
        if (!self.config.inline && !self.config.static)
            bind(window, "resize", debouncedResize);
        if (window.ontouchstart !== undefined)
            bind(window.document, "touchstart", documentClick);
        else
            bind(window.document, "mousedown", documentClick);
        bind(window.document, "focus", documentClick, { capture: true });
        if (self.config.clickOpens === true) {
            bind(self._input, "focus", self.open);
            bind(self._input, "click", self.open);
        }
        if (self.daysContainer !== undefined) {
            bind(self.monthNav, "click", onMonthNavClick);
            bind(self.monthNav, ["keyup", "increment"], onYearInput);
            bind(self.daysContainer, "click", selectDate);
        }
        if (self.timeContainer !== undefined &&
            self.minuteElement !== undefined &&
            self.hourElement !== undefined) {
            var selText = function (e) {
                return getEventTarget(e).select();
            };
            bind(self.timeContainer, ["increment"], updateTime);
            bind(self.timeContainer, "blur", updateTime, { capture: true });
            bind(self.timeContainer, "click", timeIncrement);
            bind([self.hourElement, self.minuteElement], ["focus", "click"], selText);
            if (self.secondElement !== undefined)
                bind(self.secondElement, "focus", function () { return self.secondElement && self.secondElement.select(); });
            if (self.amPM !== undefined) {
                bind(self.amPM, "click", function (e) {
                    updateTime(e);
                });
            }
        }
        if (self.config.allowInput) {
            bind(self._input, "blur", onBlur);
        }
    }
    function jumpToDate(jumpDate, triggerChange) {
        var jumpTo = jumpDate !== undefined
            ? self.parseDate(jumpDate)
            : self.latestSelectedDateObj ||
                (self.config.minDate && self.config.minDate > self.now
                    ? self.config.minDate
                    : self.config.maxDate && self.config.maxDate < self.now
                        ? self.config.maxDate
                        : self.now);
        var oldYear = self.currentYear;
        var oldMonth = self.currentMonth;
        try {
            if (jumpTo !== undefined) {
                self.currentYear = jumpTo.getFullYear();
                self.currentMonth = jumpTo.getMonth();
            }
        }
        catch (e) {
            e.message = "Invalid date supplied: " + jumpTo;
            self.config.errorHandler(e);
        }
        if (triggerChange && self.currentYear !== oldYear) {
            triggerEvent("onYearChange");
            buildMonthSwitch();
        }
        if (triggerChange &&
            (self.currentYear !== oldYear || self.currentMonth !== oldMonth)) {
            triggerEvent("onMonthChange");
        }
        self.redraw();
    }
    function timeIncrement(e) {
        var eventTarget = getEventTarget(e);
        if (~eventTarget.className.indexOf("arrow"))
            incrementNumInput(e, eventTarget.classList.contains("arrowUp") ? 1 : -1);
    }
    function incrementNumInput(e, delta, inputElem) {
        var target = e && getEventTarget(e);
        var input = inputElem ||
            (target && target.parentNode && target.parentNode.firstChild);
        var event = createEvent("increment");
        event.delta = delta;
        input && input.dispatchEvent(event);
    }
    function build() {
        var fragment = window.document.createDocumentFragment();
        self.calendarContainer = createElement("div", "flatpickr-calendar");
        self.calendarContainer.tabIndex = -1;
        if (!self.config.noCalendar) {
            fragment.appendChild(buildMonthNav());
            self.innerContainer = createElement("div", "flatpickr-innerContainer");
            if (self.config.weekNumbers) {
                var _a = buildWeeks(), weekWrapper = _a.weekWrapper, weekNumbers = _a.weekNumbers;
                self.innerContainer.appendChild(weekWrapper);
                self.weekNumbers = weekNumbers;
                self.weekWrapper = weekWrapper;
            }
            self.rContainer = createElement("div", "flatpickr-rContainer");
            self.rContainer.appendChild(buildWeekdays());
            if (!self.daysContainer) {
                self.daysContainer = createElement("div", "flatpickr-days");
                self.daysContainer.tabIndex = -1;
            }
            buildDays();
            self.rContainer.appendChild(self.daysContainer);
            self.innerContainer.appendChild(self.rContainer);
            fragment.appendChild(self.innerContainer);
        }
        if (self.config.enableTime) {
            fragment.appendChild(buildTime());
        }
        toggleClass(self.calendarContainer, "rangeMode", self.config.mode === "range");
        toggleClass(self.calendarContainer, "animate", self.config.animate === true);
        toggleClass(self.calendarContainer, "multiMonth", self.config.showMonths > 1);
        self.calendarContainer.appendChild(fragment);
        var customAppend = self.config.appendTo !== undefined &&
            self.config.appendTo.nodeType !== undefined;
        if (self.config.inline || self.config.static) {
            self.calendarContainer.classList.add(self.config.inline ? "inline" : "static");
            if (self.config.inline) {
                if (!customAppend && self.element.parentNode)
                    self.element.parentNode.insertBefore(self.calendarContainer, self._input.nextSibling);
                else if (self.config.appendTo !== undefined)
                    self.config.appendTo.appendChild(self.calendarContainer);
            }
            if (self.config.static) {
                var wrapper = createElement("div", "flatpickr-wrapper");
                if (self.element.parentNode)
                    self.element.parentNode.insertBefore(wrapper, self.element);
                wrapper.appendChild(self.element);
                if (self.altInput)
                    wrapper.appendChild(self.altInput);
                wrapper.appendChild(self.calendarContainer);
            }
        }
        if (!self.config.static && !self.config.inline)
            (self.config.appendTo !== undefined
                ? self.config.appendTo
                : window.document.body).appendChild(self.calendarContainer);
    }
    function createDay(className, date, _dayNumber, i) {
        var dateIsEnabled = isEnabled(date, true), dayElement = createElement("span", className, date.getDate().toString());
        dayElement.dateObj = date;
        dayElement.$i = i;
        dayElement.setAttribute("aria-label", self.formatDate(date, self.config.ariaDateFormat));
        if (className.indexOf("hidden") === -1 &&
            compareDates(date, self.now) === 0) {
            self.todayDateElem = dayElement;
            dayElement.classList.add("today");
            dayElement.setAttribute("aria-current", "date");
        }
        if (dateIsEnabled) {
            dayElement.tabIndex = -1;
            if (isDateSelected(date)) {
                dayElement.classList.add("selected");
                self.selectedDateElem = dayElement;
                if (self.config.mode === "range") {
                    toggleClass(dayElement, "startRange", self.selectedDates[0] &&
                        compareDates(date, self.selectedDates[0], true) === 0);
                    toggleClass(dayElement, "endRange", self.selectedDates[1] &&
                        compareDates(date, self.selectedDates[1], true) === 0);
                    if (className === "nextMonthDay")
                        dayElement.classList.add("inRange");
                }
            }
        }
        else {
            dayElement.classList.add("flatpickr-disabled");
        }
        if (self.config.mode === "range") {
            if (isDateInRange(date) && !isDateSelected(date))
                dayElement.classList.add("inRange");
        }
        if (self.weekNumbers &&
            self.config.showMonths === 1 &&
            className !== "prevMonthDay" &&
            i % 7 === 6) {
            self.weekNumbers.insertAdjacentHTML("beforeend", "<span class='flatpickr-day'>" + self.config.getWeek(date) + "</span>");
        }
        triggerEvent("onDayCreate", dayElement);
        return dayElement;
    }
    function focusOnDayElem(targetNode) {
        targetNode.focus();
        if (self.config.mode === "range")
            onMouseOver(targetNode);
    }
    function getFirstAvailableDay(delta) {
        var startMonth = delta > 0 ? 0 : self.config.showMonths - 1;
        var endMonth = delta > 0 ? self.config.showMonths : -1;
        for (var m = startMonth; m != endMonth; m += delta) {
            var month = self.daysContainer.children[m];
            var startIndex = delta > 0 ? 0 : month.children.length - 1;
            var endIndex = delta > 0 ? month.children.length : -1;
            for (var i = startIndex; i != endIndex; i += delta) {
                var c = month.children[i];
                if (c.className.indexOf("hidden") === -1 && isEnabled(c.dateObj))
                    return c;
            }
        }
        return undefined;
    }
    function getNextAvailableDay(current, delta) {
        var givenMonth = current.className.indexOf("Month") === -1
            ? current.dateObj.getMonth()
            : self.currentMonth;
        var endMonth = delta > 0 ? self.config.showMonths : -1;
        var loopDelta = delta > 0 ? 1 : -1;
        for (var m = givenMonth - self.currentMonth; m != endMonth; m += loopDelta) {
            var month = self.daysContainer.children[m];
            var startIndex = givenMonth - self.currentMonth === m
                ? current.$i + delta
                : delta < 0
                    ? month.children.length - 1
                    : 0;
            var numMonthDays = month.children.length;
            for (var i = startIndex; i >= 0 && i < numMonthDays && i != (delta > 0 ? numMonthDays : -1); i += loopDelta) {
                var c = month.children[i];
                if (c.className.indexOf("hidden") === -1 &&
                    isEnabled(c.dateObj) &&
                    Math.abs(current.$i - i) >= Math.abs(delta))
                    return focusOnDayElem(c);
            }
        }
        self.changeMonth(loopDelta);
        focusOnDay(getFirstAvailableDay(loopDelta), 0);
        return undefined;
    }
    function focusOnDay(current, offset) {
        var activeElement = getClosestActiveElement();
        var dayFocused = isInView(activeElement || document.body);
        var startElem = current !== undefined
            ? current
            : dayFocused
                ? activeElement
                : self.selectedDateElem !== undefined && isInView(self.selectedDateElem)
                    ? self.selectedDateElem
                    : self.todayDateElem !== undefined && isInView(self.todayDateElem)
                        ? self.todayDateElem
                        : getFirstAvailableDay(offset > 0 ? 1 : -1);
        if (startElem === undefined) {
            self._input.focus();
        }
        else if (!dayFocused) {
            focusOnDayElem(startElem);
        }
        else {
            getNextAvailableDay(startElem, offset);
        }
    }
    function buildMonthDays(year, month) {
        var firstOfMonth = (new Date(year, month, 1).getDay() - self.l10n.firstDayOfWeek + 7) % 7;
        var prevMonthDays = self.utils.getDaysInMonth((month - 1 + 12) % 12, year);
        var daysInMonth = self.utils.getDaysInMonth(month, year), days = window.document.createDocumentFragment(), isMultiMonth = self.config.showMonths > 1, prevMonthDayClass = isMultiMonth ? "prevMonthDay hidden" : "prevMonthDay", nextMonthDayClass = isMultiMonth ? "nextMonthDay hidden" : "nextMonthDay";
        var dayNumber = prevMonthDays + 1 - firstOfMonth, dayIndex = 0;
        for (; dayNumber <= prevMonthDays; dayNumber++, dayIndex++) {
            days.appendChild(createDay("flatpickr-day " + prevMonthDayClass, new Date(year, month - 1, dayNumber), dayNumber, dayIndex));
        }
        for (dayNumber = 1; dayNumber <= daysInMonth; dayNumber++, dayIndex++) {
            days.appendChild(createDay("flatpickr-day", new Date(year, month, dayNumber), dayNumber, dayIndex));
        }
        for (var dayNum = daysInMonth + 1; dayNum <= 42 - firstOfMonth &&
            (self.config.showMonths === 1 || dayIndex % 7 !== 0); dayNum++, dayIndex++) {
            days.appendChild(createDay("flatpickr-day " + nextMonthDayClass, new Date(year, month + 1, dayNum % daysInMonth), dayNum, dayIndex));
        }
        var dayContainer = createElement("div", "dayContainer");
        dayContainer.appendChild(days);
        return dayContainer;
    }
    function buildDays() {
        if (self.daysContainer === undefined) {
            return;
        }
        clearNode(self.daysContainer);
        if (self.weekNumbers)
            clearNode(self.weekNumbers);
        var frag = document.createDocumentFragment();
        for (var i = 0; i < self.config.showMonths; i++) {
            var d = new Date(self.currentYear, self.currentMonth, 1);
            d.setMonth(self.currentMonth + i);
            frag.appendChild(buildMonthDays(d.getFullYear(), d.getMonth()));
        }
        self.daysContainer.appendChild(frag);
        self.days = self.daysContainer.firstChild;
        if (self.config.mode === "range" && self.selectedDates.length === 1) {
            onMouseOver();
        }
    }
    function buildMonthSwitch() {
        if (self.config.showMonths > 1 ||
            self.config.monthSelectorType !== "dropdown")
            return;
        var shouldBuildMonth = function (month) {
            if (self.config.minDate !== undefined &&
                self.currentYear === self.config.minDate.getFullYear() &&
                month < self.config.minDate.getMonth()) {
                return false;
            }
            return !(self.config.maxDate !== undefined &&
                self.currentYear === self.config.maxDate.getFullYear() &&
                month > self.config.maxDate.getMonth());
        };
        self.monthsDropdownContainer.tabIndex = -1;
        self.monthsDropdownContainer.innerHTML = "";
        for (var i = 0; i < 12; i++) {
            if (!shouldBuildMonth(i))
                continue;
            var month = createElement("option", "flatpickr-monthDropdown-month");
            month.value = new Date(self.currentYear, i).getMonth().toString();
            month.textContent = monthToStr(i, self.config.shorthandCurrentMonth, self.l10n);
            month.tabIndex = -1;
            if (self.currentMonth === i) {
                month.selected = true;
            }
            self.monthsDropdownContainer.appendChild(month);
        }
    }
    function buildMonth() {
        var container = createElement("div", "flatpickr-month");
        var monthNavFragment = window.document.createDocumentFragment();
        var monthElement;
        if (self.config.showMonths > 1 ||
            self.config.monthSelectorType === "static") {
            monthElement = createElement("span", "cur-month");
        }
        else {
            self.monthsDropdownContainer = createElement("select", "flatpickr-monthDropdown-months");
            self.monthsDropdownContainer.setAttribute("aria-label", self.l10n.monthAriaLabel);
            bind(self.monthsDropdownContainer, "change", function (e) {
                var target = getEventTarget(e);
                var selectedMonth = parseInt(target.value, 10);
                self.changeMonth(selectedMonth - self.currentMonth);
                triggerEvent("onMonthChange");
            });
            buildMonthSwitch();
            monthElement = self.monthsDropdownContainer;
        }
        var yearInput = createNumberInput("cur-year", { tabindex: "-1" });
        var yearElement = yearInput.getElementsByTagName("input")[0];
        yearElement.setAttribute("aria-label", self.l10n.yearAriaLabel);
        if (self.config.minDate) {
            yearElement.setAttribute("min", self.config.minDate.getFullYear().toString());
        }
        if (self.config.maxDate) {
            yearElement.setAttribute("max", self.config.maxDate.getFullYear().toString());
            yearElement.disabled =
                !!self.config.minDate &&
                    self.config.minDate.getFullYear() === self.config.maxDate.getFullYear();
        }
        var currentMonth = createElement("div", "flatpickr-current-month");
        currentMonth.appendChild(monthElement);
        currentMonth.appendChild(yearInput);
        monthNavFragment.appendChild(currentMonth);
        container.appendChild(monthNavFragment);
        return {
            container: container,
            yearElement: yearElement,
            monthElement: monthElement,
        };
    }
    function buildMonths() {
        clearNode(self.monthNav);
        self.monthNav.appendChild(self.prevMonthNav);
        if (self.config.showMonths) {
            self.yearElements = [];
            self.monthElements = [];
        }
        for (var m = self.config.showMonths; m--;) {
            var month = buildMonth();
            self.yearElements.push(month.yearElement);
            self.monthElements.push(month.monthElement);
            self.monthNav.appendChild(month.container);
        }
        self.monthNav.appendChild(self.nextMonthNav);
    }
    function buildMonthNav() {
        self.monthNav = createElement("div", "flatpickr-months");
        self.yearElements = [];
        self.monthElements = [];
        self.prevMonthNav = createElement("span", "flatpickr-prev-month");
        self.prevMonthNav.innerHTML = self.config.prevArrow;
        self.nextMonthNav = createElement("span", "flatpickr-next-month");
        self.nextMonthNav.innerHTML = self.config.nextArrow;
        buildMonths();
        Object.defineProperty(self, "_hidePrevMonthArrow", {
            get: function () { return self.__hidePrevMonthArrow; },
            set: function (bool) {
                if (self.__hidePrevMonthArrow !== bool) {
                    toggleClass(self.prevMonthNav, "flatpickr-disabled", bool);
                    self.__hidePrevMonthArrow = bool;
                }
            },
        });
        Object.defineProperty(self, "_hideNextMonthArrow", {
            get: function () { return self.__hideNextMonthArrow; },
            set: function (bool) {
                if (self.__hideNextMonthArrow !== bool) {
                    toggleClass(self.nextMonthNav, "flatpickr-disabled", bool);
                    self.__hideNextMonthArrow = bool;
                }
            },
        });
        self.currentYearElement = self.yearElements[0];
        updateNavigationCurrentMonth();
        return self.monthNav;
    }
    function buildTime() {
        self.calendarContainer.classList.add("hasTime");
        if (self.config.noCalendar)
            self.calendarContainer.classList.add("noCalendar");
        var defaults = getDefaultHours(self.config);
        self.timeContainer = createElement("div", "flatpickr-time");
        self.timeContainer.tabIndex = -1;
        var separator = createElement("span", "flatpickr-time-separator", ":");
        var hourInput = createNumberInput("flatpickr-hour", {
            "aria-label": self.l10n.hourAriaLabel,
        });
        self.hourElement = hourInput.getElementsByTagName("input")[0];
        var minuteInput = createNumberInput("flatpickr-minute", {
            "aria-label": self.l10n.minuteAriaLabel,
        });
        self.minuteElement = minuteInput.getElementsByTagName("input")[0];
        self.hourElement.tabIndex = self.minuteElement.tabIndex = -1;
        self.hourElement.value = pad(self.latestSelectedDateObj
            ? self.latestSelectedDateObj.getHours()
            : self.config.time_24hr
                ? defaults.hours
                : military2ampm(defaults.hours));
        self.minuteElement.value = pad(self.latestSelectedDateObj
            ? self.latestSelectedDateObj.getMinutes()
            : defaults.minutes);
        self.hourElement.setAttribute("step", self.config.hourIncrement.toString());
        self.minuteElement.setAttribute("step", self.config.minuteIncrement.toString());
        self.hourElement.setAttribute("min", self.config.time_24hr ? "0" : "1");
        self.hourElement.setAttribute("max", self.config.time_24hr ? "23" : "12");
        self.hourElement.setAttribute("maxlength", "2");
        self.minuteElement.setAttribute("min", "0");
        self.minuteElement.setAttribute("max", "59");
        self.minuteElement.setAttribute("maxlength", "2");
        self.timeContainer.appendChild(hourInput);
        self.timeContainer.appendChild(separator);
        self.timeContainer.appendChild(minuteInput);
        if (self.config.time_24hr)
            self.timeContainer.classList.add("time24hr");
        if (self.config.enableSeconds) {
            self.timeContainer.classList.add("hasSeconds");
            var secondInput = createNumberInput("flatpickr-second");
            self.secondElement = secondInput.getElementsByTagName("input")[0];
            self.secondElement.value = pad(self.latestSelectedDateObj
                ? self.latestSelectedDateObj.getSeconds()
                : defaults.seconds);
            self.secondElement.setAttribute("step", self.minuteElement.getAttribute("step"));
            self.secondElement.setAttribute("min", "0");
            self.secondElement.setAttribute("max", "59");
            self.secondElement.setAttribute("maxlength", "2");
            self.timeContainer.appendChild(createElement("span", "flatpickr-time-separator", ":"));
            self.timeContainer.appendChild(secondInput);
        }
        if (!self.config.time_24hr) {
            self.amPM = createElement("span", "flatpickr-am-pm", self.l10n.amPM[int((self.latestSelectedDateObj
                ? self.hourElement.value
                : self.config.defaultHour) > 11)]);
            self.amPM.title = self.l10n.toggleTitle;
            self.amPM.tabIndex = -1;
            self.timeContainer.appendChild(self.amPM);
        }
        return self.timeContainer;
    }
    function buildWeekdays() {
        if (!self.weekdayContainer)
            self.weekdayContainer = createElement("div", "flatpickr-weekdays");
        else
            clearNode(self.weekdayContainer);
        for (var i = self.config.showMonths; i--;) {
            var container = createElement("div", "flatpickr-weekdaycontainer");
            self.weekdayContainer.appendChild(container);
        }
        updateWeekdays();
        return self.weekdayContainer;
    }
    function updateWeekdays() {
        if (!self.weekdayContainer) {
            return;
        }
        var firstDayOfWeek = self.l10n.firstDayOfWeek;
        var weekdays = __spreadArrays(self.l10n.weekdays.shorthand);
        if (firstDayOfWeek > 0 && firstDayOfWeek < weekdays.length) {
            weekdays = __spreadArrays(weekdays.splice(firstDayOfWeek, weekdays.length), weekdays.splice(0, firstDayOfWeek));
        }
        for (var i = self.config.showMonths; i--;) {
            self.weekdayContainer.children[i].innerHTML = "\n      <span class='flatpickr-weekday'>\n        " + weekdays.join("</span><span class='flatpickr-weekday'>") + "\n      </span>\n      ";
        }
    }
    function buildWeeks() {
        self.calendarContainer.classList.add("hasWeeks");
        var weekWrapper = createElement("div", "flatpickr-weekwrapper");
        weekWrapper.appendChild(createElement("span", "flatpickr-weekday", self.l10n.weekAbbreviation));
        var weekNumbers = createElement("div", "flatpickr-weeks");
        weekWrapper.appendChild(weekNumbers);
        return {
            weekWrapper: weekWrapper,
            weekNumbers: weekNumbers,
        };
    }
    function changeMonth(value, isOffset) {
        if (isOffset === void 0) { isOffset = true; }
        var delta = isOffset ? value : value - self.currentMonth;
        if ((delta < 0 && self._hidePrevMonthArrow === true) ||
            (delta > 0 && self._hideNextMonthArrow === true))
            return;
        self.currentMonth += delta;
        if (self.currentMonth < 0 || self.currentMonth > 11) {
            self.currentYear += self.currentMonth > 11 ? 1 : -1;
            self.currentMonth = (self.currentMonth + 12) % 12;
            triggerEvent("onYearChange");
            buildMonthSwitch();
        }
        buildDays();
        triggerEvent("onMonthChange");
        updateNavigationCurrentMonth();
    }
    function clear(triggerChangeEvent, toInitial) {
        if (triggerChangeEvent === void 0) { triggerChangeEvent = true; }
        if (toInitial === void 0) { toInitial = true; }
        self.input.value = "";
        if (self.altInput !== undefined)
            self.altInput.value = "";
        if (self.mobileInput !== undefined)
            self.mobileInput.value = "";
        self.selectedDates = [];
        self.latestSelectedDateObj = undefined;
        if (toInitial === true) {
            self.currentYear = self._initialDate.getFullYear();
            self.currentMonth = self._initialDate.getMonth();
        }
        if (self.config.enableTime === true) {
            var _a = getDefaultHours(self.config), hours = _a.hours, minutes = _a.minutes, seconds = _a.seconds;
            setHours(hours, minutes, seconds);
        }
        self.redraw();
        if (triggerChangeEvent)
            triggerEvent("onChange");
    }
    function close() {
        self.isOpen = false;
        if (!self.isMobile) {
            if (self.calendarContainer !== undefined) {
                self.calendarContainer.classList.remove("open");
            }
            if (self._input !== undefined) {
                self._input.classList.remove("active");
            }
        }
        triggerEvent("onClose");
    }
    function destroy() {
        if (self.config !== undefined)
            triggerEvent("onDestroy");
        for (var i = self._handlers.length; i--;) {
            self._handlers[i].remove();
        }
        self._handlers = [];
        if (self.mobileInput) {
            if (self.mobileInput.parentNode)
                self.mobileInput.parentNode.removeChild(self.mobileInput);
            self.mobileInput = undefined;
        }
        else if (self.calendarContainer && self.calendarContainer.parentNode) {
            if (self.config.static && self.calendarContainer.parentNode) {
                var wrapper = self.calendarContainer.parentNode;
                wrapper.lastChild && wrapper.removeChild(wrapper.lastChild);
                if (wrapper.parentNode) {
                    while (wrapper.firstChild)
                        wrapper.parentNode.insertBefore(wrapper.firstChild, wrapper);
                    wrapper.parentNode.removeChild(wrapper);
                }
            }
            else
                self.calendarContainer.parentNode.removeChild(self.calendarContainer);
        }
        if (self.altInput) {
            self.input.type = "text";
            if (self.altInput.parentNode)
                self.altInput.parentNode.removeChild(self.altInput);
            delete self.altInput;
        }
        if (self.input) {
            self.input.type = self.input._type;
            self.input.classList.remove("flatpickr-input");
            self.input.removeAttribute("readonly");
        }
        [
            "_showTimeInput",
            "latestSelectedDateObj",
            "_hideNextMonthArrow",
            "_hidePrevMonthArrow",
            "__hideNextMonthArrow",
            "__hidePrevMonthArrow",
            "isMobile",
            "isOpen",
            "selectedDateElem",
            "minDateHasTime",
            "maxDateHasTime",
            "days",
            "daysContainer",
            "_input",
            "_positionElement",
            "innerContainer",
            "rContainer",
            "monthNav",
            "todayDateElem",
            "calendarContainer",
            "weekdayContainer",
            "prevMonthNav",
            "nextMonthNav",
            "monthsDropdownContainer",
            "currentMonthElement",
            "currentYearElement",
            "navigationCurrentMonth",
            "selectedDateElem",
            "config",
        ].forEach(function (k) {
            try {
                delete self[k];
            }
            catch (_) { }
        });
    }
    function isCalendarElem(elem) {
        return self.calendarContainer.contains(elem);
    }
    function documentClick(e) {
        if (self.isOpen && !self.config.inline) {
            var eventTarget_1 = getEventTarget(e);
            var isCalendarElement = isCalendarElem(eventTarget_1);
            var isInput = eventTarget_1 === self.input ||
                eventTarget_1 === self.altInput ||
                self.element.contains(eventTarget_1) ||
                (e.path &&
                    e.path.indexOf &&
                    (~e.path.indexOf(self.input) ||
                        ~e.path.indexOf(self.altInput)));
            var lostFocus = !isInput &&
                !isCalendarElement &&
                !isCalendarElem(e.relatedTarget);
            var isIgnored = !self.config.ignoredFocusElements.some(function (elem) {
                return elem.contains(eventTarget_1);
            });
            if (lostFocus && isIgnored) {
                if (self.config.allowInput) {
                    self.setDate(self._input.value, false, self.config.altInput
                        ? self.config.altFormat
                        : self.config.dateFormat);
                }
                if (self.timeContainer !== undefined &&
                    self.minuteElement !== undefined &&
                    self.hourElement !== undefined &&
                    self.input.value !== "" &&
                    self.input.value !== undefined) {
                    updateTime();
                }
                self.close();
                if (self.config &&
                    self.config.mode === "range" &&
                    self.selectedDates.length === 1)
                    self.clear(false);
            }
        }
    }
    function changeYear(newYear) {
        if (!newYear ||
            (self.config.minDate && newYear < self.config.minDate.getFullYear()) ||
            (self.config.maxDate && newYear > self.config.maxDate.getFullYear()))
            return;
        var newYearNum = newYear, isNewYear = self.currentYear !== newYearNum;
        self.currentYear = newYearNum || self.currentYear;
        if (self.config.maxDate &&
            self.currentYear === self.config.maxDate.getFullYear()) {
            self.currentMonth = Math.min(self.config.maxDate.getMonth(), self.currentMonth);
        }
        else if (self.config.minDate &&
            self.currentYear === self.config.minDate.getFullYear()) {
            self.currentMonth = Math.max(self.config.minDate.getMonth(), self.currentMonth);
        }
        if (isNewYear) {
            self.redraw();
            triggerEvent("onYearChange");
            buildMonthSwitch();
        }
    }
    function isEnabled(date, timeless) {
        var _a;
        if (timeless === void 0) { timeless = true; }
        var dateToCheck = self.parseDate(date, undefined, timeless);
        if ((self.config.minDate &&
            dateToCheck &&
            compareDates(dateToCheck, self.config.minDate, timeless !== undefined ? timeless : !self.minDateHasTime) < 0) ||
            (self.config.maxDate &&
                dateToCheck &&
                compareDates(dateToCheck, self.config.maxDate, timeless !== undefined ? timeless : !self.maxDateHasTime) > 0))
            return false;
        if (!self.config.enable && self.config.disable.length === 0)
            return true;
        if (dateToCheck === undefined)
            return false;
        var bool = !!self.config.enable, array = (_a = self.config.enable) !== null && _a !== void 0 ? _a : self.config.disable;
        for (var i = 0, d = void 0; i < array.length; i++) {
            d = array[i];
            if (typeof d === "function" &&
                d(dateToCheck))
                return bool;
            else if (d instanceof Date &&
                dateToCheck !== undefined &&
                d.getTime() === dateToCheck.getTime())
                return bool;
            else if (typeof d === "string") {
                var parsed = self.parseDate(d, undefined, true);
                return parsed && parsed.getTime() === dateToCheck.getTime()
                    ? bool
                    : !bool;
            }
            else if (typeof d === "object" &&
                dateToCheck !== undefined &&
                d.from &&
                d.to &&
                dateToCheck.getTime() >= d.from.getTime() &&
                dateToCheck.getTime() <= d.to.getTime())
                return bool;
        }
        return !bool;
    }
    function isInView(elem) {
        if (self.daysContainer !== undefined)
            return (elem.className.indexOf("hidden") === -1 &&
                elem.className.indexOf("flatpickr-disabled") === -1 &&
                self.daysContainer.contains(elem));
        return false;
    }
    function onBlur(e) {
        var isInput = e.target === self._input;
        var valueChanged = self._input.value.trimEnd() !== getDateStr();
        if (isInput &&
            valueChanged &&
            !(e.relatedTarget && isCalendarElem(e.relatedTarget))) {
            self.setDate(self._input.value, true, e.target === self.altInput
                ? self.config.altFormat
                : self.config.dateFormat);
        }
    }
    function onKeyDown(e) {
        var eventTarget = getEventTarget(e);
        var isInput = self.config.wrap
            ? element.contains(eventTarget)
            : eventTarget === self._input;
        var allowInput = self.config.allowInput;
        var allowKeydown = self.isOpen && (!allowInput || !isInput);
        var allowInlineKeydown = self.config.inline && isInput && !allowInput;
        if (e.keyCode === 13 && isInput) {
            if (allowInput) {
                self.setDate(self._input.value, true, eventTarget === self.altInput
                    ? self.config.altFormat
                    : self.config.dateFormat);
                self.close();
                return eventTarget.blur();
            }
            else {
                self.open();
            }
        }
        else if (isCalendarElem(eventTarget) ||
            allowKeydown ||
            allowInlineKeydown) {
            var isTimeObj = !!self.timeContainer &&
                self.timeContainer.contains(eventTarget);
            switch (e.keyCode) {
                case 13:
                    if (isTimeObj) {
                        e.preventDefault();
                        updateTime();
                        focusAndClose();
                    }
                    else
                        selectDate(e);
                    break;
                case 27:
                    e.preventDefault();
                    focusAndClose();
                    break;
                case 8:
                case 46:
                    if (isInput && !self.config.allowInput) {
                        e.preventDefault();
                        self.clear();
                    }
                    break;
                case 37:
                case 39:
                    if (!isTimeObj && !isInput) {
                        e.preventDefault();
                        var activeElement = getClosestActiveElement();
                        if (self.daysContainer !== undefined &&
                            (allowInput === false ||
                                (activeElement && isInView(activeElement)))) {
                            var delta_1 = e.keyCode === 39 ? 1 : -1;
                            if (!e.ctrlKey)
                                focusOnDay(undefined, delta_1);
                            else {
                                e.stopPropagation();
                                changeMonth(delta_1);
                                focusOnDay(getFirstAvailableDay(1), 0);
                            }
                        }
                    }
                    else if (self.hourElement)
                        self.hourElement.focus();
                    break;
                case 38:
                case 40:
                    e.preventDefault();
                    var delta = e.keyCode === 40 ? 1 : -1;
                    if ((self.daysContainer &&
                        eventTarget.$i !== undefined) ||
                        eventTarget === self.input ||
                        eventTarget === self.altInput) {
                        if (e.ctrlKey) {
                            e.stopPropagation();
                            changeYear(self.currentYear - delta);
                            focusOnDay(getFirstAvailableDay(1), 0);
                        }
                        else if (!isTimeObj)
                            focusOnDay(undefined, delta * 7);
                    }
                    else if (eventTarget === self.currentYearElement) {
                        changeYear(self.currentYear - delta);
                    }
                    else if (self.config.enableTime) {
                        if (!isTimeObj && self.hourElement)
                            self.hourElement.focus();
                        updateTime(e);
                        self._debouncedChange();
                    }
                    break;
                case 9:
                    if (isTimeObj) {
                        var elems = [
                            self.hourElement,
                            self.minuteElement,
                            self.secondElement,
                            self.amPM,
                        ]
                            .concat(self.pluginElements)
                            .filter(function (x) { return x; });
                        var i = elems.indexOf(eventTarget);
                        if (i !== -1) {
                            var target = elems[i + (e.shiftKey ? -1 : 1)];
                            e.preventDefault();
                            (target || self._input).focus();
                        }
                    }
                    else if (!self.config.noCalendar &&
                        self.daysContainer &&
                        self.daysContainer.contains(eventTarget) &&
                        e.shiftKey) {
                        e.preventDefault();
                        self._input.focus();
                    }
                    break;
            }
        }
        if (self.amPM !== undefined && eventTarget === self.amPM) {
            switch (e.key) {
                case self.l10n.amPM[0].charAt(0):
                case self.l10n.amPM[0].charAt(0).toLowerCase():
                    self.amPM.textContent = self.l10n.amPM[0];
                    setHoursFromInputs();
                    updateValue();
                    break;
                case self.l10n.amPM[1].charAt(0):
                case self.l10n.amPM[1].charAt(0).toLowerCase():
                    self.amPM.textContent = self.l10n.amPM[1];
                    setHoursFromInputs();
                    updateValue();
                    break;
            }
        }
        if (isInput || isCalendarElem(eventTarget)) {
            triggerEvent("onKeyDown", e);
        }
    }
    function onMouseOver(elem, cellClass) {
        if (cellClass === void 0) { cellClass = "flatpickr-day"; }
        if (self.selectedDates.length !== 1 ||
            (elem &&
                (!elem.classList.contains(cellClass) ||
                    elem.classList.contains("flatpickr-disabled"))))
            return;
        var hoverDate = elem
            ? elem.dateObj.getTime()
            : self.days.firstElementChild.dateObj.getTime(), initialDate = self.parseDate(self.selectedDates[0], undefined, true).getTime(), rangeStartDate = Math.min(hoverDate, self.selectedDates[0].getTime()), rangeEndDate = Math.max(hoverDate, self.selectedDates[0].getTime());
        var containsDisabled = false;
        var minRange = 0, maxRange = 0;
        for (var t = rangeStartDate; t < rangeEndDate; t += duration.DAY) {
            if (!isEnabled(new Date(t), true)) {
                containsDisabled =
                    containsDisabled || (t > rangeStartDate && t < rangeEndDate);
                if (t < initialDate && (!minRange || t > minRange))
                    minRange = t;
                else if (t > initialDate && (!maxRange || t < maxRange))
                    maxRange = t;
            }
        }
        var hoverableCells = Array.from(self.rContainer.querySelectorAll("*:nth-child(-n+" + self.config.showMonths + ") > ." + cellClass));
        hoverableCells.forEach(function (dayElem) {
            var date = dayElem.dateObj;
            var timestamp = date.getTime();
            var outOfRange = (minRange > 0 && timestamp < minRange) ||
                (maxRange > 0 && timestamp > maxRange);
            if (outOfRange) {
                dayElem.classList.add("notAllowed");
                ["inRange", "startRange", "endRange"].forEach(function (c) {
                    dayElem.classList.remove(c);
                });
                return;
            }
            else if (containsDisabled && !outOfRange)
                return;
            ["startRange", "inRange", "endRange", "notAllowed"].forEach(function (c) {
                dayElem.classList.remove(c);
            });
            if (elem !== undefined) {
                elem.classList.add(hoverDate <= self.selectedDates[0].getTime()
                    ? "startRange"
                    : "endRange");
                if (initialDate < hoverDate && timestamp === initialDate)
                    dayElem.classList.add("startRange");
                else if (initialDate > hoverDate && timestamp === initialDate)
                    dayElem.classList.add("endRange");
                if (timestamp >= minRange &&
                    (maxRange === 0 || timestamp <= maxRange) &&
                    isBetween(timestamp, initialDate, hoverDate))
                    dayElem.classList.add("inRange");
            }
        });
    }
    function onResize() {
        if (self.isOpen && !self.config.static && !self.config.inline)
            positionCalendar();
    }
    function open(e, positionElement) {
        if (positionElement === void 0) { positionElement = self._positionElement; }
        if (self.isMobile === true) {
            if (e) {
                e.preventDefault();
                var eventTarget = getEventTarget(e);
                if (eventTarget) {
                    eventTarget.blur();
                }
            }
            if (self.mobileInput !== undefined) {
                self.mobileInput.focus();
                self.mobileInput.click();
            }
            triggerEvent("onOpen");
            return;
        }
        else if (self._input.disabled || self.config.inline) {
            return;
        }
        var wasOpen = self.isOpen;
        self.isOpen = true;
        if (!wasOpen) {
            self.calendarContainer.classList.add("open");
            self._input.classList.add("active");
            triggerEvent("onOpen");
            positionCalendar(positionElement);
        }
        if (self.config.enableTime === true && self.config.noCalendar === true) {
            if (self.config.allowInput === false &&
                (e === undefined ||
                    !self.timeContainer.contains(e.relatedTarget))) {
                setTimeout(function () { return self.hourElement.select(); }, 50);
            }
        }
    }
    function minMaxDateSetter(type) {
        return function (date) {
            var dateObj = (self.config["_" + type + "Date"] = self.parseDate(date, self.config.dateFormat));
            var inverseDateObj = self.config["_" + (type === "min" ? "max" : "min") + "Date"];
            if (dateObj !== undefined) {
                self[type === "min" ? "minDateHasTime" : "maxDateHasTime"] =
                    dateObj.getHours() > 0 ||
                        dateObj.getMinutes() > 0 ||
                        dateObj.getSeconds() > 0;
            }
            if (self.selectedDates) {
                self.selectedDates = self.selectedDates.filter(function (d) { return isEnabled(d); });
                if (!self.selectedDates.length && type === "min")
                    setHoursFromDate(dateObj);
                updateValue();
            }
            if (self.daysContainer) {
                redraw();
                if (dateObj !== undefined)
                    self.currentYearElement[type] = dateObj.getFullYear().toString();
                else
                    self.currentYearElement.removeAttribute(type);
                self.currentYearElement.disabled =
                    !!inverseDateObj &&
                        dateObj !== undefined &&
                        inverseDateObj.getFullYear() === dateObj.getFullYear();
            }
        };
    }
    function parseConfig() {
        var boolOpts = [
            "wrap",
            "weekNumbers",
            "allowInput",
            "allowInvalidPreload",
            "clickOpens",
            "time_24hr",
            "enableTime",
            "noCalendar",
            "altInput",
            "shorthandCurrentMonth",
            "inline",
            "static",
            "enableSeconds",
            "disableMobile",
        ];
        var userConfig = __assign(__assign({}, JSON.parse(JSON.stringify(element.dataset || {}))), instanceConfig);
        var formats = {};
        self.config.parseDate = userConfig.parseDate;
        self.config.formatDate = userConfig.formatDate;
        Object.defineProperty(self.config, "enable", {
            get: function () { return self.config._enable; },
            set: function (dates) {
                self.config._enable = parseDateRules(dates);
            },
        });
        Object.defineProperty(self.config, "disable", {
            get: function () { return self.config._disable; },
            set: function (dates) {
                self.config._disable = parseDateRules(dates);
            },
        });
        var timeMode = userConfig.mode === "time";
        if (!userConfig.dateFormat && (userConfig.enableTime || timeMode)) {
            var defaultDateFormat = flatpickr.defaultConfig.dateFormat || defaults.dateFormat;
            formats.dateFormat =
                userConfig.noCalendar || timeMode
                    ? "H:i" + (userConfig.enableSeconds ? ":S" : "")
                    : defaultDateFormat + " H:i" + (userConfig.enableSeconds ? ":S" : "");
        }
        if (userConfig.altInput &&
            (userConfig.enableTime || timeMode) &&
            !userConfig.altFormat) {
            var defaultAltFormat = flatpickr.defaultConfig.altFormat || defaults.altFormat;
            formats.altFormat =
                userConfig.noCalendar || timeMode
                    ? "h:i" + (userConfig.enableSeconds ? ":S K" : " K")
                    : defaultAltFormat + (" h:i" + (userConfig.enableSeconds ? ":S" : "") + " K");
        }
        Object.defineProperty(self.config, "minDate", {
            get: function () { return self.config._minDate; },
            set: minMaxDateSetter("min"),
        });
        Object.defineProperty(self.config, "maxDate", {
            get: function () { return self.config._maxDate; },
            set: minMaxDateSetter("max"),
        });
        var minMaxTimeSetter = function (type) { return function (val) {
            self.config[type === "min" ? "_minTime" : "_maxTime"] = self.parseDate(val, "H:i:S");
        }; };
        Object.defineProperty(self.config, "minTime", {
            get: function () { return self.config._minTime; },
            set: minMaxTimeSetter("min"),
        });
        Object.defineProperty(self.config, "maxTime", {
            get: function () { return self.config._maxTime; },
            set: minMaxTimeSetter("max"),
        });
        if (userConfig.mode === "time") {
            self.config.noCalendar = true;
            self.config.enableTime = true;
        }
        Object.assign(self.config, formats, userConfig);
        for (var i = 0; i < boolOpts.length; i++)
            self.config[boolOpts[i]] =
                self.config[boolOpts[i]] === true ||
                    self.config[boolOpts[i]] === "true";
        HOOKS.filter(function (hook) { return self.config[hook] !== undefined; }).forEach(function (hook) {
            self.config[hook] = arrayify(self.config[hook] || []).map(bindToInstance);
        });
        self.isMobile =
            !self.config.disableMobile &&
                !self.config.inline &&
                self.config.mode === "single" &&
                !self.config.disable.length &&
                !self.config.enable &&
                !self.config.weekNumbers &&
                /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        for (var i = 0; i < self.config.plugins.length; i++) {
            var pluginConf = self.config.plugins[i](self) || {};
            for (var key in pluginConf) {
                if (HOOKS.indexOf(key) > -1) {
                    self.config[key] = arrayify(pluginConf[key])
                        .map(bindToInstance)
                        .concat(self.config[key]);
                }
                else if (typeof userConfig[key] === "undefined")
                    self.config[key] = pluginConf[key];
            }
        }
        if (!userConfig.altInputClass) {
            self.config.altInputClass =
                getInputElem().className + " " + self.config.altInputClass;
        }
        triggerEvent("onParseConfig");
    }
    function getInputElem() {
        return self.config.wrap
            ? element.querySelector("[data-input]")
            : element;
    }
    function setupLocale() {
        if (typeof self.config.locale !== "object" &&
            typeof flatpickr.l10ns[self.config.locale] === "undefined")
            self.config.errorHandler(new Error("flatpickr: invalid locale " + self.config.locale));
        self.l10n = __assign(__assign({}, flatpickr.l10ns.default), (typeof self.config.locale === "object"
            ? self.config.locale
            : self.config.locale !== "default"
                ? flatpickr.l10ns[self.config.locale]
                : undefined));
        tokenRegex.D = "(" + self.l10n.weekdays.shorthand.join("|") + ")";
        tokenRegex.l = "(" + self.l10n.weekdays.longhand.join("|") + ")";
        tokenRegex.M = "(" + self.l10n.months.shorthand.join("|") + ")";
        tokenRegex.F = "(" + self.l10n.months.longhand.join("|") + ")";
        tokenRegex.K = "(" + self.l10n.amPM[0] + "|" + self.l10n.amPM[1] + "|" + self.l10n.amPM[0].toLowerCase() + "|" + self.l10n.amPM[1].toLowerCase() + ")";
        var userConfig = __assign(__assign({}, instanceConfig), JSON.parse(JSON.stringify(element.dataset || {})));
        if (userConfig.time_24hr === undefined &&
            flatpickr.defaultConfig.time_24hr === undefined) {
            self.config.time_24hr = self.l10n.time_24hr;
        }
        self.formatDate = createDateFormatter(self);
        self.parseDate = createDateParser({ config: self.config, l10n: self.l10n });
    }
    function positionCalendar(customPositionElement) {
        if (typeof self.config.position === "function") {
            return void self.config.position(self, customPositionElement);
        }
        if (self.calendarContainer === undefined)
            return;
        triggerEvent("onPreCalendarPosition");
        var positionElement = customPositionElement || self._positionElement;
        var calendarHeight = Array.prototype.reduce.call(self.calendarContainer.children, (function (acc, child) { return acc + child.offsetHeight; }), 0), calendarWidth = self.calendarContainer.offsetWidth, configPos = self.config.position.split(" "), configPosVertical = configPos[0], configPosHorizontal = configPos.length > 1 ? configPos[1] : null, inputBounds = positionElement.getBoundingClientRect(), distanceFromBottom = window.innerHeight - inputBounds.bottom, showOnTop = configPosVertical === "above" ||
            (configPosVertical !== "below" &&
                distanceFromBottom < calendarHeight &&
                inputBounds.top > calendarHeight);
        var top = window.pageYOffset +
            inputBounds.top +
            (!showOnTop ? positionElement.offsetHeight + 2 : -calendarHeight - 2);
        toggleClass(self.calendarContainer, "arrowTop", !showOnTop);
        toggleClass(self.calendarContainer, "arrowBottom", showOnTop);
        if (self.config.inline)
            return;
        var left = window.pageXOffset + inputBounds.left;
        var isCenter = false;
        var isRight = false;
        if (configPosHorizontal === "center") {
            left -= (calendarWidth - inputBounds.width) / 2;
            isCenter = true;
        }
        else if (configPosHorizontal === "right") {
            left -= calendarWidth - inputBounds.width;
            isRight = true;
        }
        toggleClass(self.calendarContainer, "arrowLeft", !isCenter && !isRight);
        toggleClass(self.calendarContainer, "arrowCenter", isCenter);
        toggleClass(self.calendarContainer, "arrowRight", isRight);
        var right = window.document.body.offsetWidth -
            (window.pageXOffset + inputBounds.right);
        var rightMost = left + calendarWidth > window.document.body.offsetWidth;
        var centerMost = right + calendarWidth > window.document.body.offsetWidth;
        toggleClass(self.calendarContainer, "rightMost", rightMost);
        if (self.config.static)
            return;
        self.calendarContainer.style.top = top + "px";
        if (!rightMost) {
            self.calendarContainer.style.left = left + "px";
            self.calendarContainer.style.right = "auto";
        }
        else if (!centerMost) {
            self.calendarContainer.style.left = "auto";
            self.calendarContainer.style.right = right + "px";
        }
        else {
            var doc = getDocumentStyleSheet();
            if (doc === undefined)
                return;
            var bodyWidth = window.document.body.offsetWidth;
            var centerLeft = Math.max(0, bodyWidth / 2 - calendarWidth / 2);
            var centerBefore = ".flatpickr-calendar.centerMost:before";
            var centerAfter = ".flatpickr-calendar.centerMost:after";
            var centerIndex = doc.cssRules.length;
            var centerStyle = "{left:" + inputBounds.left + "px;right:auto;}";
            toggleClass(self.calendarContainer, "rightMost", false);
            toggleClass(self.calendarContainer, "centerMost", true);
            doc.insertRule(centerBefore + "," + centerAfter + centerStyle, centerIndex);
            self.calendarContainer.style.left = centerLeft + "px";
            self.calendarContainer.style.right = "auto";
        }
    }
    function getDocumentStyleSheet() {
        var editableSheet = null;
        for (var i = 0; i < document.styleSheets.length; i++) {
            var sheet = document.styleSheets[i];
            if (!sheet.cssRules)
                continue;
            editableSheet = sheet;
            break;
        }
        return editableSheet != null ? editableSheet : createStyleSheet();
    }
    function createStyleSheet() {
        var style = document.createElement("style");
        document.head.appendChild(style);
        return style.sheet;
    }
    function redraw() {
        if (self.config.noCalendar || self.isMobile)
            return;
        buildMonthSwitch();
        updateNavigationCurrentMonth();
        buildDays();
    }
    function focusAndClose() {
        self._input.focus();
        if (window.navigator.userAgent.indexOf("MSIE") !== -1 ||
            navigator.msMaxTouchPoints !== undefined) {
            setTimeout(self.close, 0);
        }
        else {
            self.close();
        }
    }
    function selectDate(e) {
        e.preventDefault();
        e.stopPropagation();
        var isSelectable = function (day) {
            return day.classList &&
                day.classList.contains("flatpickr-day") &&
                !day.classList.contains("flatpickr-disabled") &&
                !day.classList.contains("notAllowed");
        };
        var t = findParent(getEventTarget(e), isSelectable);
        if (t === undefined)
            return;
        var target = t;
        var selectedDate = (self.latestSelectedDateObj = new Date(target.dateObj.getTime()));
        var shouldChangeMonth = (selectedDate.getMonth() < self.currentMonth ||
            selectedDate.getMonth() >
                self.currentMonth + self.config.showMonths - 1) &&
            self.config.mode !== "range";
        self.selectedDateElem = target;
        if (self.config.mode === "single")
            self.selectedDates = [selectedDate];
        else if (self.config.mode === "multiple") {
            var selectedIndex = isDateSelected(selectedDate);
            if (selectedIndex)
                self.selectedDates.splice(parseInt(selectedIndex), 1);
            else
                self.selectedDates.push(selectedDate);
        }
        else if (self.config.mode === "range") {
            if (self.selectedDates.length === 2) {
                self.clear(false, false);
            }
            self.latestSelectedDateObj = selectedDate;
            self.selectedDates.push(selectedDate);
            if (compareDates(selectedDate, self.selectedDates[0], true) !== 0)
                self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });
        }
        setHoursFromInputs();
        if (shouldChangeMonth) {
            var isNewYear = self.currentYear !== selectedDate.getFullYear();
            self.currentYear = selectedDate.getFullYear();
            self.currentMonth = selectedDate.getMonth();
            if (isNewYear) {
                triggerEvent("onYearChange");
                buildMonthSwitch();
            }
            triggerEvent("onMonthChange");
        }
        updateNavigationCurrentMonth();
        buildDays();
        updateValue();
        if (!shouldChangeMonth &&
            self.config.mode !== "range" &&
            self.config.showMonths === 1)
            focusOnDayElem(target);
        else if (self.selectedDateElem !== undefined &&
            self.hourElement === undefined) {
            self.selectedDateElem && self.selectedDateElem.focus();
        }
        if (self.hourElement !== undefined)
            self.hourElement !== undefined && self.hourElement.focus();
        if (self.config.closeOnSelect) {
            var single = self.config.mode === "single" && !self.config.enableTime;
            var range = self.config.mode === "range" &&
                self.selectedDates.length === 2 &&
                !self.config.enableTime;
            if (single || range) {
                focusAndClose();
            }
        }
        triggerChange();
    }
    var CALLBACKS = {
        locale: [setupLocale, updateWeekdays],
        showMonths: [buildMonths, setCalendarWidth, buildWeekdays],
        minDate: [jumpToDate],
        maxDate: [jumpToDate],
        positionElement: [updatePositionElement],
        clickOpens: [
            function () {
                if (self.config.clickOpens === true) {
                    bind(self._input, "focus", self.open);
                    bind(self._input, "click", self.open);
                }
                else {
                    self._input.removeEventListener("focus", self.open);
                    self._input.removeEventListener("click", self.open);
                }
            },
        ],
    };
    function set(option, value) {
        if (option !== null && typeof option === "object") {
            Object.assign(self.config, option);
            for (var key in option) {
                if (CALLBACKS[key] !== undefined)
                    CALLBACKS[key].forEach(function (x) { return x(); });
            }
        }
        else {
            self.config[option] = value;
            if (CALLBACKS[option] !== undefined)
                CALLBACKS[option].forEach(function (x) { return x(); });
            else if (HOOKS.indexOf(option) > -1)
                self.config[option] = arrayify(value);
        }
        self.redraw();
        updateValue(true);
    }
    function setSelectedDate(inputDate, format) {
        var dates = [];
        if (inputDate instanceof Array)
            dates = inputDate.map(function (d) { return self.parseDate(d, format); });
        else if (inputDate instanceof Date || typeof inputDate === "number")
            dates = [self.parseDate(inputDate, format)];
        else if (typeof inputDate === "string") {
            switch (self.config.mode) {
                case "single":
                case "time":
                    dates = [self.parseDate(inputDate, format)];
                    break;
                case "multiple":
                    dates = inputDate
                        .split(self.config.conjunction)
                        .map(function (date) { return self.parseDate(date, format); });
                    break;
                case "range":
                    dates = inputDate
                        .split(self.l10n.rangeSeparator)
                        .map(function (date) { return self.parseDate(date, format); });
                    break;
            }
        }
        else
            self.config.errorHandler(new Error("Invalid date supplied: " + JSON.stringify(inputDate)));
        self.selectedDates = (self.config.allowInvalidPreload
            ? dates
            : dates.filter(function (d) { return d instanceof Date && isEnabled(d, false); }));
        if (self.config.mode === "range")
            self.selectedDates.sort(function (a, b) { return a.getTime() - b.getTime(); });
    }
    function setDate(date, triggerChange, format) {
        if (triggerChange === void 0) { triggerChange = false; }
        if (format === void 0) { format = self.config.dateFormat; }
        if ((date !== 0 && !date) || (date instanceof Array && date.length === 0))
            return self.clear(triggerChange);
        setSelectedDate(date, format);
        self.latestSelectedDateObj =
            self.selectedDates[self.selectedDates.length - 1];
        self.redraw();
        jumpToDate(undefined, triggerChange);
        setHoursFromDate();
        if (self.selectedDates.length === 0) {
            self.clear(false);
        }
        updateValue(triggerChange);
        if (triggerChange)
            triggerEvent("onChange");
    }
    function parseDateRules(arr) {
        return arr
            .slice()
            .map(function (rule) {
            if (typeof rule === "string" ||
                typeof rule === "number" ||
                rule instanceof Date) {
                return self.parseDate(rule, undefined, true);
            }
            else if (rule &&
                typeof rule === "object" &&
                rule.from &&
                rule.to)
                return {
                    from: self.parseDate(rule.from, undefined),
                    to: self.parseDate(rule.to, undefined),
                };
            return rule;
        })
            .filter(function (x) { return x; });
    }
    function setupDates() {
        self.selectedDates = [];
        self.now = self.parseDate(self.config.now) || new Date();
        var preloadedDate = self.config.defaultDate ||
            ((self.input.nodeName === "INPUT" ||
                self.input.nodeName === "TEXTAREA") &&
                self.input.placeholder &&
                self.input.value === self.input.placeholder
                ? null
                : self.input.value);
        if (preloadedDate)
            setSelectedDate(preloadedDate, self.config.dateFormat);
        self._initialDate =
            self.selectedDates.length > 0
                ? self.selectedDates[0]
                : self.config.minDate &&
                    self.config.minDate.getTime() > self.now.getTime()
                    ? self.config.minDate
                    : self.config.maxDate &&
                        self.config.maxDate.getTime() < self.now.getTime()
                        ? self.config.maxDate
                        : self.now;
        self.currentYear = self._initialDate.getFullYear();
        self.currentMonth = self._initialDate.getMonth();
        if (self.selectedDates.length > 0)
            self.latestSelectedDateObj = self.selectedDates[0];
        if (self.config.minTime !== undefined)
            self.config.minTime = self.parseDate(self.config.minTime, "H:i");
        if (self.config.maxTime !== undefined)
            self.config.maxTime = self.parseDate(self.config.maxTime, "H:i");
        self.minDateHasTime =
            !!self.config.minDate &&
                (self.config.minDate.getHours() > 0 ||
                    self.config.minDate.getMinutes() > 0 ||
                    self.config.minDate.getSeconds() > 0);
        self.maxDateHasTime =
            !!self.config.maxDate &&
                (self.config.maxDate.getHours() > 0 ||
                    self.config.maxDate.getMinutes() > 0 ||
                    self.config.maxDate.getSeconds() > 0);
    }
    function setupInputs() {
        self.input = getInputElem();
        if (!self.input) {
            self.config.errorHandler(new Error("Invalid input element specified"));
            return;
        }
        self.input._type = self.input.type;
        self.input.type = "text";
        self.input.classList.add("flatpickr-input");
        self._input = self.input;
        if (self.config.altInput) {
            self.altInput = createElement(self.input.nodeName, self.config.altInputClass);
            self._input = self.altInput;
            self.altInput.placeholder = self.input.placeholder;
            self.altInput.disabled = self.input.disabled;
            self.altInput.required = self.input.required;
            self.altInput.tabIndex = self.input.tabIndex;
            self.altInput.type = "text";
            self.input.setAttribute("type", "hidden");
            if (!self.config.static && self.input.parentNode)
                self.input.parentNode.insertBefore(self.altInput, self.input.nextSibling);
        }
        if (!self.config.allowInput)
            self._input.setAttribute("readonly", "readonly");
        updatePositionElement();
    }
    function updatePositionElement() {
        self._positionElement = self.config.positionElement || self._input;
    }
    function setupMobile() {
        var inputType = self.config.enableTime
            ? self.config.noCalendar
                ? "time"
                : "datetime-local"
            : "date";
        self.mobileInput = createElement("input", self.input.className + " flatpickr-mobile");
        self.mobileInput.tabIndex = 1;
        self.mobileInput.type = inputType;
        self.mobileInput.disabled = self.input.disabled;
        self.mobileInput.required = self.input.required;
        self.mobileInput.placeholder = self.input.placeholder;
        self.mobileFormatStr =
            inputType === "datetime-local"
                ? "Y-m-d\\TH:i:S"
                : inputType === "date"
                    ? "Y-m-d"
                    : "H:i:S";
        if (self.selectedDates.length > 0) {
            self.mobileInput.defaultValue = self.mobileInput.value = self.formatDate(self.selectedDates[0], self.mobileFormatStr);
        }
        if (self.config.minDate)
            self.mobileInput.min = self.formatDate(self.config.minDate, "Y-m-d");
        if (self.config.maxDate)
            self.mobileInput.max = self.formatDate(self.config.maxDate, "Y-m-d");
        if (self.input.getAttribute("step"))
            self.mobileInput.step = String(self.input.getAttribute("step"));
        self.input.type = "hidden";
        if (self.altInput !== undefined)
            self.altInput.type = "hidden";
        try {
            if (self.input.parentNode)
                self.input.parentNode.insertBefore(self.mobileInput, self.input.nextSibling);
        }
        catch (_a) { }
        bind(self.mobileInput, "change", function (e) {
            self.setDate(getEventTarget(e).value, false, self.mobileFormatStr);
            triggerEvent("onChange");
            triggerEvent("onClose");
        });
    }
    function toggle(e) {
        if (self.isOpen === true)
            return self.close();
        self.open(e);
    }
    function triggerEvent(event, data) {
        if (self.config === undefined)
            return;
        var hooks = self.config[event];
        if (hooks !== undefined && hooks.length > 0) {
            for (var i = 0; hooks[i] && i < hooks.length; i++)
                hooks[i](self.selectedDates, self.input.value, self, data);
        }
        if (event === "onChange") {
            self.input.dispatchEvent(createEvent("change"));
            self.input.dispatchEvent(createEvent("input"));
        }
    }
    function createEvent(name) {
        var e = document.createEvent("Event");
        e.initEvent(name, true, true);
        return e;
    }
    function isDateSelected(date) {
        for (var i = 0; i < self.selectedDates.length; i++) {
            var selectedDate = self.selectedDates[i];
            if (selectedDate instanceof Date &&
                compareDates(selectedDate, date) === 0)
                return "" + i;
        }
        return false;
    }
    function isDateInRange(date) {
        if (self.config.mode !== "range" || self.selectedDates.length < 2)
            return false;
        return (compareDates(date, self.selectedDates[0]) >= 0 &&
            compareDates(date, self.selectedDates[1]) <= 0);
    }
    function updateNavigationCurrentMonth() {
        if (self.config.noCalendar || self.isMobile || !self.monthNav)
            return;
        self.yearElements.forEach(function (yearElement, i) {
            var d = new Date(self.currentYear, self.currentMonth, 1);
            d.setMonth(self.currentMonth + i);
            if (self.config.showMonths > 1 ||
                self.config.monthSelectorType === "static") {
                self.monthElements[i].textContent =
                    monthToStr(d.getMonth(), self.config.shorthandCurrentMonth, self.l10n) + " ";
            }
            else {
                self.monthsDropdownContainer.value = d.getMonth().toString();
            }
            yearElement.value = d.getFullYear().toString();
        });
        self._hidePrevMonthArrow =
            self.config.minDate !== undefined &&
                (self.currentYear === self.config.minDate.getFullYear()
                    ? self.currentMonth <= self.config.minDate.getMonth()
                    : self.currentYear < self.config.minDate.getFullYear());
        self._hideNextMonthArrow =
            self.config.maxDate !== undefined &&
                (self.currentYear === self.config.maxDate.getFullYear()
                    ? self.currentMonth + 1 > self.config.maxDate.getMonth()
                    : self.currentYear > self.config.maxDate.getFullYear());
    }
    function getDateStr(specificFormat) {
        var format = specificFormat ||
            (self.config.altInput ? self.config.altFormat : self.config.dateFormat);
        return self.selectedDates
            .map(function (dObj) { return self.formatDate(dObj, format); })
            .filter(function (d, i, arr) {
            return self.config.mode !== "range" ||
                self.config.enableTime ||
                arr.indexOf(d) === i;
        })
            .join(self.config.mode !== "range"
            ? self.config.conjunction
            : self.l10n.rangeSeparator);
    }
    function updateValue(triggerChange) {
        if (triggerChange === void 0) { triggerChange = true; }
        if (self.mobileInput !== undefined && self.mobileFormatStr) {
            self.mobileInput.value =
                self.latestSelectedDateObj !== undefined
                    ? self.formatDate(self.latestSelectedDateObj, self.mobileFormatStr)
                    : "";
        }
        self.input.value = getDateStr(self.config.dateFormat);
        if (self.altInput !== undefined) {
            self.altInput.value = getDateStr(self.config.altFormat);
        }
        if (triggerChange !== false)
            triggerEvent("onValueUpdate");
    }
    function onMonthNavClick(e) {
        var eventTarget = getEventTarget(e);
        var isPrevMonth = self.prevMonthNav.contains(eventTarget);
        var isNextMonth = self.nextMonthNav.contains(eventTarget);
        if (isPrevMonth || isNextMonth) {
            changeMonth(isPrevMonth ? -1 : 1);
        }
        else if (self.yearElements.indexOf(eventTarget) >= 0) {
            eventTarget.select();
        }
        else if (eventTarget.classList.contains("arrowUp")) {
            self.changeYear(self.currentYear + 1);
        }
        else if (eventTarget.classList.contains("arrowDown")) {
            self.changeYear(self.currentYear - 1);
        }
    }
    function timeWrapper(e) {
        e.preventDefault();
        var isKeyDown = e.type === "keydown", eventTarget = getEventTarget(e), input = eventTarget;
        if (self.amPM !== undefined && eventTarget === self.amPM) {
            self.amPM.textContent =
                self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
        }
        var min = parseFloat(input.getAttribute("min")), max = parseFloat(input.getAttribute("max")), step = parseFloat(input.getAttribute("step")), curValue = parseInt(input.value, 10), delta = e.delta ||
            (isKeyDown ? (e.which === 38 ? 1 : -1) : 0);
        var newValue = curValue + step * delta;
        if (typeof input.value !== "undefined" && input.value.length === 2) {
            var isHourElem = input === self.hourElement, isMinuteElem = input === self.minuteElement;
            if (newValue < min) {
                newValue =
                    max +
                        newValue +
                        int(!isHourElem) +
                        (int(isHourElem) && int(!self.amPM));
                if (isMinuteElem)
                    incrementNumInput(undefined, -1, self.hourElement);
            }
            else if (newValue > max) {
                newValue =
                    input === self.hourElement ? newValue - max - int(!self.amPM) : min;
                if (isMinuteElem)
                    incrementNumInput(undefined, 1, self.hourElement);
            }
            if (self.amPM &&
                isHourElem &&
                (step === 1
                    ? newValue + curValue === 23
                    : Math.abs(newValue - curValue) > step)) {
                self.amPM.textContent =
                    self.l10n.amPM[int(self.amPM.textContent === self.l10n.amPM[0])];
            }
            input.value = pad(newValue);
        }
    }
    init();
    return self;
}
function _flatpickr(nodeList, config) {
    var nodes = Array.prototype.slice
        .call(nodeList)
        .filter(function (x) { return x instanceof HTMLElement; });
    var instances = [];
    for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];
        try {
            if (node.getAttribute("data-fp-omit") !== null)
                continue;
            if (node._flatpickr !== undefined) {
                node._flatpickr.destroy();
                node._flatpickr = undefined;
            }
            node._flatpickr = FlatpickrInstance(node, config || {});
            instances.push(node._flatpickr);
        }
        catch (e) {
            console.error(e);
        }
    }
    return instances.length === 1 ? instances[0] : instances;
}
if (typeof HTMLElement !== "undefined" &&
    typeof HTMLCollection !== "undefined" &&
    typeof NodeList !== "undefined") {
    HTMLCollection.prototype.flatpickr = NodeList.prototype.flatpickr = function (config) {
        return _flatpickr(this, config);
    };
    HTMLElement.prototype.flatpickr = function (config) {
        return _flatpickr([this], config);
    };
}
var flatpickr = function (selector, config) {
    if (typeof selector === "string") {
        return _flatpickr(window.document.querySelectorAll(selector), config);
    }
    else if (selector instanceof Node) {
        return _flatpickr([selector], config);
    }
    else {
        return _flatpickr(selector, config);
    }
};
flatpickr.defaultConfig = {};
flatpickr.l10ns = {
    en: __assign({}, english),
    default: __assign({}, english),
};
flatpickr.localize = function (l10n) {
    flatpickr.l10ns.default = __assign(__assign({}, flatpickr.l10ns.default), l10n);
};
flatpickr.setDefaults = function (config) {
    flatpickr.defaultConfig = __assign(__assign({}, flatpickr.defaultConfig), config);
};
flatpickr.parseDate = createDateParser({});
flatpickr.formatDate = createDateFormatter({});
flatpickr.compareDates = compareDates;
if (typeof jQuery !== "undefined" && typeof jQuery.fn !== "undefined") {
    jQuery.fn.flatpickr = function (config) {
        return _flatpickr(this, config);
    };
}
Date.prototype.fp_incr = function (days) {
    return new Date(this.getFullYear(), this.getMonth(), this.getDate() + (typeof days === "string" ? parseInt(days, 10) : days));
};
if (typeof window !== "undefined") {
    window.flatpickr = flatpickr;
}

createCommonjsModule(function (module, exports) {
(function (global, factory) {
  factory(exports) ;
}(commonjsGlobal, (function (exports) {
  var fp = typeof window !== "undefined" && window.flatpickr !== undefined
      ? window.flatpickr
      : {
          l10ns: {},
      };
  var German = {
      weekdays: {
          shorthand: ["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"],
          longhand: [
              "Sonntag",
              "Montag",
              "Dienstag",
              "Mittwoch",
              "Donnerstag",
              "Freitag",
              "Samstag",
          ],
      },
      months: {
          shorthand: [
              "Jan",
              "Feb",
              "Mär",
              "Apr",
              "Mai",
              "Jun",
              "Jul",
              "Aug",
              "Sep",
              "Okt",
              "Nov",
              "Dez",
          ],
          longhand: [
              "Januar",
              "Februar",
              "März",
              "April",
              "Mai",
              "Juni",
              "Juli",
              "August",
              "September",
              "Oktober",
              "November",
              "Dezember",
          ],
      },
      firstDayOfWeek: 1,
      weekAbbreviation: "KW",
      rangeSeparator: " bis ",
      scrollTitle: "Zum Ändern scrollen",
      toggleTitle: "Zum Umschalten klicken",
      time_24hr: true,
  };
  fp.l10ns.de = German;
  var de = fp.l10ns;

  exports.German = German;
  exports.default = de;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
});

createCommonjsModule(function (module, exports) {
(function (global, factory) {
  factory(exports) ;
}(commonjsGlobal, (function (exports) {
  var fp = typeof window !== "undefined" && window.flatpickr !== undefined
      ? window.flatpickr
      : {
          l10ns: {},
      };
  var French = {
      firstDayOfWeek: 1,
      weekdays: {
          shorthand: ["dim", "lun", "mar", "mer", "jeu", "ven", "sam"],
          longhand: [
              "dimanche",
              "lundi",
              "mardi",
              "mercredi",
              "jeudi",
              "vendredi",
              "samedi",
          ],
      },
      months: {
          shorthand: [
              "janv",
              "févr",
              "mars",
              "avr",
              "mai",
              "juin",
              "juil",
              "août",
              "sept",
              "oct",
              "nov",
              "déc",
          ],
          longhand: [
              "janvier",
              "février",
              "mars",
              "avril",
              "mai",
              "juin",
              "juillet",
              "août",
              "septembre",
              "octobre",
              "novembre",
              "décembre",
          ],
      },
      ordinal: function (nth) {
          if (nth > 1)
              return "";
          return "er";
      },
      rangeSeparator: " au ",
      weekAbbreviation: "Sem",
      scrollTitle: "Défiler pour augmenter la valeur",
      toggleTitle: "Cliquer pour basculer",
      time_24hr: true,
  };
  fp.l10ns.fr = French;
  var fr = fp.l10ns;

  exports.French = French;
  exports.default = fr;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
});

createCommonjsModule(function (module, exports) {
(function (global, factory) {
  factory(exports) ;
}(commonjsGlobal, (function (exports) {
  var fp = typeof window !== "undefined" && window.flatpickr !== undefined
      ? window.flatpickr
      : {
          l10ns: {},
      };
  var Italian = {
      weekdays: {
          shorthand: ["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"],
          longhand: [
              "Domenica",
              "Lunedì",
              "Martedì",
              "Mercoledì",
              "Giovedì",
              "Venerdì",
              "Sabato",
          ],
      },
      months: {
          shorthand: [
              "Gen",
              "Feb",
              "Mar",
              "Apr",
              "Mag",
              "Giu",
              "Lug",
              "Ago",
              "Set",
              "Ott",
              "Nov",
              "Dic",
          ],
          longhand: [
              "Gennaio",
              "Febbraio",
              "Marzo",
              "Aprile",
              "Maggio",
              "Giugno",
              "Luglio",
              "Agosto",
              "Settembre",
              "Ottobre",
              "Novembre",
              "Dicembre",
          ],
      },
      firstDayOfWeek: 1,
      ordinal: function () { return "°"; },
      rangeSeparator: " al ",
      weekAbbreviation: "Se",
      scrollTitle: "Scrolla per aumentare",
      toggleTitle: "Clicca per cambiare",
      time_24hr: true,
  };
  fp.l10ns.it = Italian;
  var it = fp.l10ns;

  exports.Italian = Italian;
  exports.default = it;

  Object.defineProperty(exports, '__esModule', { value: true });

})));
});

const inputCss = "/*!@:root*/.sc-sdx-input:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-input-h,*.sc-sdx-input,*.sc-sdx-input:before,*.sc-sdx-input:after{box-sizing:border-box}/*!@.sr-only*/.sr-only.sc-sdx-input{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);border:0}/*!@.sr-only-focusable:active, .sr-only-focusable:focus*/.sr-only-focusable.sc-sdx-input:active,.sr-only-focusable.sc-sdx-input:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}/*!@label*/label.sc-sdx-input{display:block;margin-bottom:4px;cursor:inherit;color:#666;font-size:16px}/*!@label.readonly, label.disabled*/label.readonly.sc-sdx-input,label.disabled.sc-sdx-input{color:#bbb}/*!@label.sdx--dark-theme*/label.sdx--dark-theme.sc-sdx-input{color:#adadad}/*!@:host*/.sc-sdx-input-h{width:100%}/*!@.component:not(.readonly):not(.disabled):not(.invalid) .wrapper .input:hover:not(:focus)*/.component.sc-sdx-input:not(.readonly):not(.disabled):not(.invalid) .wrapper.sc-sdx-input .input.sc-sdx-input:hover:not(:focus){border-color:#333}/*!@.component:not(.readonly):not(.disabled):not(.invalid) .wrapper .input:hover:not(:focus) .badge*/.component.sc-sdx-input:not(.readonly):not(.disabled):not(.invalid) .wrapper.sc-sdx-input .input.sc-sdx-input:hover:not(:focus) .badge.sc-sdx-input{background-color:#0048cf}/*!@.component:focus-within.invalid sdx-validation-message*/.component.sc-sdx-input:focus-within.invalid sdx-validation-message.sc-sdx-input{display:none}/*!@.component.readonly .wrapper .input, .component.disabled .wrapper .input*/.component.readonly.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input,.component.disabled.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input{color:#bbb;border-color:#bbb;cursor:not-allowed}/*!@.component.readonly .wrapper .input::placeholder, .component.disabled .wrapper .input::placeholder*/.component.readonly.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input::placeholder,.component.disabled.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input::placeholder{color:#bbb}/*!@.component.valid .wrapper .input, .component.date .wrapper .input*/.component.valid.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input,.component.date.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input{padding-right:48px;min-width:152px}/*!@.component.invalid .wrapper .input*/.component.invalid.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input{color:#d12;border-color:#d12}/*!@.component:not(.readonly) .wrapper .input:focus*/.component.sc-sdx-input:not(.readonly) .wrapper.sc-sdx-input .input.sc-sdx-input:focus{border-color:#086adb}/*!@.component:not(.readonly) .wrapper .input:focus .badge*/.component.sc-sdx-input:not(.readonly) .wrapper.sc-sdx-input .input.sc-sdx-input:focus .badge.sc-sdx-input{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-weight:600;color:#fff;font-size:13px;max-width:50px;text-align:center;padding:0 5px;user-select:none;animation:badge 300ms linear both;background:#4294ff;pointer-events:none;transition:background 70ms cubic-bezier(0.4, 0, 0.6, 1);text-overflow:clip}@keyframes badge{0%{transform:scale(1)}25%{transform:scale(1.15)}50%{transform:scale(1)}75%{transform:scale(0.85)}100%{transform:scale(1)}}/*!@.component:not(.readonly) .wrapper .input:focus::placeholder*/.component.sc-sdx-input:not(.readonly) .wrapper.sc-sdx-input .input.sc-sdx-input:focus::placeholder{opacity:0}/*!@.component .wrapper*/.component.sc-sdx-input .wrapper.sc-sdx-input{position:relative}/*!@.component .wrapper.transition-active .input*/.component.sc-sdx-input .wrapper.transition-active.sc-sdx-input .input.sc-sdx-input{transition:all 150ms cubic-bezier(0.4, 0, 0.2, 1)}/*!@.component .wrapper .input*/.component.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input{border:1px solid #666;border-radius:5px;height:48px;padding:0 16px;line-height:24px;letter-spacing:-0.1px;font:inherit;font-size:18px;position:relative;outline:none;background-color:#fff;width:100%;color:#333;user-select:text;appearance:none;display:flex;align-items:center;caret-color:#086adb;cursor:inherit}/*!@.component .wrapper .input sdx-text-truncate*/.component.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input sdx-text-truncate.sc-sdx-input{min-width:0;width:auto}/*!@.component .wrapper .input .badge*/.component.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input .badge.sc-sdx-input{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;font-weight:600;border-radius:24px;color:#fff;font-size:13px;height:24px;line-height:24px;min-width:24px;max-width:50px;text-align:center;padding:0 5px;user-select:none;animation:badge 300ms linear both;background:#086adb;pointer-events:none;transition:background 70ms cubic-bezier(0.4, 0, 0.6, 1);margin-left:16px;text-overflow:clip}@keyframes badge{0%{transform:scale(1)}25%{transform:scale(1.15)}50%{transform:scale(1)}75%{transform:scale(0.85)}100%{transform:scale(1)}}/*!@.component .wrapper .input .badge:empty*/.component.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input .badge.sc-sdx-input:empty{visibility:hidden}/*!@.component .wrapper .input::placeholder*/.component.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input::placeholder{color:#858585;transition:inherit}/*!@.component .wrapper .input::-ms-clear*/.component.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input::-ms-clear{display:none}/*!@.component .wrapper .input:required, .component .wrapper .input:invalid*/.component.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input:required,.component.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input:invalid{box-shadow:none}/*!@.component .wrapper .input[type=search]*/.component.sc-sdx-input .wrapper.sc-sdx-input .input[type=search].sc-sdx-input{-webkit-appearance:none}/*!@.component .wrapper .input[type=search]::-webkit-search-cancel-button, .component .wrapper .input[type=search]::-webkit-search-decoration*/.component.sc-sdx-input .wrapper.sc-sdx-input .input[type=search].sc-sdx-input::-webkit-search-cancel-button,.component.sc-sdx-input .wrapper.sc-sdx-input .input[type=search].sc-sdx-input::-webkit-search-decoration{-webkit-appearance:none}/*!@.component .wrapper .input[type=number]*/.component.sc-sdx-input .wrapper.sc-sdx-input .input[type=number].sc-sdx-input{-moz-appearance:textfield}/*!@.component .wrapper .input[type=number]::-webkit-inner-spin-button, .component .wrapper .input[type=number]::-webkit-outer-spin-button*/.component.sc-sdx-input .wrapper.sc-sdx-input .input[type=number].sc-sdx-input::-webkit-inner-spin-button,.component.sc-sdx-input .wrapper.sc-sdx-input .input[type=number].sc-sdx-input::-webkit-outer-spin-button{-webkit-appearance:none;margin:0}/*!@.component .wrapper .input[data-input]::-webkit-calendar-picker-indicator*/.component.sc-sdx-input .wrapper.sc-sdx-input .input[data-input].sc-sdx-input::-webkit-calendar-picker-indicator{display:none}/*!@.component .wrapper .input.textarea*/.component.sc-sdx-input .wrapper.sc-sdx-input .input.textarea.sc-sdx-input{padding-top:11px;padding-bottom:11px;resize:none;line-height:24px}/*!@.component .wrapper .clear-button*/.component.sc-sdx-input .wrapper.sc-sdx-input .clear-button.sc-sdx-input{position:absolute;top:0;right:0;padding:12px 14px}/*!@.component .wrapper .calendar-button*/.component.sc-sdx-input .wrapper.sc-sdx-input .calendar-button.sc-sdx-input{position:absolute;top:0;right:0;padding:6px}/*!@.component .wrapper .checkmark-icon*/.component.sc-sdx-input .wrapper.sc-sdx-input .checkmark-icon.sc-sdx-input{position:absolute;top:8px;right:8px;color:#1b8712}/*!@.component label*/.component.sc-sdx-input label.sc-sdx-input{display:flex;justify-content:space-between}/*!@.component label .textarea-counter*/.component.sc-sdx-input label.sc-sdx-input .textarea-counter.sc-sdx-input{margin-left:8px}/*!@.component.sdx--dark-theme:not(.readonly):not(.disabled):not(.invalid) .wrapper .input:hover:not(:focus)*/.component.sdx--dark-theme.sc-sdx-input:not(.readonly):not(.disabled):not(.invalid) .wrapper.sc-sdx-input .input.sc-sdx-input:hover:not(:focus){border-color:#d6d6d6}/*!@.component.sdx--dark-theme:not(.readonly):not(.disabled):not(.invalid) .wrapper .input:hover:not(:focus) .badge*/.component.sdx--dark-theme.sc-sdx-input:not(.readonly):not(.disabled):not(.invalid) .wrapper.sc-sdx-input .input.sc-sdx-input:hover:not(:focus) .badge.sc-sdx-input{background-color:#4294ff}/*!@.component.sdx--dark-theme:not(.readonly) .wrapper .input:focus*/.component.sdx--dark-theme.sc-sdx-input:not(.readonly) .wrapper.sc-sdx-input .input.sc-sdx-input:focus{color:#e6e6e6;border-color:#4294ff}/*!@.component.sdx--dark-theme:not(.readonly) .wrapper .input:focus .badge*/.component.sdx--dark-theme.sc-sdx-input:not(.readonly) .wrapper.sc-sdx-input .input.sc-sdx-input:focus .badge.sc-sdx-input{background-color:#4294ff}/*!@.component.sdx--dark-theme.readonly .wrapper .input, .component.sdx--dark-theme.disabled .wrapper .input*/.component.sdx--dark-theme.readonly.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input,.component.sdx--dark-theme.disabled.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input{border-color:#5c5c5c}/*!@.component.sdx--dark-theme.readonly .wrapper .input::placeholder, .component.sdx--dark-theme.disabled .wrapper .input::placeholder*/.component.sdx--dark-theme.readonly.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input::placeholder,.component.sdx--dark-theme.disabled.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input::placeholder{color:#5c5c5c}/*!@.component.sdx--dark-theme.invalid .wrapper .input*/.component.sdx--dark-theme.invalid.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input{color:#f35d6a;border-color:#f35d6a}/*!@.component.sdx--dark-theme .wrapper .input*/.component.sdx--dark-theme.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input{border-color:#adadad;background-color:#1d1d1d;color:#e6e6e6;caret-color:#4294ff}/*!@.component.sdx--dark-theme .wrapper .input::placeholder*/.component.sdx--dark-theme.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input::placeholder{color:#8c8c8c}/*!@.component.sdx--dark-theme .wrapper .input .badge*/.component.sdx--dark-theme.sc-sdx-input .wrapper.sc-sdx-input .input.sc-sdx-input .badge.sc-sdx-input{background-color:#0a71e9}/*!@.component.sdx--dark-theme .wrapper .checkmark-icon*/.component.sdx--dark-theme.sc-sdx-input .wrapper.sc-sdx-input .checkmark-icon.sc-sdx-input{color:#21a716}";

class Input$1 {
  valueChanged() {
    var _a;
    if (!this.componentDidLoadComplete) {
      return;
    }
    this.valueDidUpdate = true;
    // Transfer value into flatpickr
    (_a = this.flatpickrInstance) === null || _a === void 0 ? void 0 : _a.setDate(this.value);
    this.updateHiddenFormInputEl();
    this.invokeChangeCallback(this.value);
  }
  nameChanged() {
    this.updateHiddenFormInputEl();
  }
  hitEnterCallbackChanged() {
    this.setInvokeHitEnterCallback();
  }
  changeCallbackChanged() {
    this.setInvokeChangeCallback();
  }
  inputCallbackChanged() {
    this.setInvokeInputCallback();
  }
  focusCallbackChanged() {
    this.setInvokeFocusCallback();
  }
  blurCallbackChanged() {
    this.setInvokeBlurCallback();
  }
  keyDownCallbackChanged() {
    this.setInvokeKeyDownCallback();
  }
  flatpickrOptionsChanged() {
    if (!this.componentDidLoadComplete) {
      return;
    }
    this.updateFlatpickrInstance();
  }
  // This is a workaround needed because of a possible bug in ngModel:
  // It might be this bug: https://github.com/angular/angular/issues/13792
  // Without the workaround, this happens (testable in sdx-angular-example-deprecated):
  // End user types "asdf":
  // - changeCallback("asdf") --> correct
  // - [changeCallback]="onChange" executes onChange("asdf") --> correct
  // - ngModel="name" --> "asd" incorrect, the last letter is missing?
  onFocus() {
    forceUpdate$1(this.el);
  }
  onKeyDown(e) {
    this.onInputElKeyDown(e);
  }
  onClick() {
    this.openDatePicker(true);
  }
  onWindowResize() {
    if (this.type !== "date" || !this.getParsedFlatpickrOptions().weekNumbers) {
      return;
    }
    clearTimeout(this.resizeTimer);
    this.resizeTimer = setTimeout(() => {
      var _a;
      const isOpen = (_a = this.flatpickrInstance) === null || _a === void 0 ? void 0 : _a.isOpen;
      // Workaround to fix calendar width
      this.updateFlatpickrInstance();
      if (isOpen) {
        this.openDatePicker();
      }
    }, 100);
  }
  async doFocus() {
    var _a;
    (_a = this.inputEl) === null || _a === void 0 ? void 0 : _a.focus();
  }
  async doBlur() {
    var _a;
    (_a = this.inputEl) === null || _a === void 0 ? void 0 : _a.blur();
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.uniqueId = uniqueId();
    this.invokeHitEnterCallback = () => null;
    this.invokeChangeCallback = () => null;
    this.invokeInputCallback = () => null;
    this.invokeFocusCallback = () => null;
    this.invokeBlurCallback = () => null;
    this.invokeKeyDownCallback = () => null;
    this.componentDidLoadComplete = false;
    this.valueDidUpdate = false;
    this.hasInputElFocus = false;
    this.srHint = "";
    this.hitEnterCallback = undefined;
    this.changeCallback = undefined;
    this.inputCallback = undefined;
    this.focusCallback = undefined;
    this.blurCallback = undefined;
    this.keyDownCallback = undefined;
    this.placeholder = "";
    this.type = "text";
    this.value = "";
    this.selectTextOnFocus = false;
    this.readonly = false;
    this.disabled = false;
    this.label = "";
    this.maxlength = undefined;
    this.flatpickrOptions = undefined;
    this.name = undefined;
    this.valid = undefined;
    this.validationMessage = undefined;
    this.required = false;
    this.autofocus = false;
    this.inputmode = undefined;
    this.clearable = false;
    this.editable = true;
    this.inputStyle = {};
    this.clearButtonStyle = {};
    this.badge = "";
    this.positionDatePicker = this.positionDatePicker.bind(this);
    this.setInvokeHitEnterCallback();
    this.setInvokeChangeCallback();
    this.setInvokeInputCallback();
    this.setInvokeFocusCallback();
    this.setInvokeBlurCallback();
    this.setInvokeKeyDownCallback();
    this.updateHiddenFormInputEl();
  }
  componentDidLoad() {
    this.updateFlatpickrInstance();
    this.updateHeight();
    if (this.autofocus) {
      // timeout because of https://github.com/ionic-team/stencil/issues/3246
      setTimeout(() => {
        this.doFocus();
      });
    }
    // give browser time to apply initial height to prevent initial animation
    setTimeout(() => { var _a; return (_a = this.wrapperEl) === null || _a === void 0 ? void 0 : _a.classList.add("transition-active"); });
    this.componentDidLoadComplete = true;
  }
  componentDidRender() {
    this.updateInputElValueIfOutOfSync();
  }
  componentDidUpdate() {
    if (this.valueDidUpdate) {
      this.updateHeight();
      this.valueDidUpdate = false;
    }
  }
  onInputElKeyPress(e) {
    const keyboardEvent = e;
    if (keyboardEvent.key === "Enter") {
      this.invokeHitEnterCallback();
    }
  }
  onInputElKeyDown(e) {
    const keyboardEvent = e;
    if (keyboardEvent.key === "Enter" || keyboardEvent.key === "ArrowDown") {
      this.openDatePicker();
    }
    this.invokeKeyDownCallback(e);
  }
  focusDatePicker() {
    var _a, _b;
    // focus to enable keyboard navigation
    const today = (_a = this.flatpickrInstance) === null || _a === void 0 ? void 0 : _a.calendarContainer.querySelector(".flatpickr-day.today");
    const selected = (_b = this.flatpickrInstance) === null || _b === void 0 ? void 0 : _b.calendarContainer.querySelector(".flatpickr-day.selected");
    selected ? selected.focus() : today.focus();
  }
  openDatePicker(withoutFocus) {
    if (!this.flatpickrInstance) {
      return;
    }
    if (this.flatpickrInstance.isOpen) {
      !withoutFocus && this.focusDatePicker();
      return;
    }
    this.flatpickrInstance.open();
    !withoutFocus && this.focusDatePicker();
    if (this.scrollContainerEl) {
      // TODO remove this after SDX-941 (date picker optimizations)
      // Forces repositioning of Flatpickr to make sure it "sticks" to the
      // input field. The event isn't removed because it exists only once per
      // sdx-input.
      this.scrollContainerEl.addEventListener("scroll", this.positionDatePicker);
    }
  }
  positionDatePicker() {
    var _a;
    (_a = this.flatpickrInstance) === null || _a === void 0 ? void 0 : _a._positionCalendar();
  }
  onInputElInput(e) {
    const value = e.target.value;
    this.invokeInputCallback(value);
  }
  // Used when "inputCallback" prop is provided
  customInputCallback(value) {
    parseFunction(this.inputCallback)(value);
    // After invoking the above callback, "this.value" is now updated.
    // If it holds another value than what the user has typed, overwrite
    // that users input with "this.value".
    // However, this is only possible *after* render, therefore a rerender is triggered.
    if (this.value !== value) {
      forceUpdate$1(this.el);
    }
  }
  // Used when *no* "inputCallback" prop is provided
  defaultInputCallback(value) {
    this.value = value;
  }
  setInvokeHitEnterCallback() {
    this.invokeHitEnterCallback = parseFunction(this.hitEnterCallback);
  }
  setInvokeChangeCallback() {
    this.invokeChangeCallback = parseFunction(this.changeCallback);
  }
  setInvokeInputCallback() {
    if (this.inputCallback) {
      this.invokeInputCallback = this.customInputCallback;
    }
    else {
      this.invokeInputCallback = this.defaultInputCallback;
    }
  }
  setInvokeFocusCallback() {
    this.invokeFocusCallback = parseFunction(this.focusCallback);
  }
  setInvokeBlurCallback() {
    this.invokeBlurCallback = parseFunction(this.blurCallback);
  }
  setInvokeKeyDownCallback() {
    this.invokeKeyDownCallback = parseFunction(this.keyDownCallback);
  }
  onInputElFocus() {
    this.hasInputElFocus = true;
    // Readonly input fields can receive focus, but their height shouldn't change
    if (!this.readonly) {
      this.updateHeight();
    }
    if (this.selectTextOnFocus) {
      this.selectText();
    }
    this.invokeFocusCallback();
  }
  onInputElBlur() {
    this.hasInputElFocus = false;
    this.updateHeight();
    this.invokeBlurCallback();
  }
  selectText() {
    setTimeout(() => {
      if (!this.isInputElement(this.inputEl)) {
        return;
      }
      this.inputEl.setSelectionRange(0, this.inputEl.value.length);
    });
  }
  /**
   * Calculate and set the autocomplete height.
   * If it's empty and focussed, it should grow.
   * If it's still empty not focussed anymore, it should shrink back.
   * If it has content, it should shrink or grow based on the content (within
   * a certain range).
   */
  updateHeight() {
    // Only change the height of textarea
    if (this.type !== "textarea") {
      return;
    }
    const inputEl = this.inputEl;
    const paddingVertical = getNumericValue("padding-top", inputEl) +
      getNumericValue("padding-bottom", inputEl);
    const lineHeight = getNumericValue("line-height", inputEl);
    const border = getNumericValue("border-top-width", inputEl) +
      getNumericValue("border-bottom-width", inputEl);
    const focussedHeight = paddingVertical + border + lineHeight * 4; // with focus, without content
    const maxHeight = paddingVertical + border + lineHeight * 10; // maximum height with content
    let newHeight = paddingVertical + border + lineHeight * 2; // initial height
    // Scrolling is disabled by default
    inputEl.style.overflow = "hidden";
    if (this.value) {
      // Shortly set the height to the current text content to take measurements
      inputEl.style.height = "auto";
      const newHeightBasedOnContent = inputEl.scrollHeight + border + lineHeight;
      // Activate scrolling if max height has been reached
      if (newHeightBasedOnContent > maxHeight) {
        inputEl.style.overflow = "auto";
      }
      newHeight = Math.min(Math.max(focussedHeight, newHeightBasedOnContent), maxHeight);
    }
    else {
      if (this.hasInputElFocus) {
        newHeight = focussedHeight;
      }
    }
    inputEl.style.height = `${newHeight}px`;
  }
  updateHiddenFormInputEl() {
    if (!this.lightDOMHiddenFormInputEl) {
      this.lightDOMHiddenFormInputEl = document.createElement("input");
      this.lightDOMHiddenFormInputEl.type = "hidden";
      this.el.append(this.lightDOMHiddenFormInputEl);
    }
    // Clean up properties added previously in case they've changed
    this.lightDOMHiddenFormInputEl.removeAttribute("name");
    this.lightDOMHiddenFormInputEl.removeAttribute("value");
    if (this.name) {
      this.lightDOMHiddenFormInputEl.name = this.name;
      this.lightDOMHiddenFormInputEl.value = this.value;
    }
  }
  // Make sure the inputEl never has its "own" state but reflects "this.value".
  updateInputElValueIfOutOfSync() {
    if (this.isInputElement(this.inputEl) &&
      this.value !== this.inputEl.value) {
      // Just update the value if something has changed to avoid setting "" in
      // case inputEl has an invalid value.
      this.inputEl.value = this.value || "";
    }
  }
  isInputElement(el) {
    return !isNil(el) && "value" in el;
  }
  updateFlatpickrInstance() {
    var _a, _b;
    if (this.type === "date") {
      this.scrollContainerEl = getScrollContainerEl(this.el);
      const flatpickrOptions = {
        wrap: true,
        allowInput: true,
        locale: "de",
        dateFormat: "d.m.Y",
        time_24hr: true,
        clickOpens: false,
        monthSelectorType: "static",
        ...this.getParsedFlatpickrOptions(),
        // these attributes should not be overwritten by consumer:
        onChange: () => {
          // wait till flatpickr updated the input value
          setTimeout(() => dispatchEvent(this.el, Input$1.eventInput));
        },
        defaultDate: this.value,
      };
      this.flatpickrInstance = flatpickr(this.inputEl.parentElement, // { wrap: true } needs access to [data-input]
      flatpickrOptions);
      // copy some important attributes to altInput field
      if (flatpickrOptions.altInput) {
        for (let prop of Object.entries(this.getAltInputProps())) {
          const [propName, propValue] = prop;
          (_b = (_a = this.flatpickrInstance) === null || _a === void 0 ? void 0 : _a.altInput) === null || _b === void 0 ? void 0 : _b.setAttribute(propName, propValue.toString());
        }
      }
    }
  }
  clear() {
    this.value = "";
    dispatchEvent(this.el, Input$1.eventInput);
  }
  isClearable() {
    return this.clearable && this.editable;
  }
  isClearIconDisplayed() {
    return this.isClearable() && !!this.value;
  }
  createLabel() {
    const { value, maxlength, uniqueId, label, required } = this;
    let counterEl;
    if (this.type === "textarea" && maxlength) {
      const valueLength = value ? value.length : 0;
      counterEl = (hAsync(Fragment, null, hAsync("span", { "aria-hidden": "true", class: "textarea-counter" }, valueLength, "/", maxlength), hAsync("span", { role: "status", class: "sr-only" }, maxlength - valueLength, " characters left.")));
    }
    if (label || counterEl) {
      return (hAsync("label", { class: this.getLabelClassNames(), htmlFor: uniqueId }, hAsync("span", null, label, required && hAsync("span", { "aria-hidden": "true" }, "\u00A0*")), counterEl));
    }
  }
  getInputStyle() {
    if (this.isClearIconDisplayed()) {
      const paddingRight = parseFloat(this.inputStyle.paddingRight) || 0;
      return {
        ...this.inputStyle,
        paddingRight: `${paddingRight + 40}px`, // $baseline-5
      };
    }
    return this.inputStyle;
  }
  // needed for flatpickr altInput feature
  getAltInputProps() {
    return {
      autoCorrect: "off",
      autoCapitalize: "off",
      spellcheck: false,
      size: 1,
      "aria-invalid": `${this.valid === false}`,
      "aria-label": this.srHint,
      "aria-describedby": "additional-information",
      "aria-placeholder": "", // prevent sr from reading out as it's not helpful for blind people
    };
  }
  getInputProps() {
    return {
      id: this.uniqueId,
      name: this.name,
      class: "input",
      placeholder: this.placeholder,
      maxLength: this.maxlength,
      style: this.getInputStyle(),
      required: this.required,
      disabled: this.disabled,
      readonly: this.readonly,
      ...this.getAltInputProps(),
      onInput: (e) => this.onInputElInput(e),
      onKeyPress: (e) => this.onInputElKeyPress(e),
      onFocus: () => this.onInputElFocus(),
      onBlur: () => this.onInputElBlur(),
      ref: (el) => (this.inputEl = el),
    };
  }
  getLabelClassNames() {
    return {
      label: true,
      [getAppearance(this.el)]: true,
      readonly: this.readonly,
      disabled: this.disabled,
    };
  }
  getComponentClassNames() {
    return {
      component: true,
      [this.type]: true,
      [getAppearance(this.el)]: true,
      readonly: this.readonly,
      disabled: this.disabled,
      editable: this.editable,
      clearable: this.clearable,
      valid: this.valid === true,
      invalid: this.valid === false,
    };
  }
  createInputField() {
    return (hAsync(Fragment, null, this.editable && (hAsync("input", { ...this.getInputProps(), type: this.type, inputmode: this.inputmode })), this.isClearable() && (hAsync("div", { style: this.clearButtonStyle, class: "clear-button" }, hAsync("sdx-animation", { animationName: this.isClearIconDisplayed() ? "scale-in" : "scale-out" }, hAsync("sdx-button", { theme: "transparent", onClick: () => this.clear(), iconName: "icon-close", "aria-hidden": "true" })))), !this.editable && (hAsync("div", { class: "input", style: this.inputStyle, tabIndex: this.disabled ? undefined : 0, ref: (el) => (this.inputEl = el) }, hAsync("sdx-text-truncate", null, this.value), hAsync("span", { class: "badge" }, this.badge))), this.editable && this.valid && (hAsync("sdx-icon", { class: "checkmark-icon", iconName: "icon-check-mark", size: 3 }))));
  }
  createNumberInputField() {
    return hAsync("input", { ...this.getInputProps(), type: "number" });
  }
  createDateInputField() {
    return (hAsync(Fragment, null, hAsync("input", { ...this.getInputProps(), "data-input": true }), hAsync("sdx-button", { tabindex: "-1", class: "calendar-button", theme: "transparent", srHint: "Calendar", iconName: "icon-calendar", iconSize: 3, disabled: this.disabled || this.readonly, valid: !(this.valid === false && !this.hasInputElFocus), onClick: () => this.openDatePicker() })));
  }
  createTextArea() {
    return hAsync("textarea", { ...this.getInputProps(), class: "input textarea" });
  }
  /**
   * Parses and returns the flatpickrOptions prop.
   */
  getParsedFlatpickrOptions() {
    let flatpickrOptions = {};
    if (this.flatpickrOptions) {
      if (typeof this.flatpickrOptions === "string") {
        flatpickrOptions = JSON.parse(this.flatpickrOptions);
      }
      else {
        // assume it's a valid flatpickr options object
        flatpickrOptions = this.flatpickrOptions;
      }
    }
    return flatpickrOptions;
  }
  render() {
    return (hAsync("div", { class: this.getComponentClassNames() }, this.createLabel(), hAsync("div", { class: "wrapper", ref: (el) => (this.wrapperEl = el) }, (() => {
      switch (this.type) {
        case "textarea":
          return this.createTextArea();
        case "date":
          return this.createDateInputField();
        case "number":
          return this.createNumberInputField();
        default:
          return this.createInputField();
      }
    })()), hAsync("div", { id: "additional-information" }, this.validationMessage && (hAsync(Fragment, null, hAsync("span", { class: "sr-only" }, this.validationMessage), hAsync("sdx-validation-message", { validationMessage: this.validationMessage, "aria-hidden": "true" }))))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "value": ["valueChanged"],
    "name": ["nameChanged"],
    "hitEnterCallback": ["hitEnterCallbackChanged"],
    "changeCallback": ["changeCallbackChanged"],
    "inputCallback": ["inputCallbackChanged"],
    "focusCallback": ["focusCallbackChanged"],
    "blurCallback": ["blurCallbackChanged"],
    "keyDownCallback": ["keyDownCallbackChanged"],
    "flatpickrOptions": ["flatpickrOptionsChanged"]
  }; }
  static get style() { return inputCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-input",
    "$members$": {
      "srHint": [1, "sr-hint"],
      "hitEnterCallback": [1, "hit-enter-callback"],
      "changeCallback": [1, "change-callback"],
      "inputCallback": [1, "input-callback"],
      "focusCallback": [1, "focus-callback"],
      "blurCallback": [1, "blur-callback"],
      "keyDownCallback": [1, "key-down-callback"],
      "placeholder": [1],
      "type": [1],
      "value": [1025],
      "selectTextOnFocus": [4, "select-text-on-focus"],
      "readonly": [4],
      "disabled": [4],
      "label": [1],
      "maxlength": [2],
      "flatpickrOptions": [8, "flatpickr-options"],
      "name": [1],
      "valid": [4],
      "validationMessage": [1, "validation-message"],
      "required": [4],
      "autofocus": [4],
      "inputmode": [1],
      "clearable": [4],
      "editable": [4],
      "inputStyle": [16],
      "clearButtonStyle": [16],
      "badge": [1],
      "hasInputElFocus": [32],
      "doFocus": [64],
      "doBlur": [64]
    },
    "$listeners$": [[2, "focus", "onFocus"], [0, "keydown", "onKeyDown"], [0, "click", "onClick"], [9, "resize", "onWindowResize"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}
/**
 * Emitted whenever user is typing or clearing/changing the input.
 * @event
 */
Input$1.eventInput = "input";

var formatDistanceLocale = {
  lessThanXSeconds: {
    one: 'less than a second',
    other: 'less than {{count}} seconds'
  },
  xSeconds: {
    one: '1 second',
    other: '{{count}} seconds'
  },
  halfAMinute: 'half a minute',
  lessThanXMinutes: {
    one: 'less than a minute',
    other: 'less than {{count}} minutes'
  },
  xMinutes: {
    one: '1 minute',
    other: '{{count}} minutes'
  },
  aboutXHours: {
    one: 'about 1 hour',
    other: 'about {{count}} hours'
  },
  xHours: {
    one: '1 hour',
    other: '{{count}} hours'
  },
  xDays: {
    one: '1 day',
    other: '{{count}} days'
  },
  aboutXWeeks: {
    one: 'about 1 week',
    other: 'about {{count}} weeks'
  },
  xWeeks: {
    one: '1 week',
    other: '{{count}} weeks'
  },
  aboutXMonths: {
    one: 'about 1 month',
    other: 'about {{count}} months'
  },
  xMonths: {
    one: '1 month',
    other: '{{count}} months'
  },
  aboutXYears: {
    one: 'about 1 year',
    other: 'about {{count}} years'
  },
  xYears: {
    one: '1 year',
    other: '{{count}} years'
  },
  overXYears: {
    one: 'over 1 year',
    other: 'over {{count}} years'
  },
  almostXYears: {
    one: 'almost 1 year',
    other: 'almost {{count}} years'
  }
};

var formatDistance = function formatDistance(token, count, options) {
  var result;
  var tokenValue = formatDistanceLocale[token];

  if (typeof tokenValue === 'string') {
    result = tokenValue;
  } else if (count === 1) {
    result = tokenValue.one;
  } else {
    result = tokenValue.other.replace('{{count}}', count.toString());
  }

  if (options !== null && options !== void 0 && options.addSuffix) {
    if (options.comparison && options.comparison > 0) {
      return 'in ' + result;
    } else {
      return result + ' ago';
    }
  }

  return result;
};

function buildFormatLongFn(args) {
  return function () {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    // TODO: Remove String()
    var width = options.width ? String(options.width) : args.defaultWidth;
    var format = args.formats[width] || args.formats[args.defaultWidth];
    return format;
  };
}

var dateFormats = {
  full: 'EEEE, MMMM do, y',
  long: 'MMMM do, y',
  medium: 'MMM d, y',
  short: 'MM/dd/yyyy'
};
var timeFormats = {
  full: 'h:mm:ss a zzzz',
  long: 'h:mm:ss a z',
  medium: 'h:mm:ss a',
  short: 'h:mm a'
};
var dateTimeFormats = {
  full: "{{date}} 'at' {{time}}",
  long: "{{date}} 'at' {{time}}",
  medium: '{{date}}, {{time}}',
  short: '{{date}}, {{time}}'
};
var formatLong = {
  date: buildFormatLongFn({
    formats: dateFormats,
    defaultWidth: 'full'
  }),
  time: buildFormatLongFn({
    formats: timeFormats,
    defaultWidth: 'full'
  }),
  dateTime: buildFormatLongFn({
    formats: dateTimeFormats,
    defaultWidth: 'full'
  })
};

var formatRelativeLocale = {
  lastWeek: "'last' eeee 'at' p",
  yesterday: "'yesterday at' p",
  today: "'today at' p",
  tomorrow: "'tomorrow at' p",
  nextWeek: "eeee 'at' p",
  other: 'P'
};

var formatRelative = function formatRelative(token, _date, _baseDate, _options) {
  return formatRelativeLocale[token];
};

function buildLocalizeFn(args) {
  return function (dirtyIndex, options) {
    var context = options !== null && options !== void 0 && options.context ? String(options.context) : 'standalone';
    var valuesArray;

    if (context === 'formatting' && args.formattingValues) {
      var defaultWidth = args.defaultFormattingWidth || args.defaultWidth;
      var width = options !== null && options !== void 0 && options.width ? String(options.width) : defaultWidth;
      valuesArray = args.formattingValues[width] || args.formattingValues[defaultWidth];
    } else {
      var _defaultWidth = args.defaultWidth;

      var _width = options !== null && options !== void 0 && options.width ? String(options.width) : args.defaultWidth;

      valuesArray = args.values[_width] || args.values[_defaultWidth];
    }

    var index = args.argumentCallback ? args.argumentCallback(dirtyIndex) : dirtyIndex; // @ts-ignore: For some reason TypeScript just don't want to match it, no matter how hard we try. I challenge you to try to remove it!

    return valuesArray[index];
  };
}

var eraValues = {
  narrow: ['B', 'A'],
  abbreviated: ['BC', 'AD'],
  wide: ['Before Christ', 'Anno Domini']
};
var quarterValues = {
  narrow: ['1', '2', '3', '4'],
  abbreviated: ['Q1', 'Q2', 'Q3', 'Q4'],
  wide: ['1st quarter', '2nd quarter', '3rd quarter', '4th quarter']
}; // Note: in English, the names of days of the week and months are capitalized.
// If you are making a new locale based on this one, check if the same is true for the language you're working on.
// Generally, formatted dates should look like they are in the middle of a sentence,
// e.g. in Spanish language the weekdays and months should be in the lowercase.

var monthValues = {
  narrow: ['J', 'F', 'M', 'A', 'M', 'J', 'J', 'A', 'S', 'O', 'N', 'D'],
  abbreviated: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
  wide: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December']
};
var dayValues = {
  narrow: ['S', 'M', 'T', 'W', 'T', 'F', 'S'],
  short: ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'],
  abbreviated: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
  wide: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday']
};
var dayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'morning',
    afternoon: 'afternoon',
    evening: 'evening',
    night: 'night'
  }
};
var formattingDayPeriodValues = {
  narrow: {
    am: 'a',
    pm: 'p',
    midnight: 'mi',
    noon: 'n',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  abbreviated: {
    am: 'AM',
    pm: 'PM',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  },
  wide: {
    am: 'a.m.',
    pm: 'p.m.',
    midnight: 'midnight',
    noon: 'noon',
    morning: 'in the morning',
    afternoon: 'in the afternoon',
    evening: 'in the evening',
    night: 'at night'
  }
};

var ordinalNumber = function ordinalNumber(dirtyNumber, _options) {
  var number = Number(dirtyNumber); // If ordinal numbers depend on context, for example,
  // if they are different for different grammatical genders,
  // use `options.unit`.
  //
  // `unit` can be 'year', 'quarter', 'month', 'week', 'date', 'dayOfYear',
  // 'day', 'hour', 'minute', 'second'.

  var rem100 = number % 100;

  if (rem100 > 20 || rem100 < 10) {
    switch (rem100 % 10) {
      case 1:
        return number + 'st';

      case 2:
        return number + 'nd';

      case 3:
        return number + 'rd';
    }
  }

  return number + 'th';
};

var localize = {
  ordinalNumber: ordinalNumber,
  era: buildLocalizeFn({
    values: eraValues,
    defaultWidth: 'wide'
  }),
  quarter: buildLocalizeFn({
    values: quarterValues,
    defaultWidth: 'wide',
    argumentCallback: function argumentCallback(quarter) {
      return quarter - 1;
    }
  }),
  month: buildLocalizeFn({
    values: monthValues,
    defaultWidth: 'wide'
  }),
  day: buildLocalizeFn({
    values: dayValues,
    defaultWidth: 'wide'
  }),
  dayPeriod: buildLocalizeFn({
    values: dayPeriodValues,
    defaultWidth: 'wide',
    formattingValues: formattingDayPeriodValues,
    defaultFormattingWidth: 'wide'
  })
};

function buildMatchFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var width = options.width;
    var matchPattern = width && args.matchPatterns[width] || args.matchPatterns[args.defaultMatchWidth];
    var matchResult = string.match(matchPattern);

    if (!matchResult) {
      return null;
    }

    var matchedString = matchResult[0];
    var parsePatterns = width && args.parsePatterns[width] || args.parsePatterns[args.defaultParseWidth];
    var key = Array.isArray(parsePatterns) ? findIndex(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    }) : findKey(parsePatterns, function (pattern) {
      return pattern.test(matchedString);
    });
    var value;
    value = args.valueCallback ? args.valueCallback(key) : key;
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

function findKey(object, predicate) {
  for (var key in object) {
    if (object.hasOwnProperty(key) && predicate(object[key])) {
      return key;
    }
  }

  return undefined;
}

function findIndex(array, predicate) {
  for (var key = 0; key < array.length; key++) {
    if (predicate(array[key])) {
      return key;
    }
  }

  return undefined;
}

function buildMatchPatternFn(args) {
  return function (string) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var matchResult = string.match(args.matchPattern);
    if (!matchResult) return null;
    var matchedString = matchResult[0];
    var parseResult = string.match(args.parsePattern);
    if (!parseResult) return null;
    var value = args.valueCallback ? args.valueCallback(parseResult[0]) : parseResult[0];
    value = options.valueCallback ? options.valueCallback(value) : value;
    var rest = string.slice(matchedString.length);
    return {
      value: value,
      rest: rest
    };
  };
}

var matchOrdinalNumberPattern = /^(\d+)(th|st|nd|rd)?/i;
var parseOrdinalNumberPattern = /\d+/i;
var matchEraPatterns = {
  narrow: /^(b|a)/i,
  abbreviated: /^(b\.?\s?c\.?|b\.?\s?c\.?\s?e\.?|a\.?\s?d\.?|c\.?\s?e\.?)/i,
  wide: /^(before christ|before common era|anno domini|common era)/i
};
var parseEraPatterns = {
  any: [/^b/i, /^(a|c)/i]
};
var matchQuarterPatterns = {
  narrow: /^[1234]/i,
  abbreviated: /^q[1234]/i,
  wide: /^[1234](th|st|nd|rd)? quarter/i
};
var parseQuarterPatterns = {
  any: [/1/i, /2/i, /3/i, /4/i]
};
var matchMonthPatterns = {
  narrow: /^[jfmasond]/i,
  abbreviated: /^(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec)/i,
  wide: /^(january|february|march|april|may|june|july|august|september|october|november|december)/i
};
var parseMonthPatterns = {
  narrow: [/^j/i, /^f/i, /^m/i, /^a/i, /^m/i, /^j/i, /^j/i, /^a/i, /^s/i, /^o/i, /^n/i, /^d/i],
  any: [/^ja/i, /^f/i, /^mar/i, /^ap/i, /^may/i, /^jun/i, /^jul/i, /^au/i, /^s/i, /^o/i, /^n/i, /^d/i]
};
var matchDayPatterns = {
  narrow: /^[smtwf]/i,
  short: /^(su|mo|tu|we|th|fr|sa)/i,
  abbreviated: /^(sun|mon|tue|wed|thu|fri|sat)/i,
  wide: /^(sunday|monday|tuesday|wednesday|thursday|friday|saturday)/i
};
var parseDayPatterns = {
  narrow: [/^s/i, /^m/i, /^t/i, /^w/i, /^t/i, /^f/i, /^s/i],
  any: [/^su/i, /^m/i, /^tu/i, /^w/i, /^th/i, /^f/i, /^sa/i]
};
var matchDayPeriodPatterns = {
  narrow: /^(a|p|mi|n|(in the|at) (morning|afternoon|evening|night))/i,
  any: /^([ap]\.?\s?m\.?|midnight|noon|(in the|at) (morning|afternoon|evening|night))/i
};
var parseDayPeriodPatterns = {
  any: {
    am: /^a/i,
    pm: /^p/i,
    midnight: /^mi/i,
    noon: /^no/i,
    morning: /morning/i,
    afternoon: /afternoon/i,
    evening: /evening/i,
    night: /night/i
  }
};
var match = {
  ordinalNumber: buildMatchPatternFn({
    matchPattern: matchOrdinalNumberPattern,
    parsePattern: parseOrdinalNumberPattern,
    valueCallback: function valueCallback(value) {
      return parseInt(value, 10);
    }
  }),
  era: buildMatchFn({
    matchPatterns: matchEraPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseEraPatterns,
    defaultParseWidth: 'any'
  }),
  quarter: buildMatchFn({
    matchPatterns: matchQuarterPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseQuarterPatterns,
    defaultParseWidth: 'any',
    valueCallback: function valueCallback(index) {
      return index + 1;
    }
  }),
  month: buildMatchFn({
    matchPatterns: matchMonthPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseMonthPatterns,
    defaultParseWidth: 'any'
  }),
  day: buildMatchFn({
    matchPatterns: matchDayPatterns,
    defaultMatchWidth: 'wide',
    parsePatterns: parseDayPatterns,
    defaultParseWidth: 'any'
  }),
  dayPeriod: buildMatchFn({
    matchPatterns: matchDayPeriodPatterns,
    defaultMatchWidth: 'any',
    parsePatterns: parseDayPeriodPatterns,
    defaultParseWidth: 'any'
  })
};

/**
 * @type {Locale}
 * @category Locales
 * @summary English locale (United States).
 * @language English
 * @iso-639-2 eng
 * @author Sasha Koss [@kossnocorp]{@link https://github.com/kossnocorp}
 * @author Lesha Koss [@leshakoss]{@link https://github.com/leshakoss}
 */
var locale = {
  code: 'en-US',
  formatDistance: formatDistance,
  formatLong: formatLong,
  formatRelative: formatRelative,
  localize: localize,
  match: match,
  options: {
    weekStartsOn: 0
    /* Sunday */
    ,
    firstWeekContainsDate: 1
  }
};

function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }

  var number = Number(dirtyNumber);

  if (isNaN(number)) {
    return number;
  }

  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

function _typeof$y(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$y = function _typeof(obj) { return typeof obj; }; } else { _typeof$y = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$y(obj); }
/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */

function toDate(argument) {
  requiredArgs(1, arguments);
  var argStr = Object.prototype.toString.call(argument); // Clone the date

  if (argument instanceof Date || _typeof$y(argument) === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"); // eslint-disable-next-line no-console

      console.warn(new Error().stack);
    }

    return new Date(NaN);
  }
}

/**
 * @name addMilliseconds
 * @category Millisecond Helpers
 * @summary Add the specified number of milliseconds to the given date.
 *
 * @description
 * Add the specified number of milliseconds to the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be added. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds added
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Add 750 milliseconds to 10 July 2014 12:45:30.000:
 * const result = addMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:30.750
 */

function addMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var timestamp = toDate(dirtyDate).getTime();
  var amount = toInteger(dirtyAmount);
  return new Date(timestamp + amount);
}

/**
 * @name subMilliseconds
 * @category Millisecond Helpers
 * @summary Subtract the specified number of milliseconds from the given date.
 *
 * @description
 * Subtract the specified number of milliseconds from the given date.
 *
 * @param {Date|Number} date - the date to be changed
 * @param {Number} amount - the amount of milliseconds to be subtracted. Positive decimals will be rounded using `Math.floor`, decimals less than zero will be rounded using `Math.ceil`.
 * @returns {Date} the new date with the milliseconds subtracted
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Subtract 750 milliseconds from 10 July 2014 12:45:30.000:
 * const result = subMilliseconds(new Date(2014, 6, 10, 12, 45, 30, 0), 750)
 * //=> Thu Jul 10 2014 12:45:29.250
 */

function subMilliseconds(dirtyDate, dirtyAmount) {
  requiredArgs(2, arguments);
  var amount = toInteger(dirtyAmount);
  return addMilliseconds(dirtyDate, -amount);
}

function assign(target, object) {
  if (target == null) {
    throw new TypeError('assign requires that input parameter not be null or undefined');
  }

  for (var property in object) {
    if (Object.prototype.hasOwnProperty.call(object, property)) {
      target[property] = object[property];
    }
  }

  return target;
}

var dateLongFormatter = function dateLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'P':
      return formatLong.date({
        width: 'short'
      });

    case 'PP':
      return formatLong.date({
        width: 'medium'
      });

    case 'PPP':
      return formatLong.date({
        width: 'long'
      });

    case 'PPPP':
    default:
      return formatLong.date({
        width: 'full'
      });
  }
};

var timeLongFormatter = function timeLongFormatter(pattern, formatLong) {
  switch (pattern) {
    case 'p':
      return formatLong.time({
        width: 'short'
      });

    case 'pp':
      return formatLong.time({
        width: 'medium'
      });

    case 'ppp':
      return formatLong.time({
        width: 'long'
      });

    case 'pppp':
    default:
      return formatLong.time({
        width: 'full'
      });
  }
};

var dateTimeLongFormatter = function dateTimeLongFormatter(pattern, formatLong) {
  var matchResult = pattern.match(/(P+)(p+)?/) || [];
  var datePattern = matchResult[1];
  var timePattern = matchResult[2];

  if (!timePattern) {
    return dateLongFormatter(pattern, formatLong);
  }

  var dateTimeFormat;

  switch (datePattern) {
    case 'P':
      dateTimeFormat = formatLong.dateTime({
        width: 'short'
      });
      break;

    case 'PP':
      dateTimeFormat = formatLong.dateTime({
        width: 'medium'
      });
      break;

    case 'PPP':
      dateTimeFormat = formatLong.dateTime({
        width: 'long'
      });
      break;

    case 'PPPP':
    default:
      dateTimeFormat = formatLong.dateTime({
        width: 'full'
      });
      break;
  }

  return dateTimeFormat.replace('{{date}}', dateLongFormatter(datePattern, formatLong)).replace('{{time}}', timeLongFormatter(timePattern, formatLong));
};

var longFormatters = {
  p: timeLongFormatter,
  P: dateTimeLongFormatter
};

/**
 * Google Chrome as of 67.0.3396.87 introduced timezones with offset that includes seconds.
 * They usually appear for dates that denote time before the timezones were introduced
 * (e.g. for 'Europe/Prague' timezone the offset is GMT+00:57:44 before 1 October 1891
 * and GMT+01:00:00 after that date)
 *
 * Date#getTimezoneOffset returns the offset in minutes and would return 57 for the example above,
 * which would lead to incorrect calculations.
 *
 * This function returns the timezone offset in milliseconds that takes seconds in account.
 */
function getTimezoneOffsetInMilliseconds(date) {
  var utcDate = new Date(Date.UTC(date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()));
  utcDate.setUTCFullYear(date.getFullYear());
  return date.getTime() - utcDate.getTime();
}

var protectedDayOfYearTokens = ['D', 'DD'];
var protectedWeekYearTokens = ['YY', 'YYYY'];
function isProtectedDayOfYearToken(token) {
  return protectedDayOfYearTokens.indexOf(token) !== -1;
}
function isProtectedWeekYearToken(token) {
  return protectedWeekYearTokens.indexOf(token) !== -1;
}
function throwProtectedError(token, format, input) {
  if (token === 'YYYY') {
    throw new RangeError("Use `yyyy` instead of `YYYY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'YY') {
    throw new RangeError("Use `yy` instead of `YY` (in `".concat(format, "`) for formatting years to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'D') {
    throw new RangeError("Use `d` instead of `D` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  } else if (token === 'DD') {
    throw new RangeError("Use `dd` instead of `DD` (in `".concat(format, "`) for formatting days of the month to the input `").concat(input, "`; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md"));
  }
}

function _typeof$x(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$x = function _typeof(obj) { return typeof obj; }; } else { _typeof$x = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$x(obj); }

function _inherits$v(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$v(subClass, superClass); }

function _setPrototypeOf$v(o, p) { _setPrototypeOf$v = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$v(o, p); }

function _createSuper$v(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$v(); return function _createSuperInternal() { var Super = _getPrototypeOf$v(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$v(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$v(this, result); }; }

function _possibleConstructorReturn$v(self, call) { if (call && (_typeof$x(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$v(self); }

function _assertThisInitialized$v(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$v() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$v(o) { _getPrototypeOf$v = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$v(o); }

function _classCallCheck$w(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$w(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$w(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$w(Constructor.prototype, protoProps); if (staticProps) _defineProperties$w(Constructor, staticProps); return Constructor; }

function _defineProperty$v(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var TIMEZONE_UNIT_PRIORITY = 10;
var Setter = /*#__PURE__*/function () {
  function Setter() {
    _classCallCheck$w(this, Setter);

    _defineProperty$v(this, "subPriority", 0);
  }

  _createClass$w(Setter, [{
    key: "validate",
    value: function validate(_utcDate, _options) {
      return true;
    }
  }]);

  return Setter;
}();
var ValueSetter = /*#__PURE__*/function (_Setter) {
  _inherits$v(ValueSetter, _Setter);

  var _super = _createSuper$v(ValueSetter);

  function ValueSetter(value, validateValue, setValue, priority, subPriority) {
    var _this;

    _classCallCheck$w(this, ValueSetter);

    _this = _super.call(this);
    _this.value = value;
    _this.validateValue = validateValue;
    _this.setValue = setValue;
    _this.priority = priority;

    if (subPriority) {
      _this.subPriority = subPriority;
    }

    return _this;
  }

  _createClass$w(ValueSetter, [{
    key: "validate",
    value: function validate(utcDate, options) {
      return this.validateValue(utcDate, this.value, options);
    }
  }, {
    key: "set",
    value: function set(utcDate, flags, options) {
      return this.setValue(utcDate, flags, this.value, options);
    }
  }]);

  return ValueSetter;
}(Setter);
var DateToSystemTimezoneSetter = /*#__PURE__*/function (_Setter2) {
  _inherits$v(DateToSystemTimezoneSetter, _Setter2);

  var _super2 = _createSuper$v(DateToSystemTimezoneSetter);

  function DateToSystemTimezoneSetter() {
    var _this2;

    _classCallCheck$w(this, DateToSystemTimezoneSetter);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this2 = _super2.call.apply(_super2, [this].concat(args));

    _defineProperty$v(_assertThisInitialized$v(_this2), "priority", TIMEZONE_UNIT_PRIORITY);

    _defineProperty$v(_assertThisInitialized$v(_this2), "subPriority", -1);

    return _this2;
  }

  _createClass$w(DateToSystemTimezoneSetter, [{
    key: "set",
    value: function set(date, flags) {
      if (flags.timestampIsSet) {
        return date;
      }

      var convertedDate = new Date(0);
      convertedDate.setFullYear(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate());
      convertedDate.setHours(date.getUTCHours(), date.getUTCMinutes(), date.getUTCSeconds(), date.getUTCMilliseconds());
      return convertedDate;
    }
  }]);

  return DateToSystemTimezoneSetter;
}(Setter);

function _classCallCheck$v(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$v(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$v(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$v(Constructor.prototype, protoProps); if (staticProps) _defineProperties$v(Constructor, staticProps); return Constructor; }
var Parser = /*#__PURE__*/function () {
  function Parser() {
    _classCallCheck$v(this, Parser);
  }

  _createClass$v(Parser, [{
    key: "run",
    value: function run(dateString, token, match, options) {
      var result = this.parse(dateString, token, match, options);

      if (!result) {
        return null;
      }

      return {
        setter: new ValueSetter(result.value, this.validate, this.set, this.priority, this.subPriority),
        rest: result.rest
      };
    }
  }, {
    key: "validate",
    value: function validate(_utcDate, _value, _options) {
      return true;
    }
  }]);

  return Parser;
}();

function _typeof$w(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$w = function _typeof(obj) { return typeof obj; }; } else { _typeof$w = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$w(obj); }

function _classCallCheck$u(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$u(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$u(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$u(Constructor.prototype, protoProps); if (staticProps) _defineProperties$u(Constructor, staticProps); return Constructor; }

function _inherits$u(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$u(subClass, superClass); }

function _setPrototypeOf$u(o, p) { _setPrototypeOf$u = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$u(o, p); }

function _createSuper$u(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$u(); return function _createSuperInternal() { var Super = _getPrototypeOf$u(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$u(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$u(this, result); }; }

function _possibleConstructorReturn$u(self, call) { if (call && (_typeof$w(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$u(self); }

function _assertThisInitialized$u(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$u() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$u(o) { _getPrototypeOf$u = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$u(o); }

function _defineProperty$u(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var EraParser = /*#__PURE__*/function (_Parser) {
  _inherits$u(EraParser, _Parser);

  var _super = _createSuper$u(EraParser);

  function EraParser() {
    var _this;

    _classCallCheck$u(this, EraParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$u(_assertThisInitialized$u(_this), "priority", 140);

    _defineProperty$u(_assertThisInitialized$u(_this), "incompatibleTokens", ['R', 'u', 't', 'T']);

    return _this;
  }

  _createClass$u(EraParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // AD, BC
        case 'G':
        case 'GG':
        case 'GGG':
          return match.era(dateString, {
            width: 'abbreviated'
          }) || match.era(dateString, {
            width: 'narrow'
          });
        // A, B

        case 'GGGGG':
          return match.era(dateString, {
            width: 'narrow'
          });
        // Anno Domini, Before Christ

        case 'GGGG':
        default:
          return match.era(dateString, {
            width: 'wide'
          }) || match.era(dateString, {
            width: 'abbreviated'
          }) || match.era(dateString, {
            width: 'narrow'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      flags.era = value;
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return EraParser;
}(Parser);

/**
 * Days in 1 week.
 *
 * @name daysInWeek
 * @constant
 * @type {number}
 * @default
 */
/**
 * Milliseconds in 1 minute
 *
 * @name millisecondsInMinute
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInMinute = 60000;
/**
 * Milliseconds in 1 hour
 *
 * @name millisecondsInHour
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInHour = 3600000;
/**
 * Milliseconds in 1 second
 *
 * @name millisecondsInSecond
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInSecond = 1000;

var numericPatterns = {
  month: /^(1[0-2]|0?\d)/,
  // 0 to 12
  date: /^(3[0-1]|[0-2]?\d)/,
  // 0 to 31
  dayOfYear: /^(36[0-6]|3[0-5]\d|[0-2]?\d?\d)/,
  // 0 to 366
  week: /^(5[0-3]|[0-4]?\d)/,
  // 0 to 53
  hour23h: /^(2[0-3]|[0-1]?\d)/,
  // 0 to 23
  hour24h: /^(2[0-4]|[0-1]?\d)/,
  // 0 to 24
  hour11h: /^(1[0-1]|0?\d)/,
  // 0 to 11
  hour12h: /^(1[0-2]|0?\d)/,
  // 0 to 12
  minute: /^[0-5]?\d/,
  // 0 to 59
  second: /^[0-5]?\d/,
  // 0 to 59
  singleDigit: /^\d/,
  // 0 to 9
  twoDigits: /^\d{1,2}/,
  // 0 to 99
  threeDigits: /^\d{1,3}/,
  // 0 to 999
  fourDigits: /^\d{1,4}/,
  // 0 to 9999
  anyDigitsSigned: /^-?\d+/,
  singleDigitSigned: /^-?\d/,
  // 0 to 9, -0 to -9
  twoDigitsSigned: /^-?\d{1,2}/,
  // 0 to 99, -0 to -99
  threeDigitsSigned: /^-?\d{1,3}/,
  // 0 to 999, -0 to -999
  fourDigitsSigned: /^-?\d{1,4}/ // 0 to 9999, -0 to -9999

};
var timezonePatterns = {
  basicOptionalMinutes: /^([+-])(\d{2})(\d{2})?|Z/,
  basic: /^([+-])(\d{2})(\d{2})|Z/,
  basicOptionalSeconds: /^([+-])(\d{2})(\d{2})((\d{2}))?|Z/,
  extended: /^([+-])(\d{2}):(\d{2})|Z/,
  extendedOptionalSeconds: /^([+-])(\d{2}):(\d{2})(:(\d{2}))?|Z/
};

function mapValue(parseFnResult, mapFn) {
  if (!parseFnResult) {
    return parseFnResult;
  }

  return {
    value: mapFn(parseFnResult.value),
    rest: parseFnResult.rest
  };
}
function parseNumericPattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);

  if (!matchResult) {
    return null;
  }

  return {
    value: parseInt(matchResult[0], 10),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseTimezonePattern(pattern, dateString) {
  var matchResult = dateString.match(pattern);

  if (!matchResult) {
    return null;
  } // Input is 'Z'


  if (matchResult[0] === 'Z') {
    return {
      value: 0,
      rest: dateString.slice(1)
    };
  }

  var sign = matchResult[1] === '+' ? 1 : -1;
  var hours = matchResult[2] ? parseInt(matchResult[2], 10) : 0;
  var minutes = matchResult[3] ? parseInt(matchResult[3], 10) : 0;
  var seconds = matchResult[5] ? parseInt(matchResult[5], 10) : 0;
  return {
    value: sign * (hours * millisecondsInHour + minutes * millisecondsInMinute + seconds * millisecondsInSecond),
    rest: dateString.slice(matchResult[0].length)
  };
}
function parseAnyDigitsSigned(dateString) {
  return parseNumericPattern(numericPatterns.anyDigitsSigned, dateString);
}
function parseNDigits(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigit, dateString);

    case 2:
      return parseNumericPattern(numericPatterns.twoDigits, dateString);

    case 3:
      return parseNumericPattern(numericPatterns.threeDigits, dateString);

    case 4:
      return parseNumericPattern(numericPatterns.fourDigits, dateString);

    default:
      return parseNumericPattern(new RegExp('^\\d{1,' + n + '}'), dateString);
  }
}
function parseNDigitsSigned(n, dateString) {
  switch (n) {
    case 1:
      return parseNumericPattern(numericPatterns.singleDigitSigned, dateString);

    case 2:
      return parseNumericPattern(numericPatterns.twoDigitsSigned, dateString);

    case 3:
      return parseNumericPattern(numericPatterns.threeDigitsSigned, dateString);

    case 4:
      return parseNumericPattern(numericPatterns.fourDigitsSigned, dateString);

    default:
      return parseNumericPattern(new RegExp('^-?\\d{1,' + n + '}'), dateString);
  }
}
function dayPeriodEnumToHours(dayPeriod) {
  switch (dayPeriod) {
    case 'morning':
      return 4;

    case 'evening':
      return 17;

    case 'pm':
    case 'noon':
    case 'afternoon':
      return 12;

    case 'am':
    case 'midnight':
    case 'night':
    default:
      return 0;
  }
}
function normalizeTwoDigitYear(twoDigitYear, currentYear) {
  var isCommonEra = currentYear > 0; // Absolute number of the current year:
  // 1 -> 1 AC
  // 0 -> 1 BC
  // -1 -> 2 BC

  var absCurrentYear = isCommonEra ? currentYear : 1 - currentYear;
  var result;

  if (absCurrentYear <= 50) {
    result = twoDigitYear || 100;
  } else {
    var rangeEnd = absCurrentYear + 50;
    var rangeEndCentury = Math.floor(rangeEnd / 100) * 100;
    var isPreviousCentury = twoDigitYear >= rangeEnd % 100;
    result = twoDigitYear + rangeEndCentury - (isPreviousCentury ? 100 : 0);
  }

  return isCommonEra ? result : 1 - result;
}
function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

function _typeof$v(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$v = function _typeof(obj) { return typeof obj; }; } else { _typeof$v = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$v(obj); }

function _classCallCheck$t(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$t(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$t(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$t(Constructor.prototype, protoProps); if (staticProps) _defineProperties$t(Constructor, staticProps); return Constructor; }

function _inherits$t(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$t(subClass, superClass); }

function _setPrototypeOf$t(o, p) { _setPrototypeOf$t = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$t(o, p); }

function _createSuper$t(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$t(); return function _createSuperInternal() { var Super = _getPrototypeOf$t(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$t(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$t(this, result); }; }

function _possibleConstructorReturn$t(self, call) { if (call && (_typeof$v(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$t(self); }

function _assertThisInitialized$t(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$t() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$t(o) { _getPrototypeOf$t = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$t(o); }

function _defineProperty$t(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// From http://www.unicode.org/reports/tr35/tr35-31/tr35-dates.html#Date_Format_Patterns
// | Year     |     y | yy |   yyy |  yyyy | yyyyy |
// |----------|-------|----|-------|-------|-------|
// | AD 1     |     1 | 01 |   001 |  0001 | 00001 |
// | AD 12    |    12 | 12 |   012 |  0012 | 00012 |
// | AD 123   |   123 | 23 |   123 |  0123 | 00123 |
// | AD 1234  |  1234 | 34 |  1234 |  1234 | 01234 |
// | AD 12345 | 12345 | 45 | 12345 | 12345 | 12345 |
var YearParser = /*#__PURE__*/function (_Parser) {
  _inherits$t(YearParser, _Parser);

  var _super = _createSuper$t(YearParser);

  function YearParser() {
    var _this;

    _classCallCheck$t(this, YearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$t(_assertThisInitialized$t(_this), "priority", 130);

    _defineProperty$t(_assertThisInitialized$t(_this), "incompatibleTokens", ['Y', 'R', 'u', 'w', 'I', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$t(YearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(year) {
        return {
          year: year,
          isTwoDigitYear: token === 'yy'
        };
      };

      switch (token) {
        case 'y':
          return mapValue(parseNDigits(4, dateString), valueCallback);

        case 'yo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'year'
          }), valueCallback);

        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      var currentYear = date.getUTCFullYear();

      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, 1);
        date.setUTCHours(0, 0, 0, 0);
        return date;
      }

      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return YearParser;
}(Parser);

var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}

function startOfUTCWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

function getUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var firstWeekOfNextYear = new Date(0);
  firstWeekOfNextYear.setUTCFullYear(year + 1, 0, firstWeekContainsDate);
  firstWeekOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCWeek(firstWeekOfNextYear, options);
  var firstWeekOfThisYear = new Date(0);
  firstWeekOfThisYear.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeekOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCWeek(firstWeekOfThisYear, options);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

function _typeof$u(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$u = function _typeof(obj) { return typeof obj; }; } else { _typeof$u = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$u(obj); }

function _classCallCheck$s(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$s(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$s(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$s(Constructor.prototype, protoProps); if (staticProps) _defineProperties$s(Constructor, staticProps); return Constructor; }

function _inherits$s(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$s(subClass, superClass); }

function _setPrototypeOf$s(o, p) { _setPrototypeOf$s = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$s(o, p); }

function _createSuper$s(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$s(); return function _createSuperInternal() { var Super = _getPrototypeOf$s(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$s(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$s(this, result); }; }

function _possibleConstructorReturn$s(self, call) { if (call && (_typeof$u(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$s(self); }

function _assertThisInitialized$s(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$s() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$s(o) { _getPrototypeOf$s = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$s(o); }

function _defineProperty$s(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
// Local week-numbering year
var LocalWeekYearParser = /*#__PURE__*/function (_Parser) {
  _inherits$s(LocalWeekYearParser, _Parser);

  var _super = _createSuper$s(LocalWeekYearParser);

  function LocalWeekYearParser() {
    var _this;

    _classCallCheck$s(this, LocalWeekYearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$s(_assertThisInitialized$s(_this), "priority", 130);

    _defineProperty$s(_assertThisInitialized$s(_this), "incompatibleTokens", ['y', 'R', 'u', 'Q', 'q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);

    return _this;
  }

  _createClass$s(LocalWeekYearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(year) {
        return {
          year: year,
          isTwoDigitYear: token === 'YY'
        };
      };

      switch (token) {
        case 'Y':
          return mapValue(parseNDigits(4, dateString), valueCallback);

        case 'Yo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'year'
          }), valueCallback);

        default:
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value.isTwoDigitYear || value.year > 0;
    }
  }, {
    key: "set",
    value: function set(date, flags, value, options) {
      var currentYear = getUTCWeekYear(date, options);

      if (value.isTwoDigitYear) {
        var normalizedTwoDigitYear = normalizeTwoDigitYear(value.year, currentYear);
        date.setUTCFullYear(normalizedTwoDigitYear, 0, options.firstWeekContainsDate);
        date.setUTCHours(0, 0, 0, 0);
        return startOfUTCWeek(date, options);
      }

      var year = !('era' in flags) || flags.era === 1 ? value.year : 1 - value.year;
      date.setUTCFullYear(year, 0, options.firstWeekContainsDate);
      date.setUTCHours(0, 0, 0, 0);
      return startOfUTCWeek(date, options);
    }
  }]);

  return LocalWeekYearParser;
}(Parser);

function startOfUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var day = date.getUTCDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setUTCDate(date.getUTCDate() - diff);
  date.setUTCHours(0, 0, 0, 0);
  return date;
}

function _typeof$t(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$t = function _typeof(obj) { return typeof obj; }; } else { _typeof$t = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$t(obj); }

function _classCallCheck$r(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$r(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$r(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$r(Constructor.prototype, protoProps); if (staticProps) _defineProperties$r(Constructor, staticProps); return Constructor; }

function _inherits$r(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$r(subClass, superClass); }

function _setPrototypeOf$r(o, p) { _setPrototypeOf$r = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$r(o, p); }

function _createSuper$r(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$r(); return function _createSuperInternal() { var Super = _getPrototypeOf$r(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$r(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$r(this, result); }; }

function _possibleConstructorReturn$r(self, call) { if (call && (_typeof$t(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$r(self); }

function _assertThisInitialized$r(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$r() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$r(o) { _getPrototypeOf$r = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$r(o); }

function _defineProperty$r(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ISOWeekYearParser = /*#__PURE__*/function (_Parser) {
  _inherits$r(ISOWeekYearParser, _Parser);

  var _super = _createSuper$r(ISOWeekYearParser);

  function ISOWeekYearParser() {
    var _this;

    _classCallCheck$r(this, ISOWeekYearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$r(_assertThisInitialized$r(_this), "priority", 130);

    _defineProperty$r(_assertThisInitialized$r(_this), "incompatibleTokens", ['G', 'y', 'Y', 'u', 'Q', 'q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$r(ISOWeekYearParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      if (token === 'R') {
        return parseNDigitsSigned(4, dateString);
      }

      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      var firstWeekOfYear = new Date(0);
      firstWeekOfYear.setUTCFullYear(value, 0, 4);
      firstWeekOfYear.setUTCHours(0, 0, 0, 0);
      return startOfUTCISOWeek(firstWeekOfYear);
    }
  }]);

  return ISOWeekYearParser;
}(Parser);

function _typeof$s(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$s = function _typeof(obj) { return typeof obj; }; } else { _typeof$s = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$s(obj); }

function _classCallCheck$q(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$q(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$q(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$q(Constructor.prototype, protoProps); if (staticProps) _defineProperties$q(Constructor, staticProps); return Constructor; }

function _inherits$q(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$q(subClass, superClass); }

function _setPrototypeOf$q(o, p) { _setPrototypeOf$q = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$q(o, p); }

function _createSuper$q(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$q(); return function _createSuperInternal() { var Super = _getPrototypeOf$q(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$q(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$q(this, result); }; }

function _possibleConstructorReturn$q(self, call) { if (call && (_typeof$s(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$q(self); }

function _assertThisInitialized$q(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$q() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$q(o) { _getPrototypeOf$q = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$q(o); }

function _defineProperty$q(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var ExtendedYearParser = /*#__PURE__*/function (_Parser) {
  _inherits$q(ExtendedYearParser, _Parser);

  var _super = _createSuper$q(ExtendedYearParser);

  function ExtendedYearParser() {
    var _this;

    _classCallCheck$q(this, ExtendedYearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$q(_assertThisInitialized$q(_this), "priority", 130);

    _defineProperty$q(_assertThisInitialized$q(_this), "incompatibleTokens", ['G', 'y', 'Y', 'R', 'w', 'I', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$q(ExtendedYearParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      if (token === 'u') {
        return parseNDigitsSigned(4, dateString);
      }

      return parseNDigitsSigned(token.length, dateString);
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCFullYear(value, 0, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return ExtendedYearParser;
}(Parser);

function _typeof$r(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$r = function _typeof(obj) { return typeof obj; }; } else { _typeof$r = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$r(obj); }

function _classCallCheck$p(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$p(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$p(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$p(Constructor.prototype, protoProps); if (staticProps) _defineProperties$p(Constructor, staticProps); return Constructor; }

function _inherits$p(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$p(subClass, superClass); }

function _setPrototypeOf$p(o, p) { _setPrototypeOf$p = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$p(o, p); }

function _createSuper$p(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$p(); return function _createSuperInternal() { var Super = _getPrototypeOf$p(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$p(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$p(this, result); }; }

function _possibleConstructorReturn$p(self, call) { if (call && (_typeof$r(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$p(self); }

function _assertThisInitialized$p(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$p() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$p(o) { _getPrototypeOf$p = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$p(o); }

function _defineProperty$p(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var QuarterParser = /*#__PURE__*/function (_Parser) {
  _inherits$p(QuarterParser, _Parser);

  var _super = _createSuper$p(QuarterParser);

  function QuarterParser() {
    var _this;

    _classCallCheck$p(this, QuarterParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$p(_assertThisInitialized$p(_this), "priority", 120);

    _defineProperty$p(_assertThisInitialized$p(_this), "incompatibleTokens", ['Y', 'R', 'q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$p(QuarterParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // 1, 2, 3, 4
        case 'Q':
        case 'QQ':
          // 01, 02, 03, 04
          return parseNDigits(token.length, dateString);
        // 1st, 2nd, 3rd, 4th

        case 'Qo':
          return match.ordinalNumber(dateString, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'QQQ':
          return match.quarter(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'QQQQQ':
          return match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // 1st quarter, 2nd quarter, ...

        case 'QQQQ':
        default:
          return match.quarter(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return QuarterParser;
}(Parser);

function _typeof$q(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$q = function _typeof(obj) { return typeof obj; }; } else { _typeof$q = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$q(obj); }

function _classCallCheck$o(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$o(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$o(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$o(Constructor.prototype, protoProps); if (staticProps) _defineProperties$o(Constructor, staticProps); return Constructor; }

function _inherits$o(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$o(subClass, superClass); }

function _setPrototypeOf$o(o, p) { _setPrototypeOf$o = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$o(o, p); }

function _createSuper$o(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$o(); return function _createSuperInternal() { var Super = _getPrototypeOf$o(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$o(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$o(this, result); }; }

function _possibleConstructorReturn$o(self, call) { if (call && (_typeof$q(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$o(self); }

function _assertThisInitialized$o(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$o() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$o(o) { _getPrototypeOf$o = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$o(o); }

function _defineProperty$o(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var StandAloneQuarterParser = /*#__PURE__*/function (_Parser) {
  _inherits$o(StandAloneQuarterParser, _Parser);

  var _super = _createSuper$o(StandAloneQuarterParser);

  function StandAloneQuarterParser() {
    var _this;

    _classCallCheck$o(this, StandAloneQuarterParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$o(_assertThisInitialized$o(_this), "priority", 120);

    _defineProperty$o(_assertThisInitialized$o(_this), "incompatibleTokens", ['Y', 'R', 'Q', 'M', 'L', 'w', 'I', 'd', 'D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$o(StandAloneQuarterParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // 1, 2, 3, 4
        case 'q':
        case 'qq':
          // 01, 02, 03, 04
          return parseNDigits(token.length, dateString);
        // 1st, 2nd, 3rd, 4th

        case 'qo':
          return match.ordinalNumber(dateString, {
            unit: 'quarter'
          });
        // Q1, Q2, Q3, Q4

        case 'qqq':
          return match.quarter(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1, 2, 3, 4 (narrow quarter; could be not numerical)

        case 'qqqqq':
          return match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // 1st quarter, 2nd quarter, ...

        case 'qqqq':
        default:
          return match.quarter(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.quarter(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 4;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth((value - 1) * 3, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return StandAloneQuarterParser;
}(Parser);

function _typeof$p(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$p = function _typeof(obj) { return typeof obj; }; } else { _typeof$p = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$p(obj); }

function _classCallCheck$n(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$n(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$n(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$n(Constructor.prototype, protoProps); if (staticProps) _defineProperties$n(Constructor, staticProps); return Constructor; }

function _inherits$n(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$n(subClass, superClass); }

function _setPrototypeOf$n(o, p) { _setPrototypeOf$n = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$n(o, p); }

function _createSuper$n(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$n(); return function _createSuperInternal() { var Super = _getPrototypeOf$n(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$n(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$n(this, result); }; }

function _possibleConstructorReturn$n(self, call) { if (call && (_typeof$p(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$n(self); }

function _assertThisInitialized$n(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$n() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$n(o) { _getPrototypeOf$n = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$n(o); }

function _defineProperty$n(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var MonthParser = /*#__PURE__*/function (_Parser) {
  _inherits$n(MonthParser, _Parser);

  var _super = _createSuper$n(MonthParser);

  function MonthParser() {
    var _this;

    _classCallCheck$n(this, MonthParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$n(_assertThisInitialized$n(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'L', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);

    _defineProperty$n(_assertThisInitialized$n(_this), "priority", 110);

    return _this;
  }

  _createClass$n(MonthParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        return value - 1;
      };

      switch (token) {
        // 1, 2, ..., 12
        case 'M':
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
        // 01, 02, ..., 12

        case 'MM':
          return mapValue(parseNDigits(2, dateString), valueCallback);
        // 1st, 2nd, ..., 12th

        case 'Mo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'month'
          }), valueCallback);
        // Jan, Feb, ..., Dec

        case 'MMM':
          return match.month(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // J, F, ..., D

        case 'MMMMM':
          return match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // January, February, ..., December

        case 'MMMM':
        default:
          return match.month(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return MonthParser;
}(Parser);

function _typeof$o(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$o = function _typeof(obj) { return typeof obj; }; } else { _typeof$o = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$o(obj); }

function _classCallCheck$m(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$m(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$m(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$m(Constructor.prototype, protoProps); if (staticProps) _defineProperties$m(Constructor, staticProps); return Constructor; }

function _inherits$m(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$m(subClass, superClass); }

function _setPrototypeOf$m(o, p) { _setPrototypeOf$m = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$m(o, p); }

function _createSuper$m(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$m(); return function _createSuperInternal() { var Super = _getPrototypeOf$m(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$m(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$m(this, result); }; }

function _possibleConstructorReturn$m(self, call) { if (call && (_typeof$o(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$m(self); }

function _assertThisInitialized$m(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$m() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$m(o) { _getPrototypeOf$m = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$m(o); }

function _defineProperty$m(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var StandAloneMonthParser = /*#__PURE__*/function (_Parser) {
  _inherits$m(StandAloneMonthParser, _Parser);

  var _super = _createSuper$m(StandAloneMonthParser);

  function StandAloneMonthParser() {
    var _this;

    _classCallCheck$m(this, StandAloneMonthParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$m(_assertThisInitialized$m(_this), "priority", 110);

    _defineProperty$m(_assertThisInitialized$m(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$m(StandAloneMonthParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        return value - 1;
      };

      switch (token) {
        // 1, 2, ..., 12
        case 'L':
          return mapValue(parseNumericPattern(numericPatterns.month, dateString), valueCallback);
        // 01, 02, ..., 12

        case 'LL':
          return mapValue(parseNDigits(2, dateString), valueCallback);
        // 1st, 2nd, ..., 12th

        case 'Lo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'month'
          }), valueCallback);
        // Jan, Feb, ..., Dec

        case 'LLL':
          return match.month(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // J, F, ..., D

        case 'LLLLL':
          return match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // January, February, ..., December

        case 'LLLL':
        default:
          return match.month(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.month(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(value, 1);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return StandAloneMonthParser;
}(Parser);

function startOfUTCWeekYear(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$firstWeekCon, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs(1, arguments);
  var defaultOptions = getDefaultOptions();
  var firstWeekContainsDate = toInteger((_ref = (_ref2 = (_ref3 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref !== void 0 ? _ref : 1);
  var year = getUTCWeekYear(dirtyDate, options);
  var firstWeek = new Date(0);
  firstWeek.setUTCFullYear(year, 0, firstWeekContainsDate);
  firstWeek.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCWeek(firstWeek, options);
  return date;
}

var MILLISECONDS_IN_WEEK$1 = 604800000;
function getUTCWeek(dirtyDate, options) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCWeek(date, options).getTime() - startOfUTCWeekYear(date, options).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK$1) + 1;
}

function setUTCWeek(dirtyDate, dirtyWeek, options) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var week = toInteger(dirtyWeek);
  var diff = getUTCWeek(date, options) - week;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

function _typeof$n(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$n = function _typeof(obj) { return typeof obj; }; } else { _typeof$n = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$n(obj); }

function _classCallCheck$l(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$l(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$l(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$l(Constructor.prototype, protoProps); if (staticProps) _defineProperties$l(Constructor, staticProps); return Constructor; }

function _inherits$l(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$l(subClass, superClass); }

function _setPrototypeOf$l(o, p) { _setPrototypeOf$l = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$l(o, p); }

function _createSuper$l(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$l(); return function _createSuperInternal() { var Super = _getPrototypeOf$l(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$l(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$l(this, result); }; }

function _possibleConstructorReturn$l(self, call) { if (call && (_typeof$n(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$l(self); }

function _assertThisInitialized$l(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$l() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$l(o) { _getPrototypeOf$l = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$l(o); }

function _defineProperty$l(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var LocalWeekParser = /*#__PURE__*/function (_Parser) {
  _inherits$l(LocalWeekParser, _Parser);

  var _super = _createSuper$l(LocalWeekParser);

  function LocalWeekParser() {
    var _this;

    _classCallCheck$l(this, LocalWeekParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$l(_assertThisInitialized$l(_this), "priority", 100);

    _defineProperty$l(_assertThisInitialized$l(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'i', 't', 'T']);

    return _this;
  }

  _createClass$l(LocalWeekParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'w':
          return parseNumericPattern(numericPatterns.week, dateString);

        case 'wo':
          return match.ordinalNumber(dateString, {
            unit: 'week'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      return startOfUTCWeek(setUTCWeek(date, value, options), options);
    }
  }]);

  return LocalWeekParser;
}(Parser);

function getUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var year = date.getUTCFullYear();
  var fourthOfJanuaryOfNextYear = new Date(0);
  fourthOfJanuaryOfNextYear.setUTCFullYear(year + 1, 0, 4);
  fourthOfJanuaryOfNextYear.setUTCHours(0, 0, 0, 0);
  var startOfNextYear = startOfUTCISOWeek(fourthOfJanuaryOfNextYear);
  var fourthOfJanuaryOfThisYear = new Date(0);
  fourthOfJanuaryOfThisYear.setUTCFullYear(year, 0, 4);
  fourthOfJanuaryOfThisYear.setUTCHours(0, 0, 0, 0);
  var startOfThisYear = startOfUTCISOWeek(fourthOfJanuaryOfThisYear);

  if (date.getTime() >= startOfNextYear.getTime()) {
    return year + 1;
  } else if (date.getTime() >= startOfThisYear.getTime()) {
    return year;
  } else {
    return year - 1;
  }
}

function startOfUTCISOWeekYear(dirtyDate) {
  requiredArgs(1, arguments);
  var year = getUTCISOWeekYear(dirtyDate);
  var fourthOfJanuary = new Date(0);
  fourthOfJanuary.setUTCFullYear(year, 0, 4);
  fourthOfJanuary.setUTCHours(0, 0, 0, 0);
  var date = startOfUTCISOWeek(fourthOfJanuary);
  return date;
}

var MILLISECONDS_IN_WEEK = 604800000;
function getUTCISOWeek(dirtyDate) {
  requiredArgs(1, arguments);
  var date = toDate(dirtyDate);
  var diff = startOfUTCISOWeek(date).getTime() - startOfUTCISOWeekYear(date).getTime(); // Round the number of days to the nearest integer
  // because the number of milliseconds in a week is not constant
  // (e.g. it's different in the week of the daylight saving time clock shift)

  return Math.round(diff / MILLISECONDS_IN_WEEK) + 1;
}

function setUTCISOWeek(dirtyDate, dirtyISOWeek) {
  requiredArgs(2, arguments);
  var date = toDate(dirtyDate);
  var isoWeek = toInteger(dirtyISOWeek);
  var diff = getUTCISOWeek(date) - isoWeek;
  date.setUTCDate(date.getUTCDate() - diff * 7);
  return date;
}

function _typeof$m(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$m = function _typeof(obj) { return typeof obj; }; } else { _typeof$m = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$m(obj); }

function _classCallCheck$k(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$k(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$k(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$k(Constructor.prototype, protoProps); if (staticProps) _defineProperties$k(Constructor, staticProps); return Constructor; }

function _inherits$k(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$k(subClass, superClass); }

function _setPrototypeOf$k(o, p) { _setPrototypeOf$k = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$k(o, p); }

function _createSuper$k(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$k(); return function _createSuperInternal() { var Super = _getPrototypeOf$k(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$k(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$k(this, result); }; }

function _possibleConstructorReturn$k(self, call) { if (call && (_typeof$m(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$k(self); }

function _assertThisInitialized$k(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$k() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$k(o) { _getPrototypeOf$k = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$k(o); }

function _defineProperty$k(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ISOWeekParser = /*#__PURE__*/function (_Parser) {
  _inherits$k(ISOWeekParser, _Parser);

  var _super = _createSuper$k(ISOWeekParser);

  function ISOWeekParser() {
    var _this;

    _classCallCheck$k(this, ISOWeekParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$k(_assertThisInitialized$k(_this), "priority", 100);

    _defineProperty$k(_assertThisInitialized$k(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$k(ISOWeekParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'I':
          return parseNumericPattern(numericPatterns.week, dateString);

        case 'Io':
          return match.ordinalNumber(dateString, {
            unit: 'week'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 53;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      return startOfUTCISOWeek(setUTCISOWeek(date, value));
    }
  }]);

  return ISOWeekParser;
}(Parser);

function _typeof$l(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$l = function _typeof(obj) { return typeof obj; }; } else { _typeof$l = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$l(obj); }

function _classCallCheck$j(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$j(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$j(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$j(Constructor.prototype, protoProps); if (staticProps) _defineProperties$j(Constructor, staticProps); return Constructor; }

function _inherits$j(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$j(subClass, superClass); }

function _setPrototypeOf$j(o, p) { _setPrototypeOf$j = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$j(o, p); }

function _createSuper$j(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$j(); return function _createSuperInternal() { var Super = _getPrototypeOf$j(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$j(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$j(this, result); }; }

function _possibleConstructorReturn$j(self, call) { if (call && (_typeof$l(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$j(self); }

function _assertThisInitialized$j(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$j() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$j(o) { _getPrototypeOf$j = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$j(o); }

function _defineProperty$j(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
var DAYS_IN_MONTH_LEAP_YEAR = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; // Day of the month

var DateParser = /*#__PURE__*/function (_Parser) {
  _inherits$j(DateParser, _Parser);

  var _super = _createSuper$j(DateParser);

  function DateParser() {
    var _this;

    _classCallCheck$j(this, DateParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$j(_assertThisInitialized$j(_this), "priority", 90);

    _defineProperty$j(_assertThisInitialized$j(_this), "subPriority", 1);

    _defineProperty$j(_assertThisInitialized$j(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'w', 'I', 'D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$j(DateParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'd':
          return parseNumericPattern(numericPatterns.date, dateString);

        case 'do':
          return match.ordinalNumber(dateString, {
            unit: 'date'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);
      var month = date.getUTCMonth();

      if (isLeapYear) {
        return value >= 1 && value <= DAYS_IN_MONTH_LEAP_YEAR[month];
      } else {
        return value >= 1 && value <= DAYS_IN_MONTH[month];
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCDate(value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return DateParser;
}(Parser);

function _typeof$k(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$k = function _typeof(obj) { return typeof obj; }; } else { _typeof$k = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$k(obj); }

function _classCallCheck$i(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$i(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$i(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$i(Constructor.prototype, protoProps); if (staticProps) _defineProperties$i(Constructor, staticProps); return Constructor; }

function _inherits$i(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$i(subClass, superClass); }

function _setPrototypeOf$i(o, p) { _setPrototypeOf$i = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$i(o, p); }

function _createSuper$i(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$i(); return function _createSuperInternal() { var Super = _getPrototypeOf$i(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$i(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$i(this, result); }; }

function _possibleConstructorReturn$i(self, call) { if (call && (_typeof$k(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$i(self); }

function _assertThisInitialized$i(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$i() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$i(o) { _getPrototypeOf$i = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$i(o); }

function _defineProperty$i(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var DayOfYearParser = /*#__PURE__*/function (_Parser) {
  _inherits$i(DayOfYearParser, _Parser);

  var _super = _createSuper$i(DayOfYearParser);

  function DayOfYearParser() {
    var _this;

    _classCallCheck$i(this, DayOfYearParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$i(_assertThisInitialized$i(_this), "priority", 90);

    _defineProperty$i(_assertThisInitialized$i(_this), "subpriority", 1);

    _defineProperty$i(_assertThisInitialized$i(_this), "incompatibleTokens", ['Y', 'R', 'q', 'Q', 'M', 'L', 'w', 'I', 'd', 'E', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$i(DayOfYearParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'D':
        case 'DD':
          return parseNumericPattern(numericPatterns.dayOfYear, dateString);

        case 'Do':
          return match.ordinalNumber(dateString, {
            unit: 'date'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(date, value) {
      var year = date.getUTCFullYear();
      var isLeapYear = isLeapYearIndex(year);

      if (isLeapYear) {
        return value >= 1 && value <= 366;
      } else {
        return value >= 1 && value <= 365;
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMonth(0, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return DayOfYearParser;
}(Parser);

function setUTCDay(dirtyDate, dirtyDay, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  requiredArgs(2, arguments);
  var defaultOptions = getDefaultOptions();
  var weekStartsOn = toInteger((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = toDate(dirtyDate);
  var day = toInteger(dirtyDay);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

function _typeof$j(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$j = function _typeof(obj) { return typeof obj; }; } else { _typeof$j = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$j(obj); }

function _classCallCheck$h(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$h(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$h(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$h(Constructor.prototype, protoProps); if (staticProps) _defineProperties$h(Constructor, staticProps); return Constructor; }

function _inherits$h(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$h(subClass, superClass); }

function _setPrototypeOf$h(o, p) { _setPrototypeOf$h = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$h(o, p); }

function _createSuper$h(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$h(); return function _createSuperInternal() { var Super = _getPrototypeOf$h(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$h(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$h(this, result); }; }

function _possibleConstructorReturn$h(self, call) { if (call && (_typeof$j(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$h(self); }

function _assertThisInitialized$h(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$h() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$h(o) { _getPrototypeOf$h = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$h(o); }

function _defineProperty$h(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DayParser = /*#__PURE__*/function (_Parser) {
  _inherits$h(DayParser, _Parser);

  var _super = _createSuper$h(DayParser);

  function DayParser() {
    var _this;

    _classCallCheck$h(this, DayParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$h(_assertThisInitialized$h(_this), "priority", 90);

    _defineProperty$h(_assertThisInitialized$h(_this), "incompatibleTokens", ['D', 'i', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$h(DayParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        // Tue
        case 'E':
        case 'EE':
        case 'EEE':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // T

        case 'EEEEE':
          return match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'EEEEEE':
          return match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday

        case 'EEEE':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return DayParser;
}(Parser);

function _typeof$i(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$i = function _typeof(obj) { return typeof obj; }; } else { _typeof$i = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$i(obj); }

function _classCallCheck$g(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$g(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$g(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$g(Constructor.prototype, protoProps); if (staticProps) _defineProperties$g(Constructor, staticProps); return Constructor; }

function _inherits$g(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$g(subClass, superClass); }

function _setPrototypeOf$g(o, p) { _setPrototypeOf$g = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$g(o, p); }

function _createSuper$g(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$g(); return function _createSuperInternal() { var Super = _getPrototypeOf$g(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$g(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$g(this, result); }; }

function _possibleConstructorReturn$g(self, call) { if (call && (_typeof$i(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$g(self); }

function _assertThisInitialized$g(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$g() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$g(o) { _getPrototypeOf$g = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$g(o); }

function _defineProperty$g(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var LocalDayParser = /*#__PURE__*/function (_Parser) {
  _inherits$g(LocalDayParser, _Parser);

  var _super = _createSuper$g(LocalDayParser);

  function LocalDayParser() {
    var _this;

    _classCallCheck$g(this, LocalDayParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$g(_assertThisInitialized$g(_this), "priority", 90);

    _defineProperty$g(_assertThisInitialized$g(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'c', 't', 'T']);

    return _this;
  }

  _createClass$g(LocalDayParser, [{
    key: "parse",
    value: function parse(dateString, token, match, options) {
      var valueCallback = function valueCallback(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };

      switch (token) {
        // 3
        case 'e':
        case 'ee':
          // 03
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        // 3rd

        case 'eo':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'day'
          }), valueCallback);
        // Tue

        case 'eee':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // T

        case 'eeeee':
          return match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tu

        case 'eeeeee':
          return match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
        // Tuesday

        case 'eeee':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return LocalDayParser;
}(Parser);

function _typeof$h(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$h = function _typeof(obj) { return typeof obj; }; } else { _typeof$h = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$h(obj); }

function _classCallCheck$f(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$f(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$f(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$f(Constructor.prototype, protoProps); if (staticProps) _defineProperties$f(Constructor, staticProps); return Constructor; }

function _inherits$f(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$f(subClass, superClass); }

function _setPrototypeOf$f(o, p) { _setPrototypeOf$f = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$f(o, p); }

function _createSuper$f(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$f(); return function _createSuperInternal() { var Super = _getPrototypeOf$f(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$f(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$f(this, result); }; }

function _possibleConstructorReturn$f(self, call) { if (call && (_typeof$h(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$f(self); }

function _assertThisInitialized$f(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$f() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$f(o) { _getPrototypeOf$f = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$f(o); }

function _defineProperty$f(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var StandAloneLocalDayParser = /*#__PURE__*/function (_Parser) {
  _inherits$f(StandAloneLocalDayParser, _Parser);

  var _super = _createSuper$f(StandAloneLocalDayParser);

  function StandAloneLocalDayParser() {
    var _this;

    _classCallCheck$f(this, StandAloneLocalDayParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$f(_assertThisInitialized$f(_this), "priority", 90);

    _defineProperty$f(_assertThisInitialized$f(_this), "incompatibleTokens", ['y', 'R', 'u', 'q', 'Q', 'M', 'L', 'I', 'd', 'D', 'E', 'i', 'e', 't', 'T']);

    return _this;
  }

  _createClass$f(StandAloneLocalDayParser, [{
    key: "parse",
    value: function parse(dateString, token, match, options) {
      var valueCallback = function valueCallback(value) {
        var wholeWeekDays = Math.floor((value - 1) / 7) * 7;
        return (value + options.weekStartsOn + 6) % 7 + wholeWeekDays;
      };

      switch (token) {
        // 3
        case 'c':
        case 'cc':
          // 03
          return mapValue(parseNDigits(token.length, dateString), valueCallback);
        // 3rd

        case 'co':
          return mapValue(match.ordinalNumber(dateString, {
            unit: 'day'
          }), valueCallback);
        // Tue

        case 'ccc':
          return match.day(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // T

        case 'ccccc':
          return match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tu

        case 'cccccc':
          return match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
        // Tuesday

        case 'cccc':
        default:
          return match.day(dateString, {
            width: 'wide',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'short',
            context: 'standalone'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'standalone'
          });
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 6;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value, options) {
      date = setUTCDay(date, value, options);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return StandAloneLocalDayParser;
}(Parser);

function setUTCISODay(dirtyDate, dirtyDay) {
  requiredArgs(2, arguments);
  var day = toInteger(dirtyDay);

  if (day % 7 === 0) {
    day = day - 7;
  }

  var weekStartsOn = 1;
  var date = toDate(dirtyDate);
  var currentDay = date.getUTCDay();
  var remainder = day % 7;
  var dayIndex = (remainder + 7) % 7;
  var diff = (dayIndex < weekStartsOn ? 7 : 0) + day - currentDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
}

function _typeof$g(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$g = function _typeof(obj) { return typeof obj; }; } else { _typeof$g = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$g(obj); }

function _classCallCheck$e(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$e(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$e(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$e(Constructor.prototype, protoProps); if (staticProps) _defineProperties$e(Constructor, staticProps); return Constructor; }

function _inherits$e(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$e(subClass, superClass); }

function _setPrototypeOf$e(o, p) { _setPrototypeOf$e = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$e(o, p); }

function _createSuper$e(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$e(); return function _createSuperInternal() { var Super = _getPrototypeOf$e(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$e(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$e(this, result); }; }

function _possibleConstructorReturn$e(self, call) { if (call && (_typeof$g(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$e(self); }

function _assertThisInitialized$e(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$e() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$e(o) { _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$e(o); }

function _defineProperty$e(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ISODayParser = /*#__PURE__*/function (_Parser) {
  _inherits$e(ISODayParser, _Parser);

  var _super = _createSuper$e(ISODayParser);

  function ISODayParser() {
    var _this;

    _classCallCheck$e(this, ISODayParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$e(_assertThisInitialized$e(_this), "priority", 90);

    _defineProperty$e(_assertThisInitialized$e(_this), "incompatibleTokens", ['y', 'Y', 'u', 'q', 'Q', 'M', 'L', 'w', 'd', 'D', 'E', 'e', 'c', 't', 'T']);

    return _this;
  }

  _createClass$e(ISODayParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      var valueCallback = function valueCallback(value) {
        if (value === 0) {
          return 7;
        }

        return value;
      };

      switch (token) {
        // 2
        case 'i':
        case 'ii':
          // 02
          return parseNDigits(token.length, dateString);
        // 2nd

        case 'io':
          return match.ordinalNumber(dateString, {
            unit: 'day'
          });
        // Tue

        case 'iii':
          return mapValue(match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // T

        case 'iiiii':
          return mapValue(match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // Tu

        case 'iiiiii':
          return mapValue(match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
        // Tuesday

        case 'iiii':
        default:
          return mapValue(match.day(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'short',
            context: 'formatting'
          }) || match.day(dateString, {
            width: 'narrow',
            context: 'formatting'
          }), valueCallback);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 7;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date = setUTCISODay(date, value);
      date.setUTCHours(0, 0, 0, 0);
      return date;
    }
  }]);

  return ISODayParser;
}(Parser);

function _typeof$f(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$f = function _typeof(obj) { return typeof obj; }; } else { _typeof$f = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$f(obj); }

function _classCallCheck$d(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$d(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$d(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$d(Constructor.prototype, protoProps); if (staticProps) _defineProperties$d(Constructor, staticProps); return Constructor; }

function _inherits$d(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$d(subClass, superClass); }

function _setPrototypeOf$d(o, p) { _setPrototypeOf$d = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$d(o, p); }

function _createSuper$d(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$d(); return function _createSuperInternal() { var Super = _getPrototypeOf$d(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$d(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$d(this, result); }; }

function _possibleConstructorReturn$d(self, call) { if (call && (_typeof$f(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$d(self); }

function _assertThisInitialized$d(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$d() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$d(o) { _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$d(o); }

function _defineProperty$d(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var AMPMParser = /*#__PURE__*/function (_Parser) {
  _inherits$d(AMPMParser, _Parser);

  var _super = _createSuper$d(AMPMParser);

  function AMPMParser() {
    var _this;

    _classCallCheck$d(this, AMPMParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$d(_assertThisInitialized$d(_this), "priority", 80);

    _defineProperty$d(_assertThisInitialized$d(_this), "incompatibleTokens", ['b', 'B', 'H', 'k', 't', 'T']);

    return _this;
  }

  _createClass$d(AMPMParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'a':
        case 'aa':
        case 'aaa':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaaa':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'aaaa':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);

  return AMPMParser;
}(Parser);

function _typeof$e(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$e = function _typeof(obj) { return typeof obj; }; } else { _typeof$e = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$e(obj); }

function _classCallCheck$c(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$c(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$c(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$c(Constructor.prototype, protoProps); if (staticProps) _defineProperties$c(Constructor, staticProps); return Constructor; }

function _inherits$c(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$c(subClass, superClass); }

function _setPrototypeOf$c(o, p) { _setPrototypeOf$c = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$c(o, p); }

function _createSuper$c(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$c(); return function _createSuperInternal() { var Super = _getPrototypeOf$c(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$c(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$c(this, result); }; }

function _possibleConstructorReturn$c(self, call) { if (call && (_typeof$e(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$c(self); }

function _assertThisInitialized$c(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$c() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$c(o) { _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$c(o); }

function _defineProperty$c(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var AMPMMidnightParser = /*#__PURE__*/function (_Parser) {
  _inherits$c(AMPMMidnightParser, _Parser);

  var _super = _createSuper$c(AMPMMidnightParser);

  function AMPMMidnightParser() {
    var _this;

    _classCallCheck$c(this, AMPMMidnightParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$c(_assertThisInitialized$c(_this), "priority", 80);

    _defineProperty$c(_assertThisInitialized$c(_this), "incompatibleTokens", ['a', 'B', 'H', 'k', 't', 'T']);

    return _this;
  }

  _createClass$c(AMPMMidnightParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'b':
        case 'bb':
        case 'bbb':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbbb':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'bbbb':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);

  return AMPMMidnightParser;
}(Parser);

function _typeof$d(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$d = function _typeof(obj) { return typeof obj; }; } else { _typeof$d = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$d(obj); }

function _classCallCheck$b(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$b(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$b(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$b(Constructor.prototype, protoProps); if (staticProps) _defineProperties$b(Constructor, staticProps); return Constructor; }

function _inherits$b(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$b(subClass, superClass); }

function _setPrototypeOf$b(o, p) { _setPrototypeOf$b = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$b(o, p); }

function _createSuper$b(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$b(); return function _createSuperInternal() { var Super = _getPrototypeOf$b(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$b(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$b(this, result); }; }

function _possibleConstructorReturn$b(self, call) { if (call && (_typeof$d(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$b(self); }

function _assertThisInitialized$b(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$b() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$b(o) { _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$b(o); }

function _defineProperty$b(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var DayPeriodParser = /*#__PURE__*/function (_Parser) {
  _inherits$b(DayPeriodParser, _Parser);

  var _super = _createSuper$b(DayPeriodParser);

  function DayPeriodParser() {
    var _this;

    _classCallCheck$b(this, DayPeriodParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$b(_assertThisInitialized$b(_this), "priority", 80);

    _defineProperty$b(_assertThisInitialized$b(_this), "incompatibleTokens", ['a', 'b', 't', 'T']);

    return _this;
  }

  _createClass$b(DayPeriodParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'B':
        case 'BB':
        case 'BBB':
          return match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBBB':
          return match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });

        case 'BBBB':
        default:
          return match.dayPeriod(dateString, {
            width: 'wide',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'abbreviated',
            context: 'formatting'
          }) || match.dayPeriod(dateString, {
            width: 'narrow',
            context: 'formatting'
          });
      }
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(dayPeriodEnumToHours(value), 0, 0, 0);
      return date;
    }
  }]);

  return DayPeriodParser;
}(Parser);

function _typeof$c(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$c = function _typeof(obj) { return typeof obj; }; } else { _typeof$c = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$c(obj); }

function _classCallCheck$a(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$a(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$a(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$a(Constructor.prototype, protoProps); if (staticProps) _defineProperties$a(Constructor, staticProps); return Constructor; }

function _inherits$a(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$a(subClass, superClass); }

function _setPrototypeOf$a(o, p) { _setPrototypeOf$a = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$a(o, p); }

function _createSuper$a(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$a(); return function _createSuperInternal() { var Super = _getPrototypeOf$a(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$a(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$a(this, result); }; }

function _possibleConstructorReturn$a(self, call) { if (call && (_typeof$c(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$a(self); }

function _assertThisInitialized$a(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$a() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$a(o) { _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$a(o); }

function _defineProperty$a(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var Hour1to12Parser = /*#__PURE__*/function (_Parser) {
  _inherits$a(Hour1to12Parser, _Parser);

  var _super = _createSuper$a(Hour1to12Parser);

  function Hour1to12Parser() {
    var _this;

    _classCallCheck$a(this, Hour1to12Parser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$a(_assertThisInitialized$a(_this), "priority", 70);

    _defineProperty$a(_assertThisInitialized$a(_this), "incompatibleTokens", ['H', 'K', 'k', 't', 'T']);

    return _this;
  }

  _createClass$a(Hour1to12Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'h':
          return parseNumericPattern(numericPatterns.hour12h, dateString);

        case 'ho':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 12;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;

      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else if (!isPM && value === 12) {
        date.setUTCHours(0, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }

      return date;
    }
  }]);

  return Hour1to12Parser;
}(Parser);

function _typeof$b(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$b = function _typeof(obj) { return typeof obj; }; } else { _typeof$b = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$b(obj); }

function _classCallCheck$9(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$9(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$9(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$9(Constructor.prototype, protoProps); if (staticProps) _defineProperties$9(Constructor, staticProps); return Constructor; }

function _inherits$9(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$9(subClass, superClass); }

function _setPrototypeOf$9(o, p) { _setPrototypeOf$9 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$9(o, p); }

function _createSuper$9(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$9(); return function _createSuperInternal() { var Super = _getPrototypeOf$9(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$9(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$9(this, result); }; }

function _possibleConstructorReturn$9(self, call) { if (call && (_typeof$b(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$9(self); }

function _assertThisInitialized$9(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$9() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$9(o) { _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$9(o); }

function _defineProperty$9(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var Hour0to23Parser = /*#__PURE__*/function (_Parser) {
  _inherits$9(Hour0to23Parser, _Parser);

  var _super = _createSuper$9(Hour0to23Parser);

  function Hour0to23Parser() {
    var _this;

    _classCallCheck$9(this, Hour0to23Parser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$9(_assertThisInitialized$9(_this), "priority", 70);

    _defineProperty$9(_assertThisInitialized$9(_this), "incompatibleTokens", ['a', 'b', 'h', 'K', 'k', 't', 'T']);

    return _this;
  }

  _createClass$9(Hour0to23Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'H':
          return parseNumericPattern(numericPatterns.hour23h, dateString);

        case 'Ho':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 23;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCHours(value, 0, 0, 0);
      return date;
    }
  }]);

  return Hour0to23Parser;
}(Parser);

function _typeof$a(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$a = function _typeof(obj) { return typeof obj; }; } else { _typeof$a = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$a(obj); }

function _classCallCheck$8(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$8(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$8(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$8(Constructor.prototype, protoProps); if (staticProps) _defineProperties$8(Constructor, staticProps); return Constructor; }

function _inherits$8(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$8(subClass, superClass); }

function _setPrototypeOf$8(o, p) { _setPrototypeOf$8 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$8(o, p); }

function _createSuper$8(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$8(); return function _createSuperInternal() { var Super = _getPrototypeOf$8(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$8(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$8(this, result); }; }

function _possibleConstructorReturn$8(self, call) { if (call && (_typeof$a(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$8(self); }

function _assertThisInitialized$8(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$8() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$8(o) { _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$8(o); }

function _defineProperty$8(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var Hour0To11Parser = /*#__PURE__*/function (_Parser) {
  _inherits$8(Hour0To11Parser, _Parser);

  var _super = _createSuper$8(Hour0To11Parser);

  function Hour0To11Parser() {
    var _this;

    _classCallCheck$8(this, Hour0To11Parser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$8(_assertThisInitialized$8(_this), "priority", 70);

    _defineProperty$8(_assertThisInitialized$8(_this), "incompatibleTokens", ['h', 'H', 'k', 't', 'T']);

    return _this;
  }

  _createClass$8(Hour0To11Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'K':
          return parseNumericPattern(numericPatterns.hour11h, dateString);

        case 'Ko':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 11;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var isPM = date.getUTCHours() >= 12;

      if (isPM && value < 12) {
        date.setUTCHours(value + 12, 0, 0, 0);
      } else {
        date.setUTCHours(value, 0, 0, 0);
      }

      return date;
    }
  }]);

  return Hour0To11Parser;
}(Parser);

function _typeof$9(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$9 = function _typeof(obj) { return typeof obj; }; } else { _typeof$9 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$9(obj); }

function _classCallCheck$7(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$7(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$7(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$7(Constructor.prototype, protoProps); if (staticProps) _defineProperties$7(Constructor, staticProps); return Constructor; }

function _inherits$7(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$7(subClass, superClass); }

function _setPrototypeOf$7(o, p) { _setPrototypeOf$7 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$7(o, p); }

function _createSuper$7(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$7(); return function _createSuperInternal() { var Super = _getPrototypeOf$7(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$7(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$7(this, result); }; }

function _possibleConstructorReturn$7(self, call) { if (call && (_typeof$9(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$7(self); }

function _assertThisInitialized$7(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$7() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$7(o) { _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$7(o); }

function _defineProperty$7(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var Hour1To24Parser = /*#__PURE__*/function (_Parser) {
  _inherits$7(Hour1To24Parser, _Parser);

  var _super = _createSuper$7(Hour1To24Parser);

  function Hour1To24Parser() {
    var _this;

    _classCallCheck$7(this, Hour1To24Parser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$7(_assertThisInitialized$7(_this), "priority", 70);

    _defineProperty$7(_assertThisInitialized$7(_this), "incompatibleTokens", ['a', 'b', 'h', 'H', 'K', 't', 'T']);

    return _this;
  }

  _createClass$7(Hour1To24Parser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'k':
          return parseNumericPattern(numericPatterns.hour24h, dateString);

        case 'ko':
          return match.ordinalNumber(dateString, {
            unit: 'hour'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 1 && value <= 24;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      var hours = value <= 24 ? value % 24 : value;
      date.setUTCHours(hours, 0, 0, 0);
      return date;
    }
  }]);

  return Hour1To24Parser;
}(Parser);

function _typeof$8(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$8 = function _typeof(obj) { return typeof obj; }; } else { _typeof$8 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$8(obj); }

function _classCallCheck$6(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$6(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$6(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$6(Constructor.prototype, protoProps); if (staticProps) _defineProperties$6(Constructor, staticProps); return Constructor; }

function _inherits$6(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$6(subClass, superClass); }

function _setPrototypeOf$6(o, p) { _setPrototypeOf$6 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$6(o, p); }

function _createSuper$6(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$6(); return function _createSuperInternal() { var Super = _getPrototypeOf$6(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$6(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$6(this, result); }; }

function _possibleConstructorReturn$6(self, call) { if (call && (_typeof$8(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$6(self); }

function _assertThisInitialized$6(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$6() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$6(o) { _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$6(o); }

function _defineProperty$6(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var MinuteParser = /*#__PURE__*/function (_Parser) {
  _inherits$6(MinuteParser, _Parser);

  var _super = _createSuper$6(MinuteParser);

  function MinuteParser() {
    var _this;

    _classCallCheck$6(this, MinuteParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$6(_assertThisInitialized$6(_this), "priority", 60);

    _defineProperty$6(_assertThisInitialized$6(_this), "incompatibleTokens", ['t', 'T']);

    return _this;
  }

  _createClass$6(MinuteParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 'm':
          return parseNumericPattern(numericPatterns.minute, dateString);

        case 'mo':
          return match.ordinalNumber(dateString, {
            unit: 'minute'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMinutes(value, 0, 0);
      return date;
    }
  }]);

  return MinuteParser;
}(Parser);

function _typeof$7(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$7 = function _typeof(obj) { return typeof obj; }; } else { _typeof$7 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$7(obj); }

function _classCallCheck$5(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$5(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$5(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$5(Constructor.prototype, protoProps); if (staticProps) _defineProperties$5(Constructor, staticProps); return Constructor; }

function _inherits$5(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$5(subClass, superClass); }

function _setPrototypeOf$5(o, p) { _setPrototypeOf$5 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$5(o, p); }

function _createSuper$5(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$5(); return function _createSuperInternal() { var Super = _getPrototypeOf$5(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$5(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$5(this, result); }; }

function _possibleConstructorReturn$5(self, call) { if (call && (_typeof$7(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$5(self); }

function _assertThisInitialized$5(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$5() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$5(o) { _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$5(o); }

function _defineProperty$5(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var SecondParser = /*#__PURE__*/function (_Parser) {
  _inherits$5(SecondParser, _Parser);

  var _super = _createSuper$5(SecondParser);

  function SecondParser() {
    var _this;

    _classCallCheck$5(this, SecondParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$5(_assertThisInitialized$5(_this), "priority", 50);

    _defineProperty$5(_assertThisInitialized$5(_this), "incompatibleTokens", ['t', 'T']);

    return _this;
  }

  _createClass$5(SecondParser, [{
    key: "parse",
    value: function parse(dateString, token, match) {
      switch (token) {
        case 's':
          return parseNumericPattern(numericPatterns.second, dateString);

        case 'so':
          return match.ordinalNumber(dateString, {
            unit: 'second'
          });

        default:
          return parseNDigits(token.length, dateString);
      }
    }
  }, {
    key: "validate",
    value: function validate(_date, value) {
      return value >= 0 && value <= 59;
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCSeconds(value, 0);
      return date;
    }
  }]);

  return SecondParser;
}(Parser);

function _typeof$6(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$6 = function _typeof(obj) { return typeof obj; }; } else { _typeof$6 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$6(obj); }

function _classCallCheck$4(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$4(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$4(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$4(Constructor.prototype, protoProps); if (staticProps) _defineProperties$4(Constructor, staticProps); return Constructor; }

function _inherits$4(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$4(subClass, superClass); }

function _setPrototypeOf$4(o, p) { _setPrototypeOf$4 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$4(o, p); }

function _createSuper$4(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$4(); return function _createSuperInternal() { var Super = _getPrototypeOf$4(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$4(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$4(this, result); }; }

function _possibleConstructorReturn$4(self, call) { if (call && (_typeof$6(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$4(self); }

function _assertThisInitialized$4(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$4() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$4(o) { _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$4(o); }

function _defineProperty$4(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var FractionOfSecondParser = /*#__PURE__*/function (_Parser) {
  _inherits$4(FractionOfSecondParser, _Parser);

  var _super = _createSuper$4(FractionOfSecondParser);

  function FractionOfSecondParser() {
    var _this;

    _classCallCheck$4(this, FractionOfSecondParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$4(_assertThisInitialized$4(_this), "priority", 30);

    _defineProperty$4(_assertThisInitialized$4(_this), "incompatibleTokens", ['t', 'T']);

    return _this;
  }

  _createClass$4(FractionOfSecondParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      var valueCallback = function valueCallback(value) {
        return Math.floor(value * Math.pow(10, -token.length + 3));
      };

      return mapValue(parseNDigits(token.length, dateString), valueCallback);
    }
  }, {
    key: "set",
    value: function set(date, _flags, value) {
      date.setUTCMilliseconds(value);
      return date;
    }
  }]);

  return FractionOfSecondParser;
}(Parser);

function _typeof$5(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$5 = function _typeof(obj) { return typeof obj; }; } else { _typeof$5 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$5(obj); }

function _classCallCheck$3(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$3(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$3(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$3(Constructor.prototype, protoProps); if (staticProps) _defineProperties$3(Constructor, staticProps); return Constructor; }

function _inherits$3(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$3(subClass, superClass); }

function _setPrototypeOf$3(o, p) { _setPrototypeOf$3 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$3(o, p); }

function _createSuper$3(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$3(); return function _createSuperInternal() { var Super = _getPrototypeOf$3(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$3(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$3(this, result); }; }

function _possibleConstructorReturn$3(self, call) { if (call && (_typeof$5(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$3(self); }

function _assertThisInitialized$3(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$3() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$3(o) { _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$3(o); }

function _defineProperty$3(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ISOTimezoneWithZParser = /*#__PURE__*/function (_Parser) {
  _inherits$3(ISOTimezoneWithZParser, _Parser);

  var _super = _createSuper$3(ISOTimezoneWithZParser);

  function ISOTimezoneWithZParser() {
    var _this;

    _classCallCheck$3(this, ISOTimezoneWithZParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$3(_assertThisInitialized$3(_this), "priority", 10);

    _defineProperty$3(_assertThisInitialized$3(_this), "incompatibleTokens", ['t', 'T', 'x']);

    return _this;
  }

  _createClass$3(ISOTimezoneWithZParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      switch (token) {
        case 'X':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);

        case 'XX':
          return parseTimezonePattern(timezonePatterns.basic, dateString);

        case 'XXXX':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);

        case 'XXXXX':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);

        case 'XXX':
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }

      return new Date(date.getTime() - value);
    }
  }]);

  return ISOTimezoneWithZParser;
}(Parser);

function _typeof$4(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$4 = function _typeof(obj) { return typeof obj; }; } else { _typeof$4 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$4(obj); }

function _classCallCheck$2(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$2(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$2(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$2(Constructor.prototype, protoProps); if (staticProps) _defineProperties$2(Constructor, staticProps); return Constructor; }

function _inherits$2(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$2(subClass, superClass); }

function _setPrototypeOf$2(o, p) { _setPrototypeOf$2 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$2(o, p); }

function _createSuper$2(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$2(); return function _createSuperInternal() { var Super = _getPrototypeOf$2(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$2(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$2(this, result); }; }

function _possibleConstructorReturn$2(self, call) { if (call && (_typeof$4(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$2(self); }

function _assertThisInitialized$2(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$2() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$2(o) { _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$2(o); }

function _defineProperty$2(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var ISOTimezoneParser = /*#__PURE__*/function (_Parser) {
  _inherits$2(ISOTimezoneParser, _Parser);

  var _super = _createSuper$2(ISOTimezoneParser);

  function ISOTimezoneParser() {
    var _this;

    _classCallCheck$2(this, ISOTimezoneParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$2(_assertThisInitialized$2(_this), "priority", 10);

    _defineProperty$2(_assertThisInitialized$2(_this), "incompatibleTokens", ['t', 'T', 'X']);

    return _this;
  }

  _createClass$2(ISOTimezoneParser, [{
    key: "parse",
    value: function parse(dateString, token) {
      switch (token) {
        case 'x':
          return parseTimezonePattern(timezonePatterns.basicOptionalMinutes, dateString);

        case 'xx':
          return parseTimezonePattern(timezonePatterns.basic, dateString);

        case 'xxxx':
          return parseTimezonePattern(timezonePatterns.basicOptionalSeconds, dateString);

        case 'xxxxx':
          return parseTimezonePattern(timezonePatterns.extendedOptionalSeconds, dateString);

        case 'xxx':
        default:
          return parseTimezonePattern(timezonePatterns.extended, dateString);
      }
    }
  }, {
    key: "set",
    value: function set(date, flags, value) {
      if (flags.timestampIsSet) {
        return date;
      }

      return new Date(date.getTime() - value);
    }
  }]);

  return ISOTimezoneParser;
}(Parser);

function _typeof$3(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$3 = function _typeof(obj) { return typeof obj; }; } else { _typeof$3 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$3(obj); }

function _classCallCheck$1(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties$1(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass$1(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties$1(Constructor.prototype, protoProps); if (staticProps) _defineProperties$1(Constructor, staticProps); return Constructor; }

function _inherits$1(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf$1(subClass, superClass); }

function _setPrototypeOf$1(o, p) { _setPrototypeOf$1 = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf$1(o, p); }

function _createSuper$1(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct$1(); return function _createSuperInternal() { var Super = _getPrototypeOf$1(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf$1(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn$1(this, result); }; }

function _possibleConstructorReturn$1(self, call) { if (call && (_typeof$3(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized$1(self); }

function _assertThisInitialized$1(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct$1() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf$1(o) { _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf$1(o); }

function _defineProperty$1(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var TimestampSecondsParser = /*#__PURE__*/function (_Parser) {
  _inherits$1(TimestampSecondsParser, _Parser);

  var _super = _createSuper$1(TimestampSecondsParser);

  function TimestampSecondsParser() {
    var _this;

    _classCallCheck$1(this, TimestampSecondsParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty$1(_assertThisInitialized$1(_this), "priority", 40);

    _defineProperty$1(_assertThisInitialized$1(_this), "incompatibleTokens", '*');

    return _this;
  }

  _createClass$1(TimestampSecondsParser, [{
    key: "parse",
    value: function parse(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      return [new Date(value * 1000), {
        timestampIsSet: true
      }];
    }
  }]);

  return TimestampSecondsParser;
}(Parser);

function _typeof$2(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$2 = function _typeof(obj) { return typeof obj; }; } else { _typeof$2 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$2(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof$2(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
var TimestampMillisecondsParser = /*#__PURE__*/function (_Parser) {
  _inherits(TimestampMillisecondsParser, _Parser);

  var _super = _createSuper(TimestampMillisecondsParser);

  function TimestampMillisecondsParser() {
    var _this;

    _classCallCheck(this, TimestampMillisecondsParser);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));

    _defineProperty(_assertThisInitialized(_this), "priority", 20);

    _defineProperty(_assertThisInitialized(_this), "incompatibleTokens", '*');

    return _this;
  }

  _createClass(TimestampMillisecondsParser, [{
    key: "parse",
    value: function parse(dateString) {
      return parseAnyDigitsSigned(dateString);
    }
  }, {
    key: "set",
    value: function set(_date, _flags, value) {
      return [new Date(value), {
        timestampIsSet: true
      }];
    }
  }]);

  return TimestampMillisecondsParser;
}(Parser);

/*
 * |     | Unit                           |     | Unit                           |
 * |-----|--------------------------------|-----|--------------------------------|
 * |  a  | AM, PM                         |  A* | Milliseconds in day            |
 * |  b  | AM, PM, noon, midnight         |  B  | Flexible day period            |
 * |  c  | Stand-alone local day of week  |  C* | Localized hour w/ day period   |
 * |  d  | Day of month                   |  D  | Day of year                    |
 * |  e  | Local day of week              |  E  | Day of week                    |
 * |  f  |                                |  F* | Day of week in month           |
 * |  g* | Modified Julian day            |  G  | Era                            |
 * |  h  | Hour [1-12]                    |  H  | Hour [0-23]                    |
 * |  i! | ISO day of week                |  I! | ISO week of year               |
 * |  j* | Localized hour w/ day period   |  J* | Localized hour w/o day period  |
 * |  k  | Hour [1-24]                    |  K  | Hour [0-11]                    |
 * |  l* | (deprecated)                   |  L  | Stand-alone month              |
 * |  m  | Minute                         |  M  | Month                          |
 * |  n  |                                |  N  |                                |
 * |  o! | Ordinal number modifier        |  O* | Timezone (GMT)                 |
 * |  p  |                                |  P  |                                |
 * |  q  | Stand-alone quarter            |  Q  | Quarter                        |
 * |  r* | Related Gregorian year         |  R! | ISO week-numbering year        |
 * |  s  | Second                         |  S  | Fraction of second             |
 * |  t! | Seconds timestamp              |  T! | Milliseconds timestamp         |
 * |  u  | Extended year                  |  U* | Cyclic year                    |
 * |  v* | Timezone (generic non-locat.)  |  V* | Timezone (location)            |
 * |  w  | Local week of year             |  W* | Week of month                  |
 * |  x  | Timezone (ISO-8601 w/o Z)      |  X  | Timezone (ISO-8601)            |
 * |  y  | Year (abs)                     |  Y  | Local week-numbering year      |
 * |  z* | Timezone (specific non-locat.) |  Z* | Timezone (aliases)             |
 *
 * Letters marked by * are not implemented but reserved by Unicode standard.
 *
 * Letters marked by ! are non-standard, but implemented by date-fns:
 * - `o` modifies the previous token to turn it into an ordinal (see `parse` docs)
 * - `i` is ISO day of week. For `i` and `ii` is returns numeric ISO week days,
 *   i.e. 7 for Sunday, 1 for Monday, etc.
 * - `I` is ISO week of year, as opposed to `w` which is local week of year.
 * - `R` is ISO week-numbering year, as opposed to `Y` which is local week-numbering year.
 *   `R` is supposed to be used in conjunction with `I` and `i`
 *   for universal ISO week-numbering date, whereas
 *   `Y` is supposed to be used in conjunction with `w` and `e`
 *   for week-numbering date specific to the locale.
 */

var parsers = {
  G: new EraParser(),
  y: new YearParser(),
  Y: new LocalWeekYearParser(),
  R: new ISOWeekYearParser(),
  u: new ExtendedYearParser(),
  Q: new QuarterParser(),
  q: new StandAloneQuarterParser(),
  M: new MonthParser(),
  L: new StandAloneMonthParser(),
  w: new LocalWeekParser(),
  I: new ISOWeekParser(),
  d: new DateParser(),
  D: new DayOfYearParser(),
  E: new DayParser(),
  e: new LocalDayParser(),
  c: new StandAloneLocalDayParser(),
  i: new ISODayParser(),
  a: new AMPMParser(),
  b: new AMPMMidnightParser(),
  B: new DayPeriodParser(),
  h: new Hour1to12Parser(),
  H: new Hour0to23Parser(),
  K: new Hour0To11Parser(),
  k: new Hour1To24Parser(),
  m: new MinuteParser(),
  s: new SecondParser(),
  S: new FractionOfSecondParser(),
  X: new ISOTimezoneWithZParser(),
  x: new ISOTimezoneParser(),
  t: new TimestampSecondsParser(),
  T: new TimestampMillisecondsParser()
};

function _typeof$1(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof$1 = function _typeof(obj) { return typeof obj; }; } else { _typeof$1 = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof$1(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
// - [yYQqMLwIdDecihHKkms]o matches any available ordinal number token
//   (one of the certain letters followed by `o`)
// - (\w)\1* matches any sequences of the same letter
// - '' matches two quote characters in a row
// - '(''|[^'])+('|$) matches anything surrounded by two quote characters ('),
//   except a single quote symbol, which ends the sequence.
//   Two quote characters do not end the sequence.
//   If there is no matching single quote
//   then the sequence will continue until the end of the string.
// - . matches any single character unmatched by previous parts of the RegExps

var formattingTokensRegExp = /[yYQqMLwIdDecihHKkms]o|(\w)\1*|''|'(''|[^'])+('|$)|./g; // This RegExp catches symbols escaped by quotes, and also
// sequences of symbols P, p, and the combinations like `PPPPPPPppppp`

var longFormattingTokensRegExp = /P+p+|P+|p+|''|'(''|[^'])+('|$)|./g;
var escapedStringRegExp = /^'([^]*?)'?$/;
var doubleQuoteRegExp = /''/g;
var notWhitespaceRegExp = /\S/;
var unescapedLatinCharacterRegExp = /[a-zA-Z]/;
/**
 * @name parse
 * @category Common Helpers
 * @summary Parse the date.
 *
 * @description
 * Return the date parsed from string using the given format string.
 *
 * > ⚠️ Please note that the `format` tokens differ from Moment.js and other libraries.
 * > See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * The characters in the format string wrapped between two single quotes characters (') are escaped.
 * Two single quotes in a row, whether inside or outside a quoted sequence, represent a 'real' single quote.
 *
 * Format of the format string is based on Unicode Technical Standard #35:
 * https://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
 * with a few additions (see note 5 below the table).
 *
 * Not all tokens are compatible. Combinations that don't make sense or could lead to bugs are prohibited
 * and will throw `RangeError`. For example usage of 24-hour format token with AM/PM token will throw an exception:
 *
 * ```javascript
 * parse('23 AM', 'HH a', new Date())
 * //=> RangeError: The format string mustn't contain `HH` and `a` at the same time
 * ```
 *
 * See the compatibility table: https://docs.google.com/spreadsheets/d/e/2PACX-1vQOPU3xUhplll6dyoMmVUXHKl_8CRDs6_ueLmex3SoqwhuolkuN3O05l4rqx5h1dKX8eb46Ul-CCSrq/pubhtml?gid=0&single=true
 *
 * Accepted format string patterns:
 * | Unit                            |Prior| Pattern | Result examples                   | Notes |
 * |---------------------------------|-----|---------|-----------------------------------|-------|
 * | Era                             | 140 | G..GGG  | AD, BC                            |       |
 * |                                 |     | GGGG    | Anno Domini, Before Christ        | 2     |
 * |                                 |     | GGGGG   | A, B                              |       |
 * | Calendar year                   | 130 | y       | 44, 1, 1900, 2017, 9999           | 4     |
 * |                                 |     | yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | yy      | 44, 01, 00, 17                    | 4     |
 * |                                 |     | yyy     | 044, 001, 123, 999                | 4     |
 * |                                 |     | yyyy    | 0044, 0001, 1900, 2017            | 4     |
 * |                                 |     | yyyyy   | ...                               | 2,4   |
 * | Local week-numbering year       | 130 | Y       | 44, 1, 1900, 2017, 9000           | 4     |
 * |                                 |     | Yo      | 44th, 1st, 1900th, 9999999th      | 4,5   |
 * |                                 |     | YY      | 44, 01, 00, 17                    | 4,6   |
 * |                                 |     | YYY     | 044, 001, 123, 999                | 4     |
 * |                                 |     | YYYY    | 0044, 0001, 1900, 2017            | 4,6   |
 * |                                 |     | YYYYY   | ...                               | 2,4   |
 * | ISO week-numbering year         | 130 | R       | -43, 1, 1900, 2017, 9999, -9999   | 4,5   |
 * |                                 |     | RR      | -43, 01, 00, 17                   | 4,5   |
 * |                                 |     | RRR     | -043, 001, 123, 999, -999         | 4,5   |
 * |                                 |     | RRRR    | -0043, 0001, 2017, 9999, -9999    | 4,5   |
 * |                                 |     | RRRRR   | ...                               | 2,4,5 |
 * | Extended year                   | 130 | u       | -43, 1, 1900, 2017, 9999, -999    | 4     |
 * |                                 |     | uu      | -43, 01, 99, -99                  | 4     |
 * |                                 |     | uuu     | -043, 001, 123, 999, -999         | 4     |
 * |                                 |     | uuuu    | -0043, 0001, 2017, 9999, -9999    | 4     |
 * |                                 |     | uuuuu   | ...                               | 2,4   |
 * | Quarter (formatting)            | 120 | Q       | 1, 2, 3, 4                        |       |
 * |                                 |     | Qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | QQ      | 01, 02, 03, 04                    |       |
 * |                                 |     | QQQ     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | QQQQ    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | QQQQQ   | 1, 2, 3, 4                        | 4     |
 * | Quarter (stand-alone)           | 120 | q       | 1, 2, 3, 4                        |       |
 * |                                 |     | qo      | 1st, 2nd, 3rd, 4th                | 5     |
 * |                                 |     | qq      | 01, 02, 03, 04                    |       |
 * |                                 |     | qqq     | Q1, Q2, Q3, Q4                    |       |
 * |                                 |     | qqqq    | 1st quarter, 2nd quarter, ...     | 2     |
 * |                                 |     | qqqqq   | 1, 2, 3, 4                        | 3     |
 * | Month (formatting)              | 110 | M       | 1, 2, ..., 12                     |       |
 * |                                 |     | Mo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | MM      | 01, 02, ..., 12                   |       |
 * |                                 |     | MMM     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | MMMM    | January, February, ..., December  | 2     |
 * |                                 |     | MMMMM   | J, F, ..., D                      |       |
 * | Month (stand-alone)             | 110 | L       | 1, 2, ..., 12                     |       |
 * |                                 |     | Lo      | 1st, 2nd, ..., 12th               | 5     |
 * |                                 |     | LL      | 01, 02, ..., 12                   |       |
 * |                                 |     | LLL     | Jan, Feb, ..., Dec                |       |
 * |                                 |     | LLLL    | January, February, ..., December  | 2     |
 * |                                 |     | LLLLL   | J, F, ..., D                      |       |
 * | Local week of year              | 100 | w       | 1, 2, ..., 53                     |       |
 * |                                 |     | wo      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | ww      | 01, 02, ..., 53                   |       |
 * | ISO week of year                | 100 | I       | 1, 2, ..., 53                     | 5     |
 * |                                 |     | Io      | 1st, 2nd, ..., 53th               | 5     |
 * |                                 |     | II      | 01, 02, ..., 53                   | 5     |
 * | Day of month                    |  90 | d       | 1, 2, ..., 31                     |       |
 * |                                 |     | do      | 1st, 2nd, ..., 31st               | 5     |
 * |                                 |     | dd      | 01, 02, ..., 31                   |       |
 * | Day of year                     |  90 | D       | 1, 2, ..., 365, 366               | 7     |
 * |                                 |     | Do      | 1st, 2nd, ..., 365th, 366th       | 5     |
 * |                                 |     | DD      | 01, 02, ..., 365, 366             | 7     |
 * |                                 |     | DDD     | 001, 002, ..., 365, 366           |       |
 * |                                 |     | DDDD    | ...                               | 2     |
 * | Day of week (formatting)        |  90 | E..EEE  | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | EEEE    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | EEEEE   | M, T, W, T, F, S, S               |       |
 * |                                 |     | EEEEEE  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | ISO day of week (formatting)    |  90 | i       | 1, 2, 3, ..., 7                   | 5     |
 * |                                 |     | io      | 1st, 2nd, ..., 7th                | 5     |
 * |                                 |     | ii      | 01, 02, ..., 07                   | 5     |
 * |                                 |     | iii     | Mon, Tue, Wed, ..., Sun           | 5     |
 * |                                 |     | iiii    | Monday, Tuesday, ..., Sunday      | 2,5   |
 * |                                 |     | iiiii   | M, T, W, T, F, S, S               | 5     |
 * |                                 |     | iiiiii  | Mo, Tu, We, Th, Fr, Sa, Su        | 5     |
 * | Local day of week (formatting)  |  90 | e       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | eo      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | ee      | 02, 03, ..., 01                   |       |
 * |                                 |     | eee     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | eeee    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | eeeee   | M, T, W, T, F, S, S               |       |
 * |                                 |     | eeeeee  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | Local day of week (stand-alone) |  90 | c       | 2, 3, 4, ..., 1                   |       |
 * |                                 |     | co      | 2nd, 3rd, ..., 1st                | 5     |
 * |                                 |     | cc      | 02, 03, ..., 01                   |       |
 * |                                 |     | ccc     | Mon, Tue, Wed, ..., Sun           |       |
 * |                                 |     | cccc    | Monday, Tuesday, ..., Sunday      | 2     |
 * |                                 |     | ccccc   | M, T, W, T, F, S, S               |       |
 * |                                 |     | cccccc  | Mo, Tu, We, Th, Fr, Sa, Su        |       |
 * | AM, PM                          |  80 | a..aaa  | AM, PM                            |       |
 * |                                 |     | aaaa    | a.m., p.m.                        | 2     |
 * |                                 |     | aaaaa   | a, p                              |       |
 * | AM, PM, noon, midnight          |  80 | b..bbb  | AM, PM, noon, midnight            |       |
 * |                                 |     | bbbb    | a.m., p.m., noon, midnight        | 2     |
 * |                                 |     | bbbbb   | a, p, n, mi                       |       |
 * | Flexible day period             |  80 | B..BBB  | at night, in the morning, ...     |       |
 * |                                 |     | BBBB    | at night, in the morning, ...     | 2     |
 * |                                 |     | BBBBB   | at night, in the morning, ...     |       |
 * | Hour [1-12]                     |  70 | h       | 1, 2, ..., 11, 12                 |       |
 * |                                 |     | ho      | 1st, 2nd, ..., 11th, 12th         | 5     |
 * |                                 |     | hh      | 01, 02, ..., 11, 12               |       |
 * | Hour [0-23]                     |  70 | H       | 0, 1, 2, ..., 23                  |       |
 * |                                 |     | Ho      | 0th, 1st, 2nd, ..., 23rd          | 5     |
 * |                                 |     | HH      | 00, 01, 02, ..., 23               |       |
 * | Hour [0-11]                     |  70 | K       | 1, 2, ..., 11, 0                  |       |
 * |                                 |     | Ko      | 1st, 2nd, ..., 11th, 0th          | 5     |
 * |                                 |     | KK      | 01, 02, ..., 11, 00               |       |
 * | Hour [1-24]                     |  70 | k       | 24, 1, 2, ..., 23                 |       |
 * |                                 |     | ko      | 24th, 1st, 2nd, ..., 23rd         | 5     |
 * |                                 |     | kk      | 24, 01, 02, ..., 23               |       |
 * | Minute                          |  60 | m       | 0, 1, ..., 59                     |       |
 * |                                 |     | mo      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | mm      | 00, 01, ..., 59                   |       |
 * | Second                          |  50 | s       | 0, 1, ..., 59                     |       |
 * |                                 |     | so      | 0th, 1st, ..., 59th               | 5     |
 * |                                 |     | ss      | 00, 01, ..., 59                   |       |
 * | Seconds timestamp               |  40 | t       | 512969520                         |       |
 * |                                 |     | tt      | ...                               | 2     |
 * | Fraction of second              |  30 | S       | 0, 1, ..., 9                      |       |
 * |                                 |     | SS      | 00, 01, ..., 99                   |       |
 * |                                 |     | SSS     | 000, 001, ..., 999                |       |
 * |                                 |     | SSSS    | ...                               | 2     |
 * | Milliseconds timestamp          |  20 | T       | 512969520900                      |       |
 * |                                 |     | TT      | ...                               | 2     |
 * | Timezone (ISO-8601 w/ Z)        |  10 | X       | -08, +0530, Z                     |       |
 * |                                 |     | XX      | -0800, +0530, Z                   |       |
 * |                                 |     | XXX     | -08:00, +05:30, Z                 |       |
 * |                                 |     | XXXX    | -0800, +0530, Z, +123456          | 2     |
 * |                                 |     | XXXXX   | -08:00, +05:30, Z, +12:34:56      |       |
 * | Timezone (ISO-8601 w/o Z)       |  10 | x       | -08, +0530, +00                   |       |
 * |                                 |     | xx      | -0800, +0530, +0000               |       |
 * |                                 |     | xxx     | -08:00, +05:30, +00:00            | 2     |
 * |                                 |     | xxxx    | -0800, +0530, +0000, +123456      |       |
 * |                                 |     | xxxxx   | -08:00, +05:30, +00:00, +12:34:56 |       |
 * | Long localized date             |  NA | P       | 05/29/1453                        | 5,8   |
 * |                                 |     | PP      | May 29, 1453                      |       |
 * |                                 |     | PPP     | May 29th, 1453                    |       |
 * |                                 |     | PPPP    | Sunday, May 29th, 1453            | 2,5,8 |
 * | Long localized time             |  NA | p       | 12:00 AM                          | 5,8   |
 * |                                 |     | pp      | 12:00:00 AM                       |       |
 * | Combination of date and time    |  NA | Pp      | 05/29/1453, 12:00 AM              |       |
 * |                                 |     | PPpp    | May 29, 1453, 12:00:00 AM         |       |
 * |                                 |     | PPPpp   | May 29th, 1453 at ...             |       |
 * |                                 |     | PPPPpp  | Sunday, May 29th, 1453 at ...     | 2,5,8 |
 * Notes:
 * 1. "Formatting" units (e.g. formatting quarter) in the default en-US locale
 *    are the same as "stand-alone" units, but are different in some languages.
 *    "Formatting" units are declined according to the rules of the language
 *    in the context of a date. "Stand-alone" units are always nominative singular.
 *    In `format` function, they will produce different result:
 *
 *    `format(new Date(2017, 10, 6), 'do LLLL', {locale: cs}) //=> '6. listopad'`
 *
 *    `format(new Date(2017, 10, 6), 'do MMMM', {locale: cs}) //=> '6. listopadu'`
 *
 *    `parse` will try to match both formatting and stand-alone units interchangably.
 *
 * 2. Any sequence of the identical letters is a pattern, unless it is escaped by
 *    the single quote characters (see below).
 *    If the sequence is longer than listed in table:
 *    - for numerical units (`yyyyyyyy`) `parse` will try to match a number
 *      as wide as the sequence
 *    - for text units (`MMMMMMMM`) `parse` will try to match the widest variation of the unit.
 *      These variations are marked with "2" in the last column of the table.
 *
 * 3. `QQQQQ` and `qqqqq` could be not strictly numerical in some locales.
 *    These tokens represent the shortest form of the quarter.
 *
 * 4. The main difference between `y` and `u` patterns are B.C. years:
 *
 *    | Year | `y` | `u` |
 *    |------|-----|-----|
 *    | AC 1 |   1 |   1 |
 *    | BC 1 |   1 |   0 |
 *    | BC 2 |   2 |  -1 |
 *
 *    Also `yy` will try to guess the century of two digit year by proximity with `referenceDate`:
 *
 *    `parse('50', 'yy', new Date(2018, 0, 1)) //=> Sat Jan 01 2050 00:00:00`
 *
 *    `parse('75', 'yy', new Date(2018, 0, 1)) //=> Wed Jan 01 1975 00:00:00`
 *
 *    while `uu` will just assign the year as is:
 *
 *    `parse('50', 'uu', new Date(2018, 0, 1)) //=> Sat Jan 01 0050 00:00:00`
 *
 *    `parse('75', 'uu', new Date(2018, 0, 1)) //=> Tue Jan 01 0075 00:00:00`
 *
 *    The same difference is true for local and ISO week-numbering years (`Y` and `R`),
 *    except local week-numbering years are dependent on `options.weekStartsOn`
 *    and `options.firstWeekContainsDate` (compare [setISOWeekYear]{@link https://date-fns.org/docs/setISOWeekYear}
 *    and [setWeekYear]{@link https://date-fns.org/docs/setWeekYear}).
 *
 * 5. These patterns are not in the Unicode Technical Standard #35:
 *    - `i`: ISO day of week
 *    - `I`: ISO week of year
 *    - `R`: ISO week-numbering year
 *    - `o`: ordinal number modifier
 *    - `P`: long localized date
 *    - `p`: long localized time
 *
 * 6. `YY` and `YYYY` tokens represent week-numbering years but they are often confused with years.
 *    You should enable `options.useAdditionalWeekYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 7. `D` and `DD` tokens represent days of the year but they are ofthen confused with days of the month.
 *    You should enable `options.useAdditionalDayOfYearTokens` to use them. See: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 *
 * 8. `P+` tokens do not have a defined priority since they are merely aliases to other tokens based
 *    on the given locale.
 *
 *    using `en-US` locale: `P` => `MM/dd/yyyy`
 *    using `en-US` locale: `p` => `hh:mm a`
 *    using `pt-BR` locale: `P` => `dd/MM/yyyy`
 *    using `pt-BR` locale: `p` => `HH:mm`
 *
 * Values will be assigned to the date in the descending order of its unit's priority.
 * Units of an equal priority overwrite each other in the order of appearance.
 *
 * If no values of higher priority are parsed (e.g. when parsing string 'January 1st' without a year),
 * the values will be taken from 3rd argument `referenceDate` which works as a context of parsing.
 *
 * `referenceDate` must be passed for correct work of the function.
 * If you're not sure which `referenceDate` to supply, create a new instance of Date:
 * `parse('02/11/2014', 'MM/dd/yyyy', new Date())`
 * In this case parsing will be done in the context of the current date.
 * If `referenceDate` is `Invalid Date` or a value not convertible to valid `Date`,
 * then `Invalid Date` will be returned.
 *
 * The result may vary by locale.
 *
 * If `formatString` matches with `dateString` but does not provides tokens, `referenceDate` will be returned.
 *
 * If parsing failed, `Invalid Date` will be returned.
 * Invalid Date is a Date, whose time value is NaN.
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {String} dateString - the string to parse
 * @param {String} formatString - the string of tokens
 * @param {Date|Number} referenceDate - defines values missing from the parsed dateString
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @param {1|2|3|4|5|6|7} [options.firstWeekContainsDate=1] - the day of January, which is always in the first week of the year
 * @param {Boolean} [options.useAdditionalWeekYearTokens=false] - if true, allows usage of the week-numbering year tokens `YY` and `YYYY`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @param {Boolean} [options.useAdditionalDayOfYearTokens=false] - if true, allows usage of the day of year tokens `D` and `DD`;
 *   see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @returns {Date} the parsed date
 * @throws {TypeError} 3 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 * @throws {RangeError} `options.firstWeekContainsDate` must be between 1 and 7
 * @throws {RangeError} `options.locale` must contain `match` property
 * @throws {RangeError} use `yyyy` instead of `YYYY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `yy` instead of `YY` for formatting years using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `d` instead of `D` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} use `dd` instead of `DD` for formatting days of the month using [format provided] to the input [input provided]; see: https://github.com/date-fns/date-fns/blob/master/docs/unicodeTokens.md
 * @throws {RangeError} format string contains an unescaped latin alphabet character
 *
 * @example
 * // Parse 11 February 2014 from middle-endian format:
 * var result = parse('02/11/2014', 'MM/dd/yyyy', new Date())
 * //=> Tue Feb 11 2014 00:00:00
 *
 * @example
 * // Parse 28th of February in Esperanto locale in the context of 2010 year:
 * import eo from 'date-fns/locale/eo'
 * var result = parse('28-a de februaro', "do 'de' MMMM", new Date(2010, 0, 1), {
 *   locale: eo
 * })
 * //=> Sun Feb 28 2010 00:00:00
 */

function parse(dirtyDateString, dirtyFormatString, dirtyReferenceDate, options) {
  var _ref, _options$locale, _ref2, _ref3, _ref4, _options$firstWeekCon, _options$locale2, _options$locale2$opti, _defaultOptions$local, _defaultOptions$local2, _ref5, _ref6, _ref7, _options$weekStartsOn, _options$locale3, _options$locale3$opti, _defaultOptions$local3, _defaultOptions$local4;

  requiredArgs(3, arguments);
  var dateString = String(dirtyDateString);
  var formatString = String(dirtyFormatString);
  var defaultOptions = getDefaultOptions();
  var locale$1 = (_ref = (_options$locale = options === null || options === void 0 ? void 0 : options.locale) !== null && _options$locale !== void 0 ? _options$locale : defaultOptions.locale) !== null && _ref !== void 0 ? _ref : locale;

  if (!locale$1.match) {
    throw new RangeError('locale must contain match property');
  }

  var firstWeekContainsDate = toInteger((_ref2 = (_ref3 = (_ref4 = (_options$firstWeekCon = options === null || options === void 0 ? void 0 : options.firstWeekContainsDate) !== null && _options$firstWeekCon !== void 0 ? _options$firstWeekCon : options === null || options === void 0 ? void 0 : (_options$locale2 = options.locale) === null || _options$locale2 === void 0 ? void 0 : (_options$locale2$opti = _options$locale2.options) === null || _options$locale2$opti === void 0 ? void 0 : _options$locale2$opti.firstWeekContainsDate) !== null && _ref4 !== void 0 ? _ref4 : defaultOptions.firstWeekContainsDate) !== null && _ref3 !== void 0 ? _ref3 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.firstWeekContainsDate) !== null && _ref2 !== void 0 ? _ref2 : 1); // Test if weekStartsOn is between 1 and 7 _and_ is not NaN

  if (!(firstWeekContainsDate >= 1 && firstWeekContainsDate <= 7)) {
    throw new RangeError('firstWeekContainsDate must be between 1 and 7 inclusively');
  }

  var weekStartsOn = toInteger((_ref5 = (_ref6 = (_ref7 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale3 = options.locale) === null || _options$locale3 === void 0 ? void 0 : (_options$locale3$opti = _options$locale3.options) === null || _options$locale3$opti === void 0 ? void 0 : _options$locale3$opti.weekStartsOn) !== null && _ref7 !== void 0 ? _ref7 : defaultOptions.weekStartsOn) !== null && _ref6 !== void 0 ? _ref6 : (_defaultOptions$local3 = defaultOptions.locale) === null || _defaultOptions$local3 === void 0 ? void 0 : (_defaultOptions$local4 = _defaultOptions$local3.options) === null || _defaultOptions$local4 === void 0 ? void 0 : _defaultOptions$local4.weekStartsOn) !== null && _ref5 !== void 0 ? _ref5 : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  if (formatString === '') {
    if (dateString === '') {
      return toDate(dirtyReferenceDate);
    } else {
      return new Date(NaN);
    }
  }

  var subFnOptions = {
    firstWeekContainsDate: firstWeekContainsDate,
    weekStartsOn: weekStartsOn,
    locale: locale$1
  }; // If timezone isn't specified, it will be set to the system timezone

  var setters = [new DateToSystemTimezoneSetter()];
  var tokens = formatString.match(longFormattingTokensRegExp).map(function (substring) {
    var firstCharacter = substring[0];

    if (firstCharacter in longFormatters) {
      var longFormatter = longFormatters[firstCharacter];
      return longFormatter(substring, locale$1.formatLong);
    }

    return substring;
  }).join('').match(formattingTokensRegExp);
  var usedTokens = [];

  var _iterator = _createForOfIteratorHelper(tokens),
      _step;

  try {
    var _loop = function _loop() {
      var token = _step.value;

      if (!(options !== null && options !== void 0 && options.useAdditionalWeekYearTokens) && isProtectedWeekYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }

      if (!(options !== null && options !== void 0 && options.useAdditionalDayOfYearTokens) && isProtectedDayOfYearToken(token)) {
        throwProtectedError(token, formatString, dirtyDateString);
      }

      var firstCharacter = token[0];
      var parser = parsers[firstCharacter];

      if (parser) {
        var incompatibleTokens = parser.incompatibleTokens;

        if (Array.isArray(incompatibleTokens)) {
          var incompatibleToken = usedTokens.find(function (usedToken) {
            return incompatibleTokens.includes(usedToken.token) || usedToken.token === firstCharacter;
          });

          if (incompatibleToken) {
            throw new RangeError("The format string mustn't contain `".concat(incompatibleToken.fullToken, "` and `").concat(token, "` at the same time"));
          }
        } else if (parser.incompatibleTokens === '*' && usedTokens.length > 0) {
          throw new RangeError("The format string mustn't contain `".concat(token, "` and any other token at the same time"));
        }

        usedTokens.push({
          token: firstCharacter,
          fullToken: token
        });
        var parseResult = parser.run(dateString, token, locale$1.match, subFnOptions);

        if (!parseResult) {
          return {
            v: new Date(NaN)
          };
        }

        setters.push(parseResult.setter);
        dateString = parseResult.rest;
      } else {
        if (firstCharacter.match(unescapedLatinCharacterRegExp)) {
          throw new RangeError('Format string contains an unescaped latin alphabet character `' + firstCharacter + '`');
        } // Replace two single quote characters with one single quote character


        if (token === "''") {
          token = "'";
        } else if (firstCharacter === "'") {
          token = cleanEscapedString(token);
        } // Cut token from string, or, if string doesn't match the token, return Invalid Date


        if (dateString.indexOf(token) === 0) {
          dateString = dateString.slice(token.length);
        } else {
          return {
            v: new Date(NaN)
          };
        }
      }
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ret = _loop();

      if (_typeof$1(_ret) === "object") return _ret.v;
    } // Check if the remaining input contains something other than whitespace

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (dateString.length > 0 && notWhitespaceRegExp.test(dateString)) {
    return new Date(NaN);
  }

  var uniquePrioritySetters = setters.map(function (setter) {
    return setter.priority;
  }).sort(function (a, b) {
    return b - a;
  }).filter(function (priority, index, array) {
    return array.indexOf(priority) === index;
  }).map(function (priority) {
    return setters.filter(function (setter) {
      return setter.priority === priority;
    }).sort(function (a, b) {
      return b.subPriority - a.subPriority;
    });
  }).map(function (setterArray) {
    return setterArray[0];
  });
  var date = toDate(dirtyReferenceDate);

  if (isNaN(date.getTime())) {
    return new Date(NaN);
  } // Convert the date in system timezone to the same date in UTC+00:00 timezone.


  var utcDate = subMilliseconds(date, getTimezoneOffsetInMilliseconds(date));
  var flags = {};

  var _iterator2 = _createForOfIteratorHelper(uniquePrioritySetters),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var setter = _step2.value;

      if (!setter.validate(utcDate, subFnOptions)) {
        return new Date(NaN);
      }

      var result = setter.set(utcDate, flags, subFnOptions); // Result is tuple (date, flags)

      if (Array.isArray(result)) {
        utcDate = result[0];
        assign(flags, result[1]); // Result is date
      } else {
        utcDate = result;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return utcDate;
}

function cleanEscapedString(input) {
  return input.match(escapedStringRegExp)[1].replace(doubleQuoteRegExp, "'");
}

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }
/**
 * @name isDate
 * @category Common Helpers
 * @summary Is the given value a date?
 *
 * @description
 * Returns true if the given value is an instance of Date. The function works for dates transferred across iframes.
 *
 * @param {*} value - the value to check
 * @returns {boolean} true if the given value is a date
 * @throws {TypeError} 1 arguments required
 *
 * @example
 * // For a valid date:
 * const result = isDate(new Date())
 * //=> true
 *
 * @example
 * // For an invalid date:
 * const result = isDate(new Date(NaN))
 * //=> true
 *
 * @example
 * // For some value:
 * const result = isDate('2014-02-31')
 * //=> false
 *
 * @example
 * // For an object:
 * const result = isDate({})
 * //=> false
 */

function isDate(value) {
  requiredArgs(1, arguments);
  return value instanceof Date || _typeof(value) === 'object' && Object.prototype.toString.call(value) === '[object Date]';
}

/**
 * @name isValid
 * @category Common Helpers
 * @summary Is the given date valid?
 *
 * @description
 * Returns false if argument is Invalid Date and true otherwise.
 * Argument is converted to Date using `toDate`. See [toDate]{@link https://date-fns.org/docs/toDate}
 * Invalid Date is a Date, whose time value is NaN.
 *
 * Time value of Date: http://es5.github.io/#x15.9.1.1
 *
 * @param {*} date - the date to check
 * @returns {Boolean} the date is valid
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // For the valid date:
 * const result = isValid(new Date(2014, 1, 31))
 * //=> true
 *
 * @example
 * // For the value, convertable into a date:
 * const result = isValid(1393804800000)
 * //=> true
 *
 * @example
 * // For the invalid date:
 * const result = isValid(new Date(''))
 * //=> false
 */

function isValid(dirtyDate) {
  requiredArgs(1, arguments);

  if (!isDate(dirtyDate) && typeof dirtyDate !== 'number') {
    return false;
  }

  var date = toDate(dirtyDate);
  return !isNaN(Number(date));
}

const inputMaskCss = "/*!@:root*/.sc-sdx-input-mask:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-input-mask-h,*.sc-sdx-input-mask,*.sc-sdx-input-mask:before,*.sc-sdx-input-mask:after{box-sizing:border-box}/*!@.sr-only*/.sr-only.sc-sdx-input-mask{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);border:0}/*!@.sr-only-focusable:active, .sr-only-focusable:focus*/.sr-only-focusable.sc-sdx-input-mask:active,.sr-only-focusable.sc-sdx-input-mask:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}/*!@label*/label.sc-sdx-input-mask{display:block;margin-bottom:4px;cursor:inherit;color:#666;font-size:16px}/*!@label.readonly, label.disabled*/label.readonly.sc-sdx-input-mask,label.disabled.sc-sdx-input-mask{color:#bbb}/*!@label.sdx--dark-theme*/label.sdx--dark-theme.sc-sdx-input-mask{color:#adadad}@media (min-width: 480px){/*!@.component*/.component.sc-sdx-input-mask{max-width:320px}}/*!@.component .wrapper*/.component.sc-sdx-input-mask .wrapper.sc-sdx-input-mask{display:flex}/*!@.component .wrapper .input:nth-of-type(1), .component .wrapper .input:nth-of-type(2)*/.component.sc-sdx-input-mask .wrapper.sc-sdx-input-mask .input.sc-sdx-input-mask:nth-of-type(1),.component.sc-sdx-input-mask .wrapper.sc-sdx-input-mask .input.sc-sdx-input-mask:nth-of-type(2){flex:2}/*!@.component .wrapper .input:nth-of-type(3)*/.component.sc-sdx-input-mask .wrapper.sc-sdx-input-mask .input.sc-sdx-input-mask:nth-of-type(3){flex:3}/*!@.component .wrapper .separator*/.component.sc-sdx-input-mask .wrapper.sc-sdx-input-mask .separator.sc-sdx-input-mask{align-self:end;text-align:center;width:16px;margin-bottom:12px}";

class Input {
  valueChanged() {
    this.updateHiddenFormInputEl();
  }
  nameChanged() {
    this.updateHiddenFormInputEl();
  }
  validationChanged() {
    // Know whether the consumer or the component changed the prop
    if (this.internalValidationChangeInProgress) {
      this.isValidationSetInternally = true;
    }
    else {
      this.isValidationSetInternally = false;
    }
  }
  async doFocus() {
    var _a;
    (_a = this.parts[0].el) === null || _a === void 0 ? void 0 : _a.doFocus();
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.parts = [
      {
        label: "Day",
        placeholder: "DD",
        maxLength: 2,
        validationMessage: "Please enter a valid day",
        validate: (value) => {
          const valueAsNumber = parseFloat(value);
          return valueAsNumber >= 1 && valueAsNumber <= 31;
        },
      },
      {
        label: "Month",
        placeholder: "MM",
        maxLength: 2,
        validationMessage: "Please enter a valid month",
        validate: (value) => {
          const valueAsNumber = parseFloat(value);
          return valueAsNumber >= 1 && valueAsNumber <= 12;
        },
      },
      {
        label: "Year",
        placeholder: "YYYY",
        maxLength: 4,
        validationMessage: "Please enter a valid year",
        validate: (value) => {
          return value.length === 4;
        },
      },
    ];
    this.internalValidationChangeInProgress = false;
    this.isValidationSetInternally = false;
    this.srHint = "";
    this.type = undefined;
    this.value = "";
    this.label = "";
    this.name = undefined;
    this.valid = undefined;
    this.validationMessage = undefined;
    this.required = false;
    this.autofocus = false;
    this.updateHiddenFormInputEl();
  }
  componentDidLoad() {
    if (this.autofocus) {
      // timeout because of https://github.com/ionic-team/stencil/issues/3246
      setTimeout(() => {
        this.doFocus();
      });
    }
  }
  updateHiddenFormInputEl() {
    if (!this.lightDOMHiddenFormInputEl) {
      this.lightDOMHiddenFormInputEl = document.createElement("input");
      this.lightDOMHiddenFormInputEl.type = "hidden";
      this.el.append(this.lightDOMHiddenFormInputEl);
    }
    // Clean up properties added previously in case they've changed
    this.lightDOMHiddenFormInputEl.removeAttribute("name");
    this.lightDOMHiddenFormInputEl.removeAttribute("value");
    if (this.name) {
      this.lightDOMHiddenFormInputEl.name = this.name;
      this.lightDOMHiddenFormInputEl.value = this.value;
    }
  }
  validate(focussed) {
    const hasValidation = this.valid !== undefined || this.validationMessage !== undefined;
    if (hasValidation && !this.isValidationSetInternally) {
      // The properties provided by the consumer are considered
      // stronger and should therefore not be overwritten
      return;
    }
    if (focussed) {
      // Do nothing while the user is still busy filling in all fields
      return;
    }
    const parts = this.parts;
    const someEmpty = parts.some((part) => { var _a; return !((_a = part.el) === null || _a === void 0 ? void 0 : _a.value); });
    const allEmpty = parts.every((part) => { var _a; return !((_a = part.el) === null || _a === void 0 ? void 0 : _a.value); });
    // Make sure validation starts from scratch every single time
    parts.forEach((part) => (part.valid = undefined));
    this.setValidation(undefined, undefined);
    if (someEmpty) {
      if (allEmpty) {
        // It's okay to have all empty
        return;
      }
      parts.forEach((part) => (part.valid = false));
      this.setValidation(false, translate("Please enter a valid date", this.el.lang));
      return;
    }
    // Validate all fields individually
    parts.forEach((part) => {
      if (part.el && part.el.value) {
        part.valid = part.validate(part.el.value);
      }
    });
    if (parts.filter((part) => part.valid === false).length > 1) {
      // If more than one field is invalid, the whole date is invalid
      parts.forEach((part) => (part.valid = false));
      this.setValidation(false, translate("Please enter a valid date", this.el.lang));
      return;
    }
    // Show validation message if needed
    for (const part of parts) {
      if (part.valid === false) {
        this.setValidation(false, translate(part.validationMessage, this.el.lang));
        return;
      }
    }
    // Validate all fields fields holistically
    if (!isValid(parse(this.value, "dd.MM.yyyy", new Date()))) {
      parts.forEach((part) => (part.valid = false));
      this.setValidation(false, translate("Please enter a valid date", this.el.lang));
      return;
    }
  }
  save() {
    // Empty value should not be ".."
    if (this.parts.every((part) => { var _a; return ((_a = part.el) === null || _a === void 0 ? void 0 : _a.value) === ""; })) {
      this.value = "";
      return;
    }
    this.value = this.parts.map((part) => { var _a; return (_a = part.el) === null || _a === void 0 ? void 0 : _a.value; }).join(".");
  }
  setValidation(valid, validationMessage) {
    this.internalValidationChangeInProgress = true;
    this.valid = valid;
    this.validationMessage = validationMessage;
    this.internalValidationChangeInProgress = false;
  }
  getLabelClassNames() {
    return {
      label: true,
      [getAppearance(this.el)]: true,
    };
  }
  getComponentClassNames() {
    return {
      component: true,
      [this.type || ""]: true,
    };
  }
  render() {
    if (!this.type) {
      return;
    }
    const parsedValue = this.value.split(".");
    return (hAsync("div", { class: this.getComponentClassNames() }, this.label && (hAsync("label", { class: this.getLabelClassNames() }, hAsync("span", null, this.label, this.required && hAsync("span", { "aria-hidden": "true" }, "\u00A0*")))), hAsync("div", { class: "wrapper" }, this.parts.map((part, i) => {
      const valid = this.isValidationSetInternally
        ? part.valid
        : this.valid;
      return (hAsync(Fragment, null, hAsync("sdx-input", { class: "input", value: parsedValue[i], label: translate(part.label, this.el.lang), placeholder: translate(part.placeholder, this.el.lang), maxlength: part.maxLength, inputmode: "decimal", valid: valid === false ? false : undefined, "aria-describedby": i === 0 ? "additional-information" : undefined, onKeyDown: (e) => {
          var _a, _b, _c;
          if (e.key === ".") {
            if ((_a = part.el) === null || _a === void 0 ? void 0 : _a.value) {
              (_c = (_b = this.parts[i + 1]) === null || _b === void 0 ? void 0 : _b.el) === null || _c === void 0 ? void 0 : _c.doFocus();
            }
          }
        }, onKeyPress: (e) => {
          if (!isFinite(+e.key)) {
            // Allow only numbers
            e.preventDefault();
          }
        }, onInput: () => this.save(), onBlur: (e) => {
          const els = this.parts.map((part) => part.el);
          const focussed = els.includes(e.relatedTarget);
          this.validate(focussed);
        }, inputStyle: {
          textAlign: "center",
        }, ref: (ref) => (this.parts[i].el = ref) }), i < this.parts.length - 1 && hAsync("span", { class: "separator" }, ".")));
    })), hAsync("div", { id: "additional-information" }, this.srHint && hAsync("span", { class: "sr-only" }, this.srHint), this.validationMessage && (hAsync(Fragment, null, hAsync("span", { class: "sr-only" }, this.validationMessage), hAsync("sdx-validation-message", { validationMessage: this.validationMessage, "aria-hidden": "true" }))))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "value": ["valueChanged"],
    "name": ["nameChanged"],
    "valid": ["validationChanged"],
    "validationMessage": ["validationChanged"]
  }; }
  static get style() { return inputMaskCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-input-mask",
    "$members$": {
      "srHint": [1, "sr-hint"],
      "type": [1],
      "value": [1025],
      "label": [1],
      "name": [1],
      "valid": [1028],
      "validationMessage": [1025, "validation-message"],
      "required": [4],
      "autofocus": [4],
      "doFocus": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}
/**
 * Emitted whenever user is typing or clearing the input.
 * @event
 */
// @ts-ignore just for documentation purposes
Input.eventInput = "input";

const inputGroupReducer = (state = {}, action) => {
  switch (action.type) {
    case "UPDATE_REAPPENDING":
      const reappendedItems = state.reappendedItems + 1;
      const reappending = reappendedItems !== state.inputItemEls.length;
      return {
        ...state,
        reappending,
        reappendedItems: reappending ? reappendedItems : 0,
      };
    case "SELECT":
      let selectedInputItemEls = state.selectedInputItemEls;
      if (state.type === "radio") {
        const alreadySelected = state.selectedInputItemEls[0] === action.inputItemEl;
        if (alreadySelected) {
          selectedInputItemEls = [];
        }
        else {
          selectedInputItemEls = [action.inputItemEl];
        }
      }
      else {
        // "checkbox"
        const selectionIndex = state.selectedInputItemEls.indexOf(action.inputItemEl);
        const alreadySelected = selectionIndex > -1;
        if (alreadySelected) {
          // remove from selection
          selectedInputItemEls = selectedInputItemEls.filter((inputItemElFromSelection) => inputItemElFromSelection !== action.inputItemEl);
        }
        else {
          // add to selection
          selectedInputItemEls = [...selectedInputItemEls, action.inputItemEl];
        }
      }
      return {
        ...state,
        selectedInputItemEls,
      };
    case "ADD_INPUT_ITEM_EL":
      return {
        ...state,
        inputItemEls: add(state.inputItemEls, action.inputItemEl).sort(sortByAppearanceInDomTree),
      };
    case "REMOVE_INPUT_ITEM_EL":
      return {
        ...state,
        inputItemEls: remove(state.inputItemEls, action.inputItemEl).sort(sortByAppearanceInDomTree),
      };
    default:
      return state;
  }
};
function getInitialState$4() {
  return {
    type: "radio",
    theme: "none",
    name: "",
    inline: false,
    reappending: false,
    reappendedItems: 0,
    selectedInputItemEls: [],
    inputItemEls: [],
  };
}

const inputGroupCss = "/*!@:root*/.sc-sdx-input-group:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-input-group-h,*.sc-sdx-input-group,*.sc-sdx-input-group:before,*.sc-sdx-input-group:after{box-sizing:border-box}/*!@label*/label.sc-sdx-input-group{display:block;margin-bottom:4px;cursor:inherit;color:#666;font-size:16px}/*!@label.readonly, label.disabled*/label.readonly.sc-sdx-input-group,label.disabled.sc-sdx-input-group{color:#bbb}/*!@label.sdx--dark-theme*/label.sdx--dark-theme.sc-sdx-input-group{color:#adadad}/*!@.component .inline*/.component.sc-sdx-input-group .inline.sc-sdx-input-group{display:flex;flex-wrap:wrap;flex-direction:row;align-content:stretch;gap:32px}/*!@.component .inline.input-container*/.component.sc-sdx-input-group .inline.input-container.sc-sdx-input-group{gap:16px}";

class InputGroup {
  stateChanged({}, prev) {
    const state = this.state.get();
    const prevState = prev.get();
    if (state.selectedInputItemEls !== prevState.selectedInputItemEls) {
      this.selectedInputItemElsChanged(state);
    }
  }
  typeChanged() {
    this.store.set("type", this.type);
  }
  changeCallbackChanged() {
    this.setInvokeChangeCallback();
  }
  nameChanged() {
    this.store.set("name", this.name);
  }
  inlineChanged() {
    this.store.set("inline", this.inline);
  }
  themeChanged() {
    this.store.set("theme", this.theme);
  }
  valueChanged() {
    if (!this.componentDidLoadComplete) {
      return;
    }
    this.valueChangedInProgress = true;
    const { allValuesValid, validatedValues, inputItemEls } = this.getByValues(this.value);
    if (!allValuesValid) {
      this.value = validatedValues;
      return;
    }
    // Update the selection
    if (!this.selectedInputItemElsChangedInProgress) {
      // Set selection
      this.store.set("selectedInputItemEls", inputItemEls);
    }
    if (this.isConnected) {
      this.invokeChangeCallback(this.value);
    }
    this.valueChangedInProgress = false;
  }
  /**
   * Returns the current selection.
   * @deprecated read the "value" prop instead
   */
  async getSelection() {
    return this.value;
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.invokeChangeCallback = () => null;
    this.componentDidLoadComplete = false;
    this.isConnected = false;
    this.isReappending = false;
    // When the selection changes by setting `this.value = [ "one", "two", ... ]`,
    // the checked item els will be updated - but syncing back to "this.value"
    // is necessary, as long as `this.value` is valid.
    // These flag control in which way the sync happens.
    this.valueChangedInProgress = false;
    this.selectedInputItemElsChangedInProgress = false;
    this.state = undefined;
    this.type = "radio";
    this.theme = "none";
    this.changeCallback = undefined;
    this.name = undefined;
    this.inline = false;
    this.label = "";
    this.value = [];
    this.valid = undefined;
    this.validationMessage = undefined;
    this.required = false;
    this.name = uniqueId();
    this.setInvokeChangeCallback();
    this.store = new StoreConnection(this, inputGroupReducer, getInitialState$4(), ["selectedInputItemEls", "inputItemEls"]);
    this.store.set("type", this.type);
    this.store.set("theme", this.theme);
    this.store.set("inline", this.inline);
    this.store.set("name", this.name);
    this.store.flush();
  }
  connectedCallback() {
    this.isConnected = true;
    // The component is being reconnected
    if (this.isReappending) {
      this.store.set("reappending", true);
      this.isReappending = false;
    }
  }
  disconnectedCallback() {
    this.isConnected = false;
    // Know that a disconnection happened, maybe because the component was
    // removed, cached or it's being appended to document.body.
    const isStillInDocument = closest(this.el, document.documentElement);
    if (isStillInDocument) {
      this.isReappending = true;
    }
  }
  componentDidLoad() {
    const { selectedInputItemEls } = this.state.get();
    // Initial selection:
    // If there items with the "checked" prop, use those.
    // If not, check if there's a "value" prop on the component and use that instead.
    if (selectedInputItemEls.length) {
      const { validatedValues } = this.getByValues(selectedInputItemEls.map((el) => el.value));
      this.value = validatedValues;
    }
    else {
      // use "value"
      const { allValuesValid, validatedValues, inputItemEls } = this.getByValues(this.value);
      if (allValuesValid && validatedValues.length) {
        this.store.set("selectedInputItemEls", inputItemEls);
      }
    }
    this.store.subscribe();
    this.componentDidLoadComplete = true;
  }
  selectedInputItemElsChanged(state) {
    this.selectedInputItemElsChangedInProgress = true;
    // Update the "value"
    if (!this.valueChangedInProgress) {
      const { validatedValues } = this.getByValues(state.selectedInputItemEls.map((el) => el.value));
      this.value = validatedValues;
    }
    this.selectedInputItemElsChangedInProgress = false;
  }
  setInvokeChangeCallback() {
    this.invokeChangeCallback = parseFunction(this.changeCallback);
  }
  /**
   * Checks if an array of values is valid and create a valid version of it.
   * For convenience, all input items matching the values will also be
   * returned.
   */
  getByValues(values) {
    const { inputItemEls } = this.state.get();
    if (Array.isArray(values)) {
      if (!values.length) {
        // Nothing to do, don't replace [] with [] because of change detection
        return {
          allValuesValid: true,
          validatedValues: values,
          inputItemEls: [],
        };
      }
      // Filter out undefined values
      const definedValues = values.filter((value) => value !== undefined);
      if (!definedValues.length) {
        // Either only undefined values or completely empty
        return { allValuesValid: false, validatedValues: [], inputItemEls: [] };
      }
      const validatedValues = [];
      const foundInputItemEls = [];
      let isValid = true;
      // Check if values exist in the options
      for (let i = 0; i < definedValues.length; i++) {
        const value = definedValues[i];
        const foundInputItemEl = inputItemEls.find((el) => el.value === value);
        if (foundInputItemEl) {
          if (this.type === "checkbox" || (this.type === "radio" && i === 0)) {
            foundInputItemEls.push(foundInputItemEl);
            validatedValues.push(foundInputItemEl.value);
          }
          else {
            // Radios should only respect one value
            isValid = false;
          }
        }
      }
      if (validatedValues.length === 0) {
        // no values found
        return {
          allValuesValid: false,
          validatedValues,
          inputItemEls: foundInputItemEls,
        };
      }
      return {
        allValuesValid: isValid,
        validatedValues,
        inputItemEls: foundInputItemEls,
      };
    }
    // All non-array types will be reset (to an empty array)
    return { allValuesValid: false, validatedValues: [], inputItemEls: [] };
  }
  getComponentClassNames() {
    return {
      component: true,
      [getAppearance(this.el)]: true,
    };
  }
  getLabelClassNames() {
    return {
      label: true,
      [getAppearance(this.el)]: true,
    };
  }
  getSlotClassNames() {
    return {
      slot: true,
      inline: this.inline,
      "input-container": this.theme === "container",
    };
  }
  render() {
    return (hAsync(Host, { role: "group", "aria-label": this.label }, hAsync("div", { class: this.getComponentClassNames() }, this.label && (hAsync("label", { class: this.getLabelClassNames() }, this.label, this.required && hAsync("span", { "aria-hidden": "true" }, "\u00A0*"))), hAsync("div", { class: this.getSlotClassNames(), onInput: (e) => {
        // stop input event of input-item and dispatch a new one where input-group is the new target
        e.stopPropagation();
        dispatchEvent(this.el, InputGroup.eventInput);
      } }, hAsync("slot", null)), this.validationMessage && (hAsync("sdx-validation-message", { validationMessage: this.validationMessage })))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "state": ["stateChanged"],
    "type": ["typeChanged"],
    "changeCallback": ["changeCallbackChanged"],
    "name": ["nameChanged"],
    "inline": ["inlineChanged"],
    "theme": ["themeChanged"],
    "value": ["valueChanged"]
  }; }
  static get style() { return inputGroupCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-input-group",
    "$members$": {
      "type": [1],
      "theme": [1],
      "changeCallback": [1, "change-callback"],
      "name": [1],
      "inline": [4],
      "label": [1],
      "value": [1040],
      "valid": [4],
      "validationMessage": [1, "validation-message"],
      "required": [4],
      "state": [32],
      "getSelection": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}
/**
 * Emitted whenever user is changing options.
 * @event
 */
InputGroup.eventInput = "input";

const inputItemCss = "/*!@:root*/.sc-sdx-input-item:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-input-item-h,*.sc-sdx-input-item,*.sc-sdx-input-item:before,*.sc-sdx-input-item:after{box-sizing:border-box}/*!@.input.checkbox:hover input:not(:disabled).focus + label::before, .input.checkbox:hover input:not(:disabled):checked + label::before, .input.radio:hover input:not(:disabled).focus + label::before, .input.radio:hover input:not(:disabled):checked + label::before*/.input.checkbox.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled).focus+label.sc-sdx-input-item::before,.input.checkbox.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled):checked+label.sc-sdx-input-item::before,.input.radio.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled).focus+label.sc-sdx-input-item::before,.input.radio.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled):checked+label.sc-sdx-input-item::before{border-color:#0048cf}/*!@.input.checkbox:hover input:not(:disabled):checked + label::after, .input.radio:hover input:not(:disabled):checked + label::after*/.input.checkbox.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled):checked+label.sc-sdx-input-item::after,.input.radio.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled):checked+label.sc-sdx-input-item::after{transform:scale(1);border-color:#0048cf;color:#0048cf}/*!@.input.checkbox:hover input:not(:disabled) + label::before, .input.radio:hover input:not(:disabled) + label::before*/.input.checkbox.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled)+label.sc-sdx-input-item::before,.input.radio.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled)+label.sc-sdx-input-item::before{border-color:#333}/*!@.input.checkbox:hover input:not(:disabled) + label::after, .input.radio:hover input:not(:disabled) + label::after*/.input.checkbox.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled)+label.sc-sdx-input-item::after,.input.radio.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled)+label.sc-sdx-input-item::after{transform:scale(0.5)}/*!@.input.checkbox input, .input.radio input*/.input.checkbox.sc-sdx-input-item input.sc-sdx-input-item,.input.radio.sc-sdx-input-item input.sc-sdx-input-item{position:absolute;visibility:hidden}/*!@.input.checkbox input.invalid + label::before, .input.radio input.invalid + label::before*/.input.checkbox.sc-sdx-input-item input.invalid.sc-sdx-input-item+label.sc-sdx-input-item::before,.input.radio.sc-sdx-input-item input.invalid.sc-sdx-input-item+label.sc-sdx-input-item::before{border-color:#d12}/*!@.input.checkbox input.focus + label::before, .input.checkbox input:checked + label::before, .input.radio input.focus + label::before, .input.radio input:checked + label::before*/.input.checkbox.sc-sdx-input-item input.focus.sc-sdx-input-item+label.sc-sdx-input-item::before,.input.checkbox.sc-sdx-input-item input.sc-sdx-input-item:checked+label.sc-sdx-input-item::before,.input.radio.sc-sdx-input-item input.focus.sc-sdx-input-item+label.sc-sdx-input-item::before,.input.radio.sc-sdx-input-item input.sc-sdx-input-item:checked+label.sc-sdx-input-item::before{border-color:#086adb}/*!@.input.checkbox input:checked + label::after, .input.radio input:checked + label::after*/.input.checkbox.sc-sdx-input-item input.sc-sdx-input-item:checked+label.sc-sdx-input-item::after,.input.radio.sc-sdx-input-item input.sc-sdx-input-item:checked+label.sc-sdx-input-item::after{transform:scale(1);border-color:#086adb;color:#086adb}/*!@.input.checkbox input:disabled + label, .input.radio input:disabled + label*/.input.checkbox.sc-sdx-input-item input.sc-sdx-input-item:disabled+label.sc-sdx-input-item,.input.radio.sc-sdx-input-item input.sc-sdx-input-item:disabled+label.sc-sdx-input-item{color:#bbb}/*!@.input.checkbox input:disabled + label::before, .input.radio input:disabled + label::before*/.input.checkbox.sc-sdx-input-item input.sc-sdx-input-item:disabled+label.sc-sdx-input-item::before,.input.radio.sc-sdx-input-item input.sc-sdx-input-item:disabled+label.sc-sdx-input-item::before{border-color:#bbb}/*!@.input.checkbox input:disabled + label::after, .input.radio input:disabled + label::after*/.input.checkbox.sc-sdx-input-item input.sc-sdx-input-item:disabled+label.sc-sdx-input-item::after,.input.radio.sc-sdx-input-item input.sc-sdx-input-item:disabled+label.sc-sdx-input-item::after{border-color:#bbb;color:#bbb}/*!@.input.checkbox label, .input.radio label*/.input.checkbox.sc-sdx-input-item label.sc-sdx-input-item,.input.radio.sc-sdx-input-item label.sc-sdx-input-item{flex-grow:1;padding-left:37px;position:relative;min-height:1em;cursor:inherit}/*!@.input.checkbox label::before, .input.checkbox label::after, .input.radio label::before, .input.radio label::after*/.input.checkbox.sc-sdx-input-item label.sc-sdx-input-item::before,.input.checkbox.sc-sdx-input-item label.sc-sdx-input-item::after,.input.radio.sc-sdx-input-item label.sc-sdx-input-item::before,.input.radio.sc-sdx-input-item label.sc-sdx-input-item::after{content:\"\";position:absolute;top:0;left:0;margin-top:1px;transition:all 200ms cubic-bezier(0.4, 0, 0.2, 1);transform-origin:50% 50%}/*!@.input.checkbox label::before, .input.radio label::before*/.input.checkbox.sc-sdx-input-item label.sc-sdx-input-item::before,.input.radio.sc-sdx-input-item label.sc-sdx-input-item::before{border:1px solid #666}/*!@.input.checkbox label::after, .input.radio label::after*/.input.checkbox.sc-sdx-input-item label.sc-sdx-input-item::after,.input.radio.sc-sdx-input-item label.sc-sdx-input-item::after{transform:scale(0)}/*!@.input.checkbox label::before*/.input.checkbox.sc-sdx-input-item label.sc-sdx-input-item::before{border-radius:5px;width:22px;height:22px}/*!@.input.checkbox label::after*/.input.checkbox.sc-sdx-input-item label.sc-sdx-input-item::after{font-family:sdx-icons;content:\"\\e00b\";color:#666;left:2px}/*!@.input.radio label::before*/.input.radio.sc-sdx-input-item label.sc-sdx-input-item::before{border-radius:50%;width:22px;height:22px}/*!@.input.radio label::after*/.input.radio.sc-sdx-input-item label.sc-sdx-input-item::after{top:6px;left:6px;border:5px solid;border-radius:50%;background-color:#086adb}/*!@.input.sdx--dark-theme.checkbox:hover input:not(:disabled).focus + label::before, .input.sdx--dark-theme.checkbox:hover input:not(:disabled):checked + label::before, .input.sdx--dark-theme.radio:hover input:not(:disabled).focus + label::before, .input.sdx--dark-theme.radio:hover input:not(:disabled):checked + label::before*/.input.sdx--dark-theme.checkbox.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled).focus+label.sc-sdx-input-item::before,.input.sdx--dark-theme.checkbox.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled):checked+label.sc-sdx-input-item::before,.input.sdx--dark-theme.radio.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled).focus+label.sc-sdx-input-item::before,.input.sdx--dark-theme.radio.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled):checked+label.sc-sdx-input-item::before{border-color:#5ca3ff}/*!@.input.sdx--dark-theme.checkbox:hover input:not(:disabled):checked + label::after, .input.sdx--dark-theme.radio:hover input:not(:disabled):checked + label::after*/.input.sdx--dark-theme.checkbox.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled):checked+label.sc-sdx-input-item::after,.input.sdx--dark-theme.radio.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled):checked+label.sc-sdx-input-item::after{border-color:#5ca3ff;color:#5ca3ff}/*!@.input.sdx--dark-theme.checkbox:hover input:not(:disabled) + label::before, .input.sdx--dark-theme.radio:hover input:not(:disabled) + label::before*/.input.sdx--dark-theme.checkbox.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled)+label.sc-sdx-input-item::before,.input.sdx--dark-theme.radio.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled)+label.sc-sdx-input-item::before{border-color:#d6d6d6}/*!@.input.sdx--dark-theme.checkbox:hover input:not(:disabled) + label::after, .input.sdx--dark-theme.radio:hover input:not(:disabled) + label::after*/.input.sdx--dark-theme.checkbox.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled)+label.sc-sdx-input-item::after,.input.sdx--dark-theme.radio.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled)+label.sc-sdx-input-item::after{color:#d6d6d6}/*!@.input.sdx--dark-theme.checkbox input.invalid + label::before, .input.sdx--dark-theme.radio input.invalid + label::before*/.input.sdx--dark-theme.checkbox.sc-sdx-input-item input.invalid.sc-sdx-input-item+label.sc-sdx-input-item::before,.input.sdx--dark-theme.radio.sc-sdx-input-item input.invalid.sc-sdx-input-item+label.sc-sdx-input-item::before{border-color:#f35d6a}/*!@.input.sdx--dark-theme.checkbox input.focus + label::before, .input.sdx--dark-theme.checkbox input:checked + label::before, .input.sdx--dark-theme.radio input.focus + label::before, .input.sdx--dark-theme.radio input:checked + label::before*/.input.sdx--dark-theme.checkbox.sc-sdx-input-item input.focus.sc-sdx-input-item+label.sc-sdx-input-item::before,.input.sdx--dark-theme.checkbox.sc-sdx-input-item input.sc-sdx-input-item:checked+label.sc-sdx-input-item::before,.input.sdx--dark-theme.radio.sc-sdx-input-item input.focus.sc-sdx-input-item+label.sc-sdx-input-item::before,.input.sdx--dark-theme.radio.sc-sdx-input-item input.sc-sdx-input-item:checked+label.sc-sdx-input-item::before{border-color:#4294ff}/*!@.input.sdx--dark-theme.checkbox input.focus + label::after, .input.sdx--dark-theme.checkbox input:checked + label::after, .input.sdx--dark-theme.radio input.focus + label::after, .input.sdx--dark-theme.radio input:checked + label::after*/.input.sdx--dark-theme.checkbox.sc-sdx-input-item input.focus.sc-sdx-input-item+label.sc-sdx-input-item::after,.input.sdx--dark-theme.checkbox.sc-sdx-input-item input.sc-sdx-input-item:checked+label.sc-sdx-input-item::after,.input.sdx--dark-theme.radio.sc-sdx-input-item input.focus.sc-sdx-input-item+label.sc-sdx-input-item::after,.input.sdx--dark-theme.radio.sc-sdx-input-item input.sc-sdx-input-item:checked+label.sc-sdx-input-item::after{color:#4294ff}/*!@.input.sdx--dark-theme.checkbox input:disabled + label, .input.sdx--dark-theme.radio input:disabled + label*/.input.sdx--dark-theme.checkbox.sc-sdx-input-item input.sc-sdx-input-item:disabled+label.sc-sdx-input-item,.input.sdx--dark-theme.radio.sc-sdx-input-item input.sc-sdx-input-item:disabled+label.sc-sdx-input-item{color:#5c5c5c}/*!@.input.sdx--dark-theme.checkbox input:disabled + label::before, .input.sdx--dark-theme.radio input:disabled + label::before*/.input.sdx--dark-theme.checkbox.sc-sdx-input-item input.sc-sdx-input-item:disabled+label.sc-sdx-input-item::before,.input.sdx--dark-theme.radio.sc-sdx-input-item input.sc-sdx-input-item:disabled+label.sc-sdx-input-item::before{border-color:#5c5c5c}/*!@.input.sdx--dark-theme.checkbox input + label::before, .input.sdx--dark-theme.radio input + label::before*/.input.sdx--dark-theme.checkbox.sc-sdx-input-item input.sc-sdx-input-item+label.sc-sdx-input-item::before,.input.sdx--dark-theme.radio.sc-sdx-input-item input.sc-sdx-input-item+label.sc-sdx-input-item::before{background-color:#1d1d1d}/*!@.input.sdx--dark-theme.checkbox label::before, .input.sdx--dark-theme.radio label::before*/.input.sdx--dark-theme.checkbox.sc-sdx-input-item label.sc-sdx-input-item::before,.input.sdx--dark-theme.radio.sc-sdx-input-item label.sc-sdx-input-item::before{border-color:#adadad}/*!@:host*/.sc-sdx-input-item-h{display:inline-block;max-width:100%}/*!@:host .component*/.sc-sdx-input-item-h .component.sc-sdx-input-item{--box-shadow-color:transparent;display:flex;flex-flow:column}/*!@:host .component input:disabled + label ::slotted([slot=description])*/.sc-sdx-input-item-h .component input:disabled+label .sc-sdx-input-item-s>[slot=description]{color:#bbb}/*!@:host .component label ::slotted([slot=description])*/.sc-sdx-input-item-h .component label .sc-sdx-input-item-s>[slot=description]{font-weight:400;line-height:21px;letter-spacing:0;font-size:16px;display:block;letter-spacing:0;padding-top:5px;padding-bottom:3px;color:#666}/*!@:host(.input-container)*/.input-container.sc-sdx-input-item-h{display:block}/*!@:host(.input-container) .component.inline*/.input-container.sc-sdx-input-item-h .component.inline.sc-sdx-input-item{height:100%}/*!@:host(.input-container) .component:hover input:not(:disabled).focus + label, :host(.input-container) .component:hover input:not(:disabled):checked + label*/.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled).focus+label.sc-sdx-input-item,.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled):checked+label.sc-sdx-input-item{--box-shadow-color:#0048cf;border-color:#0048cf}/*!@:host(.input-container) .component:hover input:not(:disabled):checked + label .icon*/.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled):checked+label.sc-sdx-input-item .icon.sc-sdx-input-item{color:#0048cf}/*!@:host(.input-container) .component:hover input:not(:disabled) + label*/.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled)+label.sc-sdx-input-item{--box-shadow-color:#333;border-color:#333}/*!@:host(.input-container) .component:hover input:not(:disabled) + label .icon*/.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled)+label.sc-sdx-input-item .icon.sc-sdx-input-item{color:#333}/*!@:host(.input-container) .component input.focus + label, :host(.input-container) .component input:checked + label*/.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item input.focus.sc-sdx-input-item+label.sc-sdx-input-item,.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item input.sc-sdx-input-item:checked+label.sc-sdx-input-item{border-color:#086adb}/*!@:host(.input-container) .component input:checked.hide-checked-icon + label*/.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item input.sc-sdx-input-item:checked.hide-checked-icon+label.sc-sdx-input-item{color:#086adb}/*!@:host(.input-container) .component input:checked + label*/.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item input.sc-sdx-input-item:checked+label.sc-sdx-input-item{--box-shadow-color:#086adb}/*!@:host(.input-container) .component input:checked + label .icon*/.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item input.sc-sdx-input-item:checked+label.sc-sdx-input-item .icon.sc-sdx-input-item{color:#086adb}/*!@:host(.input-container) .component input:disabled + label*/.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item input.sc-sdx-input-item:disabled+label.sc-sdx-input-item{border-color:#bbb;color:#bbb}/*!@:host(.input-container) .component input:disabled + label .icon*/.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item input.sc-sdx-input-item:disabled+label.sc-sdx-input-item .icon.sc-sdx-input-item{color:#bbb}/*!@:host(.input-container) .component input.hide-checked-icon + label*/.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item input.hide-checked-icon.sc-sdx-input-item+label.sc-sdx-input-item{padding-left:8px;box-shadow:inset 0 0 0 1px var(--box-shadow-color)}/*!@:host(.input-container) .component input.hide-checked-icon + label::before, :host(.input-container) .component input.hide-checked-icon + label::after*/.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item input.hide-checked-icon.sc-sdx-input-item+label.sc-sdx-input-item::before,.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item input.hide-checked-icon.sc-sdx-input-item+label.sc-sdx-input-item::after{display:none}/*!@:host(.input-container) .component label*/.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item label.sc-sdx-input-item{border:1px solid #666;border-radius:5px;padding:11px 8px;padding-left:45px;transition:border-color 200ms cubic-bezier(0.4, 0, 0.2, 1), box-shadow 200ms cubic-bezier(0.4, 0, 0.2, 1), color 200ms cubic-bezier(0.4, 0, 0.2, 1)}/*!@:host(.input-container) .component label::before, :host(.input-container) .component label::after*/.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item label.sc-sdx-input-item::before,.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item label.sc-sdx-input-item::after{margin:12px}/*!@:host(.input-container) .component label .icon-placeholder*/.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item label.sc-sdx-input-item .icon-placeholder.sc-sdx-input-item{margin-top:6px;visibility:hidden}/*!@:host(.input-container) .component label .icon*/.input-container.sc-sdx-input-item-h .component.sc-sdx-input-item label.sc-sdx-input-item .icon.sc-sdx-input-item{position:absolute;bottom:8px;left:0;right:0;text-align:center;transition:color 200ms cubic-bezier(0.4, 0, 0.2, 1);color:#666}/*!@:host(.sdx--dark-theme) .component input:disabled + label ::slotted([slot=description])*/.sc-sdx-input-item-h.sdx--dark-theme .component input:disabled+label .sc-sdx-input-item-s>[slot=description]{color:#5c5c5c}/*!@:host(.sdx--dark-theme) .component input + label ::slotted([slot=description])*/.sc-sdx-input-item-h.sdx--dark-theme .component input+label .sc-sdx-input-item-s>[slot=description]{color:#adadad}/*!@:host(.input-container.sdx--dark-theme) .component:hover input:not(:disabled).focus + label, :host(.input-container.sdx--dark-theme) .component:hover input:not(:disabled):checked + label*/.input-container.sdx--dark-theme.sc-sdx-input-item-h .component.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled).focus+label.sc-sdx-input-item,.input-container.sdx--dark-theme.sc-sdx-input-item-h .component.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled):checked+label.sc-sdx-input-item{--box-shadow-color:#5ca3ff;border-color:#5ca3ff}/*!@:host(.input-container.sdx--dark-theme) .component:hover input:not(:disabled):checked + label .icon*/.input-container.sdx--dark-theme.sc-sdx-input-item-h .component.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled):checked+label.sc-sdx-input-item .icon.sc-sdx-input-item{color:#5ca3ff}/*!@:host(.input-container.sdx--dark-theme) .component:hover input:not(:disabled) + label*/.input-container.sdx--dark-theme.sc-sdx-input-item-h .component.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled)+label.sc-sdx-input-item{--box-shadow-color:#d6d6d6;border-color:#d6d6d6}/*!@:host(.input-container.sdx--dark-theme) .component:hover input:not(:disabled) + label .icon*/.input-container.sdx--dark-theme.sc-sdx-input-item-h .component.sc-sdx-input-item:hover input.sc-sdx-input-item:not(:disabled)+label.sc-sdx-input-item .icon.sc-sdx-input-item{color:#d6d6d6}/*!@:host(.input-container.sdx--dark-theme) .component input.focus + label, :host(.input-container.sdx--dark-theme) .component input:checked + label*/.input-container.sdx--dark-theme.sc-sdx-input-item-h .component.sc-sdx-input-item input.focus.sc-sdx-input-item+label.sc-sdx-input-item,.input-container.sdx--dark-theme.sc-sdx-input-item-h .component.sc-sdx-input-item input.sc-sdx-input-item:checked+label.sc-sdx-input-item{border-color:#4294ff}/*!@:host(.input-container.sdx--dark-theme) .component input:checked.hide-checked-icon + label*/.input-container.sdx--dark-theme.sc-sdx-input-item-h .component.sc-sdx-input-item input.sc-sdx-input-item:checked.hide-checked-icon+label.sc-sdx-input-item{color:#4294ff}/*!@:host(.input-container.sdx--dark-theme) .component input:checked + label*/.input-container.sdx--dark-theme.sc-sdx-input-item-h .component.sc-sdx-input-item input.sc-sdx-input-item:checked+label.sc-sdx-input-item{--box-shadow-color:#4294ff}/*!@:host(.input-container.sdx--dark-theme) .component input:checked + label .icon*/.input-container.sdx--dark-theme.sc-sdx-input-item-h .component.sc-sdx-input-item input.sc-sdx-input-item:checked+label.sc-sdx-input-item .icon.sc-sdx-input-item{color:#4294ff}/*!@:host(.input-container.sdx--dark-theme) .component input:disabled + label*/.input-container.sdx--dark-theme.sc-sdx-input-item-h .component.sc-sdx-input-item input.sc-sdx-input-item:disabled+label.sc-sdx-input-item{border-color:#5c5c5c;color:#5c5c5c}/*!@:host(.input-container.sdx--dark-theme) .component input:disabled + label .icon*/.input-container.sdx--dark-theme.sc-sdx-input-item-h .component.sc-sdx-input-item input.sc-sdx-input-item:disabled+label.sc-sdx-input-item .icon.sc-sdx-input-item{color:#5c5c5c}/*!@:host(.input-container.sdx--dark-theme) .component label*/.input-container.sdx--dark-theme.sc-sdx-input-item-h .component.sc-sdx-input-item label.sc-sdx-input-item{border-color:#d6d6d6}/*!@:host(.input-container.sdx--dark-theme) .component label .icon*/.input-container.sdx--dark-theme.sc-sdx-input-item-h .component.sc-sdx-input-item label.sc-sdx-input-item .icon.sc-sdx-input-item{color:#adadad}";

class InputItem {
  stateChanged({}, prev) {
    const state = this.state.get();
    const prevState = prev.get();
    if (state.name !== prevState.name) {
      this.nameChanged();
    }
    if (state.selectedInputItemEls !== prevState.selectedInputItemEls) {
      this.selectedInputItemElsChanged(state);
    }
  }
  valueChanged() {
    this.updateHiddenFormInputEl();
  }
  nameChanged() {
    this.updateHiddenFormInputEl();
  }
  disabledChanged() {
    this.updateHiddenFormInputEl();
  }
  checkedChanged() {
    var _a;
    if (!this.selectedInputItemElsChangedInProgress) {
      (_a = this.store) === null || _a === void 0 ? void 0 : _a.dispatch({ type: "SELECT", inputItemEl: this.el });
    }
    this.updateHiddenFormInputEl();
  }
  changeCallbackChanged() {
    this.setInvokeChangeCallback();
  }
  async doFocus() {
    var _a;
    (_a = this.lightDOMHiddenFormInputEl) === null || _a === void 0 ? void 0 : _a.focus();
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.uniqueId = uniqueId();
    this.invokeChangeCallback = () => null;
    this.selectedInputItemElsChangedInProgress = false;
    this.state = undefined;
    this.focused = false;
    this.type = "radio";
    this.iconName = undefined;
    this.iconSize = 2;
    this.checked = false;
    this.value = undefined;
    this.disabled = false;
    this.changeCallback = undefined;
    this.name = undefined;
    this.valid = undefined;
    this.validationMessage = undefined;
    this.required = false;
    this.hideCheckedIcon = false;
    this.labelStyle = {};
    this.srHint = "";
    // Check if it's a standalone input-item or part of an input-group (which uses a store)
    if (closest(this.el, "sdx-input-group")) {
      this.store = new StoreConnection(this, inputGroupReducer, getInitialState$4(), [
        "type",
        "theme",
        "name",
        "inline",
        "reappending",
        "selectedInputItemEls",
      ]);
    }
    this.setInvokeChangeCallback();
    this.updateHiddenFormInputEl();
  }
  connectedCallback() {
    var _a, _b, _c, _d;
    // Don't do anything while the component is being reconnected (maybe
    // because it's being appended to document.body), but send a "ping" for
    // each child (sdx-input-item).
    // After each child is has finished, "reappending" will be marked "done" by
    // the store.
    if ((_a = this.state) === null || _a === void 0 ? void 0 : _a.get().reappending) {
      (_b = this.store) === null || _b === void 0 ? void 0 : _b.dispatch({ type: "UPDATE_REAPPENDING" });
      return;
    }
    // Register self
    (_c = this.store) === null || _c === void 0 ? void 0 : _c.dispatch({
      type: "ADD_INPUT_ITEM_EL",
      inputItemEl: this.el,
    });
    if (this.checked) {
      (_d = this.store) === null || _d === void 0 ? void 0 : _d.dispatch({ type: "SELECT", inputItemEl: this.el });
    }
  }
  disconnectedCallback() {
    var _a, _b, _c;
    // See connectedCallback() for explanation
    if ((_a = this.state) === null || _a === void 0 ? void 0 : _a.get().reappending) {
      return;
    }
    // Unregister self
    (_b = this.store) === null || _b === void 0 ? void 0 : _b.dispatch({
      type: "REMOVE_INPUT_ITEM_EL",
      inputItemEl: this.el,
    });
    if (this.checked) {
      (_c = this.store) === null || _c === void 0 ? void 0 : _c.dispatch({ type: "SELECT", inputItemEl: this.el });
    }
  }
  componentWillLoad() {
    var _a;
    (_a = this.store) === null || _a === void 0 ? void 0 : _a.subscribe();
  }
  selectedInputItemElsChanged(state) {
    this.selectedInputItemElsChangedInProgress = true;
    this.checked = !!state.selectedInputItemEls.includes(this.el);
    this.selectedInputItemElsChangedInProgress = false;
  }
  getInputType() {
    var _a;
    return ((_a = this.state) === null || _a === void 0 ? void 0 : _a.get().type) || this.type;
  }
  /**
   * This handler is also being triggered by hitting the spacebar.
   * The change callback is also called here (instead of in the @Watch("checked")),
   * because native HTML checkboxes and radios don't call their change callback
   * when the .checked property is changed programmatically.
   */
  onInputElClick() {
    if (this.getInputType() === "radio") {
      // "radio"
      if (!this.checked) {
        // only check radio when it's not checked yet
        this.checked = true;
        this.invokeChangeCallback(this.checked);
      }
    }
    else {
      // "checkbox"
      this.checked = !this.checked;
      this.invokeChangeCallback(this.checked);
    }
  }
  updateHiddenFormInputEl() {
    var _a;
    if (!this.lightDOMHiddenFormInputEl) {
      this.lightDOMHiddenFormInputEl = document.createElement("input");
      this.lightDOMHiddenFormInputEl.onfocus = () => {
        this.focused = true;
      };
      this.lightDOMHiddenFormInputEl.onblur = () => {
        this.focused = false;
      };
      this.lightDOMHiddenFormInputEl.onchange = () => {
        this.checked = this.lightDOMHiddenFormInputEl.checked;
      };
      // onClick because Angular doesn't detect onChange
      // (please note that onClick is also fired when hitting the spacebar)
      this.lightDOMHiddenFormInputEl.onclick = () => this.onInputElClick();
      this.lightDOMHiddenFormInputEl.oninput = (e) => {
        e.stopPropagation();
        dispatchEvent(this.el, InputItem.eventInput);
      };
      // setAttribute because of: TS2339: Property 'ariaDescribedBy' does not exist on type 'HTMLInputElement'.
      this.lightDOMHiddenFormInputEl.setAttribute("aria-describedby", this.uniqueId);
      // @ts-ignore
      this.lightDOMHiddenFormInputEl.style =
        // top and left for NVDA outline
        // dimensions set to catch a click
        // z-index to catch click even on label::after
        "position: absolute; opacity: 0; top: 0; left: 0; width:100%; height: 100%; margin:0; z-index: 1;";
      this.el.append(this.lightDOMHiddenFormInputEl);
    }
    if (!this.lightDOMHiddenSrHintEl) {
      this.lightDOMHiddenSrHintEl = document.createElement("span");
      this.lightDOMHiddenSrHintEl.id = this.uniqueId;
      // @ts-ignore
      this.lightDOMHiddenSrHintEl.style =
        "position: absolute; width: 1px; height: 1px; overflow: hidden;"; // sr-only
      // Adding commas so that screen reader can pronounce better
      this.lightDOMHiddenSrHintEl.textContent = `
        ${this.srHint},
        ${this.el.textContent /* contains label and description text */},
        ${this.validationMessage || ""}
      `;
      this.el.append(this.lightDOMHiddenSrHintEl);
    }
    this.lightDOMHiddenFormInputEl.type = this.getInputType();
    this.lightDOMHiddenFormInputEl.name =
      ((_a = this.state) === null || _a === void 0 ? void 0 : _a.get().name) || this.name || "";
    this.lightDOMHiddenFormInputEl.disabled = this.disabled;
    // Clean up properties added previously in case they've changed
    this.lightDOMHiddenFormInputEl.checked = false;
    this.lightDOMHiddenFormInputEl.tabIndex = 0;
    this.lightDOMHiddenFormInputEl.value = "";
    if (this.checked) {
      this.lightDOMHiddenFormInputEl.value = this.value || "on";
      this.lightDOMHiddenFormInputEl.checked = true;
    }
    this.lightDOMHiddenFormInputEl.style.cursor = this.disabled
      ? "not-allowed"
      : "pointer";
  }
  setInvokeChangeCallback() {
    this.invokeChangeCallback = parseFunction(this.changeCallback);
  }
  getHostClassNames() {
    var _a;
    return {
      "input-container": ((_a = this.state) === null || _a === void 0 ? void 0 : _a.get().theme) === "container",
      [getAppearance(this.el)]: true,
    };
  }
  getComponentClassNames() {
    var _a;
    return {
      component: true,
      [getAppearance(this.el)]: true,
      inline: !!((_a = this.state) === null || _a === void 0 ? void 0 : _a.get().inline),
      input: true,
      [this.getInputType()]: true,
    };
  }
  render() {
    var _a;
    return (hAsync(Host, { class: this.getHostClassNames() }, hAsync("div", { class: this.getComponentClassNames() }, hAsync("input", { type: this.getInputType(), checked: this.checked, disabled: this.disabled, tabindex: -1, class: {
        focus: this.focused,
        invalid: this.valid === false,
        "hide-checked-icon": this.hideCheckedIcon,
      } }), hAsync("label", { style: this.labelStyle }, hAsync("slot", null), this.required && hAsync("span", { "aria-hidden": "true" }, "\u00A0*"), hAsync("span", { class: "description" }, hAsync("slot", { name: "description" })), ((_a = this.state) === null || _a === void 0 ? void 0 : _a.get().theme) === "container" && this.iconName && (hAsync("div", { "aria-hidden": "true" }, hAsync("sdx-icon", { class: "icon-placeholder", "icon-name": this.iconName, size: this.iconSize }), hAsync("sdx-icon", { class: "icon", "icon-name": this.iconName, size: this.iconSize })))), this.validationMessage && (hAsync("sdx-validation-message", { validationMessage: this.validationMessage, "aria-hidden": "true" })))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "state": ["stateChanged"],
    "value": ["valueChanged"],
    "name": ["nameChanged"],
    "disabled": ["disabledChanged"],
    "checked": ["checkedChanged"],
    "changeCallback": ["changeCallbackChanged"]
  }; }
  static get style() { return inputItemCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-input-item",
    "$members$": {
      "type": [1],
      "iconName": [1, "icon-name"],
      "iconSize": [2, "icon-size"],
      "checked": [1028],
      "value": [8],
      "disabled": [4],
      "changeCallback": [1, "change-callback"],
      "name": [1],
      "valid": [4],
      "validationMessage": [1, "validation-message"],
      "required": [4],
      "hideCheckedIcon": [4, "hide-checked-icon"],
      "labelStyle": [16],
      "srHint": [1, "sr-hint"],
      "state": [32],
      "focused": [32],
      "doFocus": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}
/**
 * Emitted whenever user is checking/unchecking the item.
 * @event
 */
InputItem.eventInput = "input";

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return root.Date.now();
};

/** Used to match a single whitespace character. */
var reWhitespace = /\s/;

/**
 * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
 * character of `string`.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {number} Returns the index of the last non-whitespace character.
 */
function trimmedEndIndex(string) {
  var index = string.length;

  while (index-- && reWhitespace.test(string.charAt(index))) {}
  return index;
}

/** Used to match leading whitespace. */
var reTrimStart = /^\s+/;

/**
 * The base implementation of `_.trim`.
 *
 * @private
 * @param {string} string The string to trim.
 * @returns {string} Returns the trimmed string.
 */
function baseTrim(string) {
  return string
    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
    : string;
}

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/** Error message constants. */
var FUNC_ERROR_TEXT$1 = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide `options` to indicate whether `func`
 * should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

class ItunesAutocomplete {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.artists = [];
    this.loading = false;
    this.fetchThrottled = throttle(this.fetch, 500);
  }
  onChange(keyword) {
    // Show loading spinner
    this.loading = true;
    this.fetchThrottled(keyword);
  }
  fetch(keyword) {
    // Clear results from last search (if any)
    this.artists = [];
    // Ensure keyword length
    if (keyword.length < 3) {
      this.loading = false;
      return;
    }
    // Request data
    fetch(`https://itunes.apple.com/search?term=${encodeURI(keyword)}&entity=musicArtist&limit=10`, {
      method: "post",
    })
      .then((payload) => payload.json())
      .then((payload) => (this.artists = payload.results.map((result) => result.artistName)))
      .then(() => setTimeout(() => {
      this.loading = false;
    }, 100)); // timeout because there's a gap between data arrival and the select rendering
  }
  render() {
    return (hAsync("sdx-select", { label: "Your favourite artist on iTunes", placeholder: "Search artists...", onInput: (e) => {
        const selection = e.target.value;
        this.onChange(selection[0]);
      }, keyboardBehavior: "autocomplete", filterFunction: () => true /* iTunes already filters, bypass local filter */, loading: this.loading }, this.artists.map((artist) => (hAsync("sdx-select-option", null, artist)))));
  }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-itunes-autocomplete",
    "$members$": {
      "artists": [32],
      "loading": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const loadingSpinnerCss = "/*!@:root*/.sc-sdx-loading-spinner:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-loading-spinner-h,*.sc-sdx-loading-spinner,*.sc-sdx-loading-spinner:before,*.sc-sdx-loading-spinner:after{box-sizing:border-box}/*!@.sr-only*/.sr-only.sc-sdx-loading-spinner{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);border:0}/*!@.sr-only-focusable:active, .sr-only-focusable:focus*/.sr-only-focusable.sc-sdx-loading-spinner:active,.sr-only-focusable.sc-sdx-loading-spinner:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}@keyframes rotate{100%{transform:rotate(360deg)}}@keyframes dash{0%{stroke-dasharray:1, 150;stroke-dashoffset:0}50%{stroke-dasharray:90, 150;stroke-dashoffset:-35}100%{stroke-dasharray:90, 150;stroke-dashoffset:-124}}/*!@.component svg*/.component.sc-sdx-loading-spinner svg.sc-sdx-loading-spinner{animation:rotate 2s linear infinite}/*!@.circle*/.circle.sc-sdx-loading-spinner{animation:dash 1.5s ease-in-out infinite;stroke:#015}/*!@.stroke-inherit*/.stroke-inherit.sc-sdx-loading-spinner{stroke:currentColor}/*!@.circle.sdx--dark-theme*/.circle.sdx--dark-theme.sc-sdx-loading-spinner{stroke:#e6e6e6}/*!@.stroke-inherit.sdx--dark-theme*/.stroke-inherit.sdx--dark-theme.sc-sdx-loading-spinner{stroke:currentColor}";

class LoadingSpinner {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = "small";
    this.srHint = "status: loading";
    this.strokeInherit = false;
  }
  getCircleClassNames() {
    return {
      circle: true,
      [getAppearance(this.el)]: true,
      "stroke-inherit": this.strokeInherit,
    };
  }
  render() {
    const circleBorderWidth = 7;
    const baseWidth = 27;
    const sizePx = this.size === "small" ? baseWidth : 52;
    // The strokeWidth is just 7px if the default size is set.
    // Otherwise we need to adjust the width as it grows with the circle width.
    const strokeWidth = `${circleBorderWidth * (baseWidth / sizePx)}px`;
    return (hAsync("div", { class: "component", style: { width: `${sizePx}px`, height: `${sizePx}px` } }, hAsync("span", { class: "sr-only" }, this.srHint), hAsync("svg", { viewBox: "0 0 50 50", width: "100%", height: "100%" }, hAsync("circle", { class: this.getCircleClassNames(), cx: "25", cy: "25", r: "20", fill: "none", "stroke-width": strokeWidth, "stroke-linecap": "round" }))));
  }
  get el() { return getElement(this); }
  static get style() { return loadingSpinnerCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-loading-spinner",
    "$members$": {
      "size": [1],
      "srHint": [1, "sr-hint"],
      "strokeInherit": [4, "stroke-inherit"]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const menuFlyoutReducer = (state = {}, action) => {
  switch (action.type) {
    case "ADD_ARROW_EL":
      return {
        ...state,
        arrowEls: add(state.arrowEls, action.arrowEl),
      };
    case "REMOVE_ARROW_EL":
      return {
        ...state,
        arrowEls: remove(state.arrowEls, action.arrowEl),
      };
    default:
      return state;
  }
};
function getInitialState$3() {
  return {
    display: "closed",
    direction: "bottom-right",
    toggle: () => Promise.resolve(),
    contentEl: undefined,
    userInteractionInProgress: false,
    toggleEl: undefined,
    arrowEls: [],
  };
}

const menuFlyoutCss = "/*!@:root*/.sc-sdx-menu-flyout:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-menu-flyout-h,*.sc-sdx-menu-flyout,*.sc-sdx-menu-flyout:before,*.sc-sdx-menu-flyout:after{box-sizing:border-box}/*!@:host*/.sc-sdx-menu-flyout-h{display:inline-block}";

class MenuFlyout {
  stateChanged({}, prev) {
    const state = this.state.get();
    const prevState = prev.get();
    if (state.display !== prevState.display) {
      this.displayChanged(state);
    }
    if (state.arrowEls !== prevState.arrowEls) {
      this.arrowElsChanged();
    }
  }
  directionChanged() {
    const { display } = this.state.get();
    if (display !== "closed") {
      // If the flyout is open, re-open it with new direction
      this.close().then(() => {
        this.store.set("direction", this.direction);
        this.open();
      });
    }
    else {
      this.store.set("direction", this.direction);
    }
  }
  displayChangeCallbackChanged() {
    this.setInvokeDisplayChangeCallback();
  }
  onWindowResize() {
    const { display, direction } = this.state.get();
    if (display === "closed") {
      return;
    }
    const currentAngle = getScreenOrientationAngle();
    if (currentAngle !== this.lastScreenOrientationAngle) {
      // just close in case of an orientation change
      this.lastScreenOrientationAngle = currentAngle;
      this.close();
    }
    else {
      // in case of a desktop browser resize just recalculate the position
      this.positionContentEl(direction);
    }
  }
  /**
   * Toggles the flyout.
   */
  toggle() {
    const { display } = this.state.get();
    if (display === "open") {
      return this.close();
    }
    else if (display === "closed") {
      return this.open();
    }
    else ;
    return Promise.resolve();
  }
  /**
   * Opens the flyout.
   */
  open() {
    return new Promise((resolve) => {
      const { display, direction, contentEl, userInteractionInProgress } = this.state.get();
      if (!contentEl) {
        return;
      }
      // Only a closed flyout can be opened
      if (!(display === "closed" || display === "closing")) {
        resolve();
        return;
      }
      this.overlayOutletEl = getOverlayOutletEl();
      this.scrollContainerEl = getScrollContainerEl(this.el);
      // Check if the flyout is inside a scrollable element.
      // If yes, append the list there to make sure it scrolls and isn't
      // detached from the toggle.
      if (this.scrollContainerEl) {
        this.overlayOutletEl = this.scrollContainerEl;
      }
      else {
        this.scrollContainerEl = document.documentElement;
      }
      // Make contentEl overlap all other content
      appendToOverlayOutlet(contentEl, this.overlayOutletEl, this.el);
      // Set dimensions
      contentEl.style.opacity = "0";
      contentEl.style.transform = "translateY(0)";
      this.positionContentEl(direction);
      const offsetY = 
      // Update direction (overwritten above)
      this.state.get().direction === "top-left" ||
        this.state.get().direction === "top-right"
        ? -this.offsetY
        : this.offsetY;
      this.setDisplay("opening", userInteractionInProgress);
      anime.remove(contentEl);
      anime({
        targets: contentEl,
        duration: this.animated ? this.animationDuration : 0,
        translateY: offsetY,
        opacity: 1,
        easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
        complete: () => {
          this.setDisplay("open", userInteractionInProgress);
          resolve();
        },
      });
    });
  }
  /**
   * Closes the flyout.
   */
  close() {
    return new Promise((resolve) => {
      const { display, contentEl, userInteractionInProgress } = this.state.get();
      if (!contentEl) {
        return;
      }
      // Only an opened flyout can be closed
      if (display === "closed" || display === "closing") {
        resolve();
        return;
      }
      this.setDisplay("closing", userInteractionInProgress);
      anime.remove(contentEl);
      anime({
        targets: contentEl,
        duration: this.animated ? this.animationDuration : 0,
        translateY: 0,
        opacity: 0,
        easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
        complete: () => {
          contentEl.style.display = "none";
          // Reset to original direction (it might have changed during opening
          // because of not enough space)
          this.store.set("direction", this.direction);
          this.setDisplay("closed", userInteractionInProgress);
          // Move contentEl back
          appendToOverlayOutlet(contentEl, this.el, this.el);
          resolve();
        },
      });
    });
  }
  /**
   * @private
   * Calls close(), but only when the component is allowed to be closed.
   */
  async requestToClose(e) {
    const { contentEl, display } = this.state.get();
    if (!(contentEl && display === "open")) {
      return;
    }
    if (e instanceof KeyboardEvent) {
      if (e.key === "Escape") {
        this.store.set("userInteractionInProgress", true);
        this.close();
        this.store.set("userInteractionInProgress", false);
      }
      return;
    }
    const didClickOnContentEl = e.composedPath().includes(contentEl);
    if (didClickOnContentEl) {
      if (this.closeOnClick) {
        this.store.set("userInteractionInProgress", true);
        this.store.set("userInteractionInProgress", false);
        return;
      }
      return;
    }
    // Clicked somewhere else on window
    this.store.set("userInteractionInProgress", true);
    this.close();
    this.store.set("userInteractionInProgress", false);
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.sdxdisplaychange = createEvent(this, "sdxdisplaychange", 7);
    this.isConnected = false;
    this.invokeDisplayChangeCallback = () => null;
    this.animationDuration = 300;
    this.oppositeDirection = {
      x: {
        "top-right": "top-left",
        "top-left": "top-right",
        "bottom-right": "bottom-left",
        "bottom-left": "bottom-right",
      },
      y: {
        "top-right": "bottom-right",
        "top-left": "bottom-left",
        "bottom-right": "top-right",
        "bottom-left": "top-left",
      },
    };
    /**
     * The arrow is basically a 14px square (rotated by 45°).
     */
    this.arrowUnrotatedWidth = 14;
    /**
     * Horizontal distance between contentEl and arrowEl.
     */
    this.offsetX = 24;
    /**
     * Vertical distance between toggleEl and arrowEl (and, on mobiles, to the
     * screen).
     */
    this.offsetY = 16;
    this.lastScreenOrientationAngle = 0;
    this.state = undefined;
    this.direction = "bottom-right";
    this.closeOnClick = false;
    this.displayChangeCallback = undefined;
    this.animated = true;
    this.setInvokeDisplayChangeCallback();
    this.store = new StoreConnection(this, menuFlyoutReducer, getInitialState$3(), ["display", "direction", "contentEl", "toggleEl", "arrowEls"]);
    this.store.set("direction", this.direction);
    this.store.set("toggle", this.toggle.bind(this));
    this.store.flush();
  }
  connectedCallback() {
    this.isConnected = true;
  }
  disconnectedCallback() {
    this.isConnected = false;
    // Make sure the flyout is closed when removed from the DOM
    this.close();
  }
  componentDidLoad() {
    this.store.subscribe();
  }
  displayChanged(state) {
    this.invokeDisplayChangeCallback(state.display);
  }
  setDisplay(display, userInteractionInProgress) {
    this.store.set("display", display);
    // Only fire events on end user interaction
    if (!userInteractionInProgress) {
      return;
    }
    this.sdxdisplaychange.emit({ display });
  }
  arrowElsChanged() {
    if (!this.isConnected) {
      return;
    }
    this.positionArrowEls();
  }
  setInvokeDisplayChangeCallback() {
    this.invokeDisplayChangeCallback = parseFunction(this.displayChangeCallback);
  }
  positionContentEl(direction) {
    const { contentEl, toggleEl } = this.state.get();
    if (!(contentEl && toggleEl && this.scrollContainerEl)) {
      return;
    }
    const elRect = this.el.getBoundingClientRect();
    const elHalfWidth = elRect.width / 2;
    const isDirection = {
      bottom: direction === "bottom-right" || direction === "bottom-left",
      left: direction === "top-left" || direction === "bottom-left",
      right: direction === "top-right" || direction === "bottom-right",
      top: direction === "top-right" || direction === "top-left",
    };
    let spaceTowards = {
      bottom: document.documentElement.clientHeight - elRect.bottom,
      left: elRect.left + elHalfWidth,
      right: document.documentElement.clientWidth - elRect.right + elHalfWidth,
      top: elRect.top,
    };
    let scrollContainerElRect = {
      bottom: 0,
      left: 0,
      right: 0,
      top: 0,
    };
    // If the overlay is inside an offset parent, include all its spacings
    // in the calculation.
    if (this.scrollContainerEl !== document.documentElement) {
      scrollContainerElRect = this.scrollContainerEl.getBoundingClientRect();
      // Subtract toggleElChildRect from scrollContainerElRect
      spaceTowards = {
        bottom: scrollContainerElRect.bottom - elRect.bottom,
        left: spaceTowards.left - scrollContainerElRect.left,
        right: scrollContainerElRect.right - elHalfWidth,
        top: elRect.top - scrollContainerElRect.top,
      };
    }
    // Show the contentEl to take measurements
    contentEl.style.display = "block";
    const contentElWidth = contentEl.clientWidth;
    const contentElHeight = contentEl.clientHeight;
    const hasEnoughSpaceTo = {
      bottom: spaceTowards.bottom - MenuFlyout.minSpaceToWindow >=
        contentElHeight + this.arrowUnrotatedWidth,
      left: spaceTowards.left - MenuFlyout.minSpaceToWindow >= contentElWidth,
      right: spaceTowards.right - MenuFlyout.minSpaceToWindow >= contentElWidth,
      top: spaceTowards.top - MenuFlyout.minSpaceToWindow >=
        contentElHeight + this.arrowUnrotatedWidth,
    };
    const bottom = spaceTowards.top +
      getScrollTopLeft(this.scrollContainerEl).scrollTop +
      elRect.height;
    const left = spaceTowards.left +
      getScrollTopLeft(this.scrollContainerEl).scrollLeft -
      contentElWidth +
      this.offsetX +
      this.arrowUnrotatedWidth / 2;
    const right = spaceTowards.left +
      getScrollTopLeft(this.scrollContainerEl).scrollLeft -
      this.offsetX -
      this.arrowUnrotatedWidth / 2;
    const top = spaceTowards.top +
      getScrollTopLeft(this.scrollContainerEl).scrollTop -
      contentElHeight;
    let currentDirection = direction;
    // Place the contentEl
    const fallbackLeft = left < 0 ? 0 : left;
    if (isDirection.left) {
      if (hasEnoughSpaceTo.left) {
        contentEl.style.left = `${left}px`;
      }
      else {
        if (hasEnoughSpaceTo.right) {
          contentEl.style.left = `${right}px`;
          currentDirection = this.oppositeDirection.x[currentDirection];
        }
        else {
          contentEl.style.left = `${fallbackLeft}px`;
        }
      }
    }
    if (isDirection.right) {
      if (hasEnoughSpaceTo.right) {
        contentEl.style.left = `${right}px`;
      }
      else {
        contentEl.style.left = `${fallbackLeft}px`;
        currentDirection = this.oppositeDirection.x[currentDirection];
      }
    }
    if (isDirection.top) {
      if (hasEnoughSpaceTo.top) {
        contentEl.style.top = `${top}px`;
      }
      else {
        if (hasEnoughSpaceTo.bottom) {
          contentEl.style.top = `${bottom}px`;
          currentDirection = this.oppositeDirection.y[currentDirection];
        }
        else {
          contentEl.style.top = `${top}px`;
        }
      }
    }
    if (isDirection.bottom) {
      if (hasEnoughSpaceTo.bottom) {
        contentEl.style.top = `${bottom}px`;
      }
      else {
        if (hasEnoughSpaceTo.top) {
          contentEl.style.top = `${top}px`;
          currentDirection = this.oppositeDirection.y[currentDirection];
        }
        else {
          contentEl.style.top = `${bottom}px`;
        }
      }
    }
    // Update direction
    this.store.set("direction", currentDirection);
    this.positionArrowEls();
  }
  positionArrowEls() {
    const { contentEl, toggleEl, arrowEls } = this.state.get();
    const contentElRect = contentEl.getBoundingClientRect();
    const toggleElRect = toggleEl.getBoundingClientRect();
    arrowEls.forEach((arrowEl) => {
      arrowEl.style.left = `${toggleElRect.left -
        contentElRect.left +
        toggleElRect.width / 2 -
        this.arrowUnrotatedWidth / 2}px`;
    });
  }
  render() {
    return hAsync("slot", null);
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "state": ["stateChanged"],
    "direction": ["directionChanged"],
    "displayChangeCallback": ["displayChangeCallbackChanged"]
  }; }
  static get style() { return menuFlyoutCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-menu-flyout",
    "$members$": {
      "direction": [1],
      "closeOnClick": [4, "close-on-click"],
      "displayChangeCallback": [1, "display-change-callback"],
      "animated": [4],
      "state": [32],
      "toggle": [64],
      "open": [64],
      "close": [64],
      "requestToClose": [64]
    },
    "$listeners$": [[9, "resize", "onWindowResize"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}
MenuFlyout.minSpaceToWindow = 24; // $baseline-3

const menuFlyoutContentCss = "/*!@:root*/.sc-sdx-menu-flyout-content:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-menu-flyout-content-h,*.sc-sdx-menu-flyout-content,*.sc-sdx-menu-flyout-content:before,*.sc-sdx-menu-flyout-content:after{box-sizing:border-box}/*!@:host*/.sc-sdx-menu-flyout-content-h{display:block}/*!@:host > .component > .arrow*/.sc-sdx-menu-flyout-content-h>.component.sc-sdx-menu-flyout-content>.arrow.sc-sdx-menu-flyout-content{display:none;position:absolute;background-color:#fff;width:15px;height:15px;transform:rotate(45deg)}/*!@:host*/.sc-sdx-menu-flyout-content-h{display:none;position:absolute;top:0;left:0;z-index:999999;box-shadow:0 0 4px 0 rgba(0, 0, 0, 0.2)}/*!@:host > .component > .body*/.sc-sdx-menu-flyout-content-h>.component.sc-sdx-menu-flyout-content>.body.sc-sdx-menu-flyout-content{position:relative;background-color:#fff;padding:24px;transition:border-bottom 200ms cubic-bezier(0.4, 0, 0.6, 1), color 200ms cubic-bezier(0.4, 0, 0.6, 1)}/*!@:host(:not(:last-of-type)) > .component > .body*/.sc-sdx-menu-flyout-content-h:not(:last-of-type)>.component.sc-sdx-menu-flyout-content>.body.sc-sdx-menu-flyout-content{border-bottom:1px solid #e4e9ec}/*!@:host(.bottom-right) > .component > .arrow,\n:host(.bottom-left) > .component > .arrow*/.bottom-right.sc-sdx-menu-flyout-content-h>.component.sc-sdx-menu-flyout-content>.arrow.sc-sdx-menu-flyout-content,.bottom-left.sc-sdx-menu-flyout-content-h>.component.sc-sdx-menu-flyout-content>.arrow.sc-sdx-menu-flyout-content{display:block;top:-7.5px;box-shadow:-1px -1px 2px 0 rgba(0, 0, 0, 0.15)}/*!@:host(.top-right) > .component > .arrow,\n:host(.top-left) > .component > .arrow*/.top-right.sc-sdx-menu-flyout-content-h>.component.sc-sdx-menu-flyout-content>.arrow.sc-sdx-menu-flyout-content,.top-left.sc-sdx-menu-flyout-content-h>.component.sc-sdx-menu-flyout-content>.arrow.sc-sdx-menu-flyout-content{display:block;bottom:-7.5px;box-shadow:1px 1px 2px 0 rgba(0, 0, 0, 0.15)}/*!@.component.sdx--dark-theme > .body,\n.component.sdx--dark-theme > .arrow*/.component.sdx--dark-theme.sc-sdx-menu-flyout-content>.body.sc-sdx-menu-flyout-content,.component.sdx--dark-theme.sc-sdx-menu-flyout-content>.arrow.sc-sdx-menu-flyout-content{background-color:#242424}/*!@:host(:not(:last-of-type).sdx--dark-theme) > .component > .body*/.sc-sdx-menu-flyout-content-h:not(:last-of-type).sdx--dark-theme>.component.sc-sdx-menu-flyout-content>.body.sc-sdx-menu-flyout-content{border-bottom:1px solid #707070}";

class MenuFlyoutContent {
  stateChanged({}, prev) {
    const state = this.state.get();
    const prevState = prev.get();
    if (state.display !== prevState.display) {
      this.displayChanged(state);
    }
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.state = undefined;
    this.store = new StoreConnection(this, menuFlyoutReducer, getInitialState$3(), ["direction", "display"]);
  }
  connectedCallback() {
    // Register self
    this.store.set("contentEl", this.el);
    // Re-register arrow el (but only if already rendered)
    if (this.arrowEl) {
      this.store.dispatch({
        type: "ADD_ARROW_EL",
        arrowEl: this.arrowEl,
      });
    }
  }
  disconnectedCallback() {
    // Unregister arrow el (but only if already rendered)
    // If a component is created and appended in direct succession (like with
    // Angular's ng-content), disconnectedCallback() is called before render()
    if (this.arrowEl) {
      this.store.dispatch({
        type: "REMOVE_ARROW_EL",
        arrowEl: this.arrowEl,
      });
    }
    // Unregister self
    this.store.set("contentEl", undefined);
  }
  componentDidLoad() {
    // Register arrow el
    this.store.dispatch({
      type: "ADD_ARROW_EL",
      arrowEl: this.arrowEl,
    });
    this.store.subscribe();
  }
  displayChanged(state) {
    var _a;
    if (state.display === "open") {
      (_a = this.trapFocusEl) === null || _a === void 0 ? void 0 : _a.doFocus();
    }
  }
  getHostClassNames() {
    return {
      ...computedProperty(this.state.get().direction),
    };
  }
  getComponentClassNames() {
    return {
      component: true,
      [getAppearance(this.el)]: true,
    };
  }
  render() {
    return (hAsync(Host, { class: this.getHostClassNames(), role: "dialog", "aria-labelledby": "sdx-dialog-content-label", "aria-describedby": "sdx-dialog-content-description" }, hAsync("div", { class: this.getComponentClassNames() }, hAsync("div", { class: "arrow", ref: (el) => (this.arrowEl = el) }), hAsync("div", { class: "body" }, hAsync("sdx-trap-focus", { ref: (el) => (this.trapFocusEl = el), lang: this.el.lang }, hAsync("slot", null))))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "state": ["stateChanged"]
  }; }
  static get style() { return menuFlyoutContentCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-menu-flyout-content",
    "$members$": {
      "state": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const menuFlyoutCtaCss = "/*!@:root*/.sc-sdx-menu-flyout-cta:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-menu-flyout-cta-h,*.sc-sdx-menu-flyout-cta,*.sc-sdx-menu-flyout-cta:before,*.sc-sdx-menu-flyout-cta:after{box-sizing:border-box}/*!@:host*/.sc-sdx-menu-flyout-cta-h{display:block}/*!@:host > .component > .arrow*/.sc-sdx-menu-flyout-cta-h>.component.sc-sdx-menu-flyout-cta>.arrow.sc-sdx-menu-flyout-cta{display:none;position:absolute;background-color:#fff;width:15px;height:15px;transform:rotate(45deg)}/*!@:host*/.sc-sdx-menu-flyout-cta-h{display:none;position:absolute;top:0;left:0;z-index:60000;box-shadow:0 0 4px 0 rgba(0, 0, 0, 0.2);min-width:254px;max-width:850px}/*!@:host > .component > .body*/.sc-sdx-menu-flyout-cta-h>.component.sc-sdx-menu-flyout-cta>.body.sc-sdx-menu-flyout-cta{position:relative;background-color:#fff;padding:12px 24px;transition:border-bottom 200ms cubic-bezier(0.4, 0, 0.6, 1), color 200ms cubic-bezier(0.4, 0, 0.6, 1)}/*!@:host(:not(:last-of-type)) > .component > .body*/.sc-sdx-menu-flyout-cta-h:not(:last-of-type)>.component.sc-sdx-menu-flyout-cta>.body.sc-sdx-menu-flyout-cta{border-bottom:1px solid #e4e9ec}/*!@:host(.bottom-right) > .component > .arrow,\n:host(.bottom-left) > .component > .arrow*/.bottom-right.sc-sdx-menu-flyout-cta-h>.component.sc-sdx-menu-flyout-cta>.arrow.sc-sdx-menu-flyout-cta,.bottom-left.sc-sdx-menu-flyout-cta-h>.component.sc-sdx-menu-flyout-cta>.arrow.sc-sdx-menu-flyout-cta{display:block;top:-7.5px;box-shadow:-1px -1px 2px 0 rgba(0, 0, 0, 0.15)}/*!@:host(.top-right) > .component > .arrow,\n:host(.top-left) > .component > .arrow*/.top-right.sc-sdx-menu-flyout-cta-h>.component.sc-sdx-menu-flyout-cta>.arrow.sc-sdx-menu-flyout-cta,.top-left.sc-sdx-menu-flyout-cta-h>.component.sc-sdx-menu-flyout-cta>.arrow.sc-sdx-menu-flyout-cta{display:block;bottom:-7.5px;box-shadow:1px 1px 2px 0 rgba(0, 0, 0, 0.15)}/*!@:host(.bottom-left) > .component > .arrow,\n:host(.top-left) > .component > .arrow*/.bottom-left.sc-sdx-menu-flyout-cta-h>.component.sc-sdx-menu-flyout-cta>.arrow.sc-sdx-menu-flyout-cta,.top-left.sc-sdx-menu-flyout-cta-h>.component.sc-sdx-menu-flyout-cta>.arrow.sc-sdx-menu-flyout-cta{right:24px}/*!@:host(.bottom-right) > .component > .arrow,\n:host(.top-right) > .component > .arrow*/.bottom-right.sc-sdx-menu-flyout-cta-h>.component.sc-sdx-menu-flyout-cta>.arrow.sc-sdx-menu-flyout-cta,.top-right.sc-sdx-menu-flyout-cta-h>.component.sc-sdx-menu-flyout-cta>.arrow.sc-sdx-menu-flyout-cta{left:24px}/*!@:host(.small) > .component > .body*/.small.sc-sdx-menu-flyout-cta-h>.component.sc-sdx-menu-flyout-cta>.body.sc-sdx-menu-flyout-cta{width:254px}/*!@:host(.medium) > .component > .body*/.medium.sc-sdx-menu-flyout-cta-h>.component.sc-sdx-menu-flyout-cta>.body.sc-sdx-menu-flyout-cta{width:480px}/*!@:host(.large) > .component > .body*/.large.sc-sdx-menu-flyout-cta-h>.component.sc-sdx-menu-flyout-cta>.body.sc-sdx-menu-flyout-cta{width:850px}";

class MenuFlyoutCta {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.state = undefined;
    this.size = "auto";
    this.store = new StoreConnection(this, menuFlyoutReducer, getInitialState$3(), ["direction"]);
  }
  connectedCallback() {
    // Register self
    this.store.set("contentEl", this.el);
    // Re-register arrow el (but only if already rendered)
    if (this.arrowEl) {
      this.store.dispatch({
        type: "ADD_ARROW_EL",
        arrowEl: this.arrowEl,
      });
    }
  }
  disconnectedCallback() {
    // Unregister arrow el (but only if already rendered)
    // If a component is created and appended in direct succession (like with
    // Angular's ng-content), disconnectedCallback() is called before render()
    if (this.arrowEl) {
      this.store.dispatch({
        type: "REMOVE_ARROW_EL",
        arrowEl: this.arrowEl,
      });
    }
    // Unregister self
    this.store.set("contentEl", undefined);
  }
  componentDidLoad() {
    // Register arrow el
    this.store.dispatch({
      type: "ADD_ARROW_EL",
      arrowEl: this.arrowEl,
    });
    this.store.subscribe();
  }
  getHostClassNames() {
    return {
      [this.size]: true,
      ...computedProperty(this.state.get().direction),
    };
  }
  render() {
    return (hAsync(Host, { class: this.getHostClassNames() }, hAsync("div", { class: "component" }, hAsync("div", { class: "arrow", ref: (el) => (this.arrowEl = el) }), hAsync("div", { class: "body" }, hAsync("slot", null)))));
  }
  get el() { return getElement(this); }
  static get style() { return menuFlyoutCtaCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-menu-flyout-cta",
    "$members$": {
      "size": [1],
      "state": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const menuFlyoutListCss = "/*!@:root*/.sc-sdx-menu-flyout-list:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-menu-flyout-list-h,*.sc-sdx-menu-flyout-list,*.sc-sdx-menu-flyout-list:before,*.sc-sdx-menu-flyout-list:after{box-sizing:border-box}/*!@:host*/.sc-sdx-menu-flyout-list-h{display:none;position:absolute;top:0;left:0;z-index:999999;box-shadow:0 0 4px 0 rgba(0, 0, 0, 0.2);width:254px}/*!@ul*/ul.sc-sdx-menu-flyout-list{list-style-type:none;margin:0;padding:0}";

class MenuFlyoutList {
  stateChanged({}, prev) {
    const state = this.state.get();
    const prevState = prev.get();
    if (state.display !== prevState.display) {
      this.displayChanged(state);
    }
  }
  onKeyDown(e) {
    // do not save childs at componentDidLoad because they could be added dynamically or parsed async
    const getChildsArray = () => Array.from(this.el.querySelectorAll("sdx-menu-flyout-list-item"));
    switch (e.key) {
      case "ArrowDown":
        const nextEl = getNextFromList(getChildsArray(), document.activeElement);
        nextEl.doFocus();
        e.preventDefault();
        break;
      case "ArrowUp":
        const previousEl = getPreviousFromList(getChildsArray(), document.activeElement);
        previousEl.doFocus();
        e.preventDefault();
        break;
      case " ":
        const currentEl = document.activeElement;
        currentEl.doClick();
        e.preventDefault();
        break;
    }
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.state = undefined;
    this.srHint = "";
    this.store = new StoreConnection(this, menuFlyoutReducer, getInitialState$3(), ["display"]);
  }
  connectedCallback() {
    // Register self
    this.store.set("contentEl", this.el);
  }
  componentDidLoad() {
    this.store.subscribe();
  }
  displayChanged(state) {
    var _a;
    if (state.display === "open") {
      (_a = this.trapFocusEl) === null || _a === void 0 ? void 0 : _a.doFocus();
    }
  }
  getHostClassNames() {
    return {
      [getAppearance(this.el)]: true,
    };
  }
  render() {
    return (hAsync(Host, { role: "dialog", class: this.getHostClassNames(), "aria-label": this.srHint }, hAsync("sdx-trap-focus", { ref: (el) => (this.trapFocusEl = el), lang: this.el.lang }, hAsync("div", { role: "list" }, hAsync("slot", null)))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "state": ["stateChanged"]
  }; }
  static get style() { return menuFlyoutListCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-menu-flyout-list",
    "$members$": {
      "srHint": [1, "sr-hint"],
      "state": [32]
    },
    "$listeners$": [[0, "keydown", "onKeyDown"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const menuFlyoutListItemCss = "/*!@:root*/.sc-sdx-menu-flyout-list-item:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-menu-flyout-list-item-h,*.sc-sdx-menu-flyout-list-item,*.sc-sdx-menu-flyout-list-item:before,*.sc-sdx-menu-flyout-list-item:after{box-sizing:border-box}/*!@:host*/.sc-sdx-menu-flyout-list-item-h{display:block}/*!@:host > .component > .arrow*/.sc-sdx-menu-flyout-list-item-h>.component.sc-sdx-menu-flyout-list-item>.arrow.sc-sdx-menu-flyout-list-item{display:none;position:absolute;background-color:#fff;width:15px;height:15px;transform:rotate(45deg)}/*!@:host*/.sc-sdx-menu-flyout-list-item-h{display:block}/*!@:host > .component.focused > .arrow,\n:host > .component.focused > .body*/.sc-sdx-menu-flyout-list-item-h>.component.focused.sc-sdx-menu-flyout-list-item>.arrow.sc-sdx-menu-flyout-list-item,.sc-sdx-menu-flyout-list-item-h>.component.focused.sc-sdx-menu-flyout-list-item>.body.sc-sdx-menu-flyout-list-item{color:#fff;background-color:#086adb !important}/*!@:host > .component > .body*/.sc-sdx-menu-flyout-list-item-h>.component.sc-sdx-menu-flyout-list-item>.body.sc-sdx-menu-flyout-list-item{position:relative;background-color:#fff;color:#086adb;display:block;padding:12px 24px;text-align:center;text-decoration:none;transition:border-bottom 200ms cubic-bezier(0.4, 0, 0.6, 1), color 200ms cubic-bezier(0.4, 0, 0.6, 1);outline:none}/*!@:host(.selectable) > .component > .body*/.selectable.sc-sdx-menu-flyout-list-item-h>.component.sc-sdx-menu-flyout-list-item>.body.sc-sdx-menu-flyout-list-item{cursor:pointer}/*!@:host(:not(.selectable)) > .component > .body*/.sc-sdx-menu-flyout-list-item-h:not(.selectable)>.component.sc-sdx-menu-flyout-list-item>.body.sc-sdx-menu-flyout-list-item{cursor:not-allowed}/*!@:host(.selectable:hover) > .component > .arrow,\n:host(.selectable:hover) > .component > .body*/.selectable.sc-sdx-menu-flyout-list-item-h:hover>.component.sc-sdx-menu-flyout-list-item>.arrow.sc-sdx-menu-flyout-list-item,.selectable.sc-sdx-menu-flyout-list-item-h:hover>.component.sc-sdx-menu-flyout-list-item>.body.sc-sdx-menu-flyout-list-item{color:#fff;background-color:#086adb !important}/*!@:host(.disabled) > .component > .body*/.disabled.sc-sdx-menu-flyout-list-item-h>.component.sc-sdx-menu-flyout-list-item>.body.sc-sdx-menu-flyout-list-item{color:#d6d6d6}/*!@:host(.disabled) > .component > .body.disabled, :host(.disabled) > .component > .body:disabled*/.disabled.sc-sdx-menu-flyout-list-item-h>.component.sc-sdx-menu-flyout-list-item>.body.disabled.sc-sdx-menu-flyout-list-item,.disabled.sc-sdx-menu-flyout-list-item-h>.component.sc-sdx-menu-flyout-list-item>.body.sc-sdx-menu-flyout-list-item:disabled{cursor:not-allowed}/*!@:host(.disabled) > .component > .body.disabled:active, :host(.disabled) > .component > .body:disabled:active*/.disabled.sc-sdx-menu-flyout-list-item-h>.component.sc-sdx-menu-flyout-list-item>.body.disabled.sc-sdx-menu-flyout-list-item:active,.disabled.sc-sdx-menu-flyout-list-item-h>.component.sc-sdx-menu-flyout-list-item>.body.sc-sdx-menu-flyout-list-item:disabled:active{pointer-events:none;transform:none}/*!@:host(:last-of-type) > .component > .body*/.sc-sdx-menu-flyout-list-item-h:last-of-type>.component.sc-sdx-menu-flyout-list-item>.body.sc-sdx-menu-flyout-list-item{border-bottom:none}/*!@:host(:not(:last-of-type)) > .component > .body*/.sc-sdx-menu-flyout-list-item-h:not(:last-of-type)>.component.sc-sdx-menu-flyout-list-item>.body.sc-sdx-menu-flyout-list-item{border-bottom:1px solid #e4e9ec}/*!@:host(.bottom-right:first-of-type) > .component > .arrow,\n:host(.bottom-left:first-of-type) > .component > .arrow*/.bottom-right.sc-sdx-menu-flyout-list-item-h:first-of-type>.component.sc-sdx-menu-flyout-list-item>.arrow.sc-sdx-menu-flyout-list-item,.bottom-left.sc-sdx-menu-flyout-list-item-h:first-of-type>.component.sc-sdx-menu-flyout-list-item>.arrow.sc-sdx-menu-flyout-list-item{display:block;top:-7.5px;box-shadow:-1px -1px 2px 0 rgba(0, 0, 0, 0.15)}/*!@:host(.top-right:last-of-type) > .component > .arrow,\n:host(.top-left:last-of-type) > .component > .arrow*/.top-right.sc-sdx-menu-flyout-list-item-h:last-of-type>.component.sc-sdx-menu-flyout-list-item>.arrow.sc-sdx-menu-flyout-list-item,.top-left.sc-sdx-menu-flyout-list-item-h:last-of-type>.component.sc-sdx-menu-flyout-list-item>.arrow.sc-sdx-menu-flyout-list-item{display:block;bottom:-7.5px;box-shadow:1px 1px 2px 0 rgba(0, 0, 0, 0.15)}/*!@:host(.sdx--dark-theme) > .component.focused > .arrow,\n:host(.sdx--dark-theme) > .component.focused > .body*/.sdx--dark-theme.sc-sdx-menu-flyout-list-item-h>.component.focused.sc-sdx-menu-flyout-list-item>.arrow.sc-sdx-menu-flyout-list-item,.sdx--dark-theme.sc-sdx-menu-flyout-list-item-h>.component.focused.sc-sdx-menu-flyout-list-item>.body.sc-sdx-menu-flyout-list-item{color:#fff;background-color:#0a71e9 !important}/*!@:host(.sdx--dark-theme) > .component > .body*/.sdx--dark-theme.sc-sdx-menu-flyout-list-item-h>.component.sc-sdx-menu-flyout-list-item>.body.sc-sdx-menu-flyout-list-item{font-weight:500;background-color:#242424;color:#4294ff}/*!@:host(.sdx--dark-theme) > .component > .arrow*/.sdx--dark-theme.sc-sdx-menu-flyout-list-item-h>.component.sc-sdx-menu-flyout-list-item>.arrow.sc-sdx-menu-flyout-list-item{background-color:#242424}/*!@:host(.sdx--dark-theme.selectable:hover) > .component > .arrow,\n:host(.sdx--dark-theme.selectable:hover) > .component > .body*/.sdx--dark-theme.selectable.sc-sdx-menu-flyout-list-item-h:hover>.component.sc-sdx-menu-flyout-list-item>.arrow.sc-sdx-menu-flyout-list-item,.sdx--dark-theme.selectable.sc-sdx-menu-flyout-list-item-h:hover>.component.sc-sdx-menu-flyout-list-item>.body.sc-sdx-menu-flyout-list-item{color:#fff;background-color:#0a71e9 !important}/*!@:host(.disabled.sdx--dark-theme) > .component > .body*/.disabled.sdx--dark-theme.sc-sdx-menu-flyout-list-item-h>.component.sc-sdx-menu-flyout-list-item>.body.sc-sdx-menu-flyout-list-item{color:#5c5c5c}/*!@:host(:not(:last-of-type).sdx--dark-theme) > .component > .body*/.sc-sdx-menu-flyout-list-item-h:not(:last-of-type).sdx--dark-theme>.component.sc-sdx-menu-flyout-list-item>.body.sc-sdx-menu-flyout-list-item{border-bottom:1px solid #707070}";

class MenuFlyoutListItem {
  onClick(e) {
    if (this.disabled) {
      e.stopPropagation();
    }
  }
  onFocusChange() {
    this.anchorElFocused = !this.anchorElFocused;
  }
  async doFocus() {
    this.anchorEl.focus();
  }
  async doClick() {
    this.anchorEl.click();
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.state = undefined;
    this.anchorElFocused = false;
    this.selectable = true;
    this.href = "javascript:;";
    this.hreflang = undefined;
    this.target = undefined;
    this.disabled = false;
    this.store = new StoreConnection(this, menuFlyoutReducer, getInitialState$3(), ["direction"]);
  }
  connectedCallback() {
    // Re-register arrow el (but only if already rendered)
    if (this.arrowEl) {
      this.store.dispatch({
        type: "ADD_ARROW_EL",
        arrowEl: this.arrowEl,
      });
    }
  }
  disconnectedCallback() {
    // Unregister arrow el (but only if already rendered)
    // If a component is created and appended in direct succession (like with
    // Angular's ng-content), disconnectedCallback() is called before render()
    if (this.arrowEl) {
      this.store.dispatch({
        type: "REMOVE_ARROW_EL",
        arrowEl: this.arrowEl,
      });
    }
  }
  componentDidLoad() {
    // Register arrow el
    this.store.dispatch({
      type: "ADD_ARROW_EL",
      arrowEl: this.arrowEl,
    });
    this.store.subscribe();
  }
  getHostClassNames() {
    const { direction } = this.state.get();
    return {
      [getAppearance(this.el)]: true,
      selectable: this.selectable && !this.disabled,
      disabled: this.disabled,
      ...computedProperty(direction),
    };
  }
  getComponentClassNames() {
    return {
      component: true,
      focused: this.anchorElFocused,
    };
  }
  getLinkClassNames() {
    return {
      body: true,
      disabled: this.disabled,
    };
  }
  render() {
    return (
    // eslint-disable-next-line jsx-a11y/role-supports-aria-props
    hAsync(Host, { class: this.getHostClassNames(), "aria-disabled": this.disabled && "true", role: "listitem" }, hAsync("div", { class: this.getComponentClassNames() }, hAsync("div", { class: "arrow", ref: (el) => (this.arrowEl = el) }), hAsync("a", { href: this.href, hreflang: this.hreflang, target: this.target, class: this.getLinkClassNames(), ref: (el) => (this.anchorEl = el) }, hAsync("slot", null)))));
  }
  get el() { return getElement(this); }
  static get style() { return menuFlyoutListItemCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-menu-flyout-list-item",
    "$members$": {
      "selectable": [4],
      "href": [1],
      "hreflang": [1],
      "target": [1],
      "disabled": [4],
      "state": [32],
      "anchorElFocused": [32],
      "doFocus": [64],
      "doClick": [64]
    },
    "$listeners$": [[2, "click", "onClick"], [0, "focusin", "onFocusChange"], [0, "focusout", "onFocusChange"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const menuFlyoutToggleCss = "/*!@:root*/.sc-sdx-menu-flyout-toggle:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-menu-flyout-toggle-h,*.sc-sdx-menu-flyout-toggle,*.sc-sdx-menu-flyout-toggle:before,*.sc-sdx-menu-flyout-toggle:after{box-sizing:border-box}/*!@.toggle*/.toggle.sc-sdx-menu-flyout-toggle{padding:0;background-color:transparent;color:#086adb;border:none;font:inherit;outline:none;cursor:pointer}/*!@.toggle:hover, .toggle:focus*/.toggle.sc-sdx-menu-flyout-toggle:hover,.toggle.sc-sdx-menu-flyout-toggle:focus{color:#0048cf}/*!@.toggle.sdx--dark-theme*/.toggle.sdx--dark-theme.sc-sdx-menu-flyout-toggle{color:#4294ff}/*!@.toggle.sdx--dark-theme:hover, .toggle.sdx--dark-theme:focus*/.toggle.sdx--dark-theme.sc-sdx-menu-flyout-toggle:hover,.toggle.sdx--dark-theme.sc-sdx-menu-flyout-toggle:focus{color:#5ca3ff}";

class MenuFlyoutToggle {
  /**
   * Sets the focus on the component.
   */
  async doFocus() {
    var _a;
    (_a = this.buttonEl) === null || _a === void 0 ? void 0 : _a.focus();
  }
  onClick() {
    this.store.set("userInteractionInProgress", true);
    this.state.get().toggle();
    this.store.set("userInteractionInProgress", false);
  }
  handleKeyDown(e) {
    const key = e.key;
    if (key === "Spacebar" || key === " " || key === "Enter") {
      e.preventDefault(); // prevent scrolling, for space
      this.store.set("userInteractionInProgress", true);
      this.state.get().toggle();
      this.store.set("userInteractionInProgress", false);
    }
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.state = undefined;
    this.store = new StoreConnection(this, menuFlyoutReducer, getInitialState$3(), ["display", "toggle"]);
  }
  connectedCallback() {
    // Register self
    this.store.set("toggleEl", this.el);
  }
  disconnectedCallback() {
    // Unregister self
    this.store.set("toggleEl", undefined);
  }
  componentDidLoad() {
    this.store.subscribe();
  }
  getButtonClassNames() {
    return {
      toggle: true,
      [getAppearance(this.el)]: true,
    };
  }
  render() {
    return (hAsync("button", { type: "button", class: this.getButtonClassNames(), ref: (el) => (this.buttonEl = el), "aria-label": translate("Open dialog") }, hAsync("slot", null)));
  }
  get el() { return getElement(this); }
  static get style() { return menuFlyoutToggleCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-menu-flyout-toggle",
    "$members$": {
      "state": [32],
      "doFocus": [64]
    },
    "$listeners$": [[0, "click", "onClick"], [0, "keydown", "handleKeyDown"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const numericStepperCss = "/*!@:root*/.sc-sdx-numeric-stepper:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-numeric-stepper-h,*.sc-sdx-numeric-stepper,*.sc-sdx-numeric-stepper:before,*.sc-sdx-numeric-stepper:after{box-sizing:border-box}/*!@label*/label.sc-sdx-numeric-stepper{display:block;margin-bottom:4px;cursor:inherit;color:#666;font-size:16px}/*!@label.readonly, label.disabled*/label.readonly.sc-sdx-numeric-stepper,label.disabled.sc-sdx-numeric-stepper{color:#bbb}/*!@label.sdx--dark-theme*/label.sdx--dark-theme.sc-sdx-numeric-stepper{color:#adadad}/*!@:host*/.sc-sdx-numeric-stepper-h{display:block}/*!@.component .wrapper*/.component.sc-sdx-numeric-stepper .wrapper.sc-sdx-numeric-stepper{position:relative;width:144px}/*!@.component .wrapper .left,\n.component .wrapper .right*/.component.sc-sdx-numeric-stepper .wrapper.sc-sdx-numeric-stepper .left.sc-sdx-numeric-stepper,.component.sc-sdx-numeric-stepper .wrapper.sc-sdx-numeric-stepper .right.sc-sdx-numeric-stepper{position:absolute;top:0;display:inline-block;margin:8px}/*!@.component .wrapper .left*/.component.sc-sdx-numeric-stepper .wrapper.sc-sdx-numeric-stepper .left.sc-sdx-numeric-stepper{left:0}/*!@.component .wrapper .right*/.component.sc-sdx-numeric-stepper .wrapper.sc-sdx-numeric-stepper .right.sc-sdx-numeric-stepper{left:96px}";

class NumericStepper {
  changeCallbackChanged() {
    this.setInvokeChangeCallback();
  }
  valueChanged() {
    this.setValue(this.value);
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.invokeChangeCallback = () => null;
    this.srHintValue = "";
    this.decreaseDisabled = true;
    this.increaseDisabled = true;
    this.label = "";
    this.srHint = "";
    this.min = 1;
    this.max = 999;
    this.value = this.min;
    this.changeCallback = undefined;
    this.valid = undefined;
    this.validationMessage = undefined;
    this.disabled = false;
    this.inputElValue = undefined;
    this.setValue(this.value);
    this.setInvokeChangeCallback();
    this.srHintValue = `${this.label} ${this.srHint}`;
  }
  setInvokeChangeCallback() {
    this.invokeChangeCallback = parseFunction(this.changeCallback);
  }
  decrease() {
    if (this.value !== undefined) {
      this.setValue(this.value - 1, true);
      this.el.blur();
    }
  }
  increase() {
    if (this.value !== undefined) {
      this.setValue(this.value + 1, true);
      this.el.blur();
    }
  }
  setValue(value, internalChange = false) {
    const prevValue = this.value;
    let valueAsNumber;
    if (typeof value === "string") {
      const parsedValue = parseFloat(value);
      valueAsNumber = isNaN(parsedValue) ? undefined : parsedValue;
    }
    else {
      valueAsNumber = value;
    }
    // Set new value within range
    if (valueAsNumber !== undefined && valueAsNumber > this.max) {
      this.value = this.max;
    }
    else if (valueAsNumber !== undefined && valueAsNumber < this.min) {
      this.value = this.min;
    }
    else {
      this.value = valueAsNumber;
    }
    // Sync input field
    this.inputElValue = JSON.stringify(this.value);
    // Update button states
    this.increaseDisabled = this.value === undefined || this.value >= this.max;
    this.decreaseDisabled = this.value === undefined || this.value <= this.min;
    // Only invoke callbacks if value really changed
    if (prevValue === this.value) {
      return;
    }
    this.invokeChangeCallback(this.value);
    if (internalChange) {
      dispatchEvent(this.el, NumericStepper.eventInput);
    }
  }
  focusInputField() {
    this.sdxInputEl.focus();
  }
  getInputStyle() {
    return {
      textAlign: "center",
      padding: "0 56px",
    };
  }
  getLabelClassNames() {
    return {
      label: true,
      [getAppearance(this.el)]: true,
    };
  }
  getComponentClassNames() {
    return {
      component: true,
      [getAppearance(this.el)]: true,
    };
  }
  getButtonClassNames(position) {
    return {
      [position]: true,
      invalid: this.valid === false,
    };
  }
  render() {
    return (hAsync("div", { class: this.getComponentClassNames() }, this.label && (hAsync("label", { class: this.getLabelClassNames(), onClick: () => this.focusInputField(), "aria-hidden": "true" }, this.label)), hAsync("div", { class: "wrapper" }, hAsync("sdx-input", { srHint: this.srHintValue, type: "number", ref: (el) => (this.sdxInputEl = el), onInput: (e) => {
        this.inputElValue = e.target.value;
        e.stopPropagation();
      }, blurCallback: () => this.setValue(this.inputElValue, true), inputStyle: this.getInputStyle(), value: this.inputElValue, disabled: this.disabled, valid: this.valid, validationMessage: this.validationMessage }), hAsync("sdx-button", { theme: "transparent", class: this.getButtonClassNames("left"), iconName: "icon-minus", iconSize: 3, disabled: this.decreaseDisabled || this.disabled, onClick: () => this.decrease(), tabindex: "-1", "aria-hidden": "true", valid: this.valid && this.validationMessage !== "" }), hAsync("sdx-button", { theme: "transparent", class: this.getButtonClassNames("right"), iconName: "icon-plus", iconSize: 3, disabled: this.increaseDisabled || this.disabled, onClick: () => this.increase(), tabindex: "-1", "aria-hidden": "true", valid: this.valid && this.validationMessage !== "" }))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "changeCallback": ["changeCallbackChanged"],
    "value": ["valueChanged"],
    "min": ["valueChanged"],
    "max": ["valueChanged"]
  }; }
  static get style() { return numericStepperCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-numeric-stepper",
    "$members$": {
      "label": [1],
      "srHint": [1, "sr-hint"],
      "min": [2],
      "max": [2],
      "value": [1026],
      "changeCallback": [1, "change-callback"],
      "valid": [4],
      "validationMessage": [1, "validation-message"],
      "disabled": [4],
      "inputElValue": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}
/**
 * Emitted whenever increase or decrease button is pressed or value of input field changes.
 * @event
 */
NumericStepper.eventInput = "input";

const optionPickerCss = ":root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}:host,*,*:before,*:after{box-sizing:border-box}";

class OptionPicker {
  optionsChanged() {
    this.optionsParsed = parseJson(this.options) || [];
  }
  valueChanged() {
    this.invokeChangeCallback(this.value);
  }
  changeCallbackChanged() {
    this.setInvokeChangeCallback();
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.invokeChangeCallback = () => null;
    this.options = [];
    this.changeCallback = undefined;
    this.multiple = false;
    this.name = undefined;
    this.value = [];
    this.setInvokeChangeCallback();
    this.optionsParsed = parseJson(this.options) || [];
  }
  setInvokeChangeCallback() {
    this.invokeChangeCallback = parseFunction(this.changeCallback);
  }
  render() {
    return (hAsync("sdx-input-group", { inline: true, theme: "container", name: this.name, type: this.multiple ? "checkbox" : "radio", changeCallback: (value) => (this.value = value), value: this.value }, this.optionsParsed.map((option) => (hAsync("sdx-input-item", { hideCheckedIcon: true, value: option.value, checked: option.checked }, option.name)))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "options": ["optionsChanged"],
    "value": ["valueChanged"],
    "changeCallback": ["changeCallbackChanged"]
  }; }
  static get style() { return optionPickerCss; }
  static get cmpMeta() { return {
    "$flags$": 0,
    "$tagName$": "sdx-option-picker",
    "$members$": {
      "options": [1],
      "changeCallback": [1, "change-callback"],
      "multiple": [4],
      "name": [1],
      "value": [1040]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}
/**
 * Emitted whenever user is checking/unchecking an item.
 * @event
 */
// @ts-ignore just for documentation purposes
OptionPicker.eventInput = "input";

const pieChartCss = "/*!@:root*/.sc-sdx-pie-chart:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-pie-chart-h,*.sc-sdx-pie-chart,*.sc-sdx-pie-chart:before,*.sc-sdx-pie-chart:after{box-sizing:border-box}/*!@.sr-only*/.sr-only.sc-sdx-pie-chart{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);border:0}/*!@.sr-only-focusable:active, .sr-only-focusable:focus*/.sr-only-focusable.sc-sdx-pie-chart:active,.sr-only-focusable.sc-sdx-pie-chart:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}/*!@.component*/.component.sc-sdx-pie-chart{display:flex;justify-content:center}/*!@.component.small .wrapper .chart-container .chart*/.component.small.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart{height:64px;width:64px}/*!@.component.small .wrapper .chart-container .chart svg*/.component.small.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart{height:64px;width:64px;stroke-linecap:butt}/*!@.component.small .wrapper .chart-container .chart svg circle*/.component.small.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.sc-sdx-pie-chart{stroke:#d6d6d6}/*!@.component.small .wrapper .chart-container .chart svg circle.azure*/.component.small.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.azure.sc-sdx-pie-chart{stroke:#1781e3}/*!@.component.small .wrapper .chart-container .chart svg circle.turquoise*/.component.small.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.turquoise.sc-sdx-pie-chart{stroke:#0eaba9}/*!@.component.small .wrapper .chart-container .chart svg circle.iris*/.component.small.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.iris.sc-sdx-pie-chart{stroke:#5944c6}/*!@.component.small .wrapper .chart-container .chart svg circle.orchid*/.component.small.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.orchid.sc-sdx-pie-chart{stroke:#a63297}/*!@.component.small .wrapper .chart-container .chart svg circle.pink*/.component.small.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.pink.sc-sdx-pie-chart{stroke:#e61e64}/*!@.component.small .wrapper .chart-container .metadata*/.component.small.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .metadata.sc-sdx-pie-chart{font-size:16px;top:8px;right:8px;bottom:8px;left:8px}/*!@.component.bottom .wrapper*/.component.bottom.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart{flex-direction:column;flex-basis:100%}/*!@.component.bottom .wrapper .legend*/.component.bottom.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .legend.sc-sdx-pie-chart{margin-top:24px;flex-wrap:wrap;width:100%}/*!@.component.bottom .wrapper .legend li:not(:last-of-type)*/.component.bottom.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .legend.sc-sdx-pie-chart li.sc-sdx-pie-chart:not(:last-of-type){margin-right:24px}/*!@.component.right .wrapper .legend*/.component.right.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .legend.sc-sdx-pie-chart{margin-left:32px;flex-direction:column}/*!@.component.right .wrapper .legend li:not(:last-of-type)*/.component.right.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .legend.sc-sdx-pie-chart li.sc-sdx-pie-chart:not(:last-of-type){margin-bottom:8px}/*!@.component.dark .wrapper .chart-container .metadata,\n.component.dark .wrapper .chart-container .metadata .description*/.component.dark.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .metadata.sc-sdx-pie-chart,.component.dark.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .metadata.sc-sdx-pie-chart .description.sc-sdx-pie-chart{color:#fff}/*!@.component .wrapper*/.component.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart{display:flex;align-items:center}/*!@.component .wrapper .chart-container*/.component.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart{position:relative}/*!@.component .wrapper .chart-container .chart*/.component.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart{transform:rotate(-90deg);height:182px;width:182px}/*!@.component .wrapper .chart-container .chart svg*/.component.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart{position:absolute;top:0;left:0;fill:transparent;stroke-width:2;stroke-linecap:round;height:182px;width:182px}/*!@.component .wrapper .chart-container .chart svg circle*/.component.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.sc-sdx-pie-chart{stroke:#d6d6d6}/*!@.component .wrapper .chart-container .chart svg circle.azure*/.component.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.azure.sc-sdx-pie-chart{stroke:#1781e3}/*!@.component .wrapper .chart-container .chart svg circle.turquoise*/.component.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.turquoise.sc-sdx-pie-chart{stroke:#0eaba9}/*!@.component .wrapper .chart-container .chart svg circle.iris*/.component.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.iris.sc-sdx-pie-chart{stroke:#5944c6}/*!@.component .wrapper .chart-container .chart svg circle.orchid*/.component.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.orchid.sc-sdx-pie-chart{stroke:#a63297}/*!@.component .wrapper .chart-container .chart svg circle.pink*/.component.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.pink.sc-sdx-pie-chart{stroke:#e61e64}/*!@.component .wrapper .chart-container .metadata*/.component.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .metadata.sc-sdx-pie-chart{font-weight:400;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;line-height:28px;letter-spacing:-0.89px;font-size:32px;position:absolute;display:flex;flex-direction:column;justify-content:center;align-items:center;top:32px;right:24px;bottom:24px;left:24px}/*!@.component .wrapper .chart-container .metadata .description*/.component.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .metadata.sc-sdx-pie-chart .description.sc-sdx-pie-chart{font-size:16px;color:#666;white-space:nowrap;width:100%;overflow:hidden;text-overflow:ellipsis;text-align:center}/*!@.component .wrapper .legend*/.component.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .legend.sc-sdx-pie-chart{display:flex;list-style:none;padding:0;font-weight:300;justify-content:center;margin:0}/*!@.component .wrapper .legend li*/.component.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .legend.sc-sdx-pie-chart li.sc-sdx-pie-chart{white-space:nowrap}/*!@.component.sdx--dark-theme.small .wrapper .chart-container .chart svg circle*/.component.sdx--dark-theme.small.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.sc-sdx-pie-chart{stroke:#5c5c5c}/*!@.component.sdx--dark-theme.small .wrapper .chart-container .chart svg circle.azure*/.component.sdx--dark-theme.small.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.azure.sc-sdx-pie-chart{stroke:#136fc3}/*!@.component.sdx--dark-theme.small .wrapper .chart-container .chart svg circle.turquoise*/.component.sdx--dark-theme.small.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.turquoise.sc-sdx-pie-chart{stroke:#0a7b7a}/*!@.component.sdx--dark-theme.small .wrapper .chart-container .chart svg circle.iris*/.component.sdx--dark-theme.small.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.iris.sc-sdx-pie-chart{stroke:#6f5ccb}/*!@.component.sdx--dark-theme.small .wrapper .chart-container .chart svg circle.orchid*/.component.sdx--dark-theme.small.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.orchid.sc-sdx-pie-chart{stroke:#a54c9b}/*!@.component.sdx--dark-theme.small .wrapper .chart-container .chart svg circle.pink*/.component.sdx--dark-theme.small.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .chart.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.pink.sc-sdx-pie-chart{stroke:#d41d56}/*!@.component.sdx--dark-theme .wrapper .chart-container .metadata .description*/.component.sdx--dark-theme.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart .metadata.sc-sdx-pie-chart .description.sc-sdx-pie-chart{color:#e6e6e6}/*!@.component.sdx--dark-theme .wrapper .chart-container svg circle*/.component.sdx--dark-theme.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.sc-sdx-pie-chart{stroke:#5c5c5c}/*!@.component.sdx--dark-theme .wrapper .chart-container svg circle.azure*/.component.sdx--dark-theme.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.azure.sc-sdx-pie-chart{stroke:#136fc3}/*!@.component.sdx--dark-theme .wrapper .chart-container svg circle.turquoise*/.component.sdx--dark-theme.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.turquoise.sc-sdx-pie-chart{stroke:#0a7b7a}/*!@.component.sdx--dark-theme .wrapper .chart-container svg circle.iris*/.component.sdx--dark-theme.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.iris.sc-sdx-pie-chart{stroke:#6f5ccb}/*!@.component.sdx--dark-theme .wrapper .chart-container svg circle.orchid*/.component.sdx--dark-theme.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.orchid.sc-sdx-pie-chart{stroke:#a54c9b}/*!@.component.sdx--dark-theme .wrapper .chart-container svg circle.pink*/.component.sdx--dark-theme.sc-sdx-pie-chart .wrapper.sc-sdx-pie-chart .chart-container.sc-sdx-pie-chart svg.sc-sdx-pie-chart circle.pink.sc-sdx-pie-chart{stroke:#d41d56}";

class PieChart {
  dataChanged() {
    this.dataParsed = parseJson(this.data) || [];
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.viewBox = 34;
    this.radius = 16;
    this.segmentPaddingForSizeSmall = 0;
    this.segmentPaddingForSizeMedium = 3;
    this.hundredPercent = this.radius * 2 * Math.PI;
    this.animationDuration = 300;
    this.data = [];
    this.value = "";
    this.description = undefined;
    this.legendPosition = "bottom";
    this.size = "medium";
    this.backgroundTheme = "light";
    this.dataParsed = parseJson(this.data) || [];
  }
  animateSegment(segment, timeline) {
    if (!segment.circle) {
      return;
    }
    // Initial stroke-dasharray
    segment.circle.style.strokeDasharray = `0 ${this.hundredPercent}`;
    timeline.add({
      targets: segment.circle,
      begin: () => (segment.circle.style.display = ""),
      strokeDasharray: `${segment.width} ${this.hundredPercent}`,
      duration: this.animationDuration,
      easing: "easeInQuint",
    });
  }
  animateLegendItem(legendItem, timeline) {
    if (!legendItem) {
      return;
    }
    timeline.add({
      targets: legendItem,
      opacity: 1,
      duration: this.animationDuration,
      easing: "easeInQuint",
    });
  }
  /**
   * Read the data and create a pie part (segment) for every data point.
   * The SDX pie chart is special in two ways:
   * 1. it has a spacing between the segments (called segmentPadding)
   * 2. small values (values smaller than the segmentPadding) are represented by only a dot.
   *    This makes the math behind *special*, for example:
   *    If a chart has the values [1, 1, 1, 1000], the three "1" use up much more space than
   *    they would in an ordinary pie chart (where they would be hardly recognizable).
   *    This limits the amount of data segments (e.g. [1 * 50, 1000] ends up glitchy).
   */
  dataToSegments() {
    const segmentPadding = this.size === "medium"
      ? this.segmentPaddingForSizeMedium
      : this.segmentPaddingForSizeSmall;
    // Calculate the "max"
    const totalValue = this.dataParsed.reduce((total, d) => total + d.value, 0);
    const segmentsSmallerThanPadding = this.dataParsed.filter((d) => {
      let width = (d.value / totalValue) * this.hundredPercent;
      return width < segmentPadding;
    });
    const totalValueOfSegmentsSmallerThanPadding = segmentsSmallerThanPadding.reduce((total, d) => {
      return total + d.value;
    }, 0);
    const segmentPaddingRotationDeg = (360 / this.hundredPercent) * segmentPadding;
    let rotation = segmentPaddingRotationDeg; // initial
    return this.dataParsed
      .filter(({}, i) => (this.size === "small" ? i === 0 : true)) // "small" only has one segment
      .map((d) => {
      // Calculate how much space is left without all the small segments
      // (a.k.a. calculate the "real" 100%)
      const availableWidth = this.hundredPercent -
        segmentPadding * segmentsSmallerThanPadding.length;
      let width = (d.value / (totalValue - totalValueOfSegmentsSmallerThanPadding)) *
        availableWidth;
      if (width < segmentPadding) {
        // Small values are represented by only a dot (using CSS "stroke-linecap: round;")
        width = 0;
      }
      else {
        // Create padding
        width = width - segmentPadding;
      }
      const segment = { d, width, rotation };
      rotation += this.widthToDeg(segment.width) + segmentPaddingRotationDeg;
      return segment;
    });
  }
  widthToDeg(width) {
    return (360 / this.hundredPercent) * width;
  }
  getComponentClassNames() {
    return {
      component: true,
      [getAppearance(this.el)]: true,
      [this.legendPosition]: true,
      [this.size]: true,
      [this.backgroundTheme]: true,
    };
  }
  hasLabelsOrSrHints() {
    return this.dataParsed.some(this.hasLabelOrSrHint);
  }
  hasLabelOrSrHint(d) {
    return !!d.label || !!d.srHint;
  }
  render() {
    const center = this.viewBox / 2;
    const segmentsTimeline = anime.timeline();
    const legendItemsTimeline = anime.timeline();
    return (hAsync("div", { class: this.getComponentClassNames() }, hAsync("div", { class: "wrapper" }, hAsync("div", { class: "chart-container" }, hAsync("div", { class: "chart" }, this.size === "small" && (hAsync("svg", { viewBox: `0 0 ${this.viewBox} ${this.viewBox}`, style: {
        transform: `rotate(${this.widthToDeg(this.hundredPercent)}deg)`,
      } }, hAsync("circle", { cx: center, cy: center, r: this.radius }))), this.dataToSegments().map((segment) => {
      return (hAsync("svg", { key: Math.random() /* make sure elements are not reused (causing glitchy animations) */, viewBox: `0 0 ${this.viewBox} ${this.viewBox}`, style: { transform: `rotate(${segment.rotation}deg)` } }, hAsync("circle", { class: segment.d.color, ref: (el) => this.animateSegment({ ...segment, circle: el }, segmentsTimeline), style: {
          display: "none" /* will be displayed during animation */,
        }, cx: center, cy: center, r: this.radius })));
    })), hAsync("div", { class: "metadata", "aria-hidden": "true" }, hAsync("div", { class: "value" }, this.value), this.size !== "small" && (hAsync("div", { class: "description" }, this.description)))), this.hasLabelsOrSrHints() && (hAsync("ul", { class: { legend: true, "sr-only": this.size === "small" } }, this.dataParsed.filter(this.hasLabelOrSrHint).map((d) => {
      return (hAsync("li", { key: Math.random() /* make sure elements are not reused (causing glitchy animations) */, ref: (el) => this.animateLegendItem(el, legendItemsTimeline), style: { opacity: "0" } }, hAsync("span", { "aria-hidden": "true" }, hAsync("sdx-icon", { iconName: "icon-record-filled", colorClass: d.color || "gray-tint-8" }), " ", d.label), d.srHint && hAsync("span", { class: "sr-only" }, d.srHint)));
    }))))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "data": ["dataChanged"]
  }; }
  static get style() { return pieChartCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-pie-chart",
    "$members$": {
      "data": [1],
      "value": [1],
      "description": [1],
      "legendPosition": [1, "legend-position"],
      "size": [1],
      "backgroundTheme": [1, "background-theme"]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const priceCss = "/*!@:root*/.sc-sdx-price:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-price-h,*.sc-sdx-price,*.sc-sdx-price:before,*.sc-sdx-price:after{box-sizing:border-box}/*!@.text-body-1,\n.text-standard*/.text-body-1.sc-sdx-price,.text-standard.sc-sdx-price{line-height:24px;letter-spacing:-0.1px;font-size:18px}/*!@.text-body-2,\n.text-small*/.text-body-2.sc-sdx-price,.text-small.sc-sdx-price{line-height:21px;letter-spacing:0;font-size:16px}/*!@h1,\nh2,\nh3,\nh4,\nh5,\nh6,\np*/h1.sc-sdx-price,h2.sc-sdx-price,h3.sc-sdx-price,h4.sc-sdx-price,h5.sc-sdx-price,h6.sc-sdx-price,p.sc-sdx-price{margin:0;text-align:left;word-wrap:break-word}/*!@.h1,\n.h2,\n.h3,\n.h4,\n.h5,\n.h6,\n.hero,\n.d1,\n.d2,\n.d3*/.h1.sc-sdx-price,.h2.sc-sdx-price,.h3.sc-sdx-price,.h4.sc-sdx-price,.h5.sc-sdx-price,.h6.sc-sdx-price,.hero.sc-sdx-price,.d1.sc-sdx-price,.d2.sc-sdx-price,.d3.sc-sdx-price{color:#015}/*!@.h1,\n.h2,\n.text-h1,\n.text-h2,\nh1,\nh2*/.h1.sc-sdx-price,.h2.sc-sdx-price,.text-h1.sc-sdx-price,.text-h2.sc-sdx-price,h1.sc-sdx-price,h2.sc-sdx-price{margin-bottom:32px}/*!@.h1,\n.text-h1,\nh1*/.h1.sc-sdx-price,.text-h1.sc-sdx-price,h1.sc-sdx-price{line-height:40px;letter-spacing:-1px;font-size:32px;font-weight:700}@media (min-width: 1024px){/*!@.h1,\n  .text-h1,\n  h1*/.h1.sc-sdx-price,.text-h1.sc-sdx-price,h1.sc-sdx-price{line-height:48px;letter-spacing:-1.2px;font-size:40px}}/*!@.h2,\n.text-h2,\nh2*/.h2.sc-sdx-price,.text-h2.sc-sdx-price,h2.sc-sdx-price{line-height:32px;letter-spacing:-0.75px;font-size:28px;font-weight:700}@media (min-width: 1024px){/*!@.h2,\n  .text-h2,\n  h2*/.h2.sc-sdx-price,.text-h2.sc-sdx-price,h2.sc-sdx-price{line-height:40px;letter-spacing:-1px;font-size:32px}}/*!@.h3,\n.h4,\n.text-h3,\n.text-h4,\nh3,\nh4*/.h3.sc-sdx-price,.h4.sc-sdx-price,.text-h3.sc-sdx-price,.text-h4.sc-sdx-price,h3.sc-sdx-price,h4.sc-sdx-price{margin-bottom:24px}/*!@.h3,\n.text-h3,\nh3*/.h3.sc-sdx-price,.text-h3.sc-sdx-price,h3.sc-sdx-price{line-height:32px;letter-spacing:-0.35px;font-size:24px;font-weight:600}@media (min-width: 1024px){/*!@.h3,\n  .text-h3,\n  h3*/.h3.sc-sdx-price,.text-h3.sc-sdx-price,h3.sc-sdx-price{line-height:32px;letter-spacing:-0.75px;font-size:28px}}/*!@.h4,\n.text-h4,\nh4*/.h4.sc-sdx-price,.text-h4.sc-sdx-price,h4.sc-sdx-price{line-height:24px;letter-spacing:-0.1px;font-size:20px;font-weight:600}@media (min-width: 1024px){/*!@.h4,\n  .text-h4,\n  h4*/.h4.sc-sdx-price,.text-h4.sc-sdx-price,h4.sc-sdx-price{line-height:32px;letter-spacing:-0.35px;font-size:24px}}/*!@.text-h3.text-compact*/.text-h3.text-compact.sc-sdx-price{line-height:31px}/*!@.text-h4.text-compact*/.text-h4.text-compact.sc-sdx-price{line-height:27px}/*!@.h5,\n.h6,\n.text-h5,\n.text-h6,\nh5,\nh6*/.h5.sc-sdx-price,.h6.sc-sdx-price,.text-h5.sc-sdx-price,.text-h6.sc-sdx-price,h5.sc-sdx-price,h6.sc-sdx-price{margin-bottom:8px}/*!@.h5,\n.text-h5,\nh5*/.h5.sc-sdx-price,.text-h5.sc-sdx-price,h5.sc-sdx-price{line-height:24px;letter-spacing:-0.1px;font-size:18px;font-weight:600}/*!@.h6,\n.text-h6,\nh6*/.h6.sc-sdx-price,.text-h6.sc-sdx-price,h6.sc-sdx-price{line-height:24px;letter-spacing:-0.1px;font-size:16px;font-weight:600}/*!@.paragraph,\np*/.paragraph.sc-sdx-price,p.sc-sdx-price{line-height:24px;letter-spacing:-0.1px;font-size:18px;margin-bottom:32px}/*!@.paragraph:last-child,\np:last-child*/.paragraph.sc-sdx-price:last-child,p.sc-sdx-price:last-child{margin-bottom:0}/*!@.hero,\n.text-hero,\n.d1,\n.text-d1,\n.d2,\n.text-d2,\n.d3,\n.text-d3*/.hero.sc-sdx-price,.text-hero.sc-sdx-price,.d1.sc-sdx-price,.text-d1.sc-sdx-price,.d2.sc-sdx-price,.text-d2.sc-sdx-price,.d3.sc-sdx-price,.text-d3.sc-sdx-price{font-weight:700}/*!@.hero,\n.text-hero*/.hero.sc-sdx-price,.text-hero.sc-sdx-price{line-height:80px;letter-spacing:-1.75px;font-size:70px}@media (min-width: 1024px){/*!@.hero,\n  .text-hero*/.hero.sc-sdx-price,.text-hero.sc-sdx-price{line-height:104px;letter-spacing:-2px;font-size:96px}}/*!@.d1,\n.text-d1*/.d1.sc-sdx-price,.text-d1.sc-sdx-price{line-height:64px;letter-spacing:-1.35px;font-size:54px}@media (min-width: 1024px){/*!@.d1,\n  .text-d1*/.d1.sc-sdx-price,.text-d1.sc-sdx-price{line-height:80px;letter-spacing:-1.75px;font-size:70px}}/*!@.d2,\n.text-d2*/.d2.sc-sdx-price,.text-d2.sc-sdx-price{line-height:56px;letter-spacing:-1.2px;font-size:48px}@media (min-width: 1024px){/*!@.d2,\n  .text-d2*/.d2.sc-sdx-price,.text-d2.sc-sdx-price{line-height:64px;letter-spacing:-1.35px;font-size:54px}}/*!@.d3,\n.text-d3*/.d3.sc-sdx-price,.text-d3.sc-sdx-price{line-height:48px;letter-spacing:-1.2px;font-size:40px}@media (min-width: 1024px){/*!@.d3,\n  .text-d3*/.d3.sc-sdx-price,.text-d3.sc-sdx-price{line-height:56px;letter-spacing:-1.2px;font-size:48px}}/*!@.text-b1*/.text-b1.sc-sdx-price{line-height:24px;letter-spacing:-0.1px;font-size:18px;font-weight:400}/*!@.text-b2*/.text-b2.sc-sdx-price{line-height:21px;letter-spacing:0;font-size:16px;font-weight:400}/*!@.text-sm,\n.text-smaller*/.text-sm.sc-sdx-price,.text-smaller.sc-sdx-price{line-height:18px;letter-spacing:0.1px;font-size:14px;font-weight:400}/*!@.text-compact*/.text-compact.sc-sdx-price{line-height:21px}/*!@.figcaption*/.figcaption.sc-sdx-price{line-height:18px;letter-spacing:0.1px;font-size:14px}/*!@.code*/.code.sc-sdx-price{font-family:monospace;background-color:#f8fafb;border-radius:4px;border:1px solid #d6d6d6;color:#474747;font-size:16px;padding:0 6px}/*!@address*/address.sc-sdx-price{font-style:normal}/*!@strong*/strong.sc-sdx-price{font-weight:600}/*!@em*/em.sc-sdx-price{font-style:italic}/*!@.sdx--dark-theme .code*/.sdx--dark-theme.sc-sdx-price .code.sc-sdx-price{background-color:#242424;color:#d6d6d6}/*!@.font*/.font.sc-sdx-price{font-family:TheSans, sans-serif}/*!@.font--sans*/.font--sans.sc-sdx-price{font-family:TheSans, sans-serif}/*!@.font--serif*/.font--serif.sc-sdx-price{font-family:TheSerif, serif}/*!@.font--light*/.font--light.sc-sdx-price{font-weight:300}/*!@.font--semi-light*/.font--semi-light.sc-sdx-price{font-weight:400}/*!@.font--semi-bold*/.font--semi-bold.sc-sdx-price{font-weight:600}/*!@.sdx--dark-theme .h1,\n.sdx--dark-theme .h2,\n.sdx--dark-theme .h3,\n.sdx--dark-theme .h4,\n.sdx--dark-theme .h5,\n.sdx--dark-theme .h6,\n.sdx--dark-theme .hero,\n.sdx--dark-theme .d1,\n.sdx--dark-theme .d2,\n.sdx--dark-theme .d3*/.sdx--dark-theme.sc-sdx-price .h1.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .h2.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .h3.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .h4.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .h5.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .h6.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .hero.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .d1.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .d2.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .d3.sc-sdx-price{color:unset}/*!@.sdx--dark-theme .h1,\n.sdx--dark-theme .text-h1,\n.sdx--dark-theme h1,\n.sdx--dark-theme .h2,\n.sdx--dark-theme .text-h2,\n.sdx--dark-theme h2,\n.sdx--dark-theme .h3,\n.sdx--dark-theme .text-h3,\n.sdx--dark-theme h3,\n.sdx--dark-theme .h4,\n.sdx--dark-theme .text-h4,\n.sdx--dark-theme h4,\n.sdx--dark-theme .d1,\n.sdx--dark-theme .text-d1,\n.sdx--dark-theme .d2,\n.sdx--dark-theme .text-d2,\n.sdx--dark-theme .d3,\n.sdx--dark-theme .text-d3*/.sdx--dark-theme.sc-sdx-price .h1.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .text-h1.sc-sdx-price,.sdx--dark-theme.sc-sdx-price h1.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .h2.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .text-h2.sc-sdx-price,.sdx--dark-theme.sc-sdx-price h2.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .h3.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .text-h3.sc-sdx-price,.sdx--dark-theme.sc-sdx-price h3.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .h4.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .text-h4.sc-sdx-price,.sdx--dark-theme.sc-sdx-price h4.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .d1.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .text-d1.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .d2.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .text-d2.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .d3.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .text-d3.sc-sdx-price{font-weight:600}/*!@.sdx--dark-theme .p,\n.sdx--dark-theme .paragraph,\n.sdx--dark-theme p*/.sdx--dark-theme.sc-sdx-price .p.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .paragraph.sc-sdx-price,.sdx--dark-theme.sc-sdx-price p.sc-sdx-price{font-weight:500}/*!@.sdx--dark-theme .h1,\n.sdx--dark-theme .text-h1,\n.sdx--dark-theme h1*/.sdx--dark-theme.sc-sdx-price .h1.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .text-h1.sc-sdx-price,.sdx--dark-theme.sc-sdx-price h1.sc-sdx-price{letter-spacing:-0.8px}/*!@.sdx--dark-theme .h2,\n.sdx--dark-theme .text-h2,\n.sdx--dark-theme h2*/.sdx--dark-theme.sc-sdx-price .h2.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .text-h2.sc-sdx-price,.sdx--dark-theme.sc-sdx-price h2.sc-sdx-price{letter-spacing:-0.6px}/*!@.sdx--dark-theme .h3,\n.sdx--dark-theme .text-h3,\n.sdx--dark-theme h3*/.sdx--dark-theme.sc-sdx-price .h3.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .text-h3.sc-sdx-price,.sdx--dark-theme.sc-sdx-price h3.sc-sdx-price{letter-spacing:-0.5px}/*!@.sdx--dark-theme .h4,\n.sdx--dark-theme .text-h4,\n.sdx--dark-theme h4*/.sdx--dark-theme.sc-sdx-price .h4.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .text-h4.sc-sdx-price,.sdx--dark-theme.sc-sdx-price h4.sc-sdx-price{letter-spacing:-0.2px}/*!@.sdx--dark-theme .h5,\n.sdx--dark-theme .text-h5,\n.sdx--dark-theme h5*/.sdx--dark-theme.sc-sdx-price .h5.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .text-h5.sc-sdx-price,.sdx--dark-theme.sc-sdx-price h5.sc-sdx-price{letter-spacing:-0.1px}/*!@.sdx--dark-theme .h6,\n.sdx--dark-theme .text-h6,\n.sdx--dark-theme h6*/.sdx--dark-theme.sc-sdx-price .h6.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .text-h6.sc-sdx-price,.sdx--dark-theme.sc-sdx-price h6.sc-sdx-price{letter-spacing:0px}/*!@.sdx--dark-theme .d1,\n.sdx--dark-theme .text-d1*/.sdx--dark-theme.sc-sdx-price .d1.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .text-d1.sc-sdx-price{letter-spacing:-1.4px}/*!@.sdx--dark-theme .d2,\n.sdx--dark-theme .text-d2*/.sdx--dark-theme.sc-sdx-price .d2.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .text-d2.sc-sdx-price{letter-spacing:-1px}/*!@.sdx--dark-theme .d3,\n.sdx--dark-theme .text-d3*/.sdx--dark-theme.sc-sdx-price .d3.sc-sdx-price,.sdx--dark-theme.sc-sdx-price .text-d3.sc-sdx-price{letter-spacing:-0.9px}/*!@.sdx--dark-theme strong,\n.sdx--dark-theme b*/.sdx--dark-theme.sc-sdx-price strong.sc-sdx-price,.sdx--dark-theme.sc-sdx-price b.sc-sdx-price{color:#fff}/*!@.sdx--dark-theme code*/.sdx--dark-theme.sc-sdx-price code.sc-sdx-price{background-color:#242424;border:1px solid #b1b9be;border-radius:4px;color:#cfd5d9;font-size:16px}/*!@.sr-only*/.sr-only.sc-sdx-price{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);border:0}/*!@.sr-only-focusable:active, .sr-only-focusable:focus*/.sr-only-focusable.sc-sdx-price:active,.sr-only-focusable.sc-sdx-price:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}/*!@.period*/.period.sc-sdx-price{font-size:50%;letter-spacing:0}/*!@:not(.integer) > .period*/.sc-sdx-price:not(.integer)>.period.sc-sdx-price{line-height:1}/*!@.integer .period*/.integer.sc-sdx-price .period.sc-sdx-price{font-size:26%;position:absolute;margin-left:-2em;margin-top:-0.8em}/*!@.integer.text-d1 .period, .integer.text-d2 .period, .integer.text-d3 .period*/.integer.text-d1.sc-sdx-price .period.sc-sdx-price,.integer.text-d2.sc-sdx-price .period.sc-sdx-price,.integer.text-d3.sc-sdx-price .period.sc-sdx-price{margin-top:0.55em}/*!@.text-d1,\n.text-d2,\n.text-d3*/.text-d1.sc-sdx-price,.text-d2.sc-sdx-price,.text-d3.sc-sdx-price{line-height:1}";

class Price {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.amount = 0;
    this.period = "";
    this.size = 2;
    this.srHint = "";
  }
  /**
   * Formats a price like 5.–, 5.50, –.50, or 0.–
   */
  getFormattedAmount() {
    return String(Math.round(this.amount * 100)) // 10.1 -> 1010
      .replace(/^0$/, "000") // 0 -> 000
      .replace(/^(.)$/, "0$1") // 5 -> 05
      .replace(/(..)$/, ".$1") // 1010 -> 10.10
      .replace(/00$|^(?=[.])/, "–"); // 10.00 -> 10.– and .10 -> –.10
  }
  isInteger() {
    return this.amount === Math.floor(this.amount);
  }
  getClassNames() {
    return {
      integer: this.isInteger(),
      [`text-${this.size > 6 ? "d" : "h"}${(this.size > 6 ? 9 : 6) - this.size + 1}`]: true,
      [getAppearance(this.el)]: true,
    };
  }
  render() {
    return [
      hAsync("span", { class: this.getClassNames(), "aria-hidden": "true" }, this.getFormattedAmount(), hAsync("span", { class: "period" }, this.period)),
      hAsync("span", { class: "sr-only" }, this.srHint),
    ];
  }
  get el() { return getElement(this); }
  static get style() { return priceCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-price",
    "$members$": {
      "amount": [2],
      "period": [1],
      "size": [2],
      "srHint": [1, "sr-hint"]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const progressFullReducer = (state = {}, action) => {
  switch (action.type) {
    case "ADD_STEP_EL":
      return {
        ...state,
        stepEls: add(state.stepEls, action.stepEl).sort(sortByAppearanceInDomTree),
      };
    case "REMOVE_STEP_EL":
      return {
        ...state,
        stepEls: remove(state.stepEls, action.stepEl).sort(sortByAppearanceInDomTree),
      };
    case "SET_VALUE":
      const { value } = action;
      let newValue = value;
      if (isNaN(value) || value < 1) {
        newValue = 1;
      }
      else if (value > state.stepEls.length) {
        newValue = state.stepEls.length;
      }
      return { ...state, value: newValue };
    default:
      return state;
  }
};
function getInitialState$2() {
  return {
    stepEls: [],
    value: 1,
    minVisibleSteps: 0,
    maxVisibleSteps: 0,
    userInteractionInProgress: false,
  };
}

const progressFullCss = "/*!@:root*/.sc-sdx-progress-full:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-progress-full-h,*.sc-sdx-progress-full,*.sc-sdx-progress-full:before,*.sc-sdx-progress-full:after{box-sizing:border-box}/*!@:host*/.sc-sdx-progress-full-h{display:block}/*!@:host(.hide-steps-label) .info-content*/.hide-steps-label.sc-sdx-progress-full-h .info-content.sc-sdx-progress-full{display:none}/*!@:host(.hide-steps-label) sdx-arrow*/.hide-steps-label.sc-sdx-progress-full-h sdx-arrow.sc-sdx-progress-full{top:-5px}/*!@:host(.hide-arrows) sdx-arrow*/.hide-arrows.sc-sdx-progress-full-h sdx-arrow.sc-sdx-progress-full{display:none}/*!@.component*/.component.sc-sdx-progress-full{-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;position:relative;padding:24px 0;text-align:center;min-width:240px;outline:none;font-size:0;overflow:hidden;white-space:nowrap}/*!@.component .info-content*/.component.sc-sdx-progress-full .info-content.sc-sdx-progress-full{font-weight:400;padding-bottom:14px;line-height:24px;letter-spacing:0.1px;font-size:10px}/*!@.component sdx-arrow*/.component.sc-sdx-progress-full sdx-arrow.sc-sdx-progress-full{position:absolute;bottom:3px;width:40px}/*!@.component sdx-arrow.left*/.component.sc-sdx-progress-full sdx-arrow.left.sc-sdx-progress-full{left:0}/*!@.component sdx-arrow.right*/.component.sc-sdx-progress-full sdx-arrow.right.sc-sdx-progress-full{right:0}";

class ProgressFull {
  stateChanged({}, prev) {
    const state = this.state.get();
    const prevState = prev.get();
    if (state.value !== prevState.value) {
      this.value = state.value;
    }
  }
  valueChanged({}, prev) {
    this.store.dispatch({ type: "SET_VALUE", value: this.value });
    this.updateView();
    if (this.state.get().userInteractionInProgress) {
      dispatchEvent(this.el, ProgressFull.eventInput);
    }
    this.invokeStepChangeCallback(this.value, prev);
  }
  stepChanged() {
    this.store.dispatch({ type: "SET_VALUE", value: this.step });
  }
  stepChangeCallbackChanged() {
    this.setInvokeStepChangeCallback();
  }
  /**
   * Draws the layout. Useful to redraw the component when initially
   * rendered on a hidden parent (e.g. a tabs item).
   */
  async layout() {
    this.updateView();
  }
  /**
   * Listen to window resize, so steps can be redrawn based on the width.
   */
  onWindowResizeDebounced() {
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer);
    }
    this.resizeTimer = setTimeout(() => {
      this.layout();
    }, 10);
  }
  /**
   * Move to the next step (if possible).
   */
  async nextStep() {
    if (this.value < this.state.get().stepEls.length) {
      this.store.dispatch({
        type: "SET_VALUE",
        value: this.value + 1,
      });
    }
  }
  /**
   * Move to the previous step (if possible).
   */
  async previousStep() {
    if (this.value > 1) {
      this.store.dispatch({
        type: "SET_VALUE",
        value: this.value - 1,
      });
    }
  }
  /**
   * Get the current active step.
   * @deprecated Use `value` property instead.
   */
  async getActiveStep() {
    return this.value;
  }
  /**
   * Jump to step.
   * @param index Index of the new active step.
   * @deprecated Use `value` property instead.
   */
  async setActiveStep(index) {
    this.store.dispatch({ type: "SET_VALUE", value: index });
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.allowedVisibleSteps = 1;
    this.minAllowedVisibleSteps = 3;
    this.invokeStepChangeCallback = () => null;
    this.componentDidLoadComplete = false;
    this.state = undefined;
    this.step = 1;
    this.stepsLabel = "steps";
    this.stepChangeCallback = undefined;
    this.animated = true;
    this.value = 1;
    this.store = new StoreConnection(this, progressFullReducer, getInitialState$2(), ["stepEls", "value", "minVisibleSteps", "maxVisibleSteps"]);
    this.setInvokeStepChangeCallback();
    this.store.flush();
  }
  async componentWillLoad() {
    // Wait for children because they're needed to verify this.value in length
    await waitFor(() => this.state.get().stepEls.length > 0);
    this.store.dispatch({ type: "SET_VALUE", value: this.value });
  }
  componentDidLoad() {
    this.updateView();
    this.store.subscribe();
    this.componentDidLoadComplete = true;
  }
  /**
   * Scroll the visible steps one step to the left.
   * This does not change the active step.
   */
  scrollLeft() {
    if (!this.shouldDisplayLeftArrow()) {
      return;
    }
    this.shiftVisibleStepLeft();
    this.updateStepElements();
  }
  /**
   * Scroll the visible steps one step to the right.
   * This does not change the active step.
   */
  scrollRight() {
    if (!this.shouldDisplayRightArrow()) {
      return;
    }
    this.shiftVisibleStepRight();
    this.updateStepElements();
  }
  /**
   * Calculates steps that should be displayed,
   * based on the width of the parent element.
   */
  calculateVisibleSteps() {
    const { stepEls, minVisibleSteps, maxVisibleSteps } = this.state.get();
    let currentMinVisibleSteps = minVisibleSteps;
    let currentMaxVisibleSteps = maxVisibleSteps;
    this.allowedVisibleSteps = Math.floor(this.el.offsetWidth / 100);
    // Calculate how many steps should be displayed
    if (stepEls.length <= this.minAllowedVisibleSteps) {
      this.allowedVisibleSteps = stepEls.length;
    }
    else if (this.allowedVisibleSteps < this.minAllowedVisibleSteps) {
      this.allowedVisibleSteps = this.minAllowedVisibleSteps;
    }
    else if (stepEls.length < this.allowedVisibleSteps) {
      this.allowedVisibleSteps = stepEls.length;
    }
    // Set min and max step to be visible
    if (this.value < this.allowedVisibleSteps) {
      currentMinVisibleSteps = 1;
      currentMaxVisibleSteps = this.allowedVisibleSteps;
    }
    else if (this.value < stepEls.length - 1) {
      currentMinVisibleSteps = this.value - this.allowedVisibleSteps + 2;
      currentMaxVisibleSteps = this.value + 1;
    }
    else {
      currentMinVisibleSteps = stepEls.length - this.allowedVisibleSteps + 1;
      currentMaxVisibleSteps = stepEls.length;
    }
    this.store.set("minVisibleSteps", currentMinVisibleSteps);
    this.store.set("maxVisibleSteps", currentMaxVisibleSteps);
  }
  shiftVisibleStepLeft() {
    const { minVisibleSteps, maxVisibleSteps } = this.state.get();
    if (minVisibleSteps > 1) {
      this.store.set("minVisibleSteps", minVisibleSteps - 1);
      this.store.set("maxVisibleSteps", maxVisibleSteps - 1);
    }
  }
  shiftVisibleStepRight() {
    const { stepEls, minVisibleSteps, maxVisibleSteps } = this.state.get();
    if (maxVisibleSteps < stepEls.length) {
      this.store.set("minVisibleSteps", minVisibleSteps + 1);
      this.store.set("maxVisibleSteps", maxVisibleSteps + 1);
    }
  }
  /**
   * Updates attributes and classes of the step element,
   * which controls what step will be displayed / hidden.
   * @param animation Animate the state change transition.
   */
  updateStepElements() {
    const { stepEls } = this.state.get();
    this.updateInfoElement();
    this.updateArrows();
    for (let i = 0; i < stepEls.length; i++) {
      this.updateStepEl(i);
    }
  }
  updateArrows() {
    const { stepEls } = this.state.get();
    if (!this.sdxArrowLeftEl || !this.sdxArrowRightEl) {
      return;
    }
    if (this.shouldDisplayLeftArrow()) {
      this.sdxArrowLeftEl.hidden = false;
      this.sdxArrowLeftEl.arrowHidden = false;
    }
    else {
      this.sdxArrowLeftEl.hidden = true;
      this.sdxArrowLeftEl.arrowHidden = true;
    }
    if (this.shouldDisplayRightArrow()) {
      this.sdxArrowRightEl.arrowHidden = false;
    }
    else {
      this.sdxArrowRightEl.arrowHidden = true;
    }
    if (this.isRightOutOfSight(stepEls.length)) {
      this.sdxArrowRightEl.hidden = false;
    }
    else {
      this.sdxArrowRightEl.hidden = true;
    }
    if (this.shouldDisplayArrows()) {
      this.el.classList.remove("hide-arrows");
    }
    else {
      this.el.classList.add("hide-arrows");
    }
  }
  shouldDisplayArrows() {
    const { stepEls } = this.state.get();
    return this.allowedVisibleSteps !== stepEls.length;
  }
  shouldDisplayRightArrow() {
    const { stepEls, maxVisibleSteps } = this.state.get();
    return maxVisibleSteps < stepEls.length && this.value >= maxVisibleSteps;
  }
  shouldDisplayLeftArrow() {
    return this.state.get().minVisibleSteps > 1;
  }
  updateStepEl(stepElIndex) {
    const { stepEls } = this.state.get();
    const step = stepElIndex + 1;
    anime.remove(stepEls[stepElIndex]);
    if (this.isLeftOutOfSight(step) || this.isRightOutOfSight(step)) {
      this.handleOutofSightStepEl(stepElIndex, step);
    }
    else {
      this.handleInSightStepEl(stepElIndex);
    }
  }
  handleInSightStepEl(elIndex) {
    const { stepEls } = this.state.get();
    const stepEl = stepEls[elIndex];
    stepEl.style.display = "inline-block";
    stepEl.style.width = this.getCorrectWidth();
    if (this.shouldAnimateStepElFadeIn(elIndex)) {
      this.fadeInStepEl(elIndex);
    }
    else {
      this.showStepEl(elIndex);
    }
  }
  handleOutofSightStepEl(elIndex, stepIndex) {
    const marginOutOfSight = `-${this.getCorrectWidth()}`;
    if (this.shouldAnimateStepElFadeOut(elIndex)) {
      this.fadeOutStepEl(elIndex, stepIndex, marginOutOfSight);
    }
    else {
      this.hideStepEl(elIndex, stepIndex, marginOutOfSight);
    }
  }
  showStepEl(elIndex) {
    const { stepEls } = this.state.get();
    const stepEl = stepEls[elIndex];
    stepEl.style.removeProperty("margin-left");
    stepEl.style.removeProperty("margin-right");
    stepEl.style.removeProperty("opacity");
    stepEl.classList.add("open");
    stepEl.classList.remove("hide-content");
  }
  fadeInStepEl(elIndex) {
    const { stepEls } = this.state.get();
    const stepEl = stepEls[elIndex];
    anime({
      targets: stepEl,
      duration: 400,
      marginLeft: "0",
      marginRight: "0",
      opacity: 1,
      easing: "easeOutQuad",
      complete: () => {
        stepEl.classList.add("open");
        stepEl.classList.remove("hide-content");
      },
    });
  }
  hideStepEl(elIndex, stepIndex, marginOutOfSight) {
    const { stepEls } = this.state.get();
    const stepEl = stepEls[elIndex];
    stepEl.style.display = "none";
    stepEl.style.marginLeft = this.isLeftOutOfSight(stepIndex)
      ? marginOutOfSight
      : "0";
    stepEl.style.marginRight = this.isRightOutOfSight(stepIndex)
      ? marginOutOfSight
      : "0";
    stepEl.classList.add("hide-content");
    stepEl.classList.remove("open");
  }
  fadeOutStepEl(elIndex, stepIndex, marginOutOfSight) {
    const { stepEls } = this.state.get();
    const stepEl = stepEls[elIndex];
    anime({
      targets: stepEl,
      duration: 400,
      marginLeft: this.isLeftOutOfSight(stepIndex) ? marginOutOfSight : "0",
      marginRight: this.isRightOutOfSight(stepIndex) ? marginOutOfSight : "0",
      opacity: 0,
      easing: "easeOutQuad",
      complete: () => {
        stepEl.style.display = "none";
        stepEl.classList.add("hide-content");
        stepEl.classList.remove("open");
      },
    });
  }
  shouldAnimateStepElFadeIn(elIndex) {
    const { stepEls } = this.state.get();
    return this.animated && stepEls[elIndex].classList.contains("hide-content");
  }
  shouldAnimateStepElFadeOut(elIndex) {
    const { stepEls } = this.state.get();
    return this.animated && stepEls[elIndex].classList.contains("open");
  }
  isRightOutOfSight(index) {
    return index > this.state.get().maxVisibleSteps;
  }
  isLeftOutOfSight(index) {
    return index < this.state.get().minVisibleSteps;
  }
  /**
   * Updates steps label to be visible.
   */
  updateInfoElement() {
    const { stepEls } = this.state.get();
    if (this.allowedVisibleSteps !== stepEls.length && this.stepsLabel) {
      this.el.classList.remove("hide-steps-label");
    }
    else {
      this.el.classList.add("hide-steps-label");
    }
  }
  /**
   * Retrieves width of every step based on the parent element width.
   */
  getCorrectWidth() {
    return `${this.el.clientWidth / this.allowedVisibleSteps}px`;
  }
  setInvokeStepChangeCallback() {
    this.invokeStepChangeCallback = parseFunction(this.stepChangeCallback);
  }
  updateView() {
    this.calculateVisibleSteps();
    this.updateStepElements();
  }
  render() {
    const { stepEls } = this.state.get();
    return (hAsync("div", { class: "component" }, hAsync("div", { class: "info-content" }, stepEls.length, " ", this.stepsLabel), hAsync("slot", null), hAsync("sdx-arrow", { class: "left", direction: "left", onClick: () => this.scrollLeft(), arrowHidden: true, animationDuration: !this.componentDidLoadComplete || !this.animated ? 0 : 200, ref: (el) => (this.sdxArrowLeftEl = el) }), hAsync("sdx-arrow", { class: "right", direction: "right", onClick: () => this.scrollRight(), arrowHidden: true, animationDuration: !this.componentDidLoadComplete || !this.animated ? 0 : 200, ref: (el) => (this.sdxArrowRightEl = el) })));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "state": ["stateChanged"],
    "value": ["valueChanged"],
    "step": ["stepChanged"],
    "stepsLabel": ["stepChanged"],
    "stepChangeCallback": ["stepChangeCallbackChanged"]
  }; }
  static get style() { return progressFullCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-progress-full",
    "$members$": {
      "step": [2],
      "stepsLabel": [1, "steps-label"],
      "stepChangeCallback": [1, "step-change-callback"],
      "animated": [4],
      "value": [1026],
      "state": [32],
      "layout": [64],
      "nextStep": [64],
      "previousStep": [64],
      "getActiveStep": [64],
      "setActiveStep": [64]
    },
    "$listeners$": [[9, "resize", "onWindowResizeDebounced"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}
/**
 * Emitted when a user clicks on the button or description of a completed step.
 * @event
 */
ProgressFull.eventInput = "input";

const progressFullStepCss = "/*!@:root*/.sc-sdx-progress-full-step:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-progress-full-step-h,*.sc-sdx-progress-full-step,*.sc-sdx-progress-full-step:before,*.sc-sdx-progress-full-step:after{box-sizing:border-box}/*!@:host*/.sc-sdx-progress-full-step-h{display:inline-block;overflow:hidden;vertical-align:top}/*!@.component*/.component.sc-sdx-progress-full-step{position:relative}/*!@.component.active .progress-line-left, .component.completed .progress-line-left*/.component.active.sc-sdx-progress-full-step .progress-line-left.sc-sdx-progress-full-step,.component.completed.sc-sdx-progress-full-step .progress-line-left.sc-sdx-progress-full-step{background:#1b8712}/*!@.component.active button*/.component.active.sc-sdx-progress-full-step button.sc-sdx-progress-full-step{color:#fff;border-color:#086adb;background-color:#086adb}/*!@.component.active button:hover*/.component.active.sc-sdx-progress-full-step button.sc-sdx-progress-full-step:hover{border-color:#0048cf;background-color:#0048cf}/*!@.component.completed button,\n.component.completed .progress-content*/.component.completed.sc-sdx-progress-full-step button.sc-sdx-progress-full-step,.component.completed.sc-sdx-progress-full-step .progress-content.sc-sdx-progress-full-step{cursor:pointer}/*!@.component.completed button*/.component.completed.sc-sdx-progress-full-step button.sc-sdx-progress-full-step{color:#fff;border-color:#1b8712;background-color:#1b8712}/*!@.component.completed button:hover*/.component.completed.sc-sdx-progress-full-step button.sc-sdx-progress-full-step:hover{border-color:#0d6f2c;background-color:#0d6f2c}/*!@.component.completed .progress-line-right*/.component.completed.sc-sdx-progress-full-step .progress-line-right.sc-sdx-progress-full-step{background:#1b8712}/*!@.component.first .progress-line-right, .component.middle-left .progress-line-right, .component.middle .progress-line-right, .component.middle-right .progress-line-right*/.component.first.sc-sdx-progress-full-step .progress-line-right.sc-sdx-progress-full-step,.component.middle-left.sc-sdx-progress-full-step .progress-line-right.sc-sdx-progress-full-step,.component.middle.sc-sdx-progress-full-step .progress-line-right.sc-sdx-progress-full-step,.component.middle-right.sc-sdx-progress-full-step .progress-line-right.sc-sdx-progress-full-step{transition:all 200ms ease;width:35%;height:1px;position:absolute;top:12px;right:0}/*!@.component.last .progress-line-left, .component.middle-left .progress-line-left, .component.middle .progress-line-left, .component.middle-right .progress-line-left*/.component.last.sc-sdx-progress-full-step .progress-line-left.sc-sdx-progress-full-step,.component.middle-left.sc-sdx-progress-full-step .progress-line-left.sc-sdx-progress-full-step,.component.middle.sc-sdx-progress-full-step .progress-line-left.sc-sdx-progress-full-step,.component.middle-right.sc-sdx-progress-full-step .progress-line-left.sc-sdx-progress-full-step{transition:all 200ms ease;width:35%;height:1px;position:absolute;top:12px;left:0}/*!@.component.first .progress-line-left*/.component.first.sc-sdx-progress-full-step .progress-line-left.sc-sdx-progress-full-step{background:none}/*!@.component.last .progress-line-right*/.component.last.sc-sdx-progress-full-step .progress-line-right.sc-sdx-progress-full-step{background:none}/*!@.component button*/.component.sc-sdx-progress-full-step button.sc-sdx-progress-full-step{border:1px solid #086adb;color:#086adb;border-radius:100%;width:24px;height:24px;outline:none;background-color:transparent;align-items:center;justify-content:center;line-height:normal;font-family:inherit}/*!@.component button,\n.component .progress-content*/.component.sc-sdx-progress-full-step button.sc-sdx-progress-full-step,.component.sc-sdx-progress-full-step .progress-content.sc-sdx-progress-full-step{cursor:default;letter-spacing:normal;text-align:center;transition:all 150ms ease-in-out}/*!@.component .progress-content*/.component.sc-sdx-progress-full-step .progress-content.sc-sdx-progress-full-step{font-weight:400;line-height:21px;letter-spacing:0;font-size:16px;word-wrap:break-word;white-space:normal;margin:8px 0}/*!@.component .button-container button*/.component.sc-sdx-progress-full-step .button-container.sc-sdx-progress-full-step button.sc-sdx-progress-full-step{font-weight:600;display:inline-flex;font-size:14px;align-items:center;justify-content:center;padding:0}/*!@.component .progress-line-left,\n.component .progress-line-right*/.component.sc-sdx-progress-full-step .progress-line-left.sc-sdx-progress-full-step,.component.sc-sdx-progress-full-step .progress-line-right.sc-sdx-progress-full-step{background:#adadad}/*!@.component.sdx--dark-theme.active .progress-line-left, .component.sdx--dark-theme.completed .progress-line-left*/.component.sdx--dark-theme.active.sc-sdx-progress-full-step .progress-line-left.sc-sdx-progress-full-step,.component.sdx--dark-theme.completed.sc-sdx-progress-full-step .progress-line-left.sc-sdx-progress-full-step{background:#1c8912}/*!@.component.sdx--dark-theme.active button*/.component.sdx--dark-theme.active.sc-sdx-progress-full-step button.sc-sdx-progress-full-step{color:#fff;border-color:#0a71e9;background-color:#0a71e9}/*!@.component.sdx--dark-theme.active button:hover*/.component.sdx--dark-theme.active.sc-sdx-progress-full-step button.sc-sdx-progress-full-step:hover{border-color:#147df5;background-color:#147df5}/*!@.component.sdx--dark-theme.completed button*/.component.sdx--dark-theme.completed.sc-sdx-progress-full-step button.sc-sdx-progress-full-step{color:#fff;border-color:#1c8912;background-color:#1c8912}/*!@.component.sdx--dark-theme.completed button:hover*/.component.sdx--dark-theme.completed.sc-sdx-progress-full-step button.sc-sdx-progress-full-step:hover{border-color:#1f9414;background-color:#1f9414}/*!@.component.sdx--dark-theme.completed .progress-line-right*/.component.sdx--dark-theme.completed.sc-sdx-progress-full-step .progress-line-right.sc-sdx-progress-full-step{background:#1c8912}/*!@.component.sdx--dark-theme button*/.component.sdx--dark-theme.sc-sdx-progress-full-step button.sc-sdx-progress-full-step{border-color:#0a71e9;color:#0a71e9}/*!@.component.sdx--dark-theme .progress-line-left,\n.component.sdx--dark-theme .progress-line-right*/.component.sdx--dark-theme.sc-sdx-progress-full-step .progress-line-left.sc-sdx-progress-full-step,.component.sdx--dark-theme.sc-sdx-progress-full-step .progress-line-right.sc-sdx-progress-full-step{background:#707070}";

class ProgressFullStep {
  stepClickCallbackChanged() {
    this.setInvokeStepClickCallback();
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.invokeStepClickCallback = () => null;
    this.state = undefined;
    this.stepClickCallback = undefined;
    this.store = new StoreConnection(this, progressFullReducer, getInitialState$2(), ["stepEls", "value", "minVisibleSteps", "maxVisibleSteps"]);
    this.setInvokeStepClickCallback();
  }
  connectedCallback() {
    // Register self
    this.store.dispatch({ type: "ADD_STEP_EL", stepEl: this.el });
  }
  disconnectedCallback() {
    // Unregister self
    this.store.dispatch({ type: "REMOVE_STEP_EL", stepEl: this.el });
  }
  componentDidLoad() {
    this.store.subscribe();
  }
  setInvokeStepClickCallback() {
    this.invokeStepClickCallback = parseFunction(this.stepClickCallback);
  }
  // Returns 1, 2, 3, etc...
  getStep() {
    const { stepEls } = this.state.get();
    return stepEls.indexOf(this.el) + 1;
  }
  /**
   * Based on the position and ammount of visible steps a css class name is recalculuated for the step.
   * @param index Position of the step.
   */
  getPosition() {
    const { stepEls, minVisibleSteps, maxVisibleSteps } = this.state.get();
    const step = this.getStep();
    if (step === 1) {
      return "first";
    }
    else if (step === stepEls.length) {
      return "last";
    }
    else if (step === minVisibleSteps) {
      return "middle-left";
    }
    else if (step === maxVisibleSteps) {
      return "middle-right";
    }
    else if (step > 1 && step < stepEls.length) {
      return "middle";
    }
    return "none";
  }
  getStatus() {
    const { value } = this.state.get();
    if (this.getStep() > value) {
      return "none";
    }
    else if (this.getStep() === value) {
      return "active";
    }
    return "completed";
  }
  onClick() {
    if (this.getStatus() === "completed") {
      this.store.set("userInteractionInProgress", true);
      this.store.dispatch({
        type: "SET_VALUE",
        value: this.getStep(),
      });
      this.store.set("userInteractionInProgress", false);
      this.invokeStepClickCallback();
    }
  }
  getComponentClassNames() {
    return {
      component: true,
      [getAppearance(this.el)]: true,
      [this.getStatus()]: true,
      [this.getPosition()]: true,
    };
  }
  render() {
    return (hAsync("div", { class: this.getComponentClassNames() }, hAsync("div", { class: "progress-line-right" }), hAsync("div", { class: "progress-line-left" }), hAsync("div", { class: "button-container" }, hAsync("button", { type: "button", onClick: () => this.onClick() }, this.getStep())), hAsync("div", { onClick: () => this.onClick(), class: "progress-content" }, hAsync("slot", null))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "stepClickCallback": ["stepClickCallbackChanged"]
  }; }
  static get style() { return progressFullStepCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-progress-full-step",
    "$members$": {
      "stepClickCallback": [1, "step-click-callback"],
      "state": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const ribbonCss = "/*!@:root*/.sc-sdx-ribbon:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-ribbon-h,*.sc-sdx-ribbon,*.sc-sdx-ribbon:before,*.sc-sdx-ribbon:after{box-sizing:border-box}/*!@:host*/.sc-sdx-ribbon-h{display:block;position:relative}/*!@.component*/.component.sc-sdx-ribbon{display:flex;justify-content:center;height:100%}/*!@.component > .slot*/.component.sc-sdx-ribbon>.slot.sc-sdx-ribbon{width:100%}/*!@.sales > .ribbon-container,\n.hint > .ribbon-container,\n.topic-dark > .ribbon-container,\n.topic-light > .ribbon-container*/.sales.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon,.hint.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon,.topic-dark.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon,.topic-light.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{position:absolute;font-weight:500;line-height:21px;letter-spacing:0;font-size:16px;line-height:24px;top:calc(24px / 100 * -1 * 55);z-index:1;padding:0 24px;border-radius:5px;color:#fff}/*!@.sales > .ribbon-container*/.sales.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{background-color:#a63297}/*!@.hint > .ribbon-container*/.hint.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{background-color:#0c847e}/*!@.topic-dark > .ribbon-container*/.topic-dark.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{background-color:#015}/*!@.topic-light > .ribbon-container*/.topic-light.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{color:#015;border:1px solid #015;background-color:#fff}/*!@.sales.sdx--dark-theme > .ribbon-container*/.sales.sdx--dark-theme.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{background-color:#a54c9b}/*!@.hint.sdx--dark-theme > .ribbon-container*/.hint.sdx--dark-theme.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{background-color:#0a7b7a}/*!@.topic-dark.sdx--dark-theme > .ribbon-container*/.topic-dark.sdx--dark-theme.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{background-color:#136fc3}/*!@.topic-light.sdx--dark-theme > .ribbon-container*/.topic-light.sdx--dark-theme.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{color:#e6e6e6;border:1px solid #e6e6e6;background-color:#141414}/*!@.loop > .ribbon-container*/.loop.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{position:absolute;overflow:hidden;top:-5px}/*!@.loop > .ribbon-container .content*/.loop.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon .content.sc-sdx-ribbon{color:#fff;background-color:#a63297;text-align:center;position:absolute;width:141.4%;-webkit-transform-origin:bottom left;-moz-transform-origin:bottom left;-ms-transform-origin:bottom left;-o-transform-origin:bottom left;transform-origin:bottom left}/*!@.loop > .ribbon-container .content::before, .loop > .ribbon-container .content::after*/.loop.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon .content.sc-sdx-ribbon::before,.loop.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon .content.sc-sdx-ribbon::after{content:\"\";position:absolute;bottom:-4px;border-left:4px solid transparent;border-right:4px solid transparent;border-top:4px solid #7f2879}/*!@.loop > .ribbon-container .content::before*/.loop.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon .content.sc-sdx-ribbon::before{left:0}/*!@.loop > .ribbon-container .content::after*/.loop.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon .content.sc-sdx-ribbon::after{right:0}/*!@.small > .slot*/.small.sc-sdx-ribbon>.slot.sc-sdx-ribbon{min-height:96px}/*!@.normal > .slot*/.normal.sc-sdx-ribbon>.slot.sc-sdx-ribbon{min-height:112px}/*!@.large > .slot*/.large.sc-sdx-ribbon>.slot.sc-sdx-ribbon{min-height:128px}/*!@.loop.small > .ribbon-container*/.loop.small.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{font-size:14px;width:96px;height:96px}/*!@.loop.normal > .ribbon-container*/.loop.normal.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{font-size:16px;width:112px;height:112px}/*!@.loop.large > .ribbon-container*/.loop.large.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{font-size:18px;width:128px;height:128px}/*!@.loop.left > .ribbon-container*/.loop.left.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{left:-5px}/*!@.loop.left > .ribbon-container .content*/.loop.left.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon .content.sc-sdx-ribbon{-webkit-transform:rotate(-45deg);-moz-transform:rotate(-45deg);-ms-transform:rotate(-45deg);-o-transform:rotate(-45deg);transform:rotate(-45deg);bottom:0}/*!@.loop.right > .ribbon-container*/.loop.right.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{right:-5px}/*!@.loop.right > .ribbon-container .content*/.loop.right.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon .content.sc-sdx-ribbon{top:-24px;-webkit-transform:rotate(45deg);-moz-transform:rotate(45deg);-ms-transform:rotate(45deg);-o-transform:rotate(45deg);transform:rotate(45deg)}/*!@.bookmark > .ribbon-container*/.bookmark.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{position:absolute;top:6px;min-width:70px;background-color:#0eaba9;color:#fff}/*!@.bookmark > .ribbon-container::after*/.bookmark.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon::after{content:\"\";position:absolute;bottom:-8px;border-top:8px solid #0c847e}/*!@.bookmark.right > .ribbon-container*/.bookmark.right.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{right:-8px}/*!@.bookmark.right > .ribbon-container::after*/.bookmark.right.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon::after{right:0;border-right:8px solid transparent}/*!@.bookmark.left > .ribbon-container*/.bookmark.left.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{left:-8px}/*!@.bookmark.left > .ribbon-container::after*/.bookmark.left.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon::after{left:0;border-left:8px solid transparent}/*!@.bookmark.small > .ribbon-container*/.bookmark.small.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{font-size:14px;padding:4px 8px 4px}/*!@.bookmark.normal > .ribbon-container*/.bookmark.normal.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{font-size:16px;padding:6px 8px 6px}/*!@.bookmark.large > .ribbon-container*/.bookmark.large.sc-sdx-ribbon>.ribbon-container.sc-sdx-ribbon{font-size:18px;padding:8px 8px 8px}";

class Ribbon {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.label = "Ribbon";
    this.theme = "";
    this.design = "loop";
    this.position = "right";
    this.size = "normal";
  }
  getComponentClassNames() {
    if (this.theme) {
      return {
        component: true,
        [this.theme]: true,
        [getAppearance(this.el)]: true,
      };
    }
    // fallback for backwards compatibility
    return {
      component: true,
      [this.design]: true,
      [this.position]: true,
      [this.size]: true,
    };
  }
  render() {
    return (hAsync("div", { class: this.getComponentClassNames() }, hAsync("div", { class: "ribbon-container" }, !this.theme && this.design === "loop" ? (hAsync("div", { class: "content" }, this.label)) : (this.label)), hAsync("div", { class: "slot" }, hAsync("slot", null))));
  }
  get el() { return getElement(this); }
  static get style() { return ribbonCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-ribbon",
    "$members$": {
      "label": [1],
      "theme": [1],
      "design": [1],
      "position": [1],
      "size": [1]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const scrollToTopCss = "/*!@:root*/.sc-sdx-scroll-to-top:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-scroll-to-top-h,*.sc-sdx-scroll-to-top,*.sc-sdx-scroll-to-top:before,*.sc-sdx-scroll-to-top:after{box-sizing:border-box}/*!@:host*/.sc-sdx-scroll-to-top-h{z-index:55000;display:none}/*!@.scroll-to-top*/.scroll-to-top.sc-sdx-scroll-to-top{border:2px solid #086adb;border-radius:50%;background-color:rgba(255, 255, 255, 0.8);color:#086adb;height:48px;width:48px;padding:6px;outline:none;cursor:pointer}/*!@.scroll-to-top:focus, .scroll-to-top:active*/.scroll-to-top.sc-sdx-scroll-to-top:focus,.scroll-to-top.sc-sdx-scroll-to-top:active{border-color:#0048cf;color:#0048cf}@media (hover: hover){/*!@.scroll-to-top:hover*/.scroll-to-top.sc-sdx-scroll-to-top:hover{border-color:#0048cf;color:#0048cf}}/*!@.scroll-to-top:active*/.scroll-to-top.sc-sdx-scroll-to-top:active{transform:scale(0.98)}/*!@.sdx--dark-theme .scroll-to-top*/.sdx--dark-theme.sc-sdx-scroll-to-top .scroll-to-top.sc-sdx-scroll-to-top{background-color:rgba(29, 29, 29, 0.8);color:#0a71e9}/*!@.sdx--dark-theme .scroll-to-top:focus, .sdx--dark-theme .scroll-to-top:active*/.sdx--dark-theme.sc-sdx-scroll-to-top .scroll-to-top.sc-sdx-scroll-to-top:focus,.sdx--dark-theme.sc-sdx-scroll-to-top .scroll-to-top.sc-sdx-scroll-to-top:active{border-color:#147df5;color:#147df5}@media (hover: hover){/*!@.sdx--dark-theme .scroll-to-top:hover*/.sdx--dark-theme.sc-sdx-scroll-to-top .scroll-to-top.sc-sdx-scroll-to-top:hover{border-color:#147df5;color:#147df5}}";

class ScrollToTop {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.animationDuration = 500;
    this.animationTranslationY = 112;
    this.position = "fixed";
    this.demo = false;
    this.animated = true;
    this.visible = false;
    this.currentAnimation = undefined;
  }
  componentWillLoad() {
    this.visible = this.isVisible();
    this.updateVisibility();
  }
  onWindowScroll() {
    this.visible = this.isVisible();
  }
  onTouchStart() {
    // NOP - make sure touchstart is noticed. touchstart event needed for the animations (note: tracking on prod)
  }
  isVisible() {
    // should always be visible when "demo"; only used for demo on SDX documentation site
    return this.demo || this.hasScrolledOverWindowHeight();
  }
  hasScrolledOverWindowHeight() {
    // do not use window.innerHeight because of iOS
    return window.pageYOffset > document.documentElement.clientHeight;
  }
  onClick() {
    this.scrollToTop();
  }
  onVisibleChanged() {
    this.updateVisibility();
  }
  showEl() {
    this.el.style.display = "block";
    if (this.position === "fixed") {
      this.el.style.position = "fixed";
      this.el.style.bottom = "32px"; // $baseline-4
      this.el.style.right = "32px"; // $baseline-4
    }
  }
  updateVisibility() {
    var _a;
    (_a = this.currentAnimation) === null || _a === void 0 ? void 0 : _a.pause(); // if animation is running slower than new one
    if (this.visible) {
      this.showEl();
      this.currentAnimation = anime({
        targets: this.el,
        duration: this.animated ? this.animationDuration : 0,
        opacity: 1,
        translateY: 0,
        easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
      });
    }
    else {
      this.currentAnimation = anime({
        targets: this.el,
        duration: this.animated ? this.animationDuration : 0,
        opacity: 0,
        translateY: this.animationTranslationY,
        easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
        complete: () => {
          this.el.style.display = "none";
        },
      });
    }
    forceUpdate$1(this.el);
  }
  getComponentClassNames() {
    return {
      [getAppearance(this.el)]: true,
    };
  }
  scrollToTop() {
    window.scroll({ top: 0, behavior: "smooth" });
  }
  render() {
    return (hAsync("div", { class: this.getComponentClassNames() }, hAsync("button", { type: "button", class: "scroll-to-top", "aria-hidden": "true" }, hAsync("sdx-icon", { "icon-name": "icon-arrow-up", size: 3 }))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "visible": ["onVisibleChanged"]
  }; }
  static get style() { return scrollToTopCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-scroll-to-top",
    "$members$": {
      "position": [1],
      "demo": [4],
      "animated": [4],
      "visible": [32],
      "currentAnimation": [32]
    },
    "$listeners$": [[9, "scroll", "onWindowScroll"], [1, "touchstart", "onTouchStart"], [0, "click", "onClick"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const scrollViewCss = "/*!@:root*/.sc-sdx-scroll-view:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-scroll-view-h,*.sc-sdx-scroll-view,*.sc-sdx-scroll-view:before,*.sc-sdx-scroll-view:after{box-sizing:border-box}/*!@:host*/.sc-sdx-scroll-view-h{max-width:100%}/*!@.component*/.component.sc-sdx-scroll-view{height:inherit;position:relative;overflow-x:hidden}/*!@.component.is-touchscreen .scrollable*/.component.is-touchscreen.sc-sdx-scroll-view .scrollable.sc-sdx-scroll-view{overflow-x:auto}/*!@.component.is-touchscreen .scrollable::-webkit-scrollbar*/.component.is-touchscreen.sc-sdx-scroll-view .scrollable.sc-sdx-scroll-view::-webkit-scrollbar{display:none}/*!@.component .scrollable*/.component.sc-sdx-scroll-view .scrollable.sc-sdx-scroll-view{height:inherit}/*!@.component sdx-arrow*/.component.sc-sdx-scroll-view sdx-arrow.sc-sdx-scroll-view{position:absolute;top:0;width:40px}/*!@.component sdx-arrow.left*/.component.sc-sdx-scroll-view sdx-arrow.left.sc-sdx-scroll-view{left:0}/*!@.component sdx-arrow.right*/.component.sc-sdx-scroll-view sdx-arrow.right.sc-sdx-scroll-view{right:0}";

class ScrollView {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.animationInProgress = false;
    this.componentDidLoadComplete = false;
    this.showLeftArrow = false;
    this.showRightArrow = false;
    this.arrowsHidden = false;
    this.animated = true;
  }
  onWindowResizeDebounced() {
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer);
    }
    this.resizeTimer = setTimeout(() => {
      if (!this.scrollableEl) {
        return;
      }
      this.showArrowsIfNeeded();
      const { clientWidth, scrollWidth } = this.scrollableEl;
      const hasEnoughSpace = clientWidth === scrollWidth;
      // When enough space, scroll back to beginning
      if (hasEnoughSpace) {
        this.translateX(-this.getOverflow("left"), false);
      }
    }, 10);
  }
  async translateX(translateX, animated = true) {
    const scrollableEl = this.scrollableEl;
    const overflowToLeft = this.getOverflow("left");
    const overflowToRight = this.getOverflow("right");
    if (translateX > 0) {
      // to right
      translateX = Math.min(translateX, overflowToRight);
    }
    else {
      // to left
      translateX = Math.max(translateX, -overflowToLeft);
    }
    // It's already scrolling
    if (this.animationInProgress) {
      return;
    }
    // Animation starts
    this.animationInProgress = true;
    anime({
      targets: this.scrollableEl,
      easing: "easeOutQuad",
      duration: animated ? this.getAnimationDuration() : 0,
      translateX: `-=${translateX}`,
      complete: () => {
        this.animationInProgress = false;
        this.showArrowsIfNeeded();
        // "Convert" translateX into scrollLeft for touchscreens.
        // Alternatively, instead of animating "translateX", it also works to
        // animate "scrollLeft". This would make this converting obsolete.
        // However, there was a glitch that caused the scrollable element to
        // jump when hovering over the selected tab after scrolling.
        if (isTouchscreen()) {
          // Causes a scroll event
          scrollableEl.scrollTo(scrollableEl.scrollLeft + translateX, scrollableEl.scrollTop);
          anime.set(scrollableEl, { translateX: 0 });
        }
      },
    });
  }
  /**
   * Draws the layout. Useful to redraw the component when initially
   * rendered on a hidden parent (e.g. an sdx-header).
   */
  async layout() {
    this.showArrowsIfNeeded();
  }
  componentDidLoad() {
    this.showArrowsIfNeeded();
    this.componentDidLoadComplete = true;
  }
  getAnimationDuration() {
    if (!this.componentDidLoadComplete) {
      return 0;
    }
    return this.animated ? 200 : 0;
  }
  getOverflow(to) {
    const componentElRect = this.componentEl.getBoundingClientRect();
    const slotElRect = this.slotEl.getBoundingClientRect();
    const { scrollWidth } = this.scrollableEl;
    if (to === "left") {
      return componentElRect.left - slotElRect.left;
    }
    else {
      // "right"
      return slotElRect.left + scrollWidth - componentElRect.right;
    }
  }
  // getBoundingClientRect() does return floats, therefore it happens that
  // an element has an overflow of 0.666px, which is mathematically true, but
  // in reality does not count as a real overflow. Therefore check for 1
  // instead (which will be a "real" pixel, not a subpixel).
  hasOverflow(to) {
    if (to === "left") {
      return this.getOverflow("left") >= 1;
    }
    else {
      // "right"
      return this.getOverflow("right") >= 1;
    }
  }
  showArrowsIfNeeded() {
    this.showLeftArrow = this.hasOverflow("left");
    this.showRightArrow = this.hasOverflow("right");
  }
  onScroll() {
    if (this.scrollingTimer) {
      clearTimeout(this.scrollingTimer);
    }
    this.scrollingTimer = setTimeout(() => {
      this.onScrollDebounced();
    }, 50);
  }
  // Needed for touch initiated scrolling
  onScrollDebounced() {
    this.showArrowsIfNeeded();
  }
  onArrowClick(which) {
    const componentElRect = this.componentEl.getBoundingClientRect();
    // Scroll only by half of the available only so that end users don't lose
    // overview
    const translateX = componentElRect.width / 2;
    this.translateX(which === "left" ? -translateX : translateX);
  }
  getComponentClassNames() {
    return {
      component: true,
      "is-touchscreen": isTouchscreen(),
    };
  }
  render() {
    return (hAsync("div", { class: this.getComponentClassNames(), ref: (el) => (this.componentEl = el) }, hAsync("div", { class: "scrollable", onScroll: () => this.onScroll(), ref: (el) => (this.scrollableEl = el) }, hAsync("div", { class: "slot", ref: (el) => (this.slotEl = el) }, hAsync("slot", null))), hAsync("sdx-arrow", { class: "left", direction: "left", hidden: !this.showLeftArrow, onClick: () => this.onArrowClick("left"), animationDuration: this.getAnimationDuration(), arrowHidden: this.arrowsHidden }), hAsync("sdx-arrow", { class: "right", direction: "right", hidden: !this.showRightArrow, onClick: () => this.onArrowClick("right"), animationDuration: this.getAnimationDuration(), arrowHidden: this.arrowsHidden })));
  }
  static get style() { return scrollViewCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-scroll-view",
    "$members$": {
      "arrowsHidden": [4, "arrows-hidden"],
      "animated": [4],
      "showLeftArrow": [32],
      "showRightArrow": [32],
      "translateX": [64],
      "layout": [64]
    },
    "$listeners$": [[9, "resize", "onWindowResizeDebounced"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const searchCss = "/*!@:root*/.sc-sdx-search:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-search-h,*.sc-sdx-search,*.sc-sdx-search:before,*.sc-sdx-search:after{box-sizing:border-box}/*!@.sr-only*/.sr-only.sc-sdx-search{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);border:0}/*!@.sr-only-focusable:active, .sr-only-focusable:focus*/.sr-only-focusable.sc-sdx-search:active,.sr-only-focusable.sc-sdx-search:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}/*!@:host*/.sc-sdx-search-h{color:#086adb}/*!@.wrapper*/.wrapper.sc-sdx-search{position:relative}/*!@.wrapper .search-button*/.wrapper.sc-sdx-search .search-button.sc-sdx-search{position:absolute;top:0;right:0;padding:7px}/*!@.wrapper .search-button sdx-button*/.wrapper.sc-sdx-search .search-button.sc-sdx-search sdx-button.sc-sdx-search{color:inherit}";

class Search {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.invokeSearchSubmitCallback = () => null;
    this.invokeValueChangeCallback = () => null;
    this.invokeChangeCallback = () => null;
    this.value = "";
    this.placeholder = "";
    this.srHint = "";
    this.srHintForButton = "";
    this.searchSubmitCallback = undefined;
    this.changeCallback = undefined;
    this.valueChangeCallback = undefined;
  }
  valueChanged() {
    this.invokeAllChangeCallbacks();
  }
  searchSubmitCallbackChanged() {
    this.setInvokeSearchSubmitCallback();
  }
  changeCallbackChanged() {
    this.setInvokeChangeCallback();
  }
  valueChangeCallbackChanged() {
    this.setInvokeValueChangeCallback();
  }
  // Rerender on resize to show "clearable" button if needed
  onWindowResizeDebounced() {
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer);
    }
    this.resizeTimer = setTimeout(() => {
      forceUpdate$1(this.el);
    }, 10);
  }
  componentWillLoad() {
    this.setInvokeSearchSubmitCallback();
    this.setInvokeChangeCallback();
    this.setInvokeValueChangeCallback();
  }
  /**
   * Set focus to element.
   */
  async doFocus() {
    var _a;
    (_a = this.sdxInputEl) === null || _a === void 0 ? void 0 : _a.doFocus();
  }
  submitSearch() {
    if (this.sdxInputEl) {
      this.invokeSearchSubmitCallback(this.sdxInputEl.value);
    }
  }
  invokeAllChangeCallbacks() {
    this.invokeChangeCallback(this.value);
    this.invokeValueChangeCallback(this.value);
  }
  setInvokeSearchSubmitCallback() {
    this.invokeSearchSubmitCallback = parseFunction(this.searchSubmitCallback);
  }
  setInvokeValueChangeCallback() {
    this.invokeValueChangeCallback = parseFunction(this.valueChangeCallback);
  }
  setInvokeChangeCallback() {
    this.invokeChangeCallback = parseFunction(this.changeCallback);
  }
  render() {
    return (hAsync("div", { class: "wrapper" }, hAsync("sdx-input", { value: this.value, srHint: this.srHint, type: "search", placeholder: this.placeholder, hitEnterCallback: () => this.submitSearch(), onInput: (e) => {
        this.value = e.target.value;
      }, ref: (el) => (this.sdxInputEl = el), role: "search", clearable: !bp("lg"), inputStyle: {
        paddingRight: "48px" /* $baseline-6 (space for search icon) */,
      }, clearButtonStyle: {
        right: "40px" /* $baseline-5 (space for search icon) */,
      } }), hAsync("div", { class: "search-button" }, hAsync("sdx-button", { theme: "transparent", onClick: () => this.submitSearch(), srHint: this.srHintForButton, iconName: "icon-search", iconSize: 3 }))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "value": ["valueChanged"],
    "searchSubmitCallback": ["searchSubmitCallbackChanged"],
    "changeCallback": ["changeCallbackChanged"],
    "valueChangeCallback": ["valueChangeCallbackChanged"]
  }; }
  static get style() { return searchCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-search",
    "$members$": {
      "value": [1025],
      "placeholder": [1],
      "srHint": [1, "sr-hint"],
      "srHintForButton": [1, "sr-hint-for-button"],
      "searchSubmitCallback": [1, "search-submit-callback"],
      "changeCallback": [1, "change-callback"],
      "valueChangeCallback": [1, "value-change-callback"],
      "doFocus": [64]
    },
    "$listeners$": [[9, "resize", "onWindowResizeDebounced"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}
/**
 * Emitted whenever user is typing or clearing the search field.
 * @event
 */
// @ts-ignore just for documentation purposes
Search.eventInput = "input";

/**
 * Get the text that will be displayed in the selection header.
 * Fall back to an empty string if there's no selection.
 */
function getFormattedSelection(selection) {
  return selection.length ? selection.map(getDisplayText).join(", ") : "";
}
/**
 * Checks if a given "keyboard-behavior" is active, including backwards
 * compatibility with the deprecated "filterable" prop.
 * @param store Context with store properties.
 * @param keyboardBehavior Behavior to test.
 */
function isKeyboardBehavior(store, keyboardBehavior) {
  const isMatch = keyboardBehavior === store.keyboardBehavior;
  if (keyboardBehavior === "filter" && (isMatch || store.filterable)) {
    return true;
  }
  return isMatch;
}
function isFilterLongEnough(filter, filterMinLength) {
  return filter.length > 0 && filter.length >= filterMinLength;
}
function isValidFilter(filter, selection, filterMinLength) {
  return (isFilterLongEnough(filter, filterMinLength) &&
    filter !== getFormattedSelection(selection) // Ignore selection as filter
  );
}
function getDisplayText(optionEl) {
  var _a;
  return optionEl.displayText || ((_a = optionEl.textContent) === null || _a === void 0 ? void 0 : _a.trim()) || "";
}
const selectReducer = (state = {}, action) => {
  switch (action.type) {
    case "SELECT":
      let { selection } = state;
      if (action.optionEl) {
        // selecting a "real" option (not the placeholder)
        if (state.multiple) {
          // multi-select
          const alreadySelected = selection.includes(action.optionEl);
          if (alreadySelected || action.strategy === "remove") {
            // remove from selection
            selection = selection.filter((optionEl) => optionEl !== action.optionEl);
          }
          else {
            // "add" to selection
            selection = [...selection, action.optionEl].sort(sortByAppearanceInDomTree);
          }
        }
        else {
          // single select
          const alreadySelected = selection[0] === action.optionEl;
          if (alreadySelected) {
            if (action.strategy === "remove") {
              selection = [];
            }
          }
          else {
            if (action.strategy === "add") {
              selection = [action.optionEl];
            }
          }
        }
      }
      else {
        // selecting the placeholder
        if (selection.length) {
          // Only create a new array if the selection isn't empty
          // to prevent unnecessary change detection.
          selection = [];
        }
      }
      return { ...state, selection };
    case "ACTIVATE_SORT":
      return {
        ...state,
        sort: true,
        optionEls: [...state.optionEls].sort(sortByAppearanceInDomTree),
      };
    case "ADD_OPTION_EL":
      return {
        ...state,
        optionEls: state.sort
          ? add(state.optionEls, action.optionEl).sort(sortByAppearanceInDomTree)
          : add(state.optionEls, action.optionEl),
      };
    case "REMOVE_OPTION_EL":
      return {
        ...state,
        optionEls: state.sort
          ? remove(state.optionEls, action.optionEl).sort(sortByAppearanceInDomTree)
          : remove(state.optionEls, action.optionEl),
      };
    case "ADD_OPTGROUP_EL":
      return {
        ...state,
        optgroupEls: state.sort
          ? add(state.optgroupEls, action.optgroupEl).sort(sortByAppearanceInDomTree)
          : add(state.optgroupEls, action.optgroupEl),
      };
    case "REMOVE_OPTGROUP_EL":
      return {
        ...state,
        optgroupEls: state.sort
          ? remove(state.optgroupEls, action.optgroupEl).sort(sortByAppearanceInDomTree)
          : remove(state.optgroupEls, action.optgroupEl),
      };
    case "SET_FILTER":
      return {
        ...state,
        filter: isValidFilter(action.filter, state.selection, state.filterMinLength)
          ? action.filter
          : "",
      };
    case "SET_VALIDATED_FILTER_INPUT_EL_VALUE":
      return {
        ...state,
        filterInputElValue: isValidFilter(action.filterInputElValue, state.selection, state.filterMinLength)
          ? action.filterInputElValue
          : "",
      };
    case "UPDATE_REAPPENDING":
      const reappendedItems = state.reappendedItems + 1;
      const reappending = reappendedItems !== state.optionEls.length + state.optgroupEls.length;
      return {
        ...state,
        reappending,
        reappendedItems: reappending ? reappendedItems : 0,
      };
    default:
      return state;
  }
};
function getInitialState$1() {
  return {
    selection: [],
    multiple: false,
    directionX: "right",
    directionY: "bottom",
    keyboardBehavior: "focus",
    listEl: undefined,
    sort: false,
    optionEls: [],
    optgroupEls: [],
    name: undefined,
    filter: "",
    filterable: false,
    filterInputElValue: "",
    filterInputElPlaceholder: "",
    filterMinLength: 3,
    hasFilterInputElFocus: false,
    noMatchesFound: false,
    noMatchesFoundLabel: "",
    animationDuration: 0,
    reappending: false,
    reappendedItems: 0,
    connected: false,
    userInteractionInProgress: false,
    placeholder: "",
    required: false,
    display: "closed",
    loading: false,
    close: () => Promise.resolve(),
    isInsideDialog: false,
  };
}

const selectCss = "/*!@:root*/.sc-sdx-select:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-select-h,*.sc-sdx-select,*.sc-sdx-select:before,*.sc-sdx-select:after{box-sizing:border-box}/*!@label*/label.sc-sdx-select{display:block;margin-bottom:4px;cursor:inherit;color:#666;font-size:16px}/*!@label.readonly, label.disabled*/label.readonly.sc-sdx-select,label.disabled.sc-sdx-select{color:#bbb}/*!@label.sdx--dark-theme*/label.sdx--dark-theme.sc-sdx-select{color:#adadad}/*!@:host*/.sc-sdx-select-h{outline:none}/*!@.component .header-wrapper*/.component.sc-sdx-select .header-wrapper.sc-sdx-select{overflow:hidden;transition:all 200ms cubic-bezier(0.4, 0, 0.2, 1)}/*!@.component .header-wrapper .header*/.component.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select{position:relative}/*!@.component .header-wrapper .header .selection,\n.component .header-wrapper .header .thumb*/.component.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .selection.sc-sdx-select,.component.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select{transition:all 200ms cubic-bezier(0.4, 0, 0.2, 1)}/*!@.component .header-wrapper .header .thumb*/.component.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select{width:30px;position:absolute;right:-1px;top:-1px;bottom:-1px;pointer-events:none;display:flex;justify-content:center;align-items:center}/*!@.component .header-wrapper .header .thumb > .icon*/.component.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select{position:relative;width:100%;transform-origin:50% 50%}/*!@.component .header-wrapper .header .thumb > .icon::before, .component .header-wrapper .header .thumb > .icon::after*/.component.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::before,.component.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::after{position:absolute;top:50%;transition:all 200ms cubic-bezier(0.4, 0, 0.2, 1);border-radius:2px;background:#086adb;width:10px;height:2px;backface-visibility:hidden;content:\"\"}/*!@.component .header-wrapper .header .thumb > .icon::before*/.component.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::before{left:0}/*!@.component .header-wrapper .header .thumb > .icon::after*/.component.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::after{left:6px}/*!@.component .header-wrapper .header .thumb > .icon::before*/.component.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::before{transform:rotate(45deg)}/*!@.component .header-wrapper .header .thumb > .icon::after*/.component.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::after{transform:rotate(-45deg)}/*!@.component .header-wrapper .header:hover*/.component.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover{cursor:pointer}/*!@.component .header-wrapper .header:hover .thumb > .icon*/.component.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select{position:relative}/*!@.component .header-wrapper .header:hover .thumb > .icon::before, .component .header-wrapper .header:hover .thumb > .icon::after*/.component.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select::before,.component.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select::after{position:absolute;top:50%;transition:all 200ms cubic-bezier(0.4, 0, 0.2, 1);border-radius:2px;background:#0048cf;width:10px;height:2px;backface-visibility:hidden;content:\"\"}/*!@.component .header-wrapper .header:hover .thumb > .icon::before*/.component.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select::before{left:0}/*!@.component .header-wrapper .header:hover .thumb > .icon::after*/.component.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select::after{left:6px}/*!@.component.open .header-wrapper,\n.component.opening .header-wrapper*/.component.open.sc-sdx-select .header-wrapper.sc-sdx-select,.component.opening.sc-sdx-select .header-wrapper.sc-sdx-select{box-shadow:0 0 4px 0 rgba(51, 51, 51, 0.1)}/*!@.component.open .header-wrapper .header .thumb > .icon::before,\n.component.opening .header-wrapper .header .thumb > .icon::before*/.component.open.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::before,.component.opening.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::before{transform:rotate(-45deg)}/*!@.component.open .header-wrapper .header .thumb > .icon::after,\n.component.opening .header-wrapper .header .thumb > .icon::after*/.component.open.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::after,.component.opening.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::after{transform:rotate(45deg)}/*!@.component.bottom .header-wrapper*/.component.bottom.sc-sdx-select .header-wrapper.sc-sdx-select{border-radius:5px 5px 0 0}/*!@.component.top .header-wrapper*/.component.top.sc-sdx-select .header-wrapper.sc-sdx-select{border-radius:0 0 5px 5px}/*!@.component.disabled .label,\n.component.disabled .wrapper,\n.component.loading .label,\n.component.loading .wrapper*/.component.disabled.sc-sdx-select .label.sc-sdx-select,.component.disabled.sc-sdx-select .wrapper.sc-sdx-select,.component.loading.sc-sdx-select .label.sc-sdx-select,.component.loading.sc-sdx-select .wrapper.sc-sdx-select{pointer-events:none}/*!@.component.disabled*/.component.disabled.sc-sdx-select{cursor:not-allowed}/*!@.component.disabled .label*/.component.disabled.sc-sdx-select .label.sc-sdx-select{color:#bbb}/*!@.component.disabled .header-wrapper .header .thumb .icon::before, .component.disabled .header-wrapper .header .thumb .icon::after*/.component.disabled.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select .icon.sc-sdx-select::before,.component.disabled.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select .icon.sc-sdx-select::after{background-color:#bbb}/*!@.component.loading sdx-loading-spinner*/.component.loading.sc-sdx-select sdx-loading-spinner.sc-sdx-select{position:relative;right:8px}/*!@.component.focus sdx-validation-message*/.component.focus.sc-sdx-select sdx-validation-message.sc-sdx-select{display:none}/*!@.component.dark .label*/.component.dark.sc-sdx-select .label.sc-sdx-select{color:#fff}/*!@.component.autocomplete:not(.loading) .header-wrapper .header*/.component.autocomplete.sc-sdx-select:not(.loading) .header-wrapper.sc-sdx-select .header.sc-sdx-select{padding-right:0}/*!@.component.invalid:not(.focus) .header-wrapper .header .thumb > .icon*/.component.invalid.sc-sdx-select:not(.focus) .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select{position:relative}/*!@.component.invalid:not(.focus) .header-wrapper .header .thumb > .icon::before, .component.invalid:not(.focus) .header-wrapper .header .thumb > .icon::after*/.component.invalid.sc-sdx-select:not(.focus) .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::before,.component.invalid.sc-sdx-select:not(.focus) .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::after{position:absolute;top:50%;transition:all 200ms cubic-bezier(0.4, 0, 0.2, 1);border-radius:2px;background:#d12;width:10px;height:2px;backface-visibility:hidden;content:\"\"}/*!@.component.invalid:not(.focus) .header-wrapper .header .thumb > .icon::before*/.component.invalid.sc-sdx-select:not(.focus) .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::before{left:0}/*!@.component.invalid:not(.focus) .header-wrapper .header .thumb > .icon::after*/.component.invalid.sc-sdx-select:not(.focus) .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::after{left:6px}/*!@.component.invalid:not(.focus) .header-wrapper .header:hover .thumb > .icon*/.component.invalid.sc-sdx-select:not(.focus) .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select{position:relative}/*!@.component.invalid:not(.focus) .header-wrapper .header:hover .thumb > .icon::before, .component.invalid:not(.focus) .header-wrapper .header:hover .thumb > .icon::after*/.component.invalid.sc-sdx-select:not(.focus) .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select::before,.component.invalid.sc-sdx-select:not(.focus) .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select::after{position:absolute;top:50%;transition:all 200ms cubic-bezier(0.4, 0, 0.2, 1);border-radius:2px;background:#be0000;width:10px;height:2px;backface-visibility:hidden;content:\"\"}/*!@.component.invalid:not(.focus) .header-wrapper .header:hover .thumb > .icon::before*/.component.invalid.sc-sdx-select:not(.focus) .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select::before{left:0}/*!@.component.invalid:not(.focus) .header-wrapper .header:hover .thumb > .icon::after*/.component.invalid.sc-sdx-select:not(.focus) .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select::after{left:6px}/*!@.component.sdx--dark-theme .header-wrapper .header .thumb > .icon*/.component.sdx--dark-theme.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select{position:relative}/*!@.component.sdx--dark-theme .header-wrapper .header .thumb > .icon::before, .component.sdx--dark-theme .header-wrapper .header .thumb > .icon::after*/.component.sdx--dark-theme.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::before,.component.sdx--dark-theme.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::after{position:absolute;top:50%;transition:all 200ms cubic-bezier(0.4, 0, 0.2, 1);border-radius:2px;background:#4294ff;width:10px;height:2px;backface-visibility:hidden;content:\"\"}/*!@.component.sdx--dark-theme .header-wrapper .header .thumb > .icon::before*/.component.sdx--dark-theme.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::before{left:0}/*!@.component.sdx--dark-theme .header-wrapper .header .thumb > .icon::after*/.component.sdx--dark-theme.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::after{left:6px}/*!@.component.sdx--dark-theme .header-wrapper .header:hover .thumb > .icon*/.component.sdx--dark-theme.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select{position:relative}/*!@.component.sdx--dark-theme .header-wrapper .header:hover .thumb > .icon::before, .component.sdx--dark-theme .header-wrapper .header:hover .thumb > .icon::after*/.component.sdx--dark-theme.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select::before,.component.sdx--dark-theme.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select::after{position:absolute;top:50%;transition:all 200ms cubic-bezier(0.4, 0, 0.2, 1);border-radius:2px;background:#5ca3ff;width:10px;height:2px;backface-visibility:hidden;content:\"\"}/*!@.component.sdx--dark-theme .header-wrapper .header:hover .thumb > .icon::before*/.component.sdx--dark-theme.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select::before{left:0}/*!@.component.sdx--dark-theme .header-wrapper .header:hover .thumb > .icon::after*/.component.sdx--dark-theme.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select::after{left:6px}/*!@.component.open.sdx--dark-theme .header-wrapper,\n.component.opening.sdx--dark-theme .header-wrapper*/.component.open.sdx--dark-theme.sc-sdx-select .header-wrapper.sc-sdx-select,.component.opening.sdx--dark-theme.sc-sdx-select .header-wrapper.sc-sdx-select{box-shadow:none}/*!@.component.disabled.sdx--dark-theme .label*/.component.disabled.sdx--dark-theme.sc-sdx-select .label.sc-sdx-select{color:#5c5c5c}/*!@.component.disabled.sdx--dark-theme .header-wrapper .header .thumb .icon::before, .component.disabled.sdx--dark-theme .header-wrapper .header .thumb .icon::after*/.component.disabled.sdx--dark-theme.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select .icon.sc-sdx-select::before,.component.disabled.sdx--dark-theme.sc-sdx-select .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select .icon.sc-sdx-select::after{background:#5c5c5c}/*!@.component.invalid:not(.focus).sdx--dark-theme .header-wrapper .header .thumb > .icon*/.component.invalid.sc-sdx-select:not(.focus).sdx--dark-theme .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select{position:relative}/*!@.component.invalid:not(.focus).sdx--dark-theme .header-wrapper .header .thumb > .icon::before, .component.invalid:not(.focus).sdx--dark-theme .header-wrapper .header .thumb > .icon::after*/.component.invalid.sc-sdx-select:not(.focus).sdx--dark-theme .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::before,.component.invalid.sc-sdx-select:not(.focus).sdx--dark-theme .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::after{position:absolute;top:50%;transition:all 200ms cubic-bezier(0.4, 0, 0.2, 1);border-radius:2px;background:#f35d6a;width:10px;height:2px;backface-visibility:hidden;content:\"\"}/*!@.component.invalid:not(.focus).sdx--dark-theme .header-wrapper .header .thumb > .icon::before*/.component.invalid.sc-sdx-select:not(.focus).sdx--dark-theme .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::before{left:0}/*!@.component.invalid:not(.focus).sdx--dark-theme .header-wrapper .header .thumb > .icon::after*/.component.invalid.sc-sdx-select:not(.focus).sdx--dark-theme .header-wrapper.sc-sdx-select .header.sc-sdx-select .thumb.sc-sdx-select>.icon.sc-sdx-select::after{left:6px}/*!@.component.invalid:not(.focus).sdx--dark-theme .header-wrapper .header:hover .thumb > .icon*/.component.invalid.sc-sdx-select:not(.focus).sdx--dark-theme .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select{position:relative}/*!@.component.invalid:not(.focus).sdx--dark-theme .header-wrapper .header:hover .thumb > .icon::before, .component.invalid:not(.focus).sdx--dark-theme .header-wrapper .header:hover .thumb > .icon::after*/.component.invalid.sc-sdx-select:not(.focus).sdx--dark-theme .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select::before,.component.invalid.sc-sdx-select:not(.focus).sdx--dark-theme .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select::after{position:absolute;top:50%;transition:all 200ms cubic-bezier(0.4, 0, 0.2, 1);border-radius:2px;background:#fe7e89;width:10px;height:2px;backface-visibility:hidden;content:\"\"}/*!@.component.invalid:not(.focus).sdx--dark-theme .header-wrapper .header:hover .thumb > .icon::before*/.component.invalid.sc-sdx-select:not(.focus).sdx--dark-theme .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select::before{left:0}/*!@.component.invalid:not(.focus).sdx--dark-theme .header-wrapper .header:hover .thumb > .icon::after*/.component.invalid.sc-sdx-select:not(.focus).sdx--dark-theme .header-wrapper.sc-sdx-select .header.sc-sdx-select:hover .thumb.sc-sdx-select>.icon.sc-sdx-select::after{left:6px}";

class Select {
  stateChanged({}, prev) {
    const state = this.state.get();
    const prevState = prev.get();
    if (state.selection !== prevState.selection) {
      this.selectionChanged(state);
    }
    if (state.optionEls !== prevState.optionEls) {
      this.optionElsChanged(state);
    }
    if (state.filter !== prevState.filter) {
      this.filterChanged(state);
    }
    if (state.filterInputElValue !== prevState.filterInputElValue) {
      this.filterInputElValueChanged(state);
    }
  }
  valueChanged() {
    if (!this.componentDidLoadComplete) {
      return;
    }
    // Update the filter keyword when "autocomplete" and stop doing anything else
    if (isKeyboardBehavior(this.state.get(), "autocomplete")) {
      const filter = this.value[0] || "";
      if (!this.filterInputElValueChangedInProgress) {
        this.store.dispatch({ type: "SET_FILTER", filter });
        this.valueChangedInProgress = true;
        this.store.set("filterInputElValue", filter);
        this.valueChangedInProgress = false;
      }
      this.updateHiddenFormInputEl();
      this.invokeChangeCallback(this.value);
      return;
    }
    const { allValuesValid, validatedValues, optionEls } = this.getByValues(this.value);
    if (!allValuesValid) {
      this.value = validatedValues;
      return;
    }
    // Update the selection
    if (!this.selectionChangedInProgress) {
      // Set selection
      this.valueChangedInProgress = true;
      this.store.set("selection", optionEls);
      this.valueChangedInProgress = false;
    }
    // Invoke callbacks
    if (this.state.get().connected) {
      this.invokeChangeCallback(this.value);
      this.invokeSelectCallback(this.value);
    }
  }
  filterableChanged() {
    this.store.set("filterable", this.filterable);
  }
  filterInputPlaceholderChanged() {
    this.store.set("filterInputElPlaceholder", this.filterInputPlaceholder);
  }
  filterMinLengthChanged() {
    this.store.set("filterMinLength", this.filterMinLength);
  }
  noMatchesFoundLabelChanged() {
    this.store.set("noMatchesFoundLabel", this.noMatchesFoundLabel);
  }
  selectCallbackChanged() {
    this.setInvokeSelectCallback();
  }
  changeCallbackChanged() {
    this.setInvokeChangeCallback();
  }
  filterCallbackChanged() {
    this.setInvokeFilterCallback();
  }
  focusCallbackChanged() {
    this.setInvokeFocusCallback();
  }
  blurCallbackChanged() {
    this.setInvokeBlurCallback();
  }
  placeholderChanged() {
    this.store.set("placeholder", this.placeholder);
    this.resetFilter();
  }
  nameChanged() {
    this.store.set("name", this.name);
    this.updateHiddenFormInputEl();
  }
  filterFunctionChanged() {
    this.setFilterFunction();
  }
  multipleChanged() {
    this.store.set("multiple", this.multiple);
  }
  requiredChanged() {
    this.store.set("required", this.required);
  }
  keyboardBehaviorChanged() {
    this.store.set("keyboardBehavior", this.keyboardBehavior);
  }
  loadingChanged() {
    this.store.set("loading", this.loading);
    this.showNoMatchesFoundIfNecessary();
  }
  onWindowKeyDown(e) {
    if (e.key === "Tab") {
      this.isTabDown = true;
    }
  }
  onWindowKeyUp(e) {
    if (e.key === "Tab") {
      this.isTabDown = false;
    }
  }
  onFocus() {
    // Only handle focus triggered by pressing the tab key
    if (!this.isTabDown) {
      return;
    }
    this.focussed = true;
  }
  onBlur() {
    // Only handle blur triggered by pressing the tab key
    if (!this.isTabDown) {
      return;
    }
    this.close();
  }
  // { capture: true } to make sure it's executed before requestToClose() which
  // needs this.focussed to be up to date
  onWindowClick(e) {
    this.focussed =
      e.composedPath().includes(this.el) ||
        e.composedPath().includes(this.state.get().listEl);
  }
  async onWindowResize() {
    var _a;
    const { display } = this.state.get();
    if (display === "closed") {
      return;
    }
    const dialogDisplay = await ((_a = this.dialogEl) === null || _a === void 0 ? void 0 : _a.getDisplay());
    const isInsideDialog = this.setIsInsideDialog();
    if (!isInsideDialog && dialogDisplay === "open") {
      this.close();
      return;
    }
    const currentAngle = getScreenOrientationAngle();
    if (currentAngle !== this.lastScreenOrientationAngle) {
      // close in case of an orientation change
      this.lastScreenOrientationAngle = currentAngle;
      this.close();
    }
    else {
      // in case of a desktop browser just recalculate the position
      this.positionListEl();
    }
  }
  onKeyDown(e) {
    const { hasFilterInputElFocus } = this.state.get();
    // Only react to key events if the component is focussed
    if (!this.focussed) {
      return;
    }
    switch (e.which) {
      // Open focussed select
      case 32: // "space"
        // Only listen to "space" keydown if the input element (for filterable) is not focussed,
        // otherwise the user wouldn't be able to type white spaces anymore.
        if (!hasFilterInputElFocus) {
          e.preventDefault(); // Prevent scrolling
          // For single select, it's possible to select with space
          if (this.isOpenOrOpening() && !this.multiple && this.focussedEl) {
            this.focussedEl.click();
          }
          else {
            this.toggle();
          }
        }
        break;
      // Select currently focussed element
      case 13: // "enter"
        e.preventDefault(); // Prevent form submit on IE11 / Edge
        if (this.focussedEl) {
          // Just act like the user has clicked on it
          this.focussedEl.click();
        }
        break;
      // Focus previous element
      case 38: // "up"
        e.preventDefault(); // Prevent scrolling
        this.setFocussedEl("previous");
        if (this.hasVisibleOptionEls()) {
          this.open();
        }
        break;
      // Focus next element
      case 40: // "down"
        e.preventDefault(); // Prevent scrolling
        this.setFocussedEl("next");
        if (this.hasVisibleOptionEls()) {
          this.open();
        }
        break;
      default:
        // any key
        const key = e.key.toLowerCase();
        const isValidKey = key.length === 1; // exclude key names like "Shift" or "LeftArrow"
        if (isValidKey) {
          // Assume an alphanumeric key was hit
          // Only focus by letter if not filterable
          if (!this.isFilterable()) {
            this.setFocussedElByFirstLetter(key);
          }
        }
    }
  }
  /**
   * Returns the current selection.
   * @deprecated read the "value" prop instead.
   */
  async getSelection() {
    return this.value;
  }
  /**
   * Toggles the sdx-select.
   */
  toggle() {
    return new Promise((resolve) => {
      const state = this.state.get();
      // When "autocomplete" is set, only open the menu on a certain input field value length
      if (isKeyboardBehavior(state, "autocomplete")) {
        if (isFilterLongEnough(state.filterInputElValue, this.filterMinLength)) {
          this.open().then(resolve);
        }
        else {
          resolve();
        }
        return;
      }
      if (this.isOpenOrOpening()) {
        this.close().then(resolve);
      }
      else if (this.isClosedOrClosing()) {
        this.open().then(resolve);
      }
      else {
        resolve();
      }
    });
  }
  /**
   * Opens the select.
   */
  open() {
    return new Promise((resolve) => {
      const state = this.state.get();
      const { listEl } = state;
      if (!listEl) {
        return;
      }
      // Only a closed select can be opened
      if (!this.isClosedOrClosing()) {
        resolve();
        return;
      }
      this.overlayOutletEl = getOverlayOutletEl();
      this.scrollContainerEl = getScrollContainerEl(this.el);
      // Check if the select is inside a scrollable element.
      // If yes, append the options there to make sure they scroll and aren't
      // detached from the wrapperEl.
      if (this.scrollContainerEl) {
        this.overlayOutletEl = this.scrollContainerEl;
      }
      else {
        this.scrollContainerEl = document.documentElement;
      }
      const isInsideDialog = this.setIsInsideDialog();
      if (isInsideDialog) {
        this.appendTo("dialogEl");
      }
      else {
        // Make options overlap all other content
        this.appendTo("overlayOutlet");
      }
      // Set dimensions
      this.positionListEl();
      this.store.set("display", "opening");
      anime({
        targets: listEl,
        scaleY: 1,
        opacity: 1,
        scrollTop: 0,
        duration: this.getAnimationDuration(),
        easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
        complete: () => {
          this.store.set("display", "open");
          if (listEl) {
            listEl.style.transform = "";
          }
          resolve();
        },
      });
    });
  }
  /**
   * Closes the sdx-select.
   */
  close() {
    return new Promise((resolve) => {
      var _a;
      const state = this.state.get();
      if (state.display !== "open") {
        resolve();
        return;
      }
      (_a = this.dialogEl) === null || _a === void 0 ? void 0 : _a.close();
      this.setFocussedEl(null);
      // Shift focus from input field back to the sdx-select (if filterable).
      // Only an opened Select should be filterable.
      if (isKeyboardBehavior(state, "filter")) {
        this.nonEditableInputEl.doFocus();
      }
      this.store.set("display", "closing");
      anime({
        targets: state.listEl,
        scaleY: 0,
        opacity: 0.2,
        duration: this.getAnimationDuration(),
        easing: "cubicBezier(0.550, 0.085, 0.320, 1)",
        complete: () => {
          if (isKeyboardBehavior(state, "filter")) {
            this.nonEditableInputEl.doFocus();
          }
          this.store.set("display", "closed");
          // Bring options back to the component
          this.appendTo("component");
          state.listEl.style.display = "none";
          resolve();
        },
      });
    });
  }
  /**
   * @private
   * Calls close(), but only when the component is allowed to be closed.
   */
  async requestToClose(e) {
    const { listEl } = this.state.get();
    if (!listEl) {
      return;
    }
    if (e instanceof KeyboardEvent) {
      if (e.key === "Escape") {
        this.close();
      }
      return;
    }
    const didClickOnEl = e.composedPath().includes(this.el);
    const didClickOnListEl = e.composedPath().includes(listEl);
    if (didClickOnEl || didClickOnListEl) {
      return;
    }
    // Clicked somewhere else on window
    this.close();
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.sdxfilter = createEvent(this, "sdxfilter", 7);
    this.invokeSelectCallback = () => null;
    this.invokeChangeCallback = () => null;
    this.invokeFilterCallback = () => null;
    this.invokeFocusCallback = () => null;
    this.invokeBlurCallback = () => null;
    this.isTabDown = false;
    this.componentDidLoadComplete = false;
    this.hadFilterInputElFocus = false;
    this.isReappending = false;
    this.animationDuration = 200;
    this.hasConsumerProvidedListEl = false;
    this.parsedFilterFunction = () => true;
    this.visualViewportResizeHandler = () => {
      // triggered on iOS keyboard toggle
      const { listEl, isInsideDialog } = this.state.get();
      if (!isInsideDialog ||
        this.isClosedOrClosing() ||
        !listEl ||
        !visualViewport) {
        return;
      }
      // user can identify the select if a minimum of 100px are visible
      const minVisibleHeight = 100;
      const spaceMovedUpByiOS = visualViewport.offsetTop;
      // Is listEl overlapped too much by keyboard?
      if (listEl.getBoundingClientRect().top + minVisibleHeight >
        visualViewport.height) {
        listEl.style.maxHeight = "";
        document.documentElement.style.setProperty("--sdx-dialog-window-inner-height", `${visualViewport.height}px`);
      }
      else {
        listEl.style.maxHeight = `${visualViewport.height - listEl.getBoundingClientRect().top}px`;
        // event triggered before offsetTop is getting 0
        if (spaceMovedUpByiOS < 10) {
          setCssVariableWindowInnerHeight();
        }
      }
    };
    // When the selection changes by setting `this.value = [ "one", "two", ... ]`,
    // the selected options will be updated - but syncing back to "this.value" is
    // necessary, as long as `this.value` is valid.
    // These flag control in which way the sync happens.
    this.valueChangedInProgress = false;
    this.filterInputElValueChangedInProgress = false;
    this.selectionChangedInProgress = false;
    this.optionElsDidUpdate = false;
    this.lastScreenOrientationAngle = 0;
    this.state = undefined;
    this.focussed = false;
    this.isChildOfSdxFilter = false;
    this.placeholder = "";
    this.multiple = false;
    this.label = "";
    this.srHint = "";
    this.disabled = false;
    this.loading = false;
    this.keyboardBehavior = "focus";
    this.filterable = false;
    this.maxHeight = undefined;
    this.selectCallback = undefined;
    this.changeCallback = undefined;
    this.filterCallback = undefined;
    this.focusCallback = undefined;
    this.blurCallback = undefined;
    this.noMatchesFoundLabel = "No matches found...";
    this.backgroundTheme = "light";
    this.value = [];
    this.name = undefined;
    this.filterFunction = undefined;
    this.filterMinLength = 3;
    this.filterInputPlaceholder = "Type to filter...";
    this.valid = undefined;
    this.validationMessage = undefined;
    this.required = false;
    this.maxlength = undefined;
    this.animated = true;
    this.store = new StoreConnection(this, selectReducer, getInitialState$1(), [
      "selection",
      "listEl",
      "optionEls",
      "optgroupEls",
      "filter",
      "filterInputElValue",
      "hasFilterInputElFocus",
      "directionX",
      "directionY",
      "display",
      "isInsideDialog",
    ]);
    this.setInvokeSelectCallback();
    this.setInvokeChangeCallback();
    this.setInvokeFilterCallback();
    this.setInvokeFocusCallback();
    this.setInvokeBlurCallback();
    this.setFilterFunction();
    this.store.set("placeholder", this.placeholder);
    this.store.set("multiple", this.multiple);
    this.store.set("required", this.required);
    this.store.set("keyboardBehavior", this.keyboardBehavior);
    this.store.set("animationDuration", this.animated ? this.animationDuration : 0);
    this.store.set("close", this.close.bind(this));
    this.store.set("filterable", this.filterable);
    this.store.set("filterMinLength", this.filterMinLength);
    this.store.set("noMatchesFoundLabel", this.noMatchesFoundLabel);
    this.store.set("filterInputElPlaceholder", this.filterInputPlaceholder);
    this.store.set("name", this.name);
    this.store.set("loading", this.loading);
    this.setIsInsideDialog();
    this.store.flush();
    this.maxAutocompleteOptions = bp("lg")
      ? Select.maxAutocompleteOptionsDesktop
      : Select.maxAutocompleteOptionsMobile;
    this.updateHiddenFormInputEl();
    visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.addEventListener("resize", this.visualViewportResizeHandler);
  }
  connectedCallback() {
    this.store.set("connected", true);
    this.isChildOfSdxFilter = !!closest(this.el, "sdx-filter");
    // The component is being reconnected
    if (this.isReappending) {
      this.store.set("reappending", true);
      this.isReappending = false;
    }
  }
  disconnectedCallback() {
    this.store.set("connected", false);
    // Know that a disconnection happened, maybe because the component was
    // removed, cached or it's being appended to document.body.
    const isStillInDocument = closest(this.el, document.documentElement);
    if (isStillInDocument) {
      this.isReappending = true;
    }
    else {
      visualViewport === null || visualViewport === void 0 ? void 0 : visualViewport.removeEventListener("resize", this.visualViewportResizeHandler);
    }
    // Make sure the component is closed when removed from the DOM
    this.close();
  }
  componentWillLoad() {
    if (this.state.get().listEl) {
      this.hasConsumerProvidedListEl = true;
    }
  }
  componentDidLoad() {
    const { selection, listEl } = this.state.get();
    this.lastScreenOrientationAngle = getScreenOrientationAngle();
    // Now that all children are loaded, sort them now and from now on.
    // Having them sorted from the very beginning makes long lists very slow
    // on Chrome 97 and Safari 15 (but interestingly not on Firefox 95).
    this.store.dispatch({ type: "ACTIVATE_SORT" });
    // Initial selection:
    // If there are options with the "selected" prop, use those.
    // If not, check if there's a "value" and use that instead.
    if (selection.length) {
      const { validatedValues } = this.getByValues(selection.map((el) => el.value));
      this.value = validatedValues;
    }
    else if (this.value.length) {
      // use "value", if any
      const { allValuesValid, validatedValues, optionEls } = this.getByValues(this.value);
      if (allValuesValid && validatedValues.length) {
        this.store.set("selection", optionEls);
      }
    }
    else {
      // fall back by selecting first option
      this.selectFirstOptionElIfNecessary();
    }
    // List element is initially closed
    listEl.style.display = "none";
    listEl.style.opacity = ".2";
    listEl.style.transform = "scaleY(0)";
    this.store.subscribe();
    // All children are now ready
    this.componentDidLoadComplete = true;
  }
  componentDidUpdate() {
    if (this.optionElsDidUpdate) {
      // Apply filter to dynamically added options.
      // This has to happen after render() because the default filter function
      // uses .textContent which doesn't exist before render() in Angular when
      // using {{ text interpolation }}.
      this.showNoMatchesFoundIfNecessary();
      this.optionElsDidUpdate = false;
    }
  }
  selectionChanged(state) {
    this.selectionChangedInProgress = true;
    this.selectFirstOptionElIfNecessary();
    // Update state after possible first selection from above
    state = this.state.get();
    // Update the "value"
    if (!this.valueChangedInProgress) {
      const { validatedValues } = this.getByValues(state.selection.map((el) => el.value));
      this.value = validatedValues;
      if (state.userInteractionInProgress) {
        dispatchEvent(this.el, Select.eventInput);
        this.store.set("userInteractionInProgress", false);
      }
    }
    this.selectionChangedInProgress = false;
  }
  optionElsChanged(state) {
    this.optionElsDidUpdate = true;
    // If new options come in while the component is open, directly append them
    // to the body
    if (state.optionEls.length && this.isOpenOrOpening()) {
      this.appendTo("overlayOutlet");
    }
  }
  filterChanged(state) {
    this.showNoMatchesFoundIfNecessary();
    if (isKeyboardBehavior(state, "filter")) {
      this.invokeFilterCallback(state.filter);
      this.sdxfilter.emit({ keyword: state.filter });
    }
  }
  filterInputElValueChanged(state) {
    this.filterInputElValueChangedInProgress = true;
    if (isKeyboardBehavior(state, "autocomplete")) {
      this.value = [state.filterInputElValue];
      if (state.userInteractionInProgress) {
        dispatchEvent(this.el, Select.eventInput);
      }
    }
    this.filterInputElValueChangedInProgress = false;
  }
  // Appends all options to the body to guarantee visibility (as overlay)
  async appendTo(target) {
    var _a;
    const { display, listEl } = this.state.get();
    this.store.set("reappending", true);
    switch (target) {
      case "overlayOutlet":
        // When the component is already open, the list element is already
        // appended to the body. If it's appended twice, the filter input field
        // loses focus.
        if (display === "closed") {
          appendToOverlayOutlet(listEl, this.overlayOutletEl, this.el);
        }
        if (!this.hasConsumerProvidedListEl) {
          listEl.append(...this.getDirectSlotEls());
        }
        break;
      case "dialogEl":
        appendToOverlayOutlet(listEl, this.dialogContentEl, this.el);
        if (!this.hasConsumerProvidedListEl) {
          listEl.append(...this.getDirectSlotEls());
        }
        // store set reappending=false after all options have been reappended once
        this.store.set("reappending", true);
        await ((_a = this.dialogEl) === null || _a === void 0 ? void 0 : _a.open());
        break;
      default:
        // "component"
        if (this.hasConsumerProvidedListEl) {
          appendToOverlayOutlet(listEl, this.el, this.el);
        }
        else {
          this.el.append(...this.getDirectSlotEls());
          appendToOverlayOutlet(listEl, this.wrapperEl, this.el);
        }
    }
    this.store.set("reappending", false);
  }
  updateHiddenFormInputEl() {
    if (!isKeyboardBehavior(this.state.get(), "autocomplete")) {
      return;
    }
    if (!this.lightDOMHiddenFormInputEl) {
      this.lightDOMHiddenFormInputEl = document.createElement("input");
      this.lightDOMHiddenFormInputEl.type = "hidden";
      this.el.append(this.lightDOMHiddenFormInputEl);
    }
    // Clean up properties added previously in case they've changed
    this.lightDOMHiddenFormInputEl.removeAttribute("name");
    this.lightDOMHiddenFormInputEl.removeAttribute("value");
    if (this.name) {
      this.lightDOMHiddenFormInputEl.name = this.name;
      this.lightDOMHiddenFormInputEl.value = this.value[0] || "";
    }
  }
  // Resets the whole filter system
  resetFilter() {
    this.resetFilterInputEl();
    this.store.dispatch({ type: "SET_FILTER", filter: "" });
  }
  // Parses and injects the "filter-function" prop into the store
  setFilterFunction() {
    this.parsedFilterFunction = this.optionElMatchesFilter;
  }
  // Write the current selection into the filter input field
  resetFilterInputEl() {
    if (!this.isFilterable()) {
      return;
    }
    const state = this.state.get();
    let filterInputElValue = "";
    // For "autocomplete", the filter input field should contain the selected value
    if (isKeyboardBehavior(state, "autocomplete")) {
      filterInputElValue = getFormattedSelection(state.selection);
    }
    this.store.set("filterInputElValue", filterInputElValue);
  }
  positionListEl() {
    const { listEl, isInsideDialog } = this.state.get();
    if (!(this.componentEl && this.wrapperEl && this.scrollContainerEl && listEl)) {
      return;
    }
    if (isInsideDialog) {
      // due to the specificity style must be set here
      listEl.style.display = "block";
      listEl.style.minWidth = "";
      listEl.style.maxHeight = "";
      listEl.style.inset = "";
      listEl.style.transformOrigin = "";
      // stop calculating position because listEl is appended to dialogEl
      return;
    }
    const wrapperElRect = this.wrapperEl.getBoundingClientRect();
    let spaceTowards = {
      bottom: document.documentElement.clientHeight - wrapperElRect.bottom,
      left: wrapperElRect.left,
      right: document.documentElement.clientWidth - wrapperElRect.right,
      top: wrapperElRect.top,
    };
    // Height calculation
    const maxHeightFromProp = this.getMaxHeight();
    listEl.style.maxHeight = maxHeightFromProp || "none";
    let scrollContainerElRect = {
      bottom: 0,
      left: 0,
      right: 0,
      top: 0,
    };
    // If the overlay is inside an offset parent, include all its spacings
    // in the calculation.
    if (this.scrollContainerEl !== document.documentElement) {
      scrollContainerElRect = this.scrollContainerEl.getBoundingClientRect();
      // Subtract wrapperElRect from scrollContainerElRect
      spaceTowards = {
        bottom: scrollContainerElRect.bottom - wrapperElRect.bottom,
        left: wrapperElRect.left - scrollContainerElRect.left,
        right: scrollContainerElRect.right - wrapperElRect.right,
        top: wrapperElRect.top - scrollContainerElRect.top,
      };
    }
    // Show the listEl to take measurements
    listEl.style.display = "block";
    let listElWidth = listEl.clientWidth;
    let listElHeight = listEl.clientHeight;
    let maxHeight = listEl.style.maxHeight;
    // For "autocomplete", clientHeight is always 0, because it doesn't display
    // any options initially. Since that will falsify the positioning
    // calculation, act like the fully allowed number of options is displayed.
    if (isKeyboardBehavior(this.state.get(), "autocomplete")) {
      listElHeight = this.maxAutocompleteOptions * Select.selectHeight;
    }
    let directionX;
    let directionY;
    if (spaceTowards.right - Select.minSpaceToWindow >= listElWidth) {
      // enough space towards right
      directionX = "right";
    }
    else if (spaceTowards.left - Select.minSpaceToWindow >= listElWidth) {
      // enough space towards left
      directionX = "left";
    }
    else if (spaceTowards.left > spaceTowards.right) {
      // not enough space, open towards left
      directionX = "left";
    }
    else {
      // not enough space, open towards right
      directionX = "right";
    }
    if (spaceTowards.bottom - Select.minSpaceToWindow >= listElHeight) {
      // enough space towards bottom
      maxHeight = maxHeightFromProp
        ? maxHeight
        : `${spaceTowards.bottom - Select.minSpaceToWindow}px`;
      directionY = "bottom";
    }
    else if (spaceTowards.top - Select.minSpaceToWindow >= listElHeight) {
      // enough space towards top
      maxHeight = maxHeightFromProp
        ? maxHeight
        : `${spaceTowards.top - Select.minSpaceToWindow}px`;
      directionY = "top";
    }
    else if (spaceTowards.top > spaceTowards.bottom) {
      // not enough space, open towards top
      maxHeight = `${spaceTowards.top - Select.minSpaceToWindow}px`;
      directionY = "top";
    }
    else {
      // not enough space, open towards bottom
      maxHeight = `${spaceTowards.bottom - Select.minSpaceToWindow}px`;
      directionY = "bottom";
    }
    // There should always be a max-height, because even though it has enough
    // space at the time being, it might be that it grows dynamically while
    // being opened, for example by clearing a filter (which will show all
    // options immediately).
    listEl.style.maxHeight = maxHeight;
    // List should never be smaller than its wrapper
    listEl.style.minWidth = `${wrapperElRect.width}px`;
    if (directionX === "right") {
      listEl.style.right = "auto";
      listEl.style.left = `${getScrollTopLeft(this.scrollContainerEl).scrollLeft -
        scrollContainerElRect.left +
        wrapperElRect.left}px`;
    }
    else {
      // "left"
      listEl.style.left = "auto";
      listEl.style.right = `${this.scrollContainerEl.clientWidth -
        getScrollTopLeft(this.scrollContainerEl).scrollLeft +
        scrollContainerElRect.left -
        wrapperElRect.right}px`;
    }
    if (directionY === "bottom") {
      listEl.style.transformOrigin = "50% 0";
      listEl.style.bottom = "auto";
      listEl.style.top = `${getScrollTopLeft(this.scrollContainerEl).scrollTop -
        scrollContainerElRect.top +
        wrapperElRect.bottom -
        1}px`;
      // -1px = border overlap
    }
    else {
      // "top"
      listEl.style.transformOrigin = "0 100%";
      listEl.style.top = "auto";
      listEl.style.bottom = `${this.scrollContainerEl.clientHeight -
        getScrollTopLeft(this.scrollContainerEl).scrollTop +
        scrollContainerElRect.top -
        wrapperElRect.top -
        1}px`;
      // -1px = border overlap
    }
    // Propagate newly calculated direction
    this.store.set("directionX", directionX);
    this.store.set("directionY", directionY);
  }
  // If no "filter-function" is present, fall back to this
  defaultFilterFunction(optionEl, filter) {
    // Skip placeholder and empty options
    if ((filter && optionEl.placeholder) || !optionEl.textContent) {
      return false;
    }
    return optionEl.textContent.toLowerCase().indexOf(filter.toLowerCase()) > -1;
  }
  /**
   * Returns true if an option element matches the filter (e.g. in "ca" in
   * "Car").
   * @param el The option to be tested.
   * @param filter The Filter to be tested.
   */
  optionElMatchesFilter(el, filter) {
    let filterFunction = this.defaultFilterFunction;
    // If a "filter-function" prop has been passed, use this instead
    if (this.filterFunction) {
      filterFunction = parseFunction(this.filterFunction);
    }
    let match = filterFunction(el, filter);
    // When "autocomplete", all options should be hidden if there's no filter,
    // while when "filter", all options should be shown if there's no filter.
    if (isKeyboardBehavior(this.state.get(), "autocomplete") && !filter) {
      match = false;
    }
    return match;
  }
  setFocussedEl(which) {
    const { optionEls, selection } = this.state.get();
    // First, unfocus all
    for (let i = 0; i < optionEls.length; i++) {
      const optionEl = optionEls[i];
      optionEl.classList.remove("focus");
    }
    // If no element is to be selected, clear and abort
    if (which === null) {
      delete this.focussedEl;
      return;
    }
    if (which === "previous" || which === "next") {
      const lastSelectedEl = selection[selection.length - 1];
      // If there's no currently focussed element, start from the last selected element
      let focussedEl = this.focussedEl || lastSelectedEl;
      // If there's a focussed element, but is hidden, start from the first option
      if ((focussedEl === null || focussedEl === void 0 ? void 0 : focussedEl.style.display) === "none") {
        focussedEl = optionEls[0];
      }
      if (which === "previous") {
        let prevEl = getPreviousFromList(optionEls, focussedEl);
        let count = 0;
        while (prevEl !== focussedEl &&
          (prevEl.disabled || prevEl.style.display === "none") &&
          count < optionEls.length) {
          prevEl = getPreviousFromList(optionEls, prevEl);
          count++;
        }
        this.focussedEl = prevEl;
      }
      else {
        // "next"
        let nextEl = getNextFromList(optionEls, focussedEl);
        let count = 0;
        while (nextEl !== focussedEl &&
          (nextEl.disabled || nextEl.style.display === "none") &&
          count < optionEls.length) {
          nextEl = getNextFromList(optionEls, nextEl);
          count++;
        }
        this.focussedEl = nextEl;
      }
    }
    else {
      // "which" is an element
      this.focussedEl = which;
    }
    if (this.focussedEl) {
      this.focussedEl.classList.add("focus");
      this.scrollToOption(this.focussedEl);
    }
  }
  /**
   * Scrolls the list the way that an option is visible in the center.
   */
  scrollToOption(option) {
    const parent = this.state.get().listEl;
    const optionRect = option.getBoundingClientRect();
    const parentRect = parent.getBoundingClientRect();
    const isFullyVisible = optionRect.top >= parentRect.top &&
      optionRect.bottom <= parentRect.top + parent.clientHeight;
    if (!isFullyVisible) {
      parent.scrollTop = optionRect.top + parent.scrollTop - parentRect.top;
    }
  }
  /**
   * Returns all options starting with a certain letter.
   * @param letter Key value to look for.
   */
  getOptionElsByFirstLetter(letter) {
    var _a;
    const { optionEls } = this.state.get();
    const results = [];
    for (let i = 0; i < optionEls.length; i++) {
      const option = optionEls[i];
      if (((_a = option.textContent) === null || _a === void 0 ? void 0 : _a.toLowerCase().charAt(0)) === letter) {
        results.push(option);
      }
    }
    return results;
  }
  /**
   * Sets the focussed option starting by a given letter.
   * @param letter Key value to look for.
   */
  setFocussedElByFirstLetter(letter) {
    const optionsByFirstLetter = this.getOptionElsByFirstLetter(letter);
    if (optionsByFirstLetter.length) {
      let startIndex = 0;
      if (this.focussedEl) {
        const focussedElIndex = optionsByFirstLetter.indexOf(this.focussedEl);
        if (focussedElIndex > -1) {
          startIndex = focussedElIndex;
        }
      }
      let option = optionsByFirstLetter[startIndex];
      if (option.disabled || option === this.focussedEl) {
        for (let i = 0; i < optionsByFirstLetter.length; i++) {
          option = getNextFromList(optionsByFirstLetter, optionsByFirstLetter[startIndex]);
          if (option.disabled) {
            option = null;
          }
          else {
            break;
          }
          // Look behind
          if (startIndex < optionsByFirstLetter.length) {
            startIndex++;
          }
          else {
            startIndex = 0;
          }
        }
      }
      if (option) {
        this.setFocussedEl(option);
      }
    }
  }
  setInvokeSelectCallback() {
    this.invokeSelectCallback = parseFunction(this.selectCallback);
  }
  setInvokeChangeCallback() {
    this.invokeChangeCallback = parseFunction(this.changeCallback);
  }
  setInvokeFilterCallback() {
    this.invokeFilterCallback = parseFunction(this.filterCallback);
  }
  setInvokeFocusCallback() {
    this.invokeFocusCallback = parseFunction(this.focusCallback);
  }
  setInvokeBlurCallback() {
    this.invokeBlurCallback = parseFunction(this.blurCallback);
  }
  /**
   * Checks if an array of values is valid and create a valid version of it.
   * For convenience, all options matching the values will also be returned.
   */
  getByValues(values) {
    if (Array.isArray(values)) {
      if (!values.length) {
        // Nothing to do, don't replace [] with [] because of change detection
        return { allValuesValid: true, validatedValues: values, optionEls: [] };
      }
      // Filter out undefined values
      const definedValues = values.filter((value) => value !== undefined);
      if (!definedValues.length) {
        // Either only undefined values or completely empty
        return { allValuesValid: false, validatedValues: [], optionEls: [] };
      }
      const validatedValues = [];
      const foundOptionEls = [];
      const { optionEls } = this.state.get();
      let isValid = true;
      // Check if values exist in the options
      for (let i = 0; i < definedValues.length; i++) {
        const value = definedValues[i];
        const foundOptionEl = optionEls.find((el) => el.value === value);
        if (foundOptionEl) {
          if (this.multiple || (!this.multiple && i === 0)) {
            foundOptionEls.push(foundOptionEl);
            validatedValues.push(foundOptionEl.value);
          }
          else {
            // Single select should only respect one value
            isValid = false;
          }
        }
      }
      if (validatedValues.length === 0) {
        // no values found
        return {
          allValuesValid: false,
          validatedValues,
          optionEls: foundOptionEls,
        };
      }
      return {
        allValuesValid: isValid,
        validatedValues,
        optionEls: foundOptionEls,
      };
    }
    // All non-array types will be reset (to an empty array)
    return { allValuesValid: false, validatedValues: [], optionEls: [] };
  }
  // If there are options, but no selection, and no placeholder,
  // fall back by selecting first option
  selectFirstOptionElIfNecessary() {
    const { optionEls, selection, placeholder, multiple, keyboardBehavior } = this.state.get();
    if (optionEls.length &&
      !selection.length &&
      !placeholder &&
      !multiple &&
      keyboardBehavior !== "autocomplete") {
      const optionsNotDisabled = optionEls.filter((option) => !option.disabled);
      if (optionsNotDisabled.length === 0) {
        return;
      }
      this.store.set("selection", [optionsNotDisabled[0]]);
    }
  }
  showNoMatchesFoundIfNecessary() {
    const { optionEls, optgroupEls, filter, selection } = this.state.get();
    let matches = 0;
    optionEls.forEach((optionEl) => {
      let display;
      if (this.parsedFilterFunction(optionEl, filter)) {
        matches++;
        display = "";
      }
      else {
        display = "none";
      }
      // For "autocomplete", display only a certain number of option elements (for UX)
      if (isKeyboardBehavior(this.state.get(), "autocomplete")) {
        if (matches > this.maxAutocompleteOptions) {
          display = "none";
        }
      }
      optionEl.style.display = display;
    });
    optgroupEls.forEach((optgroupEl) => {
      let match = false;
      for (let optionEl of optgroupEl.querySelectorAll("sdx-select-option")) {
        if (optionEl.style.display === "") {
          match = true;
          break;
        }
      }
      optgroupEl.style.display = match ? "" : "none";
    });
    let noMatchesFound = isValidFilter(filter, selection, this.filterMinLength) &&
      matches === 0 &&
      !this.loading;
    this.store.set("noMatchesFound", noMatchesFound);
  }
  // Returns optionEls and optgroupEls directly descending from <sdx-select>,
  // sorted by their appearance in the DOM tree to avoid having all options
  // first and all optgroups last.
  getDirectSlotEls() {
    const { optionEls, optgroupEls } = this.state.get();
    return [
      ...optionEls.filter((el // skip placeholder and options within optgroups
      ) => !el.placeholder && !closest(el, "sdx-select-optgroup")),
      ...optgroupEls,
    ].sort(sortByAppearanceInDomTree);
  }
  onHeaderClick(e) {
    const targetEl = e.target;
    const didClickOnSdxInputEl = !!closest(targetEl, this.filterInputEl);
    if (this.isFilterable() &&
      this.isOpenOrOpening() &&
      didClickOnSdxInputEl &&
      !this.hadFilterInputElFocus) ;
    else {
      this.toggle();
    }
    this.hadFilterInputElFocus = this.state.get().hasFilterInputElFocus;
  }
  onAutocompleteFocus() {
    this.store.set("hasFilterInputElFocus", true);
    this.invokeFocusCallback();
  }
  onAutocompleteBlur() {
    this.store.set("hasFilterInputElFocus", false);
    this.invokeBlurCallback();
  }
  onAutocompleteInput(e) {
    const value = e.target.value;
    this.store.set("filterInputElValue", value);
    this.store.dispatch({ type: "SET_FILTER", filter: value });
    // Debounced
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer);
    }
    this.resizeTimer = setTimeout(() => {
      if (isFilterLongEnough(value, this.filterMinLength)) {
        this.open();
      }
      else {
        this.close();
      }
    }, this.state.get().animationDuration); // can be controlled using animated="false"
  }
  /**
   * True if this sdx-select is filterable using a filter input field.
   */
  isFilterable() {
    const state = this.state.get();
    return (isKeyboardBehavior(state, "filter") ||
      isKeyboardBehavior(state, "autocomplete"));
  }
  hasVisibleOptionEls() {
    return this.state
      .get()
      .optionEls.some((optioneEl) => optioneEl.style.display !== "none");
  }
  isOpenOrOpening() {
    const { display } = this.state.get();
    return display === "open" || display === "opening";
  }
  isClosedOrClosing() {
    const { display } = this.state.get();
    return display === "closed" || display === "closing";
  }
  isListOverlapping() {
    const { listEl } = this.state.get();
    if (!(listEl && this.wrapperEl)) {
      return false;
    }
    return listEl.clientWidth > this.wrapperEl.clientWidth;
  }
  /**
   * Normalizes max-height prop, e.g.:
   * 200 => "200px"
   * "50vh" => "50vh"
   */
  getMaxHeight() {
    // No max-height prop given
    if (!this.maxHeight) {
      return;
    }
    // If number, add "px"
    if (Number(this.maxHeight)) {
      return `${this.maxHeight}px`;
    }
    // Unit is already given
    return String(this.maxHeight); // TS bug? String() shouldn't be needed because of above Number()
  }
  setIsInsideDialog() {
    const newIsInsideDialog = !bp("sm") && this.keyboardBehavior !== "autocomplete";
    this.store.set("isInsideDialog", newIsInsideDialog);
    return newIsInsideDialog;
  }
  getDefaultInputFieldProps() {
    return {
      disabled: this.disabled,
      valid: this.valid,
      srHint: `${this.label} ${this.srHint} ${this.validationMessage}`,
      required: this.required,
    };
  }
  getComponentClassNames() {
    const { display, directionX, directionY } = this.state.get();
    return {
      component: true,
      focus: this.focussed,
      loading: this.loading,
      disabled: this.disabled,
      invalid: this.valid === false,
      filterable: this.isFilterable(),
      autocomplete: isKeyboardBehavior(this.state.get(), "autocomplete"),
      "is-list-overlapping": this.isListOverlapping(),
      [this.backgroundTheme]: true,
      [getAppearance(this.el)]: true,
      [display]: true,
      [directionX]: true,
      [directionY]: true,
    };
  }
  getLabelClassNames() {
    return {
      label: true,
      [getAppearance(this.el)]: true,
    };
  }
  getDefaultInputFieldStyle() {
    const state = this.state.get();
    const { isInsideDialog } = state;
    const notClosed = state.display !== "closed";
    const openTowardsTop = state.directionY === "top";
    const openTowardsBottom = state.directionY === "bottom";
    const notClosedTowardsTop = notClosed && openTowardsTop && !isInsideDialog;
    const notClosedTowardsBottom = notClosed && openTowardsBottom && !isInsideDialog;
    // Provide enough space for chevron or loading spinner
    const paddingRight = isKeyboardBehavior(state, "autocomplete") && !this.loading
      ? undefined
      : "40px";
    return {
      paddingRight,
      borderTopLeftRadius: notClosedTowardsTop ? "0" : "",
      borderTopRightRadius: notClosedTowardsTop ? "0" : "",
      borderBottomLeftRadius: notClosedTowardsBottom ? "0" : "",
      borderBottomRightRadius: notClosedTowardsBottom ? "0" : "",
    };
  }
  getAnimationDuration() {
    const { isInsideDialog, animationDuration } = this.state.get();
    return isInsideDialog ? 0 : animationDuration;
  }
  render() {
    const state = this.state.get();
    const appearance = getAppearance(this.el);
    return (hAsync(Host, { "aria-expanded": (state.display === "open").toString() }, hAsync("div", { class: this.getComponentClassNames(), ref: (el) => (this.componentEl = el) }, !this.isChildOfSdxFilter && this.label && (
    // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
    hAsync("label", { class: this.getLabelClassNames(), onClick: () => this.toggle() }, this.label, this.required && hAsync("span", { "aria-hidden": "true" }, "\u00A0*"))), hAsync("div", { class: "wrapper", ref: (el) => (this.wrapperEl = el) }, hAsync("div", { class: "header-wrapper" }, hAsync("div", { class: "header", onClick: (e) => this.onHeaderClick(e) }, hAsync("div", { class: "selection" }, isKeyboardBehavior(state, "autocomplete") ? (hAsync("sdx-input", { ...this.getDefaultInputFieldProps(), class: "autocomplete-input", value: state.filterInputElValue, placeholder: this.placeholder, maxlength: this.maxlength, editable: true, inputStyle: this.getDefaultInputFieldStyle(), onInput: (e) => this.onAutocompleteInput(e), onFocus: () => this.onAutocompleteFocus(), onBlur: () => this.onAutocompleteBlur(), ref: (el) => (this.filterInputEl = el) })) : (hAsync("sdx-input", { ...this.getDefaultInputFieldProps(), value: (this.isChildOfSdxFilter && this.label) ||
        getFormattedSelection(state.selection) ||
        this.placeholder, badge: this.multiple && state.selection.length
        ? state.selection.length.toString()
        : undefined, ref: (el) => (this.nonEditableInputEl = el), editable: false, valid: this.valid, inputStyle: {
        ...this.getDefaultInputFieldStyle(),
        borderColor: this.isOpenOrOpening()
          ? appearance === "sdx--light-theme"
            ? "#086adb" // $color-int-blue
            : "#4294FF" // $color-blue-int-3-dark-theme
          : "",
        color: this.isOpenOrOpening()
          ? appearance === "sdx--light-theme"
            ? "#1781e3" // $color-azure
            : "#4294FF" // $color-blue-int-3-dark-theme
          : "",
      } }))), (!isKeyboardBehavior(state, "autocomplete") ||
      this.loading) && (hAsync("div", { class: "thumb", "aria-live": "polite" }, this.loading ? (hAsync("sdx-loading-spinner", { srHint: this.srHint ? this.srHint : undefined, strokeInherit: true })) : (hAsync("div", { class: "icon" })))))), this.hasConsumerProvidedListEl ? (hAsync("slot", null)) : (hAsync("sdx-select-list", null, hAsync("slot", null)))), this.validationMessage && (hAsync("sdx-validation-message", { validationMessage: this.validationMessage }))), hAsync("sdx-dialog", { ref: (el) => (this.dialogEl = el), label: this.label, type: "closable-modal", animated: this.animated, onSdxdisplaychange: (e) => {
        var _a, _b;
        if (((_a = e.detail) === null || _a === void 0 ? void 0 : _a.display) === "closing") {
          // needed because closing the dialog triggers disconnect
          // of sdx-select-option
          this.store.set("reappending", true);
        }
        if (((_b = e.detail) === null || _b === void 0 ? void 0 : _b.display) === "closed") {
          this.close();
        }
      } }, hAsync("sdx-dialog-content", { fixedHeight: true, ref: (el) => (this.dialogContentEl = el) }))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "state": ["stateChanged"],
    "value": ["valueChanged"],
    "filterable": ["filterableChanged"],
    "filterInputPlaceholder": ["filterInputPlaceholderChanged"],
    "filterMinLength": ["filterMinLengthChanged"],
    "noMatchesFoundLabel": ["noMatchesFoundLabelChanged"],
    "selectCallback": ["selectCallbackChanged"],
    "changeCallback": ["changeCallbackChanged"],
    "filterCallback": ["filterCallbackChanged"],
    "focusCallback": ["focusCallbackChanged"],
    "blurCallback": ["blurCallbackChanged"],
    "placeholder": ["placeholderChanged"],
    "name": ["nameChanged"],
    "filterFunction": ["filterFunctionChanged"],
    "multiple": ["multipleChanged"],
    "required": ["requiredChanged"],
    "keyboardBehavior": ["keyboardBehaviorChanged"],
    "loading": ["loadingChanged"]
  }; }
  static get style() { return selectCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-select",
    "$members$": {
      "placeholder": [1],
      "multiple": [4],
      "label": [1],
      "srHint": [1, "sr-hint"],
      "disabled": [4],
      "loading": [4],
      "keyboardBehavior": [1, "keyboard-behavior"],
      "filterable": [4],
      "maxHeight": [8, "max-height"],
      "selectCallback": [1, "select-callback"],
      "changeCallback": [1, "change-callback"],
      "filterCallback": [1, "filter-callback"],
      "focusCallback": [1, "focus-callback"],
      "blurCallback": [1, "blur-callback"],
      "noMatchesFoundLabel": [1, "no-matches-found-label"],
      "backgroundTheme": [1, "background-theme"],
      "value": [1040],
      "name": [1],
      "filterFunction": [1, "filter-function"],
      "filterMinLength": [2, "filter-min-length"],
      "filterInputPlaceholder": [1, "filter-input-placeholder"],
      "valid": [4],
      "validationMessage": [1, "validation-message"],
      "required": [4],
      "maxlength": [2],
      "animated": [4],
      "state": [32],
      "focussed": [32],
      "isChildOfSdxFilter": [32],
      "getSelection": [64],
      "toggle": [64],
      "open": [64],
      "close": [64],
      "requestToClose": [64]
    },
    "$listeners$": [[8, "keydown", "onWindowKeyDown"], [8, "keyup", "onWindowKeyUp"], [0, "focus", "onFocus"], [0, "blur", "onBlur"], [10, "click", "onWindowClick"], [11, "touchend", "onWindowClick"], [9, "resize", "onWindowResize"], [8, "keydown", "onKeyDown"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}
Select.maxAutocompleteOptionsMobile = 5;
Select.maxAutocompleteOptionsDesktop = 10;
Select.minSpaceToWindow = 24; // $baseline-3
Select.selectHeight = 48; // $select-height
/**
 * Emitted whenever the user is selecting an option or typing while
 * `keyboard-behavior="autocomplete"`.
 * @event
 */
Select.eventInput = "input";
/**
 * Emitted when the input gets focus.
 * Used when `keyboard-behavior="filter"` or `keyboard-behavior="autocomplete"`.
 * @event
 */
// @ts-ignore just for documentation purposes
Select.eventFocus = "focus";
/**
 * Emitted when the input loses focus.
 * Used when `keyboard-behavior="filter"` or `keyboard-behavior="autocomplete"`.
 * @event
 */
// @ts-ignore just for documentation purposes
Select.eventBlur = "blur";

const selectListCss = "/*!@:root*/.sc-sdx-select-list:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-select-list-h,*.sc-sdx-select-list,*.sc-sdx-select-list:before,*.sc-sdx-select-list:after{box-sizing:border-box}/*!@:host*/.sc-sdx-select-list-h{-webkit-overflow-scrolling:touch;overflow-y:auto;position:absolute;backface-visibility:hidden;background:#fff;z-index:999999;border-radius:5px}/*!@:host(:not(.inside-dialog))*/.sc-sdx-select-list-h:not(.inside-dialog){box-shadow:0 0 4px 0 rgba(51, 51, 51, 0.1), inset 0 0 0 1px #adadad}/*!@:host(:not(.inside-dialog)) .filter-input-wrapper*/.sc-sdx-select-list-h:not(.inside-dialog) .filter-input-wrapper.sc-sdx-select-list{padding:8px}/*!@:host(.inside-dialog)*/.inside-dialog.sc-sdx-select-list-h{position:unset;margin-top:-14px}/*!@:host(.inside-dialog) .filter-input-wrapper*/.inside-dialog.sc-sdx-select-list-h .filter-input-wrapper.sc-sdx-select-list{padding-bottom:8px}/*!@:host(:focus)*/.sc-sdx-select-list-h:focus{outline:none}/*!@:host(:not(.inside-dialog).open.top),\n:host(:not(.inside-dialog).opening.top)*/.sc-sdx-select-list-h:not(.inside-dialog).open.top,.sc-sdx-select-list-h:not(.inside-dialog).opening.top{border-top:1px solid #d6d6d6}/*!@:host(:not(.inside-dialog).open.top) .component .filter-input-wrapper,\n:host(:not(.inside-dialog).opening.top) .component .filter-input-wrapper*/.sc-sdx-select-list-h:not(.inside-dialog).open.top .component.sc-sdx-select-list .filter-input-wrapper.sc-sdx-select-list,.sc-sdx-select-list-h:not(.inside-dialog).opening.top .component.sc-sdx-select-list .filter-input-wrapper.sc-sdx-select-list{border-bottom:1px solid #adadad}/*!@:host(:not(.inside-dialog).open.bottom),\n:host(:not(.inside-dialog).opening.bottom)*/.sc-sdx-select-list-h:not(.inside-dialog).open.bottom,.sc-sdx-select-list-h:not(.inside-dialog).opening.bottom{border-bottom:1px solid #d6d6d6}/*!@:host(.bottom)*/.bottom.sc-sdx-select-list-h{border-radius:0 0 5px 5px}/*!@:host(.top)*/.top.sc-sdx-select-list-h{border-radius:5px 5px 0 0}/*!@:host(.is-list-overlapping.bottom.right)*/.is-list-overlapping.bottom.right.sc-sdx-select-list-h{border-top-right-radius:5px}/*!@:host(.is-list-overlapping.bottom.left)*/.is-list-overlapping.bottom.left.sc-sdx-select-list-h{border-top-left-radius:5px}/*!@:host(.is-list-overlapping.top.right)*/.is-list-overlapping.top.right.sc-sdx-select-list-h{border-bottom-right-radius:5px}/*!@:host(.is-list-overlapping.top.left)*/.is-list-overlapping.top.left.sc-sdx-select-list-h{border-bottom-left-radius:5px}/*!@.component .no-matches-found*/.component.sc-sdx-select-list .no-matches-found.sc-sdx-select-list{height:48px;display:flex;align-items:center;padding:0 8px;color:#cf4a0c}/*!@:host(.sdx--dark-theme)*/.sdx--dark-theme.sc-sdx-select-list-h{background:#1d1d1d;box-shadow:0 0 4px 0 rgba(66, 148, 255, 0.1), inset 0 0 0 1px #4294ff}/*!@:host(.sdx--dark-theme.inside-dialog)*/.sdx--dark-theme.inside-dialog.sc-sdx-select-list-h{background:transparent;box-shadow:unset}/*!@:host(.open.top.sdx--dark-theme),\n:host(.opening.top.sdx--dark-theme)*/.open.top.sdx--dark-theme.sc-sdx-select-list-h,.opening.top.sdx--dark-theme.sc-sdx-select-list-h{border-top-color:#4294ff}/*!@:host(.open.top.sdx--dark-theme) .component .filter-input-wrapper,\n:host(.opening.top.sdx--dark-theme) .component .filter-input-wrapper*/.open.top.sdx--dark-theme.sc-sdx-select-list-h .component.sc-sdx-select-list .filter-input-wrapper.sc-sdx-select-list,.opening.top.sdx--dark-theme.sc-sdx-select-list-h .component.sc-sdx-select-list .filter-input-wrapper.sc-sdx-select-list{border-bottom-color:#707070}/*!@:host(.open.bottom.sdx--dark-theme),\n:host(.opening.bottom.sdx--dark-theme)*/.open.bottom.sdx--dark-theme.sc-sdx-select-list-h,.opening.bottom.sdx--dark-theme.sc-sdx-select-list-h{border-bottom-color:#4294ff}/*!@.component.sdx--dark-theme .no-matches-found*/.component.sdx--dark-theme.sc-sdx-select-list .no-matches-found.sc-sdx-select-list{color:#f26726}";

/**
 * This Web Component serves only to allow to append the list of options to the
 * body in order to overlap every thing else (overlaying).
 */
class SelectList {
  stateChanged({}, prev) {
    const state = this.state.get();
    const prevState = prev.get();
    if (state.display !== prevState.display) {
      this.displayChanged(state);
    }
  }
  /**
   * @private
   */
  async doFocus() {
    var _a;
    (_a = this.filterInputEl) === null || _a === void 0 ? void 0 : _a.doFocus();
  }
  /**
   * @private
   */
  async doBlur() {
    this.filterInputEl.doBlur();
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.state = undefined;
    this.store = new StoreConnection(this, selectReducer, getInitialState$1(), [
      "selection",
      "optionEls",
      "multiple",
      "directionY",
      "listEl",
      "keyboardBehavior",
      "filter",
      "filterInputElValue",
      "filterInputElPlaceholder",
      "filterMinLength",
      "noMatchesFound",
      "noMatchesFoundLabel",
      "placeholder",
      "required",
      "display",
      "loading",
      "isInsideDialog",
    ]);
  }
  connectedCallback() {
    // Register self
    this.store.set("listEl", this.el);
  }
  componentDidLoad() {
    this.store.subscribe();
  }
  displayChanged(state) {
    if (state.display === "opening") {
      // Was the placeholder displayed when opening?
      this.hadPlaceholderWhenOpened = this.showPlaceholder();
    }
    else if (state.display === "closed") {
      this.hadPlaceholderWhenOpened = undefined;
    }
  }
  /**
   * Determines whether the placeholder option should be rendered:
   *  - when no selection is in progress (UX: list should not grow while open),
   *  - when something is selected,
   *  - the placeholder prop exists
   *  - and when single select
   */
  showPlaceholder() {
    const { selection, placeholder, multiple, required } = this.state.get();
    let showPlaceholder = !!selection.length && !!placeholder && !multiple && !required;
    if (this.hadPlaceholderWhenOpened !== undefined) {
      showPlaceholder = this.hadPlaceholderWhenOpened;
    }
    return showPlaceholder;
  }
  onFilterInput(e) {
    const value = e.target.value;
    this.store.set("filterInputElValue", value);
    this.store.dispatch({ type: "SET_FILTER", filter: value });
  }
  onFilterFocus() {
    this.store.set("hasFilterInputElFocus", true);
  }
  onFilterBlur() {
    this.store.set("hasFilterInputElFocus", false);
  }
  getHostClassNames() {
    const { display, directionY, isInsideDialog } = this.state.get();
    return {
      [getAppearance(this.el)]: true,
      [display]: true,
      ...computedProperty(directionY),
      "inside-dialog": isInsideDialog,
    };
  }
  render() {
    const state = this.state.get();
    return (hAsync(Host, { tabindex: "-1", class: this.getHostClassNames() }, hAsync("div", { class: "component" }, isKeyboardBehavior(state, "filter") && (hAsync("div", { class: "filter-input-wrapper" }, hAsync("sdx-input", { class: "filter-input", value: state.filterInputElValue, placeholder: state.filterInputElPlaceholder, selectTextOnFocus: true, clearable: true, onInput: (e) => this.onFilterInput(e), onFocus: () => this.onFilterFocus(), onBlur: () => this.onFilterBlur(), ref: (el) => (this.filterInputEl = el) }))), this.showPlaceholder() && (hAsync("sdx-select-option", { placeholder: true }, state.placeholder)), hAsync("slot", null), hAsync("div", { class: "no-matches-found", style: { display: state.noMatchesFound ? "flex" : "none" } }, hAsync("sdx-icon", { "icon-name": "icon-exclamation-mark", size: 2 }), state.noMatchesFoundLabel))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "state": ["stateChanged"]
  }; }
  static get style() { return selectListCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-select-list",
    "$members$": {
      "state": [32],
      "doFocus": [64],
      "doBlur": [64]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const selectOptgroupCss = "/*!@:root*/.sc-sdx-select-optgroup:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-select-optgroup-h,*.sc-sdx-select-optgroup,*.sc-sdx-select-optgroup:before,*.sc-sdx-select-optgroup:after{box-sizing:border-box}/*!@:host(:not(.inside-dialog)) .component*/.sc-sdx-select-optgroup-h:not(.inside-dialog) .component.sc-sdx-select-optgroup{border-top:1px solid #adadad;border-bottom:1px solid #adadad}/*!@:host(:not(.inside-dialog)) .component .name*/.sc-sdx-select-optgroup-h:not(.inside-dialog) .component.sc-sdx-select-optgroup .name.sc-sdx-select-optgroup{padding:0 16px;border-left:1px solid #adadad;border-right:1px solid #adadad}/*!@:host(:not(.inside-dialog)) .component.sdx--dark-theme*/.sc-sdx-select-optgroup-h:not(.inside-dialog) .component.sdx--dark-theme.sc-sdx-select-optgroup{border-top-color:#707070;border-bottom-color:#707070}/*!@:host(:not(.inside-dialog)) .component.sdx--dark-theme .name*/.sc-sdx-select-optgroup-h:not(.inside-dialog) .component.sdx--dark-theme.sc-sdx-select-optgroup .name.sc-sdx-select-optgroup{border-left-color:#4294ff;border-right-color:#4294ff}/*!@:host*/.sc-sdx-select-optgroup-h{display:block}/*!@:host ::slotted(sdx-select-option)*/.sc-sdx-select-optgroup-h .sc-sdx-select-optgroup-s>sdx-select-option{border-top:none;border-bottom:none}/*!@:host ::slotted(sdx-select-option:not(.multiple):not(.inside-dialog))*/.sc-sdx-select-optgroup-h .sc-sdx-select-optgroup-s>sdx-select-option:not(.multiple):not(.inside-dialog){padding-left:16px}/*!@:host .component.top*/.sc-sdx-select-optgroup-h .component.top.sc-sdx-select-optgroup{border-top:none}/*!@:host .component.bottom*/.sc-sdx-select-optgroup-h .component.bottom.sc-sdx-select-optgroup{border-bottom:none}/*!@:host .component .name*/.sc-sdx-select-optgroup-h .component.sc-sdx-select-optgroup .name.sc-sdx-select-optgroup{font-weight:600;display:flex;align-items:center;white-space:nowrap;height:48px}";

class SelectOptGroup {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.state = undefined;
    this.name = "";
    this.store = new StoreConnection(this, selectReducer, getInitialState$1(), [
      "directionX",
      "directionY",
      "filter",
    ]);
  }
  connectedCallback() {
    var _a;
    // Don't do anything while the component is being reappended (maybe
    // because it's being appended to document.body), but send a "ping" for
    // each child (sdx-select-optgroup).
    // After each child is has finished, "reappending" will be marked "done" by
    // the store.
    if (this.state.get().reappending) {
      (_a = this.store) === null || _a === void 0 ? void 0 : _a.dispatch({ type: "UPDATE_REAPPENDING" });
      return;
    }
    // Register self
    this.store.dispatch({
      type: "ADD_OPTGROUP_EL",
      optgroupEl: this.el,
    });
  }
  disconnectedCallback() {
    // See connectedCallback() for explanation
    if (this.state.get().reappending) {
      return;
    }
    // Unregister self
    this.store.dispatch({
      type: "REMOVE_OPTGROUP_EL",
      optgroupEl: this.el,
    });
  }
  componentDidLoad() {
    this.store.subscribe();
  }
  getHostClassNames() {
    const { isInsideDialog } = this.state.get();
    return {
      "inside-dialog": isInsideDialog,
    };
  }
  getComponentClassNames() {
    return {
      ...computedProperty(this.state.get().directionY),
      component: true,
      [getAppearance(this.el)]: true,
    };
  }
  render() {
    return (hAsync(Host, { class: this.getHostClassNames() }, hAsync("div", { class: this.getComponentClassNames() }, this.name && hAsync("div", { class: "name" }, this.name), hAsync("slot", null))));
  }
  get el() { return getElement(this); }
  static get style() { return selectOptgroupCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-select-optgroup",
    "$members$": {
      "name": [1],
      "state": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const selectOptionCss = "/*!@:root*/.sc-sdx-select-option:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-select-option-h,*.sc-sdx-select-option,*.sc-sdx-select-option:before,*.sc-sdx-select-option:after{box-sizing:border-box}/*!@.input.checkbox:hover input:not(:disabled).focus + label::before, .input.checkbox:hover input:not(:disabled):checked + label::before, .input.radio:hover input:not(:disabled).focus + label::before, .input.radio:hover input:not(:disabled):checked + label::before*/.input.checkbox.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled).focus+label.sc-sdx-select-option::before,.input.checkbox.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled):checked+label.sc-sdx-select-option::before,.input.radio.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled).focus+label.sc-sdx-select-option::before,.input.radio.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled):checked+label.sc-sdx-select-option::before{border-color:#0048cf}/*!@.input.checkbox:hover input:not(:disabled):checked + label::after, .input.radio:hover input:not(:disabled):checked + label::after*/.input.checkbox.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled):checked+label.sc-sdx-select-option::after,.input.radio.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled):checked+label.sc-sdx-select-option::after{transform:scale(1);border-color:#0048cf;color:#0048cf}/*!@.input.checkbox:hover input:not(:disabled) + label::before, .input.radio:hover input:not(:disabled) + label::before*/.input.checkbox.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled)+label.sc-sdx-select-option::before,.input.radio.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled)+label.sc-sdx-select-option::before{border-color:#333}/*!@.input.checkbox:hover input:not(:disabled) + label::after, .input.radio:hover input:not(:disabled) + label::after*/.input.checkbox.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled)+label.sc-sdx-select-option::after,.input.radio.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled)+label.sc-sdx-select-option::after{transform:scale(0.5)}/*!@.input.checkbox input, .input.radio input*/.input.checkbox.sc-sdx-select-option input.sc-sdx-select-option,.input.radio.sc-sdx-select-option input.sc-sdx-select-option{position:absolute;visibility:hidden}/*!@.input.checkbox input.invalid + label::before, .input.radio input.invalid + label::before*/.input.checkbox.sc-sdx-select-option input.invalid.sc-sdx-select-option+label.sc-sdx-select-option::before,.input.radio.sc-sdx-select-option input.invalid.sc-sdx-select-option+label.sc-sdx-select-option::before{border-color:#d12}/*!@.input.checkbox input.focus + label::before, .input.checkbox input:checked + label::before, .input.radio input.focus + label::before, .input.radio input:checked + label::before*/.input.checkbox.sc-sdx-select-option input.focus.sc-sdx-select-option+label.sc-sdx-select-option::before,.input.checkbox.sc-sdx-select-option input.sc-sdx-select-option:checked+label.sc-sdx-select-option::before,.input.radio.sc-sdx-select-option input.focus.sc-sdx-select-option+label.sc-sdx-select-option::before,.input.radio.sc-sdx-select-option input.sc-sdx-select-option:checked+label.sc-sdx-select-option::before{border-color:#086adb}/*!@.input.checkbox input:checked + label::after, .input.radio input:checked + label::after*/.input.checkbox.sc-sdx-select-option input.sc-sdx-select-option:checked+label.sc-sdx-select-option::after,.input.radio.sc-sdx-select-option input.sc-sdx-select-option:checked+label.sc-sdx-select-option::after{transform:scale(1);border-color:#086adb;color:#086adb}/*!@.input.checkbox input:disabled + label, .input.radio input:disabled + label*/.input.checkbox.sc-sdx-select-option input.sc-sdx-select-option:disabled+label.sc-sdx-select-option,.input.radio.sc-sdx-select-option input.sc-sdx-select-option:disabled+label.sc-sdx-select-option{color:#bbb}/*!@.input.checkbox input:disabled + label::before, .input.radio input:disabled + label::before*/.input.checkbox.sc-sdx-select-option input.sc-sdx-select-option:disabled+label.sc-sdx-select-option::before,.input.radio.sc-sdx-select-option input.sc-sdx-select-option:disabled+label.sc-sdx-select-option::before{border-color:#bbb}/*!@.input.checkbox input:disabled + label::after, .input.radio input:disabled + label::after*/.input.checkbox.sc-sdx-select-option input.sc-sdx-select-option:disabled+label.sc-sdx-select-option::after,.input.radio.sc-sdx-select-option input.sc-sdx-select-option:disabled+label.sc-sdx-select-option::after{border-color:#bbb;color:#bbb}/*!@.input.checkbox label, .input.radio label*/.input.checkbox.sc-sdx-select-option label.sc-sdx-select-option,.input.radio.sc-sdx-select-option label.sc-sdx-select-option{flex-grow:1;padding-left:37px;position:relative;min-height:1em;cursor:inherit}/*!@.input.checkbox label::before, .input.checkbox label::after, .input.radio label::before, .input.radio label::after*/.input.checkbox.sc-sdx-select-option label.sc-sdx-select-option::before,.input.checkbox.sc-sdx-select-option label.sc-sdx-select-option::after,.input.radio.sc-sdx-select-option label.sc-sdx-select-option::before,.input.radio.sc-sdx-select-option label.sc-sdx-select-option::after{content:\"\";position:absolute;top:0;left:0;margin-top:1px;transition:all 200ms cubic-bezier(0.4, 0, 0.2, 1);transform-origin:50% 50%}/*!@.input.checkbox label::before, .input.radio label::before*/.input.checkbox.sc-sdx-select-option label.sc-sdx-select-option::before,.input.radio.sc-sdx-select-option label.sc-sdx-select-option::before{border:1px solid #666}/*!@.input.checkbox label::after, .input.radio label::after*/.input.checkbox.sc-sdx-select-option label.sc-sdx-select-option::after,.input.radio.sc-sdx-select-option label.sc-sdx-select-option::after{transform:scale(0)}/*!@.input.checkbox label::before*/.input.checkbox.sc-sdx-select-option label.sc-sdx-select-option::before{border-radius:5px;width:22px;height:22px}/*!@.input.checkbox label::after*/.input.checkbox.sc-sdx-select-option label.sc-sdx-select-option::after{font-family:sdx-icons;content:\"\\e00b\";color:#666;left:2px}/*!@.input.radio label::before*/.input.radio.sc-sdx-select-option label.sc-sdx-select-option::before{border-radius:50%;width:22px;height:22px}/*!@.input.radio label::after*/.input.radio.sc-sdx-select-option label.sc-sdx-select-option::after{top:6px;left:6px;border:5px solid;border-radius:50%;background-color:#086adb}/*!@.input.sdx--dark-theme.checkbox:hover input:not(:disabled).focus + label::before, .input.sdx--dark-theme.checkbox:hover input:not(:disabled):checked + label::before, .input.sdx--dark-theme.radio:hover input:not(:disabled).focus + label::before, .input.sdx--dark-theme.radio:hover input:not(:disabled):checked + label::before*/.input.sdx--dark-theme.checkbox.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled).focus+label.sc-sdx-select-option::before,.input.sdx--dark-theme.checkbox.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled):checked+label.sc-sdx-select-option::before,.input.sdx--dark-theme.radio.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled).focus+label.sc-sdx-select-option::before,.input.sdx--dark-theme.radio.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled):checked+label.sc-sdx-select-option::before{border-color:#5ca3ff}/*!@.input.sdx--dark-theme.checkbox:hover input:not(:disabled):checked + label::after, .input.sdx--dark-theme.radio:hover input:not(:disabled):checked + label::after*/.input.sdx--dark-theme.checkbox.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled):checked+label.sc-sdx-select-option::after,.input.sdx--dark-theme.radio.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled):checked+label.sc-sdx-select-option::after{border-color:#5ca3ff;color:#5ca3ff}/*!@.input.sdx--dark-theme.checkbox:hover input:not(:disabled) + label::before, .input.sdx--dark-theme.radio:hover input:not(:disabled) + label::before*/.input.sdx--dark-theme.checkbox.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled)+label.sc-sdx-select-option::before,.input.sdx--dark-theme.radio.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled)+label.sc-sdx-select-option::before{border-color:#d6d6d6}/*!@.input.sdx--dark-theme.checkbox:hover input:not(:disabled) + label::after, .input.sdx--dark-theme.radio:hover input:not(:disabled) + label::after*/.input.sdx--dark-theme.checkbox.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled)+label.sc-sdx-select-option::after,.input.sdx--dark-theme.radio.sc-sdx-select-option:hover input.sc-sdx-select-option:not(:disabled)+label.sc-sdx-select-option::after{color:#d6d6d6}/*!@.input.sdx--dark-theme.checkbox input.invalid + label::before, .input.sdx--dark-theme.radio input.invalid + label::before*/.input.sdx--dark-theme.checkbox.sc-sdx-select-option input.invalid.sc-sdx-select-option+label.sc-sdx-select-option::before,.input.sdx--dark-theme.radio.sc-sdx-select-option input.invalid.sc-sdx-select-option+label.sc-sdx-select-option::before{border-color:#f35d6a}/*!@.input.sdx--dark-theme.checkbox input.focus + label::before, .input.sdx--dark-theme.checkbox input:checked + label::before, .input.sdx--dark-theme.radio input.focus + label::before, .input.sdx--dark-theme.radio input:checked + label::before*/.input.sdx--dark-theme.checkbox.sc-sdx-select-option input.focus.sc-sdx-select-option+label.sc-sdx-select-option::before,.input.sdx--dark-theme.checkbox.sc-sdx-select-option input.sc-sdx-select-option:checked+label.sc-sdx-select-option::before,.input.sdx--dark-theme.radio.sc-sdx-select-option input.focus.sc-sdx-select-option+label.sc-sdx-select-option::before,.input.sdx--dark-theme.radio.sc-sdx-select-option input.sc-sdx-select-option:checked+label.sc-sdx-select-option::before{border-color:#4294ff}/*!@.input.sdx--dark-theme.checkbox input.focus + label::after, .input.sdx--dark-theme.checkbox input:checked + label::after, .input.sdx--dark-theme.radio input.focus + label::after, .input.sdx--dark-theme.radio input:checked + label::after*/.input.sdx--dark-theme.checkbox.sc-sdx-select-option input.focus.sc-sdx-select-option+label.sc-sdx-select-option::after,.input.sdx--dark-theme.checkbox.sc-sdx-select-option input.sc-sdx-select-option:checked+label.sc-sdx-select-option::after,.input.sdx--dark-theme.radio.sc-sdx-select-option input.focus.sc-sdx-select-option+label.sc-sdx-select-option::after,.input.sdx--dark-theme.radio.sc-sdx-select-option input.sc-sdx-select-option:checked+label.sc-sdx-select-option::after{color:#4294ff}/*!@.input.sdx--dark-theme.checkbox input:disabled + label, .input.sdx--dark-theme.radio input:disabled + label*/.input.sdx--dark-theme.checkbox.sc-sdx-select-option input.sc-sdx-select-option:disabled+label.sc-sdx-select-option,.input.sdx--dark-theme.radio.sc-sdx-select-option input.sc-sdx-select-option:disabled+label.sc-sdx-select-option{color:#5c5c5c}/*!@.input.sdx--dark-theme.checkbox input:disabled + label::before, .input.sdx--dark-theme.radio input:disabled + label::before*/.input.sdx--dark-theme.checkbox.sc-sdx-select-option input.sc-sdx-select-option:disabled+label.sc-sdx-select-option::before,.input.sdx--dark-theme.radio.sc-sdx-select-option input.sc-sdx-select-option:disabled+label.sc-sdx-select-option::before{border-color:#5c5c5c}/*!@.input.sdx--dark-theme.checkbox input + label::before, .input.sdx--dark-theme.radio input + label::before*/.input.sdx--dark-theme.checkbox.sc-sdx-select-option input.sc-sdx-select-option+label.sc-sdx-select-option::before,.input.sdx--dark-theme.radio.sc-sdx-select-option input.sc-sdx-select-option+label.sc-sdx-select-option::before{background-color:#1d1d1d}/*!@.input.sdx--dark-theme.checkbox label::before, .input.sdx--dark-theme.radio label::before*/.input.sdx--dark-theme.checkbox.sc-sdx-select-option label.sc-sdx-select-option::before,.input.sdx--dark-theme.radio.sc-sdx-select-option label.sc-sdx-select-option::before{border-color:#adadad}/*!@:host*/.sc-sdx-select-option-h{display:flex;height:48px;cursor:pointer;color:#333}/*!@:host(:not(.inside-dialog))*/.sc-sdx-select-option-h:not(.inside-dialog){border:1px solid #adadad}/*!@:host(:not(.inside-dialog)) .component .option*/.sc-sdx-select-option-h:not(.inside-dialog) .component.sc-sdx-select-option .option.sc-sdx-select-option{padding:0 16px}/*!@:host(:hover:not(.disabled):not(.inside-dialog)),\n:host(.focus:not(.disabled):not(.inside-dialog))*/.sc-sdx-select-option-h:hover:not(.disabled):not(.inside-dialog),.focus.sc-sdx-select-option-h:not(.disabled):not(.inside-dialog){background-color:#eef3f6}/*!@:host(.selected:not(.multiple):not(.inside-dialog))*/.selected.sc-sdx-select-option-h:not(.multiple):not(.inside-dialog){border-color:#086adb;background-color:#086adb;color:#fff}/*!@:host(.selected:not(.multiple):not(.inside-dialog):hover),\n:host(.selected.focus:not(.multiple):not(.inside-dialog))*/.selected.sc-sdx-select-option-h:not(.multiple):not(.inside-dialog):hover,.selected.focus.sc-sdx-select-option-h:not(.multiple):not(.inside-dialog){border-color:#0048cf;background-color:#0048cf}/*!@:host(:not(.multiple):not(.inside-dialog)) label*/.sc-sdx-select-option-h:not(.multiple):not(.inside-dialog) label.sc-sdx-select-option{padding-left:unset}/*!@:host(:not(.multiple):not(.inside-dialog)) label::before, :host(:not(.multiple):not(.inside-dialog)) label::after*/.sc-sdx-select-option-h:not(.multiple):not(.inside-dialog) label.sc-sdx-select-option::before,.sc-sdx-select-option-h:not(.multiple):not(.inside-dialog) label.sc-sdx-select-option::after{display:none}/*!@:host(.top)*/.top.sc-sdx-select-option-h{border-top:none}/*!@:host(.bottom)*/.bottom.sc-sdx-select-option-h{border-bottom:none}/*!@:host(.disabled)*/.disabled.sc-sdx-select-option-h{cursor:not-allowed;color:#d6d6d6}/*!@.component*/.component.sc-sdx-select-option{display:flex;flex:1;white-space:nowrap}/*!@.component .option*/.component.sc-sdx-select-option .option.sc-sdx-select-option{flex:1;display:flex}/*!@.component .option .input*/.component.sc-sdx-select-option .option.sc-sdx-select-option .input.sc-sdx-select-option{flex:1;display:flex;align-items:center}/*!@:host(.sdx--dark-theme)*/.sdx--dark-theme.sc-sdx-select-option-h{border-right-color:#4294ff;border-left-color:#4294ff;border-top-color:#707070;border-bottom-color:#707070;color:#e6e6e6}/*!@:host(:hover:not(.disabled):not(.inside-dialog).sdx--dark-theme),\n:host(.focus:not(.disabled):not(.inside-dialog).sdx--dark-theme)*/.sc-sdx-select-option-h:hover:not(.disabled):not(.inside-dialog).sdx--dark-theme,.focus.sc-sdx-select-option-h:not(.disabled):not(.inside-dialog).sdx--dark-theme{background-color:#222}/*!@:host(.selected:not(.inside-dialog).sdx--dark-theme)*/.selected.sc-sdx-select-option-h:not(.inside-dialog).sdx--dark-theme{border-right-color:#4294ff;border-left-color:#4294ff;border-top:#4294ff;border-bottom-color:#4294ff;background-color:#0a71e9}/*!@:host(.selected:not(.inside-dialog).sdx--dark-theme:hover),\n:host(.selected.focus:not(.inside-dialog).sdx--dark-theme)*/.selected.sc-sdx-select-option-h:not(.inside-dialog).sdx--dark-theme:hover,.selected.focus.sc-sdx-select-option-h:not(.inside-dialog).sdx--dark-theme{border-right-color:#147df5;border-left-color:#5ca3ff;border-top-color:#5ca3ff;border-bottom-color:#5ca3ff;background-color:#147df5}/*!@:host(.disabled.sdx--dark-theme)*/.disabled.sdx--dark-theme.sc-sdx-select-option-h{color:#5c5c5c}";

class SelectOption {
  stateChanged({}, prev) {
    const state = this.state.get();
    const prevState = prev.get();
    if (state.selection !== prevState.selection) {
      this.selectionChanged();
    }
    if (state.name !== prevState.name) {
      this.nameChanged();
    }
  }
  selectedChanged() {
    this.selectedChangedInProgress = true;
    if (!this.selectionChangedInProgress) {
      this.select(this.selected ? "add" : "remove");
      this.updateHiddenFormInputEl();
    }
    this.selectedChangedInProgress = false;
  }
  onClick() {
    const state = this.state.get();
    const closeAutomatically = this.shouldCloseAutomatically();
    if (this.disabled) {
      if (closeAutomatically) {
        state.close();
      }
    }
    else {
      // Don't select anything if "autocomplete", only set the filter keyword
      if (isKeyboardBehavior(state, "autocomplete")) {
        const value = getDisplayText(this.el);
        this.store.set("userInteractionInProgress", true);
        this.store.set("filterInputElValue", value);
        this.store.set("userInteractionInProgress", false);
        // Close with a little delay for the user to see what was selected
        setTimeout(() => {
          // Apply filter *after* the autocomplete has closed in order to
          // prevent glitches. Otherwise, for a brief moment, all results are
          // being displayed again.
          state
            .close()
            .then(() => this.store.dispatch({ type: "SET_FILTER", filter: value }));
        }, state.animationDuration);
        return;
      }
      const alreadySelected = this.isSelected();
      this.store.set("userInteractionInProgress", true);
      this.select("add");
      if (closeAutomatically) {
        // Close with a little delay for the user to see what was selected
        setTimeout(() => {
          state.close().then(() => {
            // Clear the filter after an option was selected (that wasn't
            // selected before)
            if (alreadySelected) {
              return;
            }
            this.store.set("filterInputElValue", "");
            this.store.dispatch({ type: "SET_FILTER", filter: "" });
          });
        }, state.animationDuration);
      }
    }
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.selectedChangedInProgress = false;
    this.selectionChangedInProgress = false;
    this.state = undefined;
    this.value = undefined;
    this.displayText = undefined;
    this.selected = false;
    this.disabled = false;
    this.placeholder = false;
    this.store = new StoreConnection(this, selectReducer, getInitialState$1(), [
      "selection",
      "multiple",
      "directionX",
      "directionY",
      "name",
      "filter",
      "animationDuration",
      "close",
      "keyboardBehavior",
      "isInsideDialog",
    ]);
  }
  connectedCallback() {
    var _a;
    // Don't do anything while the component is being reappended (maybe
    // because it's being appended to document.body), but send a "ping" for
    // each child (sdx-select-option).
    // After each child is has finished, "reappending" will be marked "done" by
    // the store.
    if (this.state.get().reappending) {
      (_a = this.store) === null || _a === void 0 ? void 0 : _a.dispatch({ type: "UPDATE_REAPPENDING" });
      return;
    }
    // Register self (except placeholder)
    this.store.dispatch({ type: "ADD_OPTION_EL", optionEl: this.el });
    if (this.selected) {
      this.select("add");
    }
  }
  disconnectedCallback() {
    // Performance: stop if the parent isn't even connected (e.g. *ngIf)
    if (!this.state.get().connected) {
      return;
    }
    // See connectedCallback() for explanation
    if (this.state.get().reappending) {
      return;
    }
    // Unregister self
    this.store.dispatch({ type: "REMOVE_OPTION_EL", optionEl: this.el });
    if (!this.el.isConnected && this.selected) {
      this.select("remove");
    }
  }
  componentDidLoad() {
    this.store.subscribe();
  }
  selectionChanged() {
    this.selectionChangedInProgress = true;
    if (!this.selectedChangedInProgress) {
      this.selected = this.isSelected();
      this.updateHiddenFormInputEl();
    }
    this.selectionChangedInProgress = false;
  }
  nameChanged() {
    this.updateHiddenFormInputEl();
  }
  updateHiddenFormInputEl() {
    const state = this.state.get();
    // See sdx-select for more information.
    if (isKeyboardBehavior(state, "autocomplete")) {
      return;
    }
    if (!this.lightDOMHiddenFormInputEl) {
      this.lightDOMHiddenFormInputEl = document.createElement("input");
      this.lightDOMHiddenFormInputEl.type = "hidden";
      this.el.append(this.lightDOMHiddenFormInputEl);
    }
    // Clean up properties added previously in case they've changed
    this.lightDOMHiddenFormInputEl.removeAttribute("name");
    this.lightDOMHiddenFormInputEl.removeAttribute("value");
    if (state.name && this.selected) {
      this.lightDOMHiddenFormInputEl.name = state.name;
      this.lightDOMHiddenFormInputEl.value = this.value || this.el.textContent;
    }
  }
  select(strategy) {
    this.store.dispatch({
      type: "SELECT",
      optionEl: this.placeholder ? null : this.el,
      strategy,
    });
  }
  isSelected() {
    return !!this.state.get().selection.includes(this.el);
  }
  shouldCloseAutomatically() {
    const { multiple, isInsideDialog } = this.state.get();
    return !(multiple || isInsideDialog);
  }
  getHostClassNames() {
    const { multiple, directionY, isInsideDialog } = this.state.get();
    return {
      multiple,
      [getAppearance(this.el)]: true,
      selected: this.isSelected(),
      disabled: this.disabled,
      ...computedProperty(directionY),
      "inside-dialog": isInsideDialog,
    };
  }
  getInputClassNames() {
    const { multiple } = this.state.get();
    return {
      input: true,
      checkbox: multiple,
      radio: !multiple,
      [getAppearance(this.el)]: true,
    };
  }
  render() {
    const inputClassNames = this.getInputClassNames();
    const { checkbox } = inputClassNames;
    return (hAsync(Host, { class: this.getHostClassNames() }, hAsync("div", { class: "component" }, hAsync("div", { class: "option" }, hAsync("div", { class: inputClassNames }, hAsync("input", { id: "input", type: checkbox ? "checkbox" : "radio", checked: this.isSelected(), disabled: this.disabled, onClick: (e) => e.stopPropagation() /* already handled in components click listener */, onInput: (e) => e.stopPropagation() }), hAsync("label", { htmlFor: "input" }, hAsync("slot", null)))))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "state": ["stateChanged"],
    "selected": ["selectedChanged"]
  }; }
  static get style() { return selectOptionCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-select-option",
    "$members$": {
      "value": [8],
      "displayText": [1, "display-text"],
      "selected": [1028],
      "disabled": [4],
      "placeholder": [4],
      "state": [32]
    },
    "$listeners$": [[0, "click", "onClick"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const showMoreCss = "/*!@:root*/.sc-sdx-show-more:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-show-more-h,*.sc-sdx-show-more,*.sc-sdx-show-more:before,*.sc-sdx-show-more:after{box-sizing:border-box}/*!@.component*/.component.sc-sdx-show-more{display:flex;align-items:center;justify-content:center}/*!@.component .count*/.component.sc-sdx-show-more .count.sc-sdx-show-more{margin-right:24px}@media (max-width: 1279px){/*!@.component*/.component.sc-sdx-show-more{flex-flow:column}/*!@.component .count*/.component.sc-sdx-show-more .count.sc-sdx-show-more{margin-bottom:8px;margin-right:0}}";

class ShowMore {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.start = 1;
    this.invokeIncrementCallback = () => null;
    this.currentlyDisplayedItems = 0;
    this.incrementBy = 10;
    this.initialItems = 0;
    this.totalItems = 0;
    this.fromLabel = "from";
    this.moreLabel = "Show more";
    this.incrementCallback = undefined;
    this.buttonTheme = "primary";
  }
  totalItemsChanged() {
    this.reset();
  }
  incrementCallbackChanged() {
    this.setInvokeIncrementCallback();
  }
  componentWillLoad() {
    this.setInvokeIncrementCallback();
    this.reset();
  }
  reset() {
    this.currentlyDisplayedItems = this.initialItems || this.incrementBy;
  }
  showMore() {
    const deltaToMax = this.totalItems - this.currentlyDisplayedItems;
    // Reached total items
    if (deltaToMax <= 0) {
      return;
    }
    if (deltaToMax > this.incrementBy) {
      this.currentlyDisplayedItems += this.incrementBy;
    }
    else {
      this.currentlyDisplayedItems += deltaToMax;
    }
    this.invokeIncrementCallback(this.currentlyDisplayedItems);
  }
  setInvokeIncrementCallback() {
    this.invokeIncrementCallback = parseFunction(this.incrementCallback);
  }
  render() {
    return (hAsync("div", { class: "component" }, hAsync("span", { class: "count" }, this.start, " \u2013 ", this.currentlyDisplayedItems, " ", this.fromLabel, " ", this.totalItems), hAsync("sdx-button", { label: this.moreLabel, theme: this.buttonTheme, onClick: () => this.showMore() })));
  }
  static get watchers() { return {
    "totalItems": ["totalItemsChanged"],
    "incrementCallback": ["incrementCallbackChanged"]
  }; }
  static get style() { return showMoreCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-show-more",
    "$members$": {
      "incrementBy": [2, "increment-by"],
      "initialItems": [2, "initial-items"],
      "totalItems": [2, "total-items"],
      "fromLabel": [1, "from-label"],
      "moreLabel": [1, "more-label"],
      "incrementCallback": [1, "increment-callback"],
      "buttonTheme": [1, "button-theme"],
      "currentlyDisplayedItems": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const stickerCircleCss = "/*!@:root*/.sc-sdx-sticker-circle:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-sticker-circle-h,*.sc-sdx-sticker-circle,*.sc-sdx-sticker-circle:before,*.sc-sdx-sticker-circle:after{box-sizing:border-box}/*!@.white*/.white.sc-sdx-sticker-circle{color:#fff}/*!@.navy*/.navy.sc-sdx-sticker-circle{color:#015}/*!@.blue*/.blue.sc-sdx-sticker-circle{color:#086adb}/*!@.blue-40, .blue-tint-2*/.blue-40.sc-sdx-sticker-circle,.blue-tint-2.sc-sdx-sticker-circle{color:#a2cdf4}/*!@.blue-20, .blue-tint-3*/.blue-20.sc-sdx-sticker-circle,.blue-tint-3.sc-sdx-sticker-circle{color:#d1e6f9}/*!@.aluminium,\n.aluminum*/.aluminium.sc-sdx-sticker-circle,.aluminum.sc-sdx-sticker-circle{color:#dde3e7}/*!@.aluminium-80, .aluminium-tint-2,\n.aluminum-80,\n.aluminum-tint-2*/.aluminium-80.sc-sdx-sticker-circle,.aluminium-tint-2.sc-sdx-sticker-circle,.aluminum-80.sc-sdx-sticker-circle,.aluminum-tint-2.sc-sdx-sticker-circle{color:#e4e9ec}/*!@.horizon*/.horizon.sc-sdx-sticker-circle{color:#eef3f6}/*!@.horizon-40, .horizon-tint-2*/.horizon-40.sc-sdx-sticker-circle,.horizon-tint-2.sc-sdx-sticker-circle{color:#f8fafb}/*!@.gray*/.gray.sc-sdx-sticker-circle{color:#333}/*!@.gray-90, .gray-tint-2*/.gray-90.sc-sdx-sticker-circle,.gray-tint-2.sc-sdx-sticker-circle{color:#474747}/*!@.gray-80, .gray-tint-3*/.gray-80.sc-sdx-sticker-circle,.gray-tint-3.sc-sdx-sticker-circle{color:#5c5c5c}/*!@.gray-mid, .gray-tint-4*/.gray-mid.sc-sdx-sticker-circle,.gray-tint-4.sc-sdx-sticker-circle{color:#666}/*!@.gray-60, .gray-tint-5*/.gray-60.sc-sdx-sticker-circle,.gray-tint-5.sc-sdx-sticker-circle{color:#858585}/*!@.gray-40, .gray-tint-6*/.gray-40.sc-sdx-sticker-circle,.gray-tint-6.sc-sdx-sticker-circle{color:#adadad}/*!@.gray-light, .gray-tint-7*/.gray-light.sc-sdx-sticker-circle,.gray-tint-7.sc-sdx-sticker-circle{color:#bbb}/*!@.gray-20, .gray-tint-8*/.gray-20.sc-sdx-sticker-circle,.gray-tint-8.sc-sdx-sticker-circle{color:#d6d6d6}/*!@.sc-blue*/.sc-blue.sc-sdx-sticker-circle{color:#1af}/*!@.sc-red*/.sc-red.sc-sdx-sticker-circle{color:#d12}/*!@.sc-purple*/.sc-purple.sc-sdx-sticker-circle{color:#5944c6}/*!@.sc-navy*/.sc-navy.sc-sdx-sticker-circle{color:#015}/*!@.sc-white*/.sc-white.sc-sdx-sticker-circle{color:#fff}/*!@.sc-gray*/.sc-gray.sc-sdx-sticker-circle{color:#333}/*!@.sc-gray-mid*/.sc-gray-mid.sc-sdx-sticker-circle{color:#666}/*!@.sc-gray-light*/.sc-gray-light.sc-sdx-sticker-circle{color:#bbb}/*!@.int-blue*/.int-blue.sc-sdx-sticker-circle{color:#086adb}/*!@.int-blue--active*/.int-blue--active.sc-sdx-sticker-circle{color:#0048cf}/*!@.int-gray*/.int-gray.sc-sdx-sticker-circle{color:#cfd5d9}/*!@.int-gray--active*/.int-gray--active.sc-sdx-sticker-circle{color:#b1b9be}/*!@.int-green*/.int-green.sc-sdx-sticker-circle{color:#1b8712}/*!@.int-green--active*/.int-green--active.sc-sdx-sticker-circle{color:#0d6f2c}/*!@.int-red*/.int-red.sc-sdx-sticker-circle{color:#d12}/*!@.int-red--active*/.int-red--active.sc-sdx-sticker-circle{color:#be0000}/*!@.int-orange*/.int-orange.sc-sdx-sticker-circle{color:#cf4a0c}/*!@.int-orange--active*/.int-orange--active.sc-sdx-sticker-circle{color:#ba3e06}/*!@.azure*/.azure.sc-sdx-sticker-circle{color:#1781e3}/*!@.azure--active*/.azure--active.sc-sdx-sticker-circle{color:#0851da}/*!@.orchid*/.orchid.sc-sdx-sticker-circle{color:#a63297}/*!@.orchid--active*/.orchid--active.sc-sdx-sticker-circle{color:#7f2879}/*!@.orchid-tint-2*/.orchid-tint-2.sc-sdx-sticker-circle{color:#ab449f}/*!@.orchid-tint-3*/.orchid-tint-3.sc-sdx-sticker-circle{color:#b458a8}/*!@.orchid-tint-4*/.orchid-tint-4.sc-sdx-sticker-circle{color:#bb6ab1}/*!@.orchid-tint-5*/.orchid-tint-5.sc-sdx-sticker-circle{color:#c47fbb}/*!@.orchid-tint-6*/.orchid-tint-6.sc-sdx-sticker-circle{color:#cb91c2}/*!@.orchid-tint-7*/.orchid-tint-7.sc-sdx-sticker-circle{color:#d2a4cc}/*!@.orchid-tint-8*/.orchid-tint-8.sc-sdx-sticker-circle{color:#dab7d5}/*!@.iris*/.iris.sc-sdx-sticker-circle{color:#5944c6}/*!@.iris--active*/.iris--active.sc-sdx-sticker-circle{color:#42389e}/*!@.iris-tint-2*/.iris-tint-2.sc-sdx-sticker-circle{color:#6754c8}/*!@.iris-tint-3*/.iris-tint-3.sc-sdx-sticker-circle{color:#7765ce}/*!@.iris-tint-4*/.iris-tint-4.sc-sdx-sticker-circle{color:#7177d2}/*!@.iris-tint-5*/.iris-tint-5.sc-sdx-sticker-circle{color:#9589d7}/*!@.iris-tint-6*/.iris-tint-6.sc-sdx-sticker-circle{color:#a59adb}/*!@.iris-tint-7*/.iris-tint-7.sc-sdx-sticker-circle{color:#b4abe0}/*!@.iris-tint-8*/.iris-tint-8.sc-sdx-sticker-circle{color:#c3bce2}/*!@.pink*/.pink.sc-sdx-sticker-circle{color:#e61e64}/*!@.pink--active*/.pink--active.sc-sdx-sticker-circle{color:#bf1b5a}/*!@.pink-tint-2*/.pink-tint-2.sc-sdx-sticker-circle{color:#e63a70}/*!@.pink-tint-3*/.pink-tint-3.sc-sdx-sticker-circle{color:#e74e7f}/*!@.pink-tint-4*/.pink-tint-4.sc-sdx-sticker-circle{color:#e8628d}/*!@.pink-tint-5*/.pink-tint-5.sc-sdx-sticker-circle{color:#ea779c}/*!@.pink-tint-6*/.pink-tint-6.sc-sdx-sticker-circle{color:#eb8baa}/*!@.pink-tint-7*/.pink-tint-7.sc-sdx-sticker-circle{color:#eca0b8}/*!@.pink-tint-8*/.pink-tint-8.sc-sdx-sticker-circle{color:#edb4c6}/*!@.apple,\n.petrol,\n.turquoise*/.apple.sc-sdx-sticker-circle,.petrol.sc-sdx-sticker-circle,.turquoise.sc-sdx-sticker-circle{color:#0eaba9}/*!@.apple--active,\n.petrol--active,\n.turquoise--active*/.apple--active.sc-sdx-sticker-circle,.petrol--active.sc-sdx-sticker-circle,.turquoise--active.sc-sdx-sticker-circle{color:#0c847e}/*!@.turquoise-tint-2*/.turquoise-tint-2.sc-sdx-sticker-circle{color:#21b1af}/*!@.turquoise-tint-3*/.turquoise-tint-3.sc-sdx-sticker-circle{color:#38b8b6}/*!@.turquoise-tint-4*/.turquoise-tint-4.sc-sdx-sticker-circle{color:#4cc0bd}/*!@.turquoise-tint-5*/.turquoise-tint-5.sc-sdx-sticker-circle{color:#67c7c5}/*!@.turquoise-tint-6*/.turquoise-tint-6.sc-sdx-sticker-circle{color:#7ececd}/*!@.turquoise-tint-7*/.turquoise-tint-7.sc-sdx-sticker-circle{color:#97d5d4}/*!@.turquoise-tint-8*/.turquoise-tint-8.sc-sdx-sticker-circle{color:#a9dbdb}/*!@.sdx--dark-theme .gray*/.sdx--dark-theme.sc-sdx-sticker-circle .gray.sc-sdx-sticker-circle{color:#e6e6e6}/*!@.sdx--dark-theme .gray-tint-2*/.sdx--dark-theme.sc-sdx-sticker-circle .gray-tint-2.sc-sdx-sticker-circle{color:#d6d6d6}/*!@.sdx--dark-theme .gray-tint-3*/.sdx--dark-theme.sc-sdx-sticker-circle .gray-tint-3.sc-sdx-sticker-circle{color:#cfd5d9}/*!@.sdx--dark-theme .gray-tint-4*/.sdx--dark-theme.sc-sdx-sticker-circle .gray-tint-4.sc-sdx-sticker-circle{color:#b1b9be}/*!@.sdx--dark-theme .gray-tint-5*/.sdx--dark-theme.sc-sdx-sticker-circle .gray-tint-5.sc-sdx-sticker-circle{color:#adadad}/*!@.sdx--dark-theme .gray-tint-6*/.sdx--dark-theme.sc-sdx-sticker-circle .gray-tint-6.sc-sdx-sticker-circle{color:#8c8c8c}/*!@.sdx--dark-theme .gray-tint-7*/.sdx--dark-theme.sc-sdx-sticker-circle .gray-tint-7.sc-sdx-sticker-circle{color:#707070}/*!@.sdx--dark-theme .gray-tint-8*/.sdx--dark-theme.sc-sdx-sticker-circle .gray-tint-8.sc-sdx-sticker-circle{color:#5c5c5c}/*!@.sdx--dark-theme .dusk*/.sdx--dark-theme.sc-sdx-sticker-circle .dusk.sc-sdx-sticker-circle{color:#141414}/*!@.sdx--dark-theme .dusk-tint-2*/.sdx--dark-theme.sc-sdx-sticker-circle .dusk-tint-2.sc-sdx-sticker-circle{color:#1d1d1d}/*!@.sdx--dark-theme .dusk-tint-3*/.sdx--dark-theme.sc-sdx-sticker-circle .dusk-tint-3.sc-sdx-sticker-circle{color:#222}/*!@.sdx--dark-theme .dusk-tint-4*/.sdx--dark-theme.sc-sdx-sticker-circle .dusk-tint-4.sc-sdx-sticker-circle{color:#242424}/*!@.sdx--dark-theme .int-blue*/.sdx--dark-theme.sc-sdx-sticker-circle .int-blue.sc-sdx-sticker-circle{color:#0a71e9}/*!@.sdx--dark-theme .int-blue--active*/.sdx--dark-theme.sc-sdx-sticker-circle .int-blue--active.sc-sdx-sticker-circle{color:#147df5}/*!@.sdx--dark-theme .int-blue2*/.sdx--dark-theme.sc-sdx-sticker-circle .int-blue2.sc-sdx-sticker-circle{color:#4294ff}/*!@.sdx--dark-theme .int-blue2--active*/.sdx--dark-theme.sc-sdx-sticker-circle .int-blue2--active.sc-sdx-sticker-circle{color:#5ca3ff}/*!@.sdx--dark-theme .int-gray*/.sdx--dark-theme.sc-sdx-sticker-circle .int-gray.sc-sdx-sticker-circle{color:#adadad}/*!@.sdx--dark-theme .int-gray--active*/.sdx--dark-theme.sc-sdx-sticker-circle .int-gray--active.sc-sdx-sticker-circle{color:#d6d6d6}/*!@.sdx--dark-theme .int-green*/.sdx--dark-theme.sc-sdx-sticker-circle .int-green.sc-sdx-sticker-circle{color:#1c8912}/*!@.sdx--dark-theme .int-green--active*/.sdx--dark-theme.sc-sdx-sticker-circle .int-green--active.sc-sdx-sticker-circle{color:#0d6f2c}/*!@.sdx--dark-theme .int-green2*/.sdx--dark-theme.sc-sdx-sticker-circle .int-green2.sc-sdx-sticker-circle{color:#21a716}/*!@.sdx--dark-theme .int-red*/.sdx--dark-theme.sc-sdx-sticker-circle .int-red.sc-sdx-sticker-circle{color:#eb1224}/*!@.sdx--dark-theme .int-red--active*/.sdx--dark-theme.sc-sdx-sticker-circle .int-red--active.sc-sdx-sticker-circle{color:#be0000}/*!@.sdx--dark-theme .int-red2*/.sdx--dark-theme.sc-sdx-sticker-circle .int-red2.sc-sdx-sticker-circle{color:#f35d6a}/*!@.sdx--dark-theme .int-red2--active*/.sdx--dark-theme.sc-sdx-sticker-circle .int-red2--active.sc-sdx-sticker-circle{color:#fe7e89}/*!@.sdx--dark-theme .int-orange*/.sdx--dark-theme.sc-sdx-sticker-circle .int-orange.sc-sdx-sticker-circle{color:#ce4a0c}/*!@.sdx--dark-theme .int-orange--active*/.sdx--dark-theme.sc-sdx-sticker-circle .int-orange--active.sc-sdx-sticker-circle{color:#de4f0d}/*!@.sdx--dark-theme .int-orange-2*/.sdx--dark-theme.sc-sdx-sticker-circle .int-orange-2.sc-sdx-sticker-circle{color:#f26726}/*!@.sdx--dark-theme .int-orange-2--active*/.sdx--dark-theme.sc-sdx-sticker-circle .int-orange-2--active.sc-sdx-sticker-circle{color:#f37b46}/*!@.sdx--dark-theme .azure*/.sdx--dark-theme.sc-sdx-sticker-circle .azure.sc-sdx-sticker-circle{color:#136fc3}/*!@.sdx--dark-theme .azure--active*/.sdx--dark-theme.sc-sdx-sticker-circle .azure--active.sc-sdx-sticker-circle{color:#1578d3}/*!@.sdx--dark-theme .orchid*/.sdx--dark-theme.sc-sdx-sticker-circle .orchid.sc-sdx-sticker-circle{color:#a54c9b}/*!@.sdx--dark-theme .orchid--active*/.sdx--dark-theme.sc-sdx-sticker-circle .orchid--active.sc-sdx-sticker-circle{color:#b053a5}/*!@.sdx--dark-theme .iris*/.sdx--dark-theme.sc-sdx-sticker-circle .iris.sc-sdx-sticker-circle{color:#6f5ccb}/*!@.sdx--dark-theme .iris--active*/.sdx--dark-theme.sc-sdx-sticker-circle .iris--active.sc-sdx-sticker-circle{color:#7867ce}/*!@.sdx--dark-theme .pink*/.sdx--dark-theme.sc-sdx-sticker-circle .pink.sc-sdx-sticker-circle{color:#d41d56}/*!@.sdx--dark-theme .pink--active*/.sdx--dark-theme.sc-sdx-sticker-circle .pink--active.sc-sdx-sticker-circle{color:#e1245f}/*!@.sdx--dark-theme .turquoise*/.sdx--dark-theme.sc-sdx-sticker-circle .turquoise.sc-sdx-sticker-circle{color:#0a7b7a}/*!@.sdx--dark-theme .turquoise--active*/.sdx--dark-theme.sc-sdx-sticker-circle .turquoise--active.sc-sdx-sticker-circle{color:#0b8483}/*!@.bg-white*/.bg-white.sc-sdx-sticker-circle{background-color:#fff}/*!@.bg-navy*/.bg-navy.sc-sdx-sticker-circle{background-color:#015}/*!@.bg-blue*/.bg-blue.sc-sdx-sticker-circle{background-color:#086adb}/*!@.bg-blue-tint-2, .bg-blue-40*/.bg-blue-tint-2.sc-sdx-sticker-circle,.bg-blue-40.sc-sdx-sticker-circle{background-color:#a2cdf4}/*!@.bg-blue-tint-3, .bg-blue-20*/.bg-blue-tint-3.sc-sdx-sticker-circle,.bg-blue-20.sc-sdx-sticker-circle{background-color:#d1e6f9}/*!@.bg-aluminium,\n.bg-aluminum*/.bg-aluminium.sc-sdx-sticker-circle,.bg-aluminum.sc-sdx-sticker-circle{background-color:#dde3e7}/*!@.bg-aluminium-80, .bg-aluminium-tint-2,\n.bg-aluminum-80,\n.bg-aluminum-tint-2*/.bg-aluminium-80.sc-sdx-sticker-circle,.bg-aluminium-tint-2.sc-sdx-sticker-circle,.bg-aluminum-80.sc-sdx-sticker-circle,.bg-aluminum-tint-2.sc-sdx-sticker-circle{background-color:#e4e9ec}/*!@.bg-horizon*/.bg-horizon.sc-sdx-sticker-circle{background-color:#eef3f6}/*!@.bg-horizon-40, .bg-horizon-tint-2*/.bg-horizon-40.sc-sdx-sticker-circle,.bg-horizon-tint-2.sc-sdx-sticker-circle{background-color:#f8fafb}/*!@.bg-gray*/.bg-gray.sc-sdx-sticker-circle{background-color:#333}/*!@.bg-gray-90, .bg-gray-tint-2*/.bg-gray-90.sc-sdx-sticker-circle,.bg-gray-tint-2.sc-sdx-sticker-circle{background-color:#474747}/*!@.bg-gray-80, .bg-gray-tint-3*/.bg-gray-80.sc-sdx-sticker-circle,.bg-gray-tint-3.sc-sdx-sticker-circle{background-color:#5c5c5c}/*!@.bg-gray-mid, .bg-gray-tint-4*/.bg-gray-mid.sc-sdx-sticker-circle,.bg-gray-tint-4.sc-sdx-sticker-circle{background-color:#666}/*!@.bg-gray-60, .bg-gray-tint-5*/.bg-gray-60.sc-sdx-sticker-circle,.bg-gray-tint-5.sc-sdx-sticker-circle{background-color:#858585}/*!@.bg-gray-40, .bg-gray-tint-6*/.bg-gray-40.sc-sdx-sticker-circle,.bg-gray-tint-6.sc-sdx-sticker-circle{background-color:#adadad}/*!@.bg-gray-light, .bg-gray-tint-7*/.bg-gray-light.sc-sdx-sticker-circle,.bg-gray-tint-7.sc-sdx-sticker-circle{background-color:#bbb}/*!@.bg-gray-20, .bg-gray-tint-8*/.bg-gray-20.sc-sdx-sticker-circle,.bg-gray-tint-8.sc-sdx-sticker-circle{background-color:#d6d6d6}/*!@.bg-sc-blue*/.bg-sc-blue.sc-sdx-sticker-circle{background-color:#1af}/*!@.bg-sc-red*/.bg-sc-red.sc-sdx-sticker-circle{background-color:#d12}/*!@.bg-sc-navy*/.bg-sc-navy.sc-sdx-sticker-circle{background-color:#015}/*!@.bg-sc-white*/.bg-sc-white.sc-sdx-sticker-circle{background-color:#fff}/*!@.bg-gradient-1*/.bg-gradient-1.sc-sdx-sticker-circle{background:radial-gradient(110% 240% at 0% 130%, rgba(19, 163, 244, 0.9) 0%, rgba(22, 158, 255, 0.5) 55%, rgba(16, 136, 222, 0) 130%), #001155}/*!@.bg-gradient-2*/.bg-gradient-2.sc-sdx-sticker-circle{background:radial-gradient(110% 220% at 0% 140%, #13a3f4 0%, rgba(22, 158, 255, 0.5) 40%, rgba(16, 136, 222, 0) 100%), radial-gradient(290% 800% at 220% -440%, #dd1122 30%, #001155 100%)}/*!@.bg-cloud*/.bg-cloud.sc-sdx-sticker-circle{background:#f9f9f9}/*!@.bg-int-blue*/.bg-int-blue.sc-sdx-sticker-circle{background-color:#086adb}/*!@.bg-int-blue--active*/.bg-int-blue--active.sc-sdx-sticker-circle{background-color:#0048cf}/*!@.bg-int-gray*/.bg-int-gray.sc-sdx-sticker-circle{background-color:#cfd5d9}/*!@.bg-int-gray--active*/.bg-int-gray--active.sc-sdx-sticker-circle{background-color:#b1b9be}/*!@.bg-int-green*/.bg-int-green.sc-sdx-sticker-circle{background-color:#1b8712}/*!@.bg-int-green--active*/.bg-int-green--active.sc-sdx-sticker-circle{background-color:#0d6f2c}/*!@.bg-int-red*/.bg-int-red.sc-sdx-sticker-circle{background-color:#d12}/*!@.bg-int-red--active*/.bg-int-red--active.sc-sdx-sticker-circle{background-color:#be0000}/*!@.bg-int-orange*/.bg-int-orange.sc-sdx-sticker-circle{background-color:#cf4a0c}/*!@.bg-int-orange--active*/.bg-int-orange--active.sc-sdx-sticker-circle{background-color:#ba3e06}/*!@.bg-azure*/.bg-azure.sc-sdx-sticker-circle{background-color:#1781e3}/*!@.bg-azure--active*/.bg-azure--active.sc-sdx-sticker-circle{background-color:#0851da}/*!@.bg-orchid*/.bg-orchid.sc-sdx-sticker-circle{background-color:#a63297}/*!@.bg-orchid--active*/.bg-orchid--active.sc-sdx-sticker-circle{background-color:#7f2879}/*!@.bg-iris*/.bg-iris.sc-sdx-sticker-circle{background-color:#5944c6}/*!@.bg-iris--active*/.bg-iris--active.sc-sdx-sticker-circle{background-color:#42389e}/*!@.bg-pink*/.bg-pink.sc-sdx-sticker-circle{background-color:#e61e64}/*!@.bg-pink--active*/.bg-pink--active.sc-sdx-sticker-circle{background-color:#bf1b5a}/*!@.bg-apple,\n.bg-petrol,\n.bg-turquoise*/.bg-apple.sc-sdx-sticker-circle,.bg-petrol.sc-sdx-sticker-circle,.bg-turquoise.sc-sdx-sticker-circle{background-color:#0eaba9}/*!@.bg-apple--active,\n.bg-petrol--active,\n.bg-turquoise--active*/.bg-apple--active.sc-sdx-sticker-circle,.bg-petrol--active.sc-sdx-sticker-circle,.bg-turquoise--active.sc-sdx-sticker-circle{background-color:#0c847e}/*!@.sdx--dark-theme .bg-dusk*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-dusk.sc-sdx-sticker-circle{background-color:#141414}/*!@.sdx--dark-theme .bg-dusk-tint-2*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-dusk-tint-2.sc-sdx-sticker-circle{background-color:#1d1d1d}/*!@.sdx--dark-theme .bg-dusk-tint-3*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-dusk-tint-3.sc-sdx-sticker-circle{background-color:#222}/*!@.sdx--dark-theme .bg-dusk-tint-4*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-dusk-tint-4.sc-sdx-sticker-circle{background-color:#242424}/*!@.sdx--dark-theme .bg-gray*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-gray.sc-sdx-sticker-circle{background-color:#e6e6e6}/*!@.sdx--dark-theme .bg-gray-tint-3*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-gray-tint-3.sc-sdx-sticker-circle{background-color:#cfd5d9}/*!@.sdx--dark-theme .bg-gray-tint-4*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-gray-tint-4.sc-sdx-sticker-circle{background-color:#b1b9be}/*!@.sdx--dark-theme .bg-gray-tint-6*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-gray-tint-6.sc-sdx-sticker-circle{background-color:#8c8c8c}/*!@.sdx--dark-theme .bg-gray-tint-7*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-gray-tint-7.sc-sdx-sticker-circle{background-color:#707070}/*!@.sdx--dark-theme .bg-gray-tint-8*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-gray-tint-8.sc-sdx-sticker-circle{background-color:#5c5c5c}/*!@.sdx--dark-theme .bg-azure*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-azure.sc-sdx-sticker-circle{background-color:#136fc3}/*!@.sdx--dark-theme .bg-azure--active*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-azure--active.sc-sdx-sticker-circle{background-color:#1578d3}/*!@.sdx--dark-theme .bg-turquoise*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-turquoise.sc-sdx-sticker-circle{background-color:#0a7b7a}/*!@.sdx--dark-theme .bg-turquoise--active*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-turquoise--active.sc-sdx-sticker-circle{background-color:#0b8483}/*!@.sdx--dark-theme .bg-iris*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-iris.sc-sdx-sticker-circle{background-color:#6f5ccb}/*!@.sdx--dark-theme .bg-iris--active*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-iris--active.sc-sdx-sticker-circle{background-color:#7867ce}/*!@.sdx--dark-theme .bg-orchid*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-orchid.sc-sdx-sticker-circle{background-color:#a54c9b}/*!@.sdx--dark-theme .bg-orchid--active*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-orchid--active.sc-sdx-sticker-circle{background-color:#b053a5}/*!@.sdx--dark-theme .bg-pink*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-pink.sc-sdx-sticker-circle{background-color:#d41d56}/*!@.sdx--dark-theme .bg-pink--active*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-pink--active.sc-sdx-sticker-circle{background-color:#e1245f}/*!@.sdx--dark-theme .bg-int-blue*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-int-blue.sc-sdx-sticker-circle{background-color:#0a71e9}/*!@.sdx--dark-theme .bg-int-blue--active*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-int-blue--active.sc-sdx-sticker-circle{background-color:#147df5}/*!@.sdx--dark-theme .bg-int-blue2*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-int-blue2.sc-sdx-sticker-circle{background-color:#4294ff}/*!@.sdx--dark-theme .bg-int-blue2--active*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-int-blue2--active.sc-sdx-sticker-circle{background-color:#5ca3ff}/*!@.sdx--dark-theme .bg-int-gray*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-int-gray.sc-sdx-sticker-circle{background-color:#adadad}/*!@.sdx--dark-theme .bg-int-gray--active*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-int-gray--active.sc-sdx-sticker-circle{background-color:#d6d6d6}/*!@.sdx--dark-theme .bg-int-green*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-int-green.sc-sdx-sticker-circle{background-color:#1c8912}/*!@.sdx--dark-theme .bg-int-green--active*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-int-green--active.sc-sdx-sticker-circle{background-color:#1f9414}/*!@.sdx--dark-theme .bg-int-green2*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-int-green2.sc-sdx-sticker-circle{background-color:#21a716}/*!@.sdx--dark-theme .bg-int-green2--active*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-int-green2--active.sc-sdx-sticker-circle{background-color:#55c24a}/*!@.sdx--dark-theme .bg-int-red*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-int-red.sc-sdx-sticker-circle{background-color:#eb1224}/*!@.sdx--dark-theme .bg-int-red--active*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-int-red--active.sc-sdx-sticker-circle{background-color:#ef2e3e}/*!@.sdx--dark-theme .bg-int-red2*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-int-red2.sc-sdx-sticker-circle{background-color:#f35d6a}/*!@.sdx--dark-theme .bg-int-red2--active*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-int-red2--active.sc-sdx-sticker-circle{background-color:#fe7e89}/*!@.sdx--dark-theme .bg-int-orange*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-int-orange.sc-sdx-sticker-circle{background-color:#ce4a0c}/*!@.sdx--dark-theme .bg-int-orange--active*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-int-orange--active.sc-sdx-sticker-circle{background-color:#de4f0d}/*!@.sdx--dark-theme .bg-int-orange2*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-int-orange2.sc-sdx-sticker-circle{background-color:#f26726}/*!@.sdx--dark-theme .bg-int-orange2--active*/.sdx--dark-theme.sc-sdx-sticker-circle .bg-int-orange2--active.sc-sdx-sticker-circle{background-color:#f37b46}/*!@.sr-only*/.sr-only.sc-sdx-sticker-circle{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);border:0}/*!@.sr-only-focusable:active, .sr-only-focusable:focus*/.sr-only-focusable.sc-sdx-sticker-circle:active,.sr-only-focusable.sc-sdx-sticker-circle:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}/*!@.visible*/.visible.sc-sdx-sticker-circle{visibility:visible !important}/*!@.invisible*/.invisible.sc-sdx-sticker-circle{visibility:hidden !important}/*!@.hide,\n.hidden*/.hide.sc-sdx-sticker-circle,.hidden.sc-sdx-sticker-circle{display:none !important}/*!@.show*/.show.sc-sdx-sticker-circle{display:block !important}@media (min-width: 0){/*!@.hidden-xs-up*/.hidden-xs-up.sc-sdx-sticker-circle{display:none !important}}@media (max-width: 479px){/*!@.hidden-xs-down*/.hidden-xs-down.sc-sdx-sticker-circle{display:none !important}}@media (min-width: 0){/*!@.visible-xs-up*/.visible-xs-up.sc-sdx-sticker-circle{display:block !important}}@media (min-width: 480px){/*!@.hidden-sm-up*/.hidden-sm-up.sc-sdx-sticker-circle{display:none !important}}@media (max-width: 767px){/*!@.hidden-sm-down*/.hidden-sm-down.sc-sdx-sticker-circle{display:none !important}}@media (min-width: 480px){/*!@.visible-sm-up*/.visible-sm-up.sc-sdx-sticker-circle{display:block !important}}@media (min-width: 768px){/*!@.hidden-md-up*/.hidden-md-up.sc-sdx-sticker-circle{display:none !important}}@media (max-width: 1023px){/*!@.hidden-md-down*/.hidden-md-down.sc-sdx-sticker-circle{display:none !important}}@media (min-width: 768px){/*!@.visible-md-up*/.visible-md-up.sc-sdx-sticker-circle{display:block !important}}@media (min-width: 1024px){/*!@.hidden-lg-up*/.hidden-lg-up.sc-sdx-sticker-circle{display:none !important}}@media (max-width: 1279px){/*!@.hidden-lg-down*/.hidden-lg-down.sc-sdx-sticker-circle{display:none !important}}@media (min-width: 1024px){/*!@.visible-lg-up*/.visible-lg-up.sc-sdx-sticker-circle{display:block !important}}@media (min-width: 1280px){/*!@.hidden-xl-up*/.hidden-xl-up.sc-sdx-sticker-circle{display:none !important}}@media (max-width: 1439px){/*!@.hidden-xl-down*/.hidden-xl-down.sc-sdx-sticker-circle{display:none !important}}@media (min-width: 1280px){/*!@.visible-xl-up*/.visible-xl-up.sc-sdx-sticker-circle{display:block !important}}@media (min-width: 1440px){/*!@.hidden-ul-up*/.hidden-ul-up.sc-sdx-sticker-circle{display:none !important}}/*!@.hidden-ul-down*/.hidden-ul-down.sc-sdx-sticker-circle{display:none !important}@media (min-width: 1440px){/*!@.visible-ul-up*/.visible-ul-up.sc-sdx-sticker-circle{display:block !important}}@media (min-width: 0){/*!@.hidden-phone-up*/.hidden-phone-up.sc-sdx-sticker-circle{display:none !important}}@media (max-width: 767px){/*!@.hidden-phone-down*/.hidden-phone-down.sc-sdx-sticker-circle{display:none !important}}@media (min-width: 768px){/*!@.hidden-tablet-up*/.hidden-tablet-up.sc-sdx-sticker-circle{display:none !important}}@media (max-width: 1023px){/*!@.hidden-tablet-down*/.hidden-tablet-down.sc-sdx-sticker-circle{display:none !important}}@media (min-width: 1024px){/*!@.hidden-desktop-up*/.hidden-desktop-up.sc-sdx-sticker-circle{display:none !important}}@media (max-width: 1279px){/*!@.hidden-desktop-down*/.hidden-desktop-down.sc-sdx-sticker-circle{display:none !important}}@media (min-width: 0){/*!@.visible-phone-up*/.visible-phone-up.sc-sdx-sticker-circle{display:block !important}}@media (min-width: 768px){/*!@.visible-tablet-up*/.visible-tablet-up.sc-sdx-sticker-circle{display:block !important}}@media (min-width: 1024px){/*!@.visible-desktop-up*/.visible-desktop-up.sc-sdx-sticker-circle{display:block !important}}/*!@:host*/.sc-sdx-sticker-circle-h{display:block}/*!@.component*/.component.sc-sdx-sticker-circle{position:relative}/*!@.component .sticker*/.component.sc-sdx-sticker-circle .sticker.sc-sdx-sticker-circle{position:absolute;overflow:hidden;border:1px solid;border-radius:50%;white-space:nowrap;pointer-events:none}/*!@.component .sticker.white, .component .sticker.sc-white*/.component.sc-sdx-sticker-circle .sticker.white.sc-sdx-sticker-circle,.component.sc-sdx-sticker-circle .sticker.sc-white.sc-sdx-sticker-circle{border:0}/*!@.component .sticker .inner*/.component.sc-sdx-sticker-circle .sticker.sc-sdx-sticker-circle .inner.sc-sdx-sticker-circle{position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);text-align:center;overflow:hidden;padding-bottom:1px}/*!@.component .sticker.mobile*/.component.sc-sdx-sticker-circle .sticker.mobile.sc-sdx-sticker-circle{border-radius:0;width:100%;height:40px;padding-top:8px}/*!@.component .slot ::slotted(img)*/.component .slot .sc-sdx-sticker-circle-s>img{display:block}";

const padding = 16;
class StickerCircle {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.size = 112;
    this.contentWidth = undefined;
    this.colorClass = "sc-white";
    this.bgColorClass = "orchid";
    this.top = undefined;
    this.bottom = undefined;
    this.left = undefined;
    this.right = undefined;
    this.srHint = "";
  }
  /**
   * Listen to window resize events, and resize sticker accordingly
   */
  onWindowResizeDebounced() {
    if (this.resizeTimer) {
      clearTimeout(this.resizeTimer);
    }
    this.resizeTimer = setTimeout(() => {
      this.layout();
    }, 10);
  }
  /**
   * Draws the layout. Useful to redraw the component
   * when initially rendered on a hidden background.
   */
  async layout() {
    if (this.wrapperEl && this.stickerEl && this.contentWidth) {
      this.stickerEl.style.transform = `scale(${this.wrapperEl.clientWidth / this.contentWidth})`;
    }
  }
  componentDidLoad() {
    this.layout();
    const img = this.el.querySelector("img");
    if (img) {
      img.addEventListener("load", () => this.layout());
    }
  }
  getClassNames(mobile) {
    const hasMobileText = hasSlot(this.el, "text-mobile");
    return {
      sticker: true,
      "hidden-sm-down": hasMobileText && !mobile,
      "hidden-md-up": hasMobileText && mobile,
      hidden: !hasMobileText && mobile,
      mobile,
      [this.colorClass]: true,
      [`bg-${this.bgColorClass}`]: true,
      [getAppearance(this.el)]: true,
    };
  }
  getComponentClassNames() {
    return {
      component: true,
      [getAppearance(this.el)]: true,
    };
  }
  getStyles() {
    const isScalingEnabled = this.contentWidth !== undefined;
    return {
      sticker: {
        width: `${this.size}px`,
        height: `${this.size}px`,
        top: `${this.top}%`,
        bottom: `${this.bottom}%`,
        left: `${this.left}%`,
        right: `${this.right}%`,
        transformOrigin: `${this.top !== undefined ? "top" : "bottom"} ${this.left !== undefined ? "left" : "right"}`,
      },
      inner: {
        maxWidth: `${this.size - 2 * padding}px`,
        maxHeight: `${this.size - 2 * padding}px`,
      },
      slot: {
        minWidth: `${isScalingEnabled ? 0 : this.size}px`,
        minHeight: `${isScalingEnabled ? 0 : this.size}px`,
      },
    };
  }
  render() {
    return (hAsync(Host, null, hAsync("div", { class: this.getComponentClassNames(), ref: (el) => (this.wrapperEl = el) }, hAsync("div", { ref: (el) => (this.stickerEl = el), class: this.getClassNames(false), style: this.getStyles().sticker }, hAsync("div", { class: "inner", style: this.getStyles().inner, "aria-hidden": "true" }, hAsync("slot", { name: "text" }))), hAsync("div", { class: this.getClassNames(true) }, hAsync("slot", { name: "text-mobile" })), hAsync("div", { class: "slot", style: this.getStyles().slot }, hAsync("slot", null))), hAsync("span", { class: "sr-only" }, this.srHint)));
  }
  get el() { return getElement(this); }
  static get style() { return stickerCircleCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-sticker-circle",
    "$members$": {
      "size": [2],
      "contentWidth": [2, "content-width"],
      "colorClass": [1, "color-class"],
      "bgColorClass": [1, "bg-color-class"],
      "top": [2],
      "bottom": [2],
      "left": [2],
      "right": [2],
      "srHint": [1, "sr-hint"],
      "layout": [64]
    },
    "$listeners$": [[9, "resize", "onWindowResizeDebounced"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const tabsReducer = (state = {}, action) => {
  switch (action.type) {
    case "ADD_TABS_ITEM_EL":
      return {
        ...state,
        tabsItemEls: add(state.tabsItemEls, action.tabsItemEl).sort(sortByAppearanceInDomTree),
      };
    case "REMOVE_TABS_ITEM_EL":
      return {
        ...state,
        tabsItemEls: remove(state.tabsItemEls, action.tabsItemEl).sort(sortByAppearanceInDomTree),
      };
    case "DESELECT_TABS_ITEM_EL":
      if (state.selectedTabsItemEl === action.tabsItemEl) {
        return { ...state, selectedTabsItemEl: undefined };
      }
      return state;
    case "RESET_TABS_ITEM_ELS":
      // Simply trigger change detection
      return { ...state, tabsItemEls: [...state.tabsItemEls] };
    default:
      return state;
  }
};
function getInitialState() {
  return {
    tabsItemEls: [],
    selectedTabsItemEl: undefined,
    userInteractionInProgress: false,
  };
}

const tabsCss = "/*!@:root*/.sc-sdx-tabs:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-tabs-h,*.sc-sdx-tabs,*.sc-sdx-tabs:before,*.sc-sdx-tabs:after{box-sizing:border-box}/*!@.button-reset*/.button-reset.sc-sdx-tabs{font-family:TheSans, sans-serif;font-weight:500;line-height:24px;letter-spacing:-0.1px;font-size:18px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;vertical-align:middle;text-decoration:none;text-align:center;color:inherit;margin:0;cursor:pointer;transition:all 70ms cubic-bezier(0.4, 0, 0.6, 1);-webkit-tap-highlight-color:transparent}/*!@.button-reset:focus*/.button-reset.sc-sdx-tabs:focus{outline:0}/*!@.button-reset::-moz-focus-inner*/.button-reset.sc-sdx-tabs::-moz-focus-inner{border:0}/*!@:host*/.sc-sdx-tabs-h{display:block}/*!@.header*/.header.sc-sdx-tabs{background:#eef3f6;border-radius:5px}/*!@.header .tablist*/.header.sc-sdx-tabs .tablist.sc-sdx-tabs{position:relative;list-style-type:none;margin:0;white-space:nowrap}/*!@.header .tablist .indicator*/.header.sc-sdx-tabs .tablist.sc-sdx-tabs .indicator.sc-sdx-tabs{position:absolute;width:120px;top:4px;bottom:4px;background-color:#fff;border-radius:3px}/*!@.header .tablist .clickable*/.header.sc-sdx-tabs .tablist.sc-sdx-tabs .clickable.sc-sdx-tabs{cursor:pointer;outline:none;user-select:none;min-width:120px;max-width:240px;padding:8px 16px;border:none;font-size:16px;background:transparent;margin-top:4px;margin-bottom:4px;position:relative}/*!@.header .tablist .clickable:is(a)*/.header.sc-sdx-tabs .tablist.sc-sdx-tabs .clickable.sc-sdx-tabs:is(a){display:inline-block}/*!@.header .tablist .clickable:hover, .header .tablist .clickable:focus*/.header.sc-sdx-tabs .tablist.sc-sdx-tabs .clickable.sc-sdx-tabs:hover,.header.sc-sdx-tabs .tablist.sc-sdx-tabs .clickable.sc-sdx-tabs:focus{color:#0048cf}/*!@.header .tablist .clickable:disabled*/.header.sc-sdx-tabs .tablist.sc-sdx-tabs .clickable.sc-sdx-tabs:disabled{color:rgba(51, 51, 51, 0.4)}/*!@.header .tablist .clickable:disabled.disabled, .header .tablist .clickable:disabled:disabled*/.header.sc-sdx-tabs .tablist.sc-sdx-tabs .clickable.sc-sdx-tabs:disabled.disabled,.header.sc-sdx-tabs .tablist.sc-sdx-tabs .clickable.sc-sdx-tabs:disabled:disabled{cursor:not-allowed}/*!@.header .tablist .clickable:disabled.disabled:active, .header .tablist .clickable:disabled:disabled:active*/.header.sc-sdx-tabs .tablist.sc-sdx-tabs .clickable.sc-sdx-tabs:disabled.disabled:active,.header.sc-sdx-tabs .tablist.sc-sdx-tabs .clickable.sc-sdx-tabs:disabled:disabled:active{pointer-events:none;transform:none}/*!@.header .tablist .clickable.selected*/.header.sc-sdx-tabs .tablist.sc-sdx-tabs .clickable.selected.sc-sdx-tabs{color:#086adb}/*!@.header .tablist .clickable.selected:focus*/.header.sc-sdx-tabs .tablist.sc-sdx-tabs .clickable.selected.sc-sdx-tabs:focus{color:#0048cf}/*!@.body*/.body.sc-sdx-tabs{padding:24px 0 0}/*!@.component.sdx--dark-theme .header*/.component.sdx--dark-theme.sc-sdx-tabs .header.sc-sdx-tabs{background:#242424}/*!@.component.sdx--dark-theme .header .tablist .indicator*/.component.sdx--dark-theme.sc-sdx-tabs .header.sc-sdx-tabs .tablist.sc-sdx-tabs .indicator.sc-sdx-tabs{background-color:rgba(173, 173, 173, 0.15)}/*!@.component.sdx--dark-theme .header .tablist .clickable:hover, .component.sdx--dark-theme .header .tablist .clickable:focus*/.component.sdx--dark-theme.sc-sdx-tabs .header.sc-sdx-tabs .tablist.sc-sdx-tabs .clickable.sc-sdx-tabs:hover,.component.sdx--dark-theme.sc-sdx-tabs .header.sc-sdx-tabs .tablist.sc-sdx-tabs .clickable.sc-sdx-tabs:focus{color:#5ca3ff}/*!@.component.sdx--dark-theme .header .tablist .clickable:disabled*/.component.sdx--dark-theme.sc-sdx-tabs .header.sc-sdx-tabs .tablist.sc-sdx-tabs .clickable.sc-sdx-tabs:disabled{color:rgba(230, 230, 230, 0.5)}/*!@.component.sdx--dark-theme .header .tablist .clickable.selected*/.component.sdx--dark-theme.sc-sdx-tabs .header.sc-sdx-tabs .tablist.sc-sdx-tabs .clickable.selected.sc-sdx-tabs{color:#4294ff}/*!@.component.sdx--dark-theme .header .tablist .clickable.selected:focus*/.component.sdx--dark-theme.sc-sdx-tabs .header.sc-sdx-tabs .tablist.sc-sdx-tabs .clickable.selected.sc-sdx-tabs:focus{color:#5ca3ff}";

class Tabs {
  stateChanged({}, prev) {
    const state = this.state.get();
    const prevState = prev.get();
    if (state.selectedTabsItemEl !== prevState.selectedTabsItemEl) {
      this.selectedTabsItemElChanged(state);
    }
    if (state.tabsItemEls !== prevState.tabsItemEls) {
      this.tabsItemElsChanged();
    }
  }
  changeCallbackChanged() {
    this.setInvokeChangeCallback();
  }
  onKeyDown(e) {
    // Only react to key events if the component is focussed
    if (e.target !== this.el) {
      return;
    }
    const { tabsItemEls, selectedTabsItemEl } = this.state.get();
    let count = 0;
    switch (e.key) {
      case "ArrowLeft": {
        e.preventDefault(); // Prevent scrolling
        let prevEl = getPreviousFromList(tabsItemEls, selectedTabsItemEl);
        if (prevEl) {
          while (prevEl.disabled && count < tabsItemEls.length) {
            prevEl = getPreviousFromList(tabsItemEls, prevEl);
            count++;
          }
          this.select(prevEl, true, true);
        }
        break;
      }
      case "ArrowRight": {
        e.preventDefault(); // Prevent scrolling
        let nextEl = getNextFromList(tabsItemEls, selectedTabsItemEl);
        if (nextEl) {
          while (nextEl.disabled && count < tabsItemEls.length) {
            nextEl = getNextFromList(tabsItemEls, nextEl);
            count++;
          }
          this.select(nextEl, true, true);
        }
        break;
      }
    }
  }
  /**
   * Draws the layout. Useful to redraw the component when initially
   * rendered on a hidden parent (e.g. an sdx-tabs-item).
   */
  async layout() {
    var _a;
    if (!isHidden(this.el)) {
      (_a = this.sdxScrollViewEl) === null || _a === void 0 ? void 0 : _a.layout();
      this.animateIndicatorElToSelectedTab();
      this.isInitialLayout = false;
    }
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.sdxselect = createEvent(this, "sdxselect", 7);
    this.isInitialLayout = true;
    this.componentDidLoadComplete = false;
    this.invokeChangeCallback = () => null;
    this.selectedTabsItemElDidUpdate = false;
    this.tabsItemElsDidUpdate = false;
    this.state = undefined;
    this.changeCallback = undefined;
    this.srHint = "";
    this.animated = true;
    this.setInvokeChangeCallback();
    this.store = new StoreConnection(this, tabsReducer, getInitialState(), [
      "tabsItemEls",
      "selectedTabsItemEl",
    ]);
    this.store.flush();
  }
  /**
   * Delay the first render() until the first item has registered itself.
   * Otherwise, if sdx-tabs-item.entry.js wasn't fetched fast enough, the
   * initial render() happens too early (see below) and therefore calls
   * componentOnReady() too early.
   *
   * sdx-tabs: constructor()
   * sdx-tabs: render() <-- too early, couldn't render buttons yet
   * sdx-tabs-item: constructor()
   * sdx-tabs: componentDidLoad()
   *
   * Note: it was also tried to move this logic into componentDidRender(),
   * which is always called *after* all childrens componentDidLoad(), but it
   * didn't work because in componentDidLoad(), the bounding rect was still 0.
   *
   * Also created https://github.com/ionic-team/stencil/issues/3411.
   */
  async componentWillLoad() {
    await waitFor(() => this.state.get().tabsItemEls.length > 0);
    this.selectDefaultTabsItem();
  }
  componentDidLoad() {
    this.layout();
    this.store.subscribe();
    this.componentDidLoadComplete = true;
  }
  componentDidUpdate() {
    if (this.selectedTabsItemElDidUpdate) {
      this.invokeChangeCallback(this.state.get().selectedTabsItemEl);
      this.layout();
      this.selectedTabsItemElDidUpdate = false;
    }
    if (this.tabsItemElsDidUpdate) {
      this.layout();
      this.tabsItemElsDidUpdate = false;
    }
  }
  selectedTabsItemElChanged(state) {
    if (!this.componentDidLoadComplete) {
      return;
    }
    // Ensure visibility of selected tabs item el (if any)
    if (!state.selectedTabsItemEl) {
      return;
    }
    this.selectedTabsItemElDidUpdate = true;
  }
  tabsItemElsChanged() {
    this.tabsItemElsDidUpdate = true;
  }
  setInvokeChangeCallback() {
    this.invokeChangeCallback = parseFunction(this.changeCallback);
  }
  getAnimationDuration() {
    if (!this.animated) {
      return 0;
    }
    return this.isInitialLayout ? 0 : 200;
  }
  /**
   * If no tabs item is selected initially, display the first one
   */
  selectDefaultTabsItem() {
    const { selectedTabsItemEl, tabsItemEls } = this.state.get();
    if (!selectedTabsItemEl) {
      const defaultTabsItemEl = tabsItemEls.find((el) => !el.disabled);
      defaultTabsItemEl && this.select(defaultTabsItemEl);
    }
  }
  animateIndicatorElToSelectedTab() {
    const { selectedTabsItemEl } = this.state.get();
    if (!selectedTabsItemEl) {
      this.indicatorEl.style.display = "none";
      return;
    }
    const componentElRect = this.componentEl.getBoundingClientRect();
    const tablistElRect = this.tablistEl.getBoundingClientRect();
    const clickableEl = this.tabsItemsWithClickableEl.get(selectedTabsItemEl);
    const clickableElRect = clickableEl.getBoundingClientRect();
    const offsetLeft = componentElRect.left;
    const scrollLeft = Math.abs(tablistElRect.left - offsetLeft);
    const clickableElLeft = clickableElRect.left - offsetLeft;
    const gutter = 4;
    this.indicatorEl.style.display = this.isInitialLayout ? "none" : "";
    const componentElCenter = componentElRect.width / 2;
    const clickableElCenter = clickableElRect.width / 2;
    const hasTabsItemElOverflow = {
      toLeft: componentElRect.left - (clickableElRect.left - gutter) > 0,
      toRight: clickableElRect.right + gutter - componentElRect.right > 0,
    };
    // Scroll to selected tab when it's out of sight
    if (hasTabsItemElOverflow.toLeft || hasTabsItemElOverflow.toRight) {
      this.sdxScrollViewEl.translateX(clickableElLeft - componentElCenter + clickableElCenter, !this.isInitialLayout);
    }
    animation.start({
      targets: this.indicatorEl,
      duration: this.getAnimationDuration(),
      easing: "easeOutQuad",
      translateX: scrollLeft + clickableElLeft + gutter,
      width: clickableElRect.right - clickableElRect.left - gutter * 2,
      complete: () => {
        this.indicatorEl.style.display = "";
      },
    });
  }
  select(el, userInteractionInProgress = false, selectedByArrowKeys = false) {
    var _a;
    this.store.set("userInteractionInProgress", userInteractionInProgress);
    this.store.set("selectedTabsItemEl", el);
    this.store.set("userInteractionInProgress", false);
    // If selected using the keyboard, ensure screen readers detect the change
    if (selectedByArrowKeys) {
      (_a = this.tabsItemsWithClickableEl.get(el)) === null || _a === void 0 ? void 0 : _a.focus();
    }
  }
  getComponentClassNames() {
    return {
      component: true,
      [getAppearance(this.el)]: true,
    };
  }
  getClickableElClassNames(tabsItemEl) {
    return {
      clickable: true,
      "button-reset": true,
      selected: tabsItemEl === this.state.get().selectedTabsItemEl,
    };
  }
  render() {
    const { tabsItemEls, selectedTabsItemEl } = this.state.get();
    this.tabsItemsWithClickableEl = new WeakMap(); // clear previous entries
    return (hAsync("div", { class: this.getComponentClassNames(), ref: (el) => (this.componentEl = el) }, hAsync("div", { class: "header" }, hAsync("sdx-scroll-view", { ref: (el) => (this.sdxScrollViewEl = el) }, hAsync("div", { class: "tablist", role: "tablist", "aria-label": this.srHint, ref: (el) => (this.tablistEl = el) }, hAsync("div", { class: "indicator", ref: (el) => (this.indicatorEl = el), style: {
        display: "none" /* will be displayed during animation */,
      } }), tabsItemEls.map((tabsItemEl) => {
      const isSelected = tabsItemEl === selectedTabsItemEl;
      const Tag = tabsItemEl.href ? "a" : "button";
      return (hAsync(Tag, { class: this.getClickableElClassNames(tabsItemEl), onClick: () => this.select(tabsItemEl, true), disabled: tabsItemEl.disabled && !tabsItemEl.href, "aria-disabled": tabsItemEl.disabled.toString(), "aria-selected": isSelected.toString(), role: "tab", tabindex: isSelected ? "0" : "-1", href: tabsItemEl.href, ref: (el) => { var _a; return el && ((_a = this.tabsItemsWithClickableEl) === null || _a === void 0 ? void 0 : _a.set(tabsItemEl, el)); } }, hAsync("sdx-text-truncate", null, hAsync("sdx-icon", { iconName: tabsItemEl.iconName }), " ", tabsItemEl.label)));
    })))), hAsync("div", { class: "body" }, hAsync("slot", null))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "state": ["stateChanged"],
    "changeCallback": ["changeCallbackChanged"]
  }; }
  static get style() { return tabsCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-tabs",
    "$members$": {
      "changeCallback": [1, "change-callback"],
      "srHint": [1, "sr-hint"],
      "animated": [4],
      "state": [32],
      "layout": [64]
    },
    "$listeners$": [[8, "keydown", "onKeyDown"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const tabsItemCss = "/*!@:root*/.sc-sdx-tabs-item:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-tabs-item-h,*.sc-sdx-tabs-item,*.sc-sdx-tabs-item:before,*.sc-sdx-tabs-item:after{box-sizing:border-box}/*!@:host*/.sc-sdx-tabs-item-h{outline:none}/*!@.component*/.component.sc-sdx-tabs-item{display:none}/*!@.component.selected*/.component.selected.sc-sdx-tabs-item{display:block}";

class TabsItem {
  stateChanged({}, prev) {
    const state = this.state.get();
    const prevState = prev.get();
    if (state.selectedTabsItemEl !== prevState.selectedTabsItemEl) {
      this.selectedTabsItemElChanged(state);
    }
  }
  selectedCallbackChanged() {
    this.setInvokeSelectedCallback();
  }
  selectedChanged() {
    this.selectedChangedInProgress = true;
    if (this.selected) {
      this.store.set("selectedTabsItemEl", this.el);
    }
    this.selectedChangedInProgress = false;
  }
  propChanged() {
    this.store.dispatch({ type: "RESET_TABS_ITEM_ELS" });
  }
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.sdxselect = createEvent(this, "sdxselect", 7);
    this.selectedChangedInProgress = false;
    this.invokeSelectedCallback = () => null;
    this.onComponentDidUpdate = [];
    this.state = undefined;
    this.selectedCallback = undefined;
    this.label = "";
    this.disabled = false;
    this.iconName = undefined;
    this.selected = false;
    this.href = undefined;
    this.setInvokeSelectedCallback();
    this.store = new StoreConnection(this, tabsReducer, getInitialState(), [
      "selectedTabsItemEl",
    ]);
  }
  connectedCallback() {
    // Register self
    this.store.dispatch({
      type: "ADD_TABS_ITEM_EL",
      tabsItemEl: this.el,
    });
    if (this.selected) {
      this.store.set("selectedTabsItemEl", this.el);
    }
  }
  disconnectedCallback() {
    this.store.dispatch({ type: "DESELECT_TABS_ITEM_EL", tabsItemEl: this.el });
    this.store.dispatch({
      type: "REMOVE_TABS_ITEM_EL",
      tabsItemEl: this.el,
    });
  }
  componentDidLoad() {
    this.store.subscribe();
  }
  componentDidUpdate() {
    this.onComponentDidUpdate.forEach((fn) => fn());
    this.onComponentDidUpdate = [];
  }
  selectedTabsItemElChanged(state) {
    if (!this.selectedChangedInProgress) {
      this.selected = state.selectedTabsItemEl === this.el;
    }
    // Make sure events are fired *after* the layout has rendered.
    this.onComponentDidUpdate.push(() => {
      if (this.selected) {
        this.layout();
        if (state.userInteractionInProgress) {
          this.sdxselect.emit();
        }
        this.invokeSelectedCallback(state.selectedTabsItemEl);
      }
    });
  }
  setInvokeSelectedCallback() {
    this.invokeSelectedCallback = parseFunction(this.selectedCallback);
  }
  // Run layout() on all SDX web components on the tab.
  layout() {
    const children = this.el.querySelectorAll("*");
    children.forEach((child) => {
      if (isSDXWebComponent(child) && typeof child.layout === "function") {
        child.layout();
      }
    });
  }
  getComponentClassNames() {
    return {
      component: true,
      selected: this.el === this.state.get().selectedTabsItemEl,
      disabled: this.disabled,
    };
  }
  render() {
    return (hAsync(Host, { role: "tabpanel", "aria-label": this.label, tabindex: this.selected ? "0" : "-1" }, hAsync("div", { class: this.getComponentClassNames() }, hAsync("slot", null))));
  }
  get el() { return getElement(this); }
  static get watchers() { return {
    "state": ["stateChanged"],
    "selectedCallback": ["selectedCallbackChanged"],
    "selected": ["selectedChanged"],
    "label": ["propChanged"],
    "disabled": ["propChanged"],
    "iconName": ["propChanged"],
    "href": ["propChanged"]
  }; }
  static get style() { return tabsItemCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-tabs-item",
    "$members$": {
      "selectedCallback": [1, "selected-callback"],
      "label": [1],
      "disabled": [4],
      "iconName": [1, "icon-name"],
      "selected": [1028],
      "href": [1],
      "state": [32]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const textTruncateCss = "/*!@:root*/.sc-sdx-text-truncate:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-text-truncate-h,*.sc-sdx-text-truncate,*.sc-sdx-text-truncate:before,*.sc-sdx-text-truncate:after{box-sizing:border-box}/*!@:host*/.sc-sdx-text-truncate-h{display:block;width:100%}/*!@.component*/.component.sc-sdx-text-truncate{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}";

class TextTruncate {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.isTruncated = false;
  }
  onMouseOver() {
    if (!this.componentEl) {
      return;
    }
    // reset state in case textContent changes from truncated text to another truncated text
    this.isTruncated = false;
    const prevPosition = this.componentEl.style.position;
    const width = this.componentEl.clientWidth;
    // measure effective width
    this.componentEl.style.position = "absolute";
    const effectiveWidth = this.componentEl.clientWidth;
    this.componentEl.style.position = prevPosition;
    this.isTruncated = effectiveWidth > width;
  }
  render() {
    return (hAsync("div", { class: "component", title: this.isTruncated ? this.el.textContent || "" : undefined, ref: (el) => (this.componentEl = el) }, hAsync("slot", null)));
  }
  get el() { return getElement(this); }
  static get style() { return textTruncateCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-text-truncate",
    "$members$": {
      "isTruncated": [32]
    },
    "$listeners$": [[1, "mouseover", "onMouseOver"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const trapFocusCss = "/*!@:root*/.sc-sdx-trap-focus:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-trap-focus-h,*.sc-sdx-trap-focus,*.sc-sdx-trap-focus:before,*.sc-sdx-trap-focus:after{box-sizing:border-box}/*!@.sr-only*/.sr-only.sc-sdx-trap-focus{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);border:0}/*!@.sr-only-focusable:active, .sr-only-focusable:focus*/.sr-only-focusable.sc-sdx-trap-focus:active,.sr-only-focusable.sc-sdx-trap-focus:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}";

class TrapFocus {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.firstFocusableElement = undefined;
  }
  onKey(e) {
    var _a;
    const isTabPressed = e.key === "Tab";
    if (!isTabPressed) {
      return;
    }
    const { startOfDialogHiddenEl, endOfDialogHiddenEl } = this;
    const hasFocusElement = (_a = this.el.shadowRoot) === null || _a === void 0 ? void 0 : _a.activeElement;
    if (e.shiftKey) {
      // if shift key pressed for shift + tab combination
      if (hasFocusElement === startOfDialogHiddenEl) {
        endOfDialogHiddenEl === null || endOfDialogHiddenEl === void 0 ? void 0 : endOfDialogHiddenEl.focus();
        e.preventDefault();
      }
    }
    else {
      // if only tab key is pressed
      if (hasFocusElement === endOfDialogHiddenEl) {
        this.setFocusToFirstElement();
        e.preventDefault();
      }
    }
  }
  /**
   * Sets the focus on the component if a child does not have the focus yet.
   */
  async doFocus() {
    const { el, slotEl } = this;
    const elWithoutSlotContainsActiveElement = el.contains(document.activeElement);
    const slotContainsActiveElement = slotEl === null || slotEl === void 0 ? void 0 : slotEl.assignedElements().some((value) => closest(document.activeElement, value));
    if (!(slotContainsActiveElement || elWithoutSlotContainsActiveElement)) {
      this.setFocusToFirstElement();
    }
  }
  setFocusToFirstElement() {
    const { startOfDialogHiddenEl, firstFocusableElement } = this;
    firstFocusableElement
      ? firstFocusableElement === null || firstFocusableElement === void 0 ? void 0 : firstFocusableElement.doFocus()
      : startOfDialogHiddenEl === null || startOfDialogHiddenEl === void 0 ? void 0 : startOfDialogHiddenEl.focus();
  }
  render() {
    return (hAsync(Host, null, hAsync("div", { class: "sr-only", "data-nosnippet": true, ref: (el) => (this.startOfDialogHiddenEl = el), tabindex: 0 }, translate("Start of dialog", this.el.lang)), hAsync("slot", { ref: (el) => (this.slotEl = el) }), hAsync("div", { class: "sr-only", "data-nosnippet": true, ref: (el) => (this.endOfDialogHiddenEl = el), tabindex: 0 }, translate("End of dialog", this.el.lang))));
  }
  get el() { return getElement(this); }
  static get style() { return trapFocusCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-trap-focus",
    "$members$": {
      "firstFocusableElement": [16],
      "doFocus": [64]
    },
    "$listeners$": [[0, "keyup", "onKey"], [0, "keydown", "onKey"]],
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

const validationMessageCss = "/*!@:root*/.sc-sdx-validation-message:root{--sdx-header-height-mobile:72px;--sdx-header-height-mobile-with-breadcrumbs:120px;--sdx-header-height-desktop:112px;--sdx-header-height-desktop-with-breadcrumbs:160px;--sdx-header-height-sticky:72px;--sdx-grid-breakpoint-xs:0;--sdx-grid-breakpoint-sm:480px;--sdx-grid-breakpoint-md:768px;--sdx-grid-breakpoint-lg:1024px;--sdx-grid-breakpoint-xl:1280px;--sdx-grid-breakpoint-ul:1440px;--sdx-baseline:8px;--sdx-baseline-2:16px;--sdx-baseline-3:24px;--sdx-baseline-4:32px;--sdx-baseline-5:40px;--sdx-baseline-6:48px;--sdx-color-sc-navy:#015;--sdx-color-sc-blue:#1af;--sdx-color-sc-red:#d12;--sdx-color-sc-white:#fff;--sdx-color-blue-tint-2:#a2cdf4;--sdx-color-blue-tint-3:#d1e6f9;--sdx-color-aluminum:#dde3e7;--sdx-color-aluminum-tint-2:#e4e9ec;--sdx-color-horizon:#eef3f6;--sdx-color-horizon-tint-2:#f8fafb;--sdx-color-gray:#333;--sdx-color-gray-tint-2:#474747;--sdx-color-gray-tint-3:#5c5c5c;--sdx-color-gray-tint-4:#666;--sdx-color-gray-tint-5:#858585;--sdx-color-gray-tint-6:#adadad;--sdx-color-gray-tint-7:#bbb;--sdx-color-gray-tint-8:#d6d6d6;--sdx-color-int-blue:#086adb;--sdx-color-int-blue--active:#0048cf;--sdx-color-int-gray:#cfd5d9;--sdx-color-int-gray--active:#b1b9be;--sdx-color-int-green:#1b8712;--sdx-color-int-green--active:#0d6f2c;--sdx-color-int-red:#d12;--sdx-color-int-red--active:#be0000;--sdx-color-int-orange:#cf4a0c;--sdx-color-int-orange--active:#ba3e06;--sdx-color-azure:#1781e3;--sdx-color-azure--active:#0851da;--sdx-color-orchid:#a63297;--sdx-color-orchid--active:#7f2879;--sdx-color-iris:#5944c6;--sdx-color-iris--active:#42389e;--sdx-color-pink:#e61e64;--sdx-color-pink--active:#bf1b5a;--sdx-color-turquoise:#0eaba9;--sdx-color-turquoise--active:#0c847e}/*!@:host,\n*,\n*:before,\n*:after*/.sc-sdx-validation-message-h,*.sc-sdx-validation-message,*.sc-sdx-validation-message:before,*.sc-sdx-validation-message:after{box-sizing:border-box}/*!@.component*/.component.sc-sdx-validation-message{display:flex;color:#d12;font-size:16px;margin-top:6px;margin-left:-8px}/*!@.component.sdx--dark-theme*/.component.sdx--dark-theme.sc-sdx-validation-message{color:#f35d6a}";

class ValidationMessage {
  constructor(hostRef) {
    registerInstance(this, hostRef);
    this.validationMessage = "";
  }
  getComponentClassNames() {
    return {
      component: true,
      [getAppearance(this.el)]: true,
    };
  }
  render() {
    return (hAsync("div", { class: this.getComponentClassNames() }, hAsync("sdx-icon", { "icon-name": "icon-exclamation-mark", size: 2, "aria-hidden": "true" }), hAsync("span", null, this.validationMessage)));
  }
  get el() { return getElement(this); }
  static get style() { return validationMessageCss; }
  static get cmpMeta() { return {
    "$flags$": 9,
    "$tagName$": "sdx-validation-message",
    "$members$": {
      "validationMessage": [1, "validation-message"]
    },
    "$listeners$": undefined,
    "$lazyBundleId$": "-",
    "$attrsToReflect$": []
  }; }
}

registerComponents([
  Accordion,
  AccordionItem,
  AccordionItemBody,
  AccordionItemHeader,
  AccordionItemSection,
  Animation,
  Arrow,
  Backdrop,
  Button,
  ButtonGroup,
  Card,
  CodeEditor,
  ColorPicker,
  Dialog,
  DialogContent,
  DialogToggle,
  Dummy,
  ExpandAndCollapse,
  Figma,
  Filter,
  FilterExampleLarge,
  FilterExampleSmall,
  Flip,
  Header,
  HeaderLeftHandMenu,
  HeaderMenu,
  Icon,
  Input$1,
  Input,
  InputGroup,
  InputItem,
  ItunesAutocomplete,
  LoadingSpinner,
  MenuFlyout,
  MenuFlyoutContent,
  MenuFlyoutCta,
  MenuFlyoutList,
  MenuFlyoutListItem,
  MenuFlyoutToggle,
  NumericStepper,
  OptionPicker,
  PieChart,
  Price,
  ProgressFull,
  ProgressFullStep,
  Ribbon,
  ScrollToTop,
  ScrollView,
  Search,
  Select,
  SelectList,
  SelectOptGroup,
  SelectOption,
  ShowMore,
  StickerCircle,
  Tabs,
  TabsItem,
  TextTruncate,
  TrapFocus,
  ValidationMessage,
]);

exports.hydrateApp = hydrateApp;


  /*hydrateAppClosure end*/
  hydrateApp(window, $stencilHydrateOpts, $stencilHydrateResults, $stencilAfterHydrate, $stencilHydrateResolve);
  }

  hydrateAppClosure($stencilWindow);
}

function createWindowFromHtml(e, t) {
 let r = templateWindows.get(t);
 return null == r && (r = new MockWindow(e), templateWindows.set(t, r)), cloneWindow(r);
}

function inspectElement(e, t, r) {
 const s = t.children;
 for (let t = 0, n = s.length; t < n; t++) {
  const n = s[t], o = n.nodeName.toLowerCase();
  if (o.includes("-")) {
   const t = e.components.find((e => e.tag === o));
   null != t && (t.count++, r > t.depth && (t.depth = r));
  } else switch (o) {
  case "a":
   const t = collectAttributes(n);
   t.href = n.href, "string" == typeof t.href && (e.anchors.some((e => e.href === t.href)) || e.anchors.push(t));
   break;

  case "img":
   const r = collectAttributes(n);
   r.src = n.src, "string" == typeof r.src && (e.imgs.some((e => e.src === r.src)) || e.imgs.push(r));
   break;

  case "link":
   const s = collectAttributes(n);
   s.href = n.href, "string" == typeof s.rel && "stylesheet" === s.rel.toLowerCase() && "string" == typeof s.href && (e.styles.some((e => e.link === s.href)) || (delete s.rel, 
   delete s.type, e.styles.push(s)));
   break;

  case "script":
   const o = collectAttributes(n);
   if (n.hasAttribute("src")) o.src = n.src, "string" == typeof o.src && (e.scripts.some((e => e.src === o.src)) || e.scripts.push(o)); else {
    const t = n.getAttribute("data-stencil-static");
    t && e.staticData.push({
     id: t,
     type: n.getAttribute("type"),
     content: n.textContent
    });
   }
  }
  inspectElement(e, n, ++r);
 }
}

function collectAttributes(e) {
 const t = {}, r = e.attributes;
 for (let e = 0, s = r.length; e < s; e++) {
  const s = r.item(e), n = s.nodeName.toLowerCase();
  if (SKIP_ATTRS.has(n)) continue;
  const o = s.nodeValue;
  "class" === n && "" === o || (t[n] = o);
 }
 return t;
}

function patchDomImplementation(e, t) {
 let r;
 if (null != e.defaultView ? (t.destroyWindow = !0, patchWindow(e.defaultView), r = e.defaultView) : (t.destroyWindow = !0, 
 t.destroyDocument = !1, r = new MockWindow(!1)), r.document !== e && (r.document = e), 
 e.defaultView !== r && (e.defaultView = r), "function" != typeof e.documentElement.constructor.prototype.getRootNode && (e.createElement("unknown-element").constructor.prototype.getRootNode = getRootNode), 
 "function" == typeof e.createEvent) {
  const t = e.createEvent("CustomEvent").constructor;
  r.CustomEvent !== t && (r.CustomEvent = t);
 }
 try {
  e.baseURI;
 } catch (t) {
  Object.defineProperty(e, "baseURI", {
   get() {
    const t = e.querySelector("base[href]");
    return t ? new URL(t.getAttribute("href"), r.location.href).href : r.location.href;
   }
  });
 }
 return r;
}

function getRootNode(e) {
 const t = null != e && !0 === e.composed;
 let r = this;
 for (;null != r.parentNode; ) r = r.parentNode, !0 === t && null == r.parentNode && null != r.host && (r = r.host);
 return r;
}

function normalizeHydrateOptions(e) {
 const t = Object.assign({
  serializeToHtml: !1,
  destroyWindow: !1,
  destroyDocument: !1
 }, e || {});
 return "boolean" != typeof t.clientHydrateAnnotations && (t.clientHydrateAnnotations = !0), 
 "boolean" != typeof t.constrainTimeouts && (t.constrainTimeouts = !0), "number" != typeof t.maxHydrateCount && (t.maxHydrateCount = 300), 
 "boolean" != typeof t.runtimeLogging && (t.runtimeLogging = !1), "number" != typeof t.timeout && (t.timeout = 15e3), 
 Array.isArray(t.excludeComponents) ? t.excludeComponents = t.excludeComponents.filter(filterValidTags).map(mapValidTags) : t.excludeComponents = [], 
 Array.isArray(t.staticComponents) ? t.staticComponents = t.staticComponents.filter(filterValidTags).map(mapValidTags) : t.staticComponents = [], 
 t;
}

function filterValidTags(e) {
 return "string" == typeof e && e.includes("-");
}

function mapValidTags(e) {
 return e.trim().toLowerCase();
}

function generateHydrateResults(e) {
 "string" != typeof e.url && (e.url = "https://hydrate.stenciljs.com/"), "string" != typeof e.buildId && (e.buildId = createHydrateBuildId());
 const t = {
  buildId: e.buildId,
  diagnostics: [],
  url: e.url,
  host: null,
  hostname: null,
  href: null,
  pathname: null,
  port: null,
  search: null,
  hash: null,
  html: null,
  httpStatus: null,
  hydratedCount: 0,
  anchors: [],
  components: [],
  imgs: [],
  scripts: [],
  staticData: [],
  styles: [],
  title: null
 };
 try {
  const r = new URL(e.url, "https://hydrate.stenciljs.com/");
  t.url = r.href, t.host = r.host, t.hostname = r.hostname, t.href = r.href, t.port = r.port, 
  t.pathname = r.pathname, t.search = r.search, t.hash = r.hash;
 } catch (e) {
  renderCatchError(t, e);
 }
 return t;
}

function renderBuildDiagnostic(e, t, r, s) {
 const n = {
  level: t,
  type: "build",
  header: r,
  messageText: s,
  relFilePath: null,
  absFilePath: null,
  lines: []
 };
 return e.pathname ? "/" !== e.pathname && (n.header += ": " + e.pathname) : e.url && (n.header += ": " + e.url), 
 e.diagnostics.push(n), n;
}

function renderBuildError(e, t) {
 return renderBuildDiagnostic(e, "error", "Hydrate Error", t);
}

function renderCatchError(e, t) {
 const r = renderBuildError(e, null);
 return null != t && (null != t.stack ? r.messageText = t.stack.toString() : null != t.message ? r.messageText = t.message.toString() : r.messageText = t.toString()), 
 r;
}

function runtimeLog(e, t, r) {
 global.console[t].apply(global.console, [ `[ ${e}  ${t} ] `, ...r ]);
}

function renderToString(e, t) {
 const r = normalizeHydrateOptions(t);
 return r.serializeToHtml = !0, new Promise((t => {
  let s;
  const n = generateHydrateResults(r);
  if (hasError(n.diagnostics)) t(n); else if ("string" == typeof e) try {
   r.destroyWindow = !0, r.destroyDocument = !0, s = new MockWindow(e), render(s, r, n, t);
  } catch (e) {
   s && s.close && s.close(), s = null, renderCatchError(n, e), t(n);
  } else if (isValidDocument(e)) try {
   r.destroyDocument = !1, s = patchDomImplementation(e, r), render(s, r, n, t);
  } catch (e) {
   s && s.close && s.close(), s = null, renderCatchError(n, e), t(n);
  } else renderBuildError(n, 'Invalid html or document. Must be either a valid "html" string, or DOM "document".'), 
  t(n);
 }));
}

function hydrateDocument(e, t) {
 const r = normalizeHydrateOptions(t);
 return r.serializeToHtml = !1, new Promise((t => {
  let s;
  const n = generateHydrateResults(r);
  if (hasError(n.diagnostics)) t(n); else if ("string" == typeof e) try {
   r.destroyWindow = !0, r.destroyDocument = !0, s = new MockWindow(e), render(s, r, n, t);
  } catch (e) {
   s && s.close && s.close(), s = null, renderCatchError(n, e), t(n);
  } else if (isValidDocument(e)) try {
   r.destroyDocument = !1, s = patchDomImplementation(e, r), render(s, r, n, t);
  } catch (e) {
   s && s.close && s.close(), s = null, renderCatchError(n, e), t(n);
  } else renderBuildError(n, 'Invalid html or document. Must be either a valid "html" string, or DOM "document".'), 
  t(n);
 }));
}

function render(e, t, r, s) {
 if (process.__stencilErrors || (process.__stencilErrors = !0, process.on("unhandledRejection", (e => {
  console.log("unhandledRejection", e);
 }))), function n(e, t, r, s) {
  try {
   e.location.href = r.url;
  } catch (e) {
   renderCatchError(s, e);
  }
  if ("string" == typeof r.userAgent) try {
   e.navigator.userAgent = r.userAgent;
  } catch (e) {}
  if ("string" == typeof r.cookie) try {
   t.cookie = r.cookie;
  } catch (e) {}
  if ("string" == typeof r.referrer) try {
   t.referrer = r.referrer;
  } catch (e) {}
  if ("string" == typeof r.direction) try {
   t.documentElement.setAttribute("dir", r.direction);
  } catch (e) {}
  if ("string" == typeof r.language) try {
   t.documentElement.setAttribute("lang", r.language);
  } catch (e) {}
  if ("string" == typeof r.buildId) try {
   t.documentElement.setAttribute("data-stencil-build", r.buildId);
  } catch (e) {}
  try {
   e.customElements = null;
  } catch (e) {}
  return r.constrainTimeouts && constrainTimeouts(e), function n(e, t, r) {
   try {
    const s = e.location.pathname;
    e.console.error = (...e) => {
     const n = e.reduce(((e, t) => {
      if (t) {
       if (null != t.stack) return e + " " + String(t.stack);
       if (null != t.message) return e + " " + String(t.message);
      }
      return String(t);
     }), "").trim();
     "" !== n && (renderCatchError(r, n), t.runtimeLogging && runtimeLog(s, "error", [ n ]));
    }, e.console.debug = (...e) => {
     renderBuildDiagnostic(r, "debug", "Hydrate Debug", [ ...e ].join(", ")), t.runtimeLogging && runtimeLog(s, "debug", e);
    }, t.runtimeLogging && [ "log", "warn", "assert", "info", "trace" ].forEach((t => {
     e.console[t] = (...e) => {
      runtimeLog(s, t, e);
     };
    }));
   } catch (e) {
    renderCatchError(r, e);
   }
  }(e, r, s), e;
 }(e, e.document, t, r), "function" == typeof t.beforeHydrate) try {
  const n = t.beforeHydrate(e.document);
  isPromise(n) ? n.then((() => {
   hydrateFactory(e, t, r, afterHydrate, s);
  })) : hydrateFactory(e, t, r, afterHydrate, s);
 } catch (n) {
  renderCatchError(r, n), finalizeHydrate(e, e.document, t, r, s);
 } else hydrateFactory(e, t, r, afterHydrate, s);
}

function afterHydrate(e, t, r, s) {
 if ("function" == typeof t.afterHydrate) try {
  const n = t.afterHydrate(e.document);
  isPromise(n) ? n.then((() => {
   finalizeHydrate(e, e.document, t, r, s);
  })) : finalizeHydrate(e, e.document, t, r, s);
 } catch (n) {
  renderCatchError(r, n), finalizeHydrate(e, e.document, t, r, s);
 } else finalizeHydrate(e, e.document, t, r, s);
}

function finalizeHydrate(e, t, r, s, n) {
 try {
  if (inspectElement(s, t.documentElement, 0), !1 !== r.removeUnusedStyles) try {
   removeUnusedStyles(t, s.diagnostics);
  } catch (e) {
   renderCatchError(s, e);
  }
  if ("string" == typeof r.title) try {
   t.title = r.title;
  } catch (e) {
   renderCatchError(s, e);
  }
  s.title = t.title, r.removeScripts && removeScripts(t.documentElement);
  try {
   updateCanonicalLink(t, r.canonicalUrl);
  } catch (e) {
   renderCatchError(s, e);
  }
  try {
   relocateMetaCharset(t);
  } catch (e) {}
  hasError(s.diagnostics) || (s.httpStatus = 200);
  try {
   const e = t.head.querySelector('meta[http-equiv="status"]');
   if (null != e) {
    const t = e.getAttribute("content");
    t && t.length > 0 && (s.httpStatus = parseInt(t, 10));
   }
  } catch (e) {}
  r.clientHydrateAnnotations && t.documentElement.classList.add("hydrated"), r.serializeToHtml && (s.html = serializeDocumentToString(t, r));
 } catch (e) {
  renderCatchError(s, e);
 }
 if (r.destroyWindow) try {
  r.destroyDocument || (e.document = null, t.defaultView = null), e.close && e.close();
 } catch (e) {
  renderCatchError(s, e);
 }
 n(s);
}

function serializeDocumentToString(e, t) {
 return serializeNodeToHtml(e, {
  approximateLineWidth: t.approximateLineWidth,
  outerHtml: !1,
  prettyHtml: t.prettyHtml,
  removeAttributeQuotes: t.removeAttributeQuotes,
  removeBooleanAttributeQuotes: t.removeBooleanAttributeQuotes,
  removeEmptyAttributes: t.removeEmptyAttributes,
  removeHtmlComments: t.removeHtmlComments,
  serializeShadowRoot: !1
 });
}

function isValidDocument(e) {
 return null != e && 9 === e.nodeType && null != e.documentElement && 1 === e.documentElement.nodeType && null != e.body && 1 === e.body.nodeType;
}

function removeScripts(e) {
 const t = e.children;
 for (let e = t.length - 1; e >= 0; e--) {
  const r = t[e];
  removeScripts(r), ("SCRIPT" === r.nodeName || "LINK" === r.nodeName && "modulepreload" === r.getAttribute("rel")) && r.remove();
 }
}

const templateWindows = new Map, isPromise = e => !!e && ("object" == typeof e || "function" == typeof e) && "function" == typeof e.then, hasError = e => null != e && 0 !== e.length && e.some((e => "error" === e.level && "runtime" !== e.type)), TASK_CANCELED_MSG = "task canceled", updateCanonicalLink = (e, t) => {
 let r = e.head.querySelector('link[rel="canonical"]');
 "string" == typeof t ? (null == r && (r = e.createElement("link"), r.setAttribute("rel", "canonical"), 
 e.head.appendChild(r)), r.setAttribute("href", t)) : null != r && (r.getAttribute("href") || r.parentNode.removeChild(r));
}, relocateMetaCharset = e => {
 const t = e.head;
 let r = t.querySelector("meta[charset]");
 null == r ? (r = e.createElement("meta"), r.setAttribute("charset", "utf-8")) : r.remove(), 
 t.insertBefore(r, t.firstChild);
}, parseCss = (e, t) => {
 let r = 1, s = 1;
 const n = [], o = e => {
  const t = e.match(/\n/g);
  t && (r += t.length);
  const n = e.lastIndexOf("\n");
  s = ~n ? e.length - n : s + e.length;
 }, i = () => {
  const e = {
   line: r,
   column: s
  };
  return t => (t.position = new z(e), m(), t);
 }, a = o => {
  const i = e.split("\n"), a = {
   level: "error",
   type: "css",
   language: "css",
   header: "CSS Parse",
   messageText: o,
   absFilePath: t,
   lines: [ {
    lineIndex: r - 1,
    lineNumber: r,
    errorCharStart: s,
    text: e[r - 1]
   } ]
  };
  if (r > 1) {
   const t = {
    lineIndex: r - 1,
    lineNumber: r - 1,
    text: e[r - 2],
    errorCharStart: -1,
    errorLength: -1
   };
   a.lines.unshift(t);
  }
  if (r + 2 < i.length) {
   const e = {
    lineIndex: r,
    lineNumber: r + 1,
    text: i[r],
    errorCharStart: -1,
    errorLength: -1
   };
   a.lines.push(e);
  }
  return n.push(a), null;
 }, l = () => u(/^{\s*/), c = () => u(/^}/), u = t => {
  const r = t.exec(e);
  if (!r) return;
  const s = r[0];
  return o(s), e = e.slice(s.length), r;
 }, d = () => {
  let t;
  const r = [];
  for (m(), h(r); e.length && "}" !== e.charAt(0) && (t = w() || A()); ) r.push(t), 
  h(r);
  return r;
 }, m = () => u(/^\s*/), h = e => {
  let t;
  for (e = e || []; t = p(); ) e.push(t);
  return e;
 }, p = () => {
  const t = i();
  if ("/" !== e.charAt(0) || "*" !== e.charAt(1)) return null;
  let r = 2;
  for (;"" !== e.charAt(r) && ("*" !== e.charAt(r) || "/" !== e.charAt(r + 1)); ) ++r;
  if (r += 2, "" === e.charAt(r - 1)) return a("End of comment missing");
  const n = e.slice(2, r - 2);
  return s += 2, o(n), e = e.slice(r), s += 2, t({
   type: 1,
   comment: n
  });
 }, f = () => {
  const e = u(/^([^{]+)/);
  return e ? trim(e[0]).replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g, "").replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g, (function(e) {
   return e.replace(/,/g, "‌");
  })).split(/\s*(?![^(]*\)),\s*/).map((function(e) {
   return e.replace(/\u200C/g, ",");
  })) : null;
 }, g = () => {
  const e = i();
  let t = u(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);
  if (!t) return null;
  if (t = trim(t[0]), !u(/^:\s*/)) return a("property missing ':'");
  const r = u(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/), s = e({
   type: 4,
   property: t.replace(commentre, ""),
   value: r ? trim(r[0]).replace(commentre, "") : ""
  });
  return u(/^[;\s]*/), s;
 }, y = () => {
  const e = [];
  if (!l()) return a("missing '{'");
  let t;
  for (h(e); t = g(); ) e.push(t), h(e);
  return c() ? e : a("missing '}'");
 }, C = () => {
  let e;
  const t = [], r = i();
  for (;e = u(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/); ) t.push(e[1]), u(/^,\s*/);
  return t.length ? r({
   type: 9,
   values: t,
   declarations: y()
  }) : null;
 }, S = (e, t) => {
  const r = new RegExp("^@" + e + "\\s*([^;]+);");
  return () => {
   const s = i(), n = u(r);
   if (!n) return null;
   const o = {
    type: t
   };
   return o[e] = n[1].trim(), s(o);
  };
 }, E = S("import", 7), b = S("charset", 0), T = S("namespace", 11), w = () => "@" !== e[0] ? null : (() => {
  const e = i();
  let t = u(/^@([-\w]+)?keyframes\s*/);
  if (!t) return null;
  const r = t[1];
  if (t = u(/^([-\w]+)\s*/), !t) return a("@keyframes missing name");
  const s = t[1];
  if (!l()) return a("@keyframes missing '{'");
  let n, o = h();
  for (;n = C(); ) o.push(n), o = o.concat(h());
  return c() ? e({
   type: 8,
   name: s,
   vendor: r,
   keyframes: o
  }) : a("@keyframes missing '}'");
 })() || (() => {
  const e = i(), t = u(/^@media *([^{]+)/);
  if (!t) return null;
  const r = trim(t[1]);
  if (!l()) return a("@media missing '{'");
  const s = h().concat(d());
  return c() ? e({
   type: 10,
   media: r,
   rules: s
  }) : a("@media missing '}'");
 })() || (() => {
  const e = i(), t = u(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);
  return t ? e({
   type: 2,
   name: trim(t[1]),
   media: trim(t[2])
  }) : null;
 })() || (() => {
  const e = i(), t = u(/^@supports *([^{]+)/);
  if (!t) return null;
  const r = trim(t[1]);
  if (!l()) return a("@supports missing '{'");
  const s = h().concat(d());
  return c() ? e({
   type: 15,
   supports: r,
   rules: s
  }) : a("@supports missing '}'");
 })() || E() || b() || T() || (() => {
  const e = i(), t = u(/^@([-\w]+)?document *([^{]+)/);
  if (!t) return null;
  const r = trim(t[1]), s = trim(t[2]);
  if (!l()) return a("@document missing '{'");
  const n = h().concat(d());
  return c() ? e({
   type: 3,
   document: s,
   vendor: r,
   rules: n
  }) : a("@document missing '}'");
 })() || (() => {
  const e = i();
  if (!u(/^@page */)) return null;
  const t = f() || [];
  if (!l()) return a("@page missing '{'");
  let r, s = h();
  for (;r = g(); ) s.push(r), s = s.concat(h());
  return c() ? e({
   type: 12,
   selectors: t,
   declarations: s
  }) : a("@page missing '}'");
 })() || (() => {
  const e = i();
  if (!u(/^@host\s*/)) return null;
  if (!l()) return a("@host missing '{'");
  const t = h().concat(d());
  return c() ? e({
   type: 6,
   rules: t
  }) : a("@host missing '}'");
 })() || (() => {
  const e = i();
  if (!u(/^@font-face\s*/)) return null;
  if (!l()) return a("@font-face missing '{'");
  let t, r = h();
  for (;t = g(); ) r.push(t), r = r.concat(h());
  return c() ? e({
   type: 5,
   declarations: r
  }) : a("@font-face missing '}'");
 })(), A = () => {
  const e = i(), t = f();
  return t ? (h(), e({
   type: 13,
   selectors: t,
   declarations: y()
  })) : a("selector missing");
 };
 class z {
  constructor(e) {
   this.start = e, this.end = {
    line: r,
    column: s
   }, this.source = t;
  }
 }
 return z.prototype.content = e, {
  diagnostics: n,
  ...addParent((() => {
   const e = d();
   return {
    type: 14,
    stylesheet: {
     source: t,
     rules: e
    }
   };
  })())
 };
}, trim = e => e ? e.trim() : "", addParent = (e, t) => {
 const r = e && "string" == typeof e.type, s = r ? e : t;
 for (const t in e) {
  const r = e[t];
  Array.isArray(r) ? r.forEach((function(e) {
   addParent(e, s);
  })) : r && "object" == typeof r && addParent(r, s);
 }
 return r && Object.defineProperty(e, "parent", {
  configurable: !0,
  writable: !0,
  enumerable: !1,
  value: t || null
 }), e;
}, commentre = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, getCssSelectors = e => {
 SELECTORS.all.length = SELECTORS.tags.length = SELECTORS.classNames.length = SELECTORS.ids.length = SELECTORS.attrs.length = 0;
 const t = (e = e.replace(/\./g, " .").replace(/\#/g, " #").replace(/\[/g, " [").replace(/\>/g, " > ").replace(/\+/g, " + ").replace(/\~/g, " ~ ").replace(/\*/g, " * ").replace(/\:not\((.*?)\)/g, " ")).split(" ");
 for (let e = 0, r = t.length; e < r; e++) t[e] = t[e].split(":")[0], 0 !== t[e].length && ("." === t[e].charAt(0) ? SELECTORS.classNames.push(t[e].slice(1)) : "#" === t[e].charAt(0) ? SELECTORS.ids.push(t[e].slice(1)) : "[" === t[e].charAt(0) ? (t[e] = t[e].slice(1).split("=")[0].split("]")[0].trim(), 
 SELECTORS.attrs.push(t[e].toLowerCase())) : /[a-z]/g.test(t[e].charAt(0)) && SELECTORS.tags.push(t[e].toLowerCase()));
 return SELECTORS.classNames = SELECTORS.classNames.sort(((e, t) => e.length < t.length ? -1 : e.length > t.length ? 1 : 0)), 
 SELECTORS;
}, SELECTORS = {
 all: [],
 tags: [],
 classNames: [],
 ids: [],
 attrs: []
}, serializeCssVisitNode = (e, t, r, s) => {
 const n = t.type;
 return 4 === n ? serializeCssDeclaration(t, r, s) : 13 === n ? serializeCssRule(e, t) : 1 === n ? "!" === t.comment[0] ? `/*${t.comment}*/` : "" : 10 === n ? serializeCssMedia(e, t) : 8 === n ? serializeCssKeyframes(e, t) : 9 === n ? serializeCssKeyframe(e, t) : 5 === n ? serializeCssFontFace(e, t) : 15 === n ? serializeCssSupports(e, t) : 7 === n ? "@import " + t.import + ";" : 0 === n ? "@charset " + t.charset + ";" : 12 === n ? serializeCssPage(e, t) : 6 === n ? "@host{" + serializeCssMapVisit(e, t.rules) + "}" : 2 === n ? "@custom-media " + t.name + " " + t.media + ";" : 3 === n ? serializeCssDocument(e, t) : 11 === n ? "@namespace " + t.namespace + ";" : "";
}, serializeCssRule = (e, t) => {
 const r = t.declarations, s = e.usedSelectors, n = t.selectors.slice();
 if (null == r || 0 === r.length) return "";
 if (s) {
  let t, r, o = !0;
  for (t = n.length - 1; t >= 0; t--) {
   const i = getCssSelectors(n[t]);
   o = !0;
   let a = i.classNames.length;
   if (a > 0 && e.hasUsedClassNames) for (r = 0; r < a; r++) if (!s.classNames.has(i.classNames[r])) {
    o = !1;
    break;
   }
   if (o && e.hasUsedTags && (a = i.tags.length, a > 0)) for (r = 0; r < a; r++) if (!s.tags.has(i.tags[r])) {
    o = !1;
    break;
   }
   if (o && e.hasUsedAttrs && (a = i.attrs.length, a > 0)) for (r = 0; r < a; r++) if (!s.attrs.has(i.attrs[r])) {
    o = !1;
    break;
   }
   if (o && e.hasUsedIds && (a = i.ids.length, a > 0)) for (r = 0; r < a; r++) if (!s.ids.has(i.ids[r])) {
    o = !1;
    break;
   }
   o || n.splice(t, 1);
  }
 }
 if (0 === n.length) return "";
 const o = [];
 let i = "";
 for (const e of t.selectors) i = removeSelectorWhitespace(e), o.includes(i) || o.push(i);
 return `${o}{${serializeCssMapVisit(e, r)}}`;
}, serializeCssDeclaration = (e, t, r) => "" === e.value ? "" : r - 1 === t ? e.property + ":" + e.value : e.property + ":" + e.value + ";", serializeCssMedia = (e, t) => {
 const r = serializeCssMapVisit(e, t.rules);
 return "" === r ? "" : "@media " + removeMediaWhitespace(t.media) + "{" + r + "}";
}, serializeCssKeyframes = (e, t) => {
 const r = serializeCssMapVisit(e, t.keyframes);
 return "" === r ? "" : "@" + (t.vendor || "") + "keyframes " + t.name + "{" + r + "}";
}, serializeCssKeyframe = (e, t) => t.values.join(",") + "{" + serializeCssMapVisit(e, t.declarations) + "}", serializeCssFontFace = (e, t) => {
 const r = serializeCssMapVisit(e, t.declarations);
 return "" === r ? "" : "@font-face{" + r + "}";
}, serializeCssSupports = (e, t) => {
 const r = serializeCssMapVisit(e, t.rules);
 return "" === r ? "" : "@supports " + t.supports + "{" + r + "}";
}, serializeCssPage = (e, t) => "@page " + t.selectors.join(", ") + "{" + serializeCssMapVisit(e, t.declarations) + "}", serializeCssDocument = (e, t) => {
 const r = serializeCssMapVisit(e, t.rules), s = "@" + (t.vendor || "") + "document " + t.document;
 return "" === r ? "" : s + "{" + r + "}";
}, serializeCssMapVisit = (e, t) => {
 let r = "";
 if (t) for (let s = 0, n = t.length; s < n; s++) r += serializeCssVisitNode(e, t[s], s, n);
 return r;
}, removeSelectorWhitespace = e => {
 let t = "", r = "", s = !1;
 for (let n = 0, o = (e = e.trim()).length; n < o; n++) if (r = e[n], "[" === r && "\\" !== t[t.length - 1] ? s = !0 : "]" === r && "\\" !== t[t.length - 1] && (s = !1), 
 !s && CSS_WS_REG.test(r)) {
  if (CSS_NEXT_CHAR_REG.test(e[n + 1])) continue;
  if (CSS_PREV_CHAR_REG.test(t[t.length - 1])) continue;
  t += " ";
 } else t += r;
 return t;
}, removeMediaWhitespace = e => {
 let t = "", r = "";
 for (let s = 0, n = (e = e.trim()).length; s < n; s++) if (r = e[s], CSS_WS_REG.test(r)) {
  if (CSS_WS_REG.test(t[t.length - 1])) continue;
  t += " ";
 } else t += r;
 return t;
}, CSS_WS_REG = /\s/, CSS_NEXT_CHAR_REG = /[>\(\)\~\,\+\s]/, CSS_PREV_CHAR_REG = /[>\(\~\,\+]/, collectUsedSelectors = (e, t) => {
 if (null != t && 1 === t.nodeType) {
  const r = t.children, s = t.nodeName.toLowerCase();
  e.tags.add(s);
  const n = t.attributes;
  for (let r = 0, s = n.length; r < s; r++) {
   const s = n.item(r), o = s.name.toLowerCase();
   if (e.attrs.add(o), "class" === o) {
    const r = t.classList;
    for (let t = 0, s = r.length; t < s; t++) e.classNames.add(r.item(t));
   } else "id" === o && e.ids.add(s.value);
  }
  if (r) for (let t = 0, s = r.length; t < s; t++) collectUsedSelectors(e, r[t]);
 }
}, removeUnusedStyles = (e, t) => {
 try {
  const r = e.head.querySelectorAll("style[data-styles]"), s = r.length;
  if (s > 0) {
   const n = (e => {
    const t = {
     attrs: new Set,
     classNames: new Set,
     ids: new Set,
     tags: new Set
    };
    return collectUsedSelectors(t, e), t;
   })(e.documentElement);
   for (let e = 0; e < s; e++) removeUnusedStyleText(n, t, r[e]);
  }
 } catch (e) {
  ((e, t, r) => {
   const s = {
    level: "error",
    type: "build",
    header: "Build Error",
    messageText: "build error",
    relFilePath: null,
    absFilePath: null,
    lines: []
   };
   null != t && (null != t.stack ? s.messageText = t.stack.toString() : null != t.message ? s.messageText = t.message.length ? t.message : "UNKNOWN ERROR" : s.messageText = t.toString()), 
   null == e || (e => e === TASK_CANCELED_MSG)(s.messageText) || e.push(s);
  })(t, e);
 }
}, removeUnusedStyleText = (e, t, r) => {
 try {
  const s = parseCss(r.innerHTML);
  if (t.push(...s.diagnostics), hasError(t)) return;
  try {
   r.innerHTML = ((e, t) => {
    const r = t.usedSelectors || null, s = {
     usedSelectors: r || null,
     hasUsedAttrs: !!r && r.attrs.size > 0,
     hasUsedClassNames: !!r && r.classNames.size > 0,
     hasUsedIds: !!r && r.ids.size > 0,
     hasUsedTags: !!r && r.tags.size > 0
    }, n = e.rules;
    if (!n) return "";
    const o = n.length, i = [];
    for (let e = 0; e < o; e++) i.push(serializeCssVisitNode(s, n[e], e, o));
    return i.join("");
   })(s.stylesheet, {
    usedSelectors: e
   });
  } catch (e) {
   t.push({
    level: "warn",
    type: "css",
    header: "CSS Stringify",
    messageText: e,
    lines: []
   });
  }
 } catch (e) {
  t.push({
   level: "warn",
   type: "css",
   header: "CSS Parse",
   messageText: e,
   lines: []
  });
 }
}, SKIP_ATTRS = new Set([ "s-id", "c-id" ]), createHydrateBuildId = () => {
 let e = "abcdefghijklmnopqrstuvwxyz", t = "";
 for (;t.length < 8; ) t += e[Math.floor(Math.random() * e.length)], 1 === t.length && (e += "0123456789");
 return t;
};

exports.createWindowFromHtml = createWindowFromHtml;
exports.hydrateDocument = hydrateDocument;
exports.renderToString = renderToString;
exports.serializeDocumentToString = serializeDocumentToString;
